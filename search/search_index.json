{"config":{"lang":["de","en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Open source firmware for ESP8266 devices ~ Total local control with quick setup and updates. Control using MQTT, Web UI, HTTP or serial. Automate using timers, rules or scripts. Integration with home automation solutions. Incredibly expandable and flexible. For OTA updates please use the new server http://ota.tasmota.com/tasmota/release and http://ota.tasmota.com/tasmota32/release . Download latest Tasmotizer to use the new OTA server during flashing. Current release ~ Tasmota 9.2.0 Julie *all documentation is for current release only Tasmota team wishes you happy holidays and a prosperous New Year! BREAKING CHANGE mDNS has been removed from all pre-compiled binaries to conserve flash size BREAKING CHANGE Removed TuyaMCU Fan functions in favor of new enum dpId's BREAKING CHANGE PN532 define USE_PN532_CAUSE_EVENTS replaced by rule trigger PN532#UID= BREAKING CHANGE KNX DPT9 (16-bit float) to DPT14 (32-bit float) Added TuyaMCU support for enum dpId's, some sensors and timers Official support for Shelly Dimmer 1 and 2 with custom STM32 firmware from James Turton Support for multiple WeMo devices Optional CCloader support for CC25xx Zigbee or CC26xx BLE New sensor support: more EZO sensors, AS608 optical and R503 capacitive fingerprint sensor, MFRC522 13.56MHz rfid card reader New commands: RfProtocol , SO115 , SO116 , SO117 , TuyaEnum , TuyaEnumList , ZbInfo , ZbLeave See changelog for a complete list of new features, changes and bug fixes. Join our community ~ See Discord , Telegram , Reddit or Google Groups for feedback, questions and troubleshooting. If you like Tasmota ~","title":"Home"},{"location":"#open-source-firmware-for-esp8266-devices","text":"Total local control with quick setup and updates. Control using MQTT, Web UI, HTTP or serial. Automate using timers, rules or scripts. Integration with home automation solutions. Incredibly expandable and flexible. For OTA updates please use the new server http://ota.tasmota.com/tasmota/release and http://ota.tasmota.com/tasmota32/release . Download latest Tasmotizer to use the new OTA server during flashing.","title":"Open source firmware for ESP8266 devices"},{"location":"#current-release","text":"Tasmota 9.2.0 Julie *all documentation is for current release only Tasmota team wishes you happy holidays and a prosperous New Year! BREAKING CHANGE mDNS has been removed from all pre-compiled binaries to conserve flash size BREAKING CHANGE Removed TuyaMCU Fan functions in favor of new enum dpId's BREAKING CHANGE PN532 define USE_PN532_CAUSE_EVENTS replaced by rule trigger PN532#UID= BREAKING CHANGE KNX DPT9 (16-bit float) to DPT14 (32-bit float) Added TuyaMCU support for enum dpId's, some sensors and timers Official support for Shelly Dimmer 1 and 2 with custom STM32 firmware from James Turton Support for multiple WeMo devices Optional CCloader support for CC25xx Zigbee or CC26xx BLE New sensor support: more EZO sensors, AS608 optical and R503 capacitive fingerprint sensor, MFRC522 13.56MHz rfid card reader New commands: RfProtocol , SO115 , SO116 , SO117 , TuyaEnum , TuyaEnumList , ZbInfo , ZbLeave See changelog for a complete list of new features, changes and bug fixes.","title":"Current release"},{"location":"#join-our-community","text":"See Discord , Telegram , Reddit or Google Groups for feedback, questions and troubleshooting.","title":"Join our community"},{"location":"#if-you-like-tasmota","text":"","title":"If you like Tasmota"},{"location":"A4988-Stepper-Motor-Controller/","text":"This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_A4988_STEPPER #define USE_A4988_STEPPER // A4988/DRV8825 stepper motor (+10k5 code) #endif This driver is used to control stepper-motors such as NEMA 17 . Configuration ~ Wiring ~ The driverboard has several connectors: powering the controller (3.3-5.0 V), input (+/-) & output (1a/1b/2a/2b), the motor (up to 35V/2A), and to control the circuit (in order at the control side of the board): Connector Description DIR Direction of rotation STEP Initiate stepping MS1 Microstep increment select MS2 Microstep increment select MS3 Microstep increment select EN Enable the power supply for the motor SLP Sleep (bridge to RST) RST Reset (bridge to SLP) Tasmota Settings ~ There are six GPIO components that should be configured to free GPIOs: A4988 DIR (170) A4988 STP (171) A4988 ENA (172) A4988 MS1 (173) A4988 MS2 (174) A4988 MS3 (175) The minimal configuration are the DIR and STEP signals. In such a configuration the motor will be permanently powered and microstepping will be set to 1/1 (full steps). A4988 Controller ~ Detailed information about the A4988 controller can be found in the datasheet . Microstepping Configuration DRV8825 Controller ~ The DRV8825 is directly pin compatible with the A4988. The microstepping increment settings are different. Also, there is one additional option on the DRV8825. Microstepping Configuration Operation ~ Refer to the Stepper Motor Commands MotorRPM is an imprecise setting due to the implementation method. Also, if the value is too high for the combination of chosen micro stepping increment ( MotorMIS ) and the number of steps the given motor needs for one revolution ( MotorSPR ), the motor will not turn but make a whining noise. You will have to experiment some to find the optimal combination for your use case. Example Project ~ The cheap auto-feeder for my cats broke. It was a fancy plastic-thingy with voice-recording-function & programmable to feed several times a day after playing back your voice (cats don't give a sh$7 about your voice - they come when they hear the food falling into the bowl). It was never precise - a concern for the amount of nutrition it gave the cats. And it was not reliable, as the torque of the internal moving mechanism was insufficient to spin the separator/proportioning wheel through the food reliably. In addition, the batteries were always drained in a day meaning very grumpy cats when we returned! Thus the wish to install a high-torque stepper-motor (with shifting gear) was born. I could power it with mains instead of relying on a battery, control it over WiFi from my home automation hub. Tasmota now offers a way to do this! The \"TasmotaSmartCatFeeder\" circuit consists of a WeMos D1 mini, a A4988 controller, and two power supplies (5V&12V). This all fits into the housing of the feeder and costs less than 50\u20ac! Virtually everything which has to be moved or rotated can be done now using these cheap components. It can be a window, door, shutter, cat or dog flap, a solar panel which follows the sun, a moving spotlight, PTZ-camera, or whatever. Wiring Diagrams ~ Convert 28BYJ-48 to bipolar so that it works with this driver Breakout Boards ~ Buy Links Banggood AliExpress #1 AliExpress #1","title":"A4988 stepper motor controller"},{"location":"A4988-Stepper-Motor-Controller/#configuration","text":"","title":"Configuration"},{"location":"A4988-Stepper-Motor-Controller/#wiring","text":"The driverboard has several connectors: powering the controller (3.3-5.0 V), input (+/-) & output (1a/1b/2a/2b), the motor (up to 35V/2A), and to control the circuit (in order at the control side of the board): Connector Description DIR Direction of rotation STEP Initiate stepping MS1 Microstep increment select MS2 Microstep increment select MS3 Microstep increment select EN Enable the power supply for the motor SLP Sleep (bridge to RST) RST Reset (bridge to SLP)","title":"Wiring"},{"location":"A4988-Stepper-Motor-Controller/#tasmota-settings","text":"There are six GPIO components that should be configured to free GPIOs: A4988 DIR (170) A4988 STP (171) A4988 ENA (172) A4988 MS1 (173) A4988 MS2 (174) A4988 MS3 (175) The minimal configuration are the DIR and STEP signals. In such a configuration the motor will be permanently powered and microstepping will be set to 1/1 (full steps).","title":"Tasmota Settings"},{"location":"A4988-Stepper-Motor-Controller/#a4988-controller","text":"Detailed information about the A4988 controller can be found in the datasheet .","title":"A4988 Controller"},{"location":"A4988-Stepper-Motor-Controller/#drv8825-controller","text":"The DRV8825 is directly pin compatible with the A4988. The microstepping increment settings are different. Also, there is one additional option on the DRV8825.","title":"DRV8825 Controller"},{"location":"A4988-Stepper-Motor-Controller/#operation","text":"Refer to the Stepper Motor Commands MotorRPM is an imprecise setting due to the implementation method. Also, if the value is too high for the combination of chosen micro stepping increment ( MotorMIS ) and the number of steps the given motor needs for one revolution ( MotorSPR ), the motor will not turn but make a whining noise. You will have to experiment some to find the optimal combination for your use case.","title":"Operation"},{"location":"A4988-Stepper-Motor-Controller/#example-project","text":"The cheap auto-feeder for my cats broke. It was a fancy plastic-thingy with voice-recording-function & programmable to feed several times a day after playing back your voice (cats don't give a sh$7 about your voice - they come when they hear the food falling into the bowl). It was never precise - a concern for the amount of nutrition it gave the cats. And it was not reliable, as the torque of the internal moving mechanism was insufficient to spin the separator/proportioning wheel through the food reliably. In addition, the batteries were always drained in a day meaning very grumpy cats when we returned! Thus the wish to install a high-torque stepper-motor (with shifting gear) was born. I could power it with mains instead of relying on a battery, control it over WiFi from my home automation hub. Tasmota now offers a way to do this! The \"TasmotaSmartCatFeeder\" circuit consists of a WeMos D1 mini, a A4988 controller, and two power supplies (5V&12V). This all fits into the housing of the feeder and costs less than 50\u20ac! Virtually everything which has to be moved or rotated can be done now using these cheap components. It can be a window, door, shutter, cat or dog flap, a solar panel which follows the sun, a moving spotlight, PTZ-camera, or whatever.","title":"Example Project"},{"location":"A4988-Stepper-Motor-Controller/#wiring-diagrams","text":"Convert 28BYJ-48 to bipolar so that it works with this driver","title":"Wiring Diagrams"},{"location":"A4988-Stepper-Motor-Controller/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"ADC/","text":"ESP8266 has a single ADC pin available. It may be used to read voltage at ADC pin or to read module supply voltage (VCC). Note When referring to the ADC pin these terms are used interchangeably: ADC (Analog-to-digital Converter), TOUT, Pin6, A0 or Analog0. Warning Check your Wi-Fi module! The ESP8266 A0 pin supports a maximum voltage of 1.0V. Many newer Wi-Fi modules have an on-board voltage divider to support a higher A0 input voltage range (typically in the range between 0 and 3.3 volts). You may need to use an external voltage divider to ensure your input voltage is in the right range. By default Tasmota uses the ADC pin to read voltage. The signal comes from an analog peripheral , or sometimes from the device itself (see Shelly 2.5 ). After wiring a peripheral to A0 pin you have to configure it in Configure Module : # Option WebUI display MQTT mesage 0 None none none 1 Analog Analog0 %value% {\"A0\":%value%} 2 Temperature Temperature %value% \u00b0C (\u00b0F) {\"Temperature\":%value%},\"TempUnit\":\"C\"} 3 Light Illuminance %value% lux {\"Illuminance\":%value%} 4 Button none none 5 Buttoni none none 6 Range Range %value% {\"Range\":%value%} 7 CT Power Voltage 230 V Current %value A Power %value W Energy Total %value kWh {\"Energy\":_%value_,\"Power\":_%value_,\"Voltage\":230,\"Current\":_%value_} The reading will show in web UI's sensor section as \" %option% %value% \" depending on the selected option. Tasmota calculates the values for temperature and light, analog values can be 1 to 1024 . Note When using Temperature (2) or light (3) a calibration could be needed. In case of shifted values AdcParam can be used to calibrate the output. Example: ADC as Analog (1) A message will be published in tele/%topic%/SENSOR JSON response as \"ANALOG\": depending on the selected option. Example: ADC as Light (3) 18 : 55 : 09 MQT : tele / tas mo ta /SENSOR = { \"Time\" : \"2019-10-31T18:55:09\" , \"ANALOG\" :{ \"Illuminance\" : 8 }} Warning Careful when setting ADC as Button, if there is constant voltage on the pin it might register as a long press and reset the device to firmware defaults Rule triggers ~ Use these triggers in rules: on ANALOG#A0div10 do ... - when the ADC input changes by more than 1% it provides a value between 0 and 100 on Tele-ANALOG#A0 do ... - triggers on tele messages with Analog object MQT: tele/tasmota/SENSOR = {\"Time\":\"2019-01-14T19:36:51\",\"ANALOG\":{\"A0\":1024}} Rule example: using a potentiometer on analog pin . ADC_VCC ~ Instead of an input, ADC pin can be used to measure supply voltage of the ESP module ( this reading in not 100% accurate ). To enable ADC_VCC feature you need to compile your own build : If you enable ADC_VCC you cannot use the pin as analog input anymore. user_config_override.h flag: // -- Internal Analog input ----------------------- #define USE_ADC_VCC // Display Vcc in Power status Supply voltage is published in tele/%topic%/STATE under \"Vcc\": in mV: 11 : 14 : 59 MQT : tele /tasmota/ STATE = { \"Time\" : \"2019-10-31T11:14:59\" , \"Uptime\" : \"0T18:36:12\" , \"UptimeSec\" : 66972 , \"Vcc\" : 3.423 , \"Heap\" : 28 , \"SleepMode\" : \"Dynamic\" , \"Sleep\" : 50 , \"LoadAvg\" : 19 , \"MqttCount\" : 6 , \"POWER\" : \"OFF\" , \"Wifi\" :{ \"AP\" : 1 , \"SSId\" : \"Tasmota\" , \"BSSId\" : \"00:00:00:00:00:00\" , \"Channel\" : 13 , \"RSSI\" : 100 , \"LinkCount\" : 1 , \"Downtime\" : \"0T00:00:06\" }}","title":"Analog pin"},{"location":"ADC/#rule-triggers","text":"Use these triggers in rules: on ANALOG#A0div10 do ... - when the ADC input changes by more than 1% it provides a value between 0 and 100 on Tele-ANALOG#A0 do ... - triggers on tele messages with Analog object MQT: tele/tasmota/SENSOR = {\"Time\":\"2019-01-14T19:36:51\",\"ANALOG\":{\"A0\":1024}} Rule example: using a potentiometer on analog pin .","title":"Rule triggers"},{"location":"ADC/#adc_vcc","text":"Instead of an input, ADC pin can be used to measure supply voltage of the ESP module ( this reading in not 100% accurate ). To enable ADC_VCC feature you need to compile your own build : If you enable ADC_VCC you cannot use the pin as analog input anymore. user_config_override.h flag: // -- Internal Analog input ----------------------- #define USE_ADC_VCC // Display Vcc in Power status Supply voltage is published in tele/%topic%/STATE under \"Vcc\": in mV: 11 : 14 : 59 MQT : tele /tasmota/ STATE = { \"Time\" : \"2019-10-31T11:14:59\" , \"Uptime\" : \"0T18:36:12\" , \"UptimeSec\" : 66972 , \"Vcc\" : 3.423 , \"Heap\" : 28 , \"SleepMode\" : \"Dynamic\" , \"Sleep\" : 50 , \"LoadAvg\" : 19 , \"MqttCount\" : 6 , \"POWER\" : \"OFF\" , \"Wifi\" :{ \"AP\" : 1 , \"SSId\" : \"Tasmota\" , \"BSSId\" : \"00:00:00:00:00:00\" , \"Channel\" : 13 , \"RSSI\" : 100 , \"LinkCount\" : 1 , \"Downtime\" : \"0T00:00:06\" }}","title":"ADC_VCC"},{"location":"AHT1x/","text":"This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_AHT1x #define USE_AHT1x // [ I2cDriver43 ] Enable AHT10 / 15 humidity and temperature sensor ( I2C address 0x38 ) ( + 0 k8 code ) #endif AHT10 or AH15 are an I 2 C temperature and humidity sensor. Configuration ~ This sensor is incompatible with other I 2 C devices on I 2 C bus Sensor datasheet implicitly says: Only a single AHT10 can be connected to the I 2 C bus and no other I 2 C devices can be connected. Wiring ~ AHT1x ESP8266 VCC 3.3V GND GND SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) After a reboot the driver will detect AHT1x automatically and display sensor readings. and in MQTT topic (according to TelePeriod): {\"Time\":\"2020-01-01T00:00:00\",\"AHT1X-0x38\":{\"Temperature\":24.7,\"Humidity\":61.9,\"DewPoint\":16.8},\"TempUnit\":\"C\"} Breakout Boards ~ AHT10 Datasheet AHT15 Datasheet","title":"AHT1x temperature and humidity sensor"},{"location":"AHT1x/#configuration","text":"This sensor is incompatible with other I 2 C devices on I 2 C bus Sensor datasheet implicitly says: Only a single AHT10 can be connected to the I 2 C bus and no other I 2 C devices can be connected.","title":"Configuration"},{"location":"AHT1x/#wiring","text":"AHT1x ESP8266 VCC 3.3V GND GND SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"AHT1x/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) After a reboot the driver will detect AHT1x automatically and display sensor readings. and in MQTT topic (according to TelePeriod): {\"Time\":\"2020-01-01T00:00:00\",\"AHT1X-0x38\":{\"Temperature\":24.7,\"Humidity\":61.9,\"DewPoint\":16.8},\"TempUnit\":\"C\"}","title":"Tasmota Settings"},{"location":"AHT1x/#breakout-boards","text":"AHT10 Datasheet AHT15 Datasheet","title":"Breakout Boards"},{"location":"AM2301/","text":"AM2301/AM2302 (DHT21/DHT22) temperature and humidity sensor ~ This feature is included only in tasmota-sensors.bin AM2301 driver supports AM2301 (DHT21) , AM2302 (DHT22) and AM2321 temperature and humidity sensors. Introduced in Tasmota through Sonoff AM2301 accessory for Sonoff TH . This driver is ONLY for single wire implementations of the sensor. Configuration ~ Wiring ~ AM2301 ESP266 - GND OUT GPIOx + 3.3V Tasmota Settings ~ In the Configuration -> Configure Module page assign: - GPIOx to AM2301 (2) After a reboot webUI will display temperature and humidity measured. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-01-01T00:00:00\" , \"AM2301\" : { \"Temperature\" : 24.6 , \"Humidity\" : 58.2 }, \"TempUnit\" : \"C\" } Commands ~ TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device. Wemos DHT Shield ~ Like the Wemos DHT11 shield specs the DATA OUT pin of Wemos DHT22 is connected to D4 of the Wemos. Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIO2 to AM2301 (2) Sensors ~ Read more about differences between sensors .","title":"AM2301 temperature and humidity sensor"},{"location":"AM2301/#am2301am2302-dht21dht22-temperature-and-humidity-sensor","text":"This feature is included only in tasmota-sensors.bin AM2301 driver supports AM2301 (DHT21) , AM2302 (DHT22) and AM2321 temperature and humidity sensors. Introduced in Tasmota through Sonoff AM2301 accessory for Sonoff TH . This driver is ONLY for single wire implementations of the sensor.","title":"AM2301/AM2302 (DHT21/DHT22) temperature and humidity sensor"},{"location":"AM2301/#configuration","text":"","title":"Configuration"},{"location":"AM2301/#wiring","text":"AM2301 ESP266 - GND OUT GPIOx + 3.3V","title":"Wiring"},{"location":"AM2301/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: - GPIOx to AM2301 (2) After a reboot webUI will display temperature and humidity measured. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-01-01T00:00:00\" , \"AM2301\" : { \"Temperature\" : 24.6 , \"Humidity\" : 58.2 }, \"TempUnit\" : \"C\" }","title":"Tasmota Settings"},{"location":"AM2301/#commands","text":"TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device.","title":"Commands"},{"location":"AM2301/#wemos-dht-shield","text":"Like the Wemos DHT11 shield specs the DATA OUT pin of Wemos DHT22 is connected to D4 of the Wemos.","title":"Wemos DHT Shield"},{"location":"AM2301/#tasmota-settings_1","text":"In the Configuration -> Configure Module page assign: GPIO2 to AM2301 (2)","title":"Tasmota Settings"},{"location":"AM2301/#sensors","text":"Read more about differences between sensors .","title":"Sensors"},{"location":"APDS-9960/","text":"APDS-9960 light and gesture sensor ~ This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_APDS9960 #define USE_APDS9960 // Enable APDS9960 Proximity Sensor (+4k7 code) #endif Broadcom APDS-9960 is a digital RGB, ambient light, proximity and gesture sensor device in a single 8-pin package. The device has an I2C compatible interface providing red, green, blue, clear (RGBC), proximity and gesture sensing with IR LED. The RGB and ambient light sensing feature detects light intensity under various lighting conditions and through various attentuation materials including darkened glass. In addition, the integrated UV-IR blocking filter enables accurate ambient light and correlated color temperature sensing. Configuration ~ Wiring Breakout ESP8266 VCC/VIN +3.3VDC GND GND SCL GPIOy SDA GPIOx INT/IRQ not used Tasmota Settings In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) After configuring the GPIO's the driver will detect the APDS-9960 automatically. On first boot sensor will start in gesture mode. It will not appear in the webUI but it can be observed via MQTT messages in console: 21 : 34 : 21 MQT : tele / tas mo ta /RESULT = { \"Gesture\" : \"Off\" } 21 : 34 : 23 MQT : tele / tas mo ta /RESULT = { \"Gesture\" : \"On\" } 21 : 34 : 25 MQT : tele / tas mo ta /SENSOR = { \"Time\" : \"2019-10-31T21:34:25\" , \"APDS9960\" :{ \"None\" : 1 }} 21 : 34 : 26 MQT : tele / tas mo ta /SENSOR = { \"Time\" : \"2019-10-31T21:34:26\" , \"APDS9960\" :{ \"Right\" : 1 }} 21 : 34 : 29 MQT : tele / tas mo ta /SENSOR = { \"Time\" : \"2019-10-31T21:34:29\" , \"APDS9960\" :{ \"Down\" : 1 }} 21 : 34 : 29 MQT : tele / tas mo ta /SENSOR = { \"Time\" : \"2019-10-31T21:34:29\" , \"APDS9960\" :{ \"Right\" : 1 }} 21 : 34 : 31 MQT : tele / tas mo ta /SENSOR = { \"Time\" : \"2019-10-31T21:34:31\" , \"APDS9960\" :{ \"Left\" : 1 }} 21 : 34 : 33 MQT : tele / tas mo ta /SENSOR = { \"Time\" : \"2019-10-31T21:34:33\" , \"APDS9960\" :{ \"Up\" : 1 }} 21 : 34 : 35 MQT : tele / tas mo ta /SENSOR = { \"Time\" : \"2019-10-31T21:34:35\" , \"APDS9960\" :{ \"Down\" : 1 }} When you enable RGBC mode with Sensor27 0 sensor will show up in web UI: and in MQTT topic (according to TelePeriod): MQT: tele/tasmota/SENSOR = {\"Time\":\"2019-10-31T21:48:51\",\"APDS9960\":{\"Red\":282,\"Green\":252,\"Blue\":196,\"Ambient\":169,\"CCT\":4217,\"Proximity\":9}} Commands ~ Command Value Description Sensor27 Show APDS9960 gesture/RGBC mode Sensor27 0 / off Disable APDS9960 gesture mode/Enable RGBC mode Sensor27 1 / on Enable APDS9960 gesture mode/Disable RGBC mode Sensor27 2 / on Enable APDS9960 gesture mode/Disable RGBC mode with half gain Sensor27 3 ...255 Set ATIME register for different integration times Example Rules ~ Device will be in RGBC mode until something is close to it, then it switches into gesture mode for 60 seconds. Rule on APDS9960#Proximity=250 do backlog Sensor27 1; RuleTimer1 60 endon on Rules#Timer=1 do Sensor27 0 endon Relay ON when ambient light is below 100 lux. Rule on APDS9960#Ambient<100 do POWER ON endon Control ON/OFF, brightness and color temperature with gestures Rule on APDS9960#Long=1 do power toggle endon on APDS9960#Up=1 do dimmer + endon on APDS9960#Down=1 do dimmer - endon on APDS9960#Left=1 do ct + endon on APDS9960#Right=1 do ct - endon Known Issues ~ The different PCB\u2019s on the market seem to differ quite substantially regarding to their electrical characteristics. We have at least one case report, where this led to a malfunction on an ESP8266-board within Tasmota but in another library too. The exact technical reason can only be suspected, but it is probably related to electrical noise and/or power consumption. In the case from above the sensor measured an incorrect high proximity value, which resulted in repeated triggering of a \"LONG\" gesture. The solution was to decrease the gain factor for proximity and gesture. Therefore the argument 2 ( sensor27 2 ) was introduced to change this at runtime. If you experience gesture sensing problems you could try this out, but if you measure proximity values <25 with nothing in front of the sensor (e.g. web interface after sensor27 0 ), then there is very likely another problem. It can be assumed, that the gesture sensitivity will suffer with reduced gain, so first try option 1 (=default). Beside that better wiring and maybe an additional capacitor over VCC and GROUND might be helpful. The measurement of the light level is briefly described in the datasheet and the open-source-libraries use the ambient-light-value directly from the sensor or calculate a LUX-value from RGB. Both variants are usable and differentiate between low and strong light, but the absolute values are questionable and at the moment we have an uncalibrated sensor. All known solutions use a fixed integration time, which is more or less the same as a fixed exposure time in photography. In contrast the TSL2561-library uses various integration times and maybe this is possible on the APDS9960 too. To eventually achieve this in the future, the option to set this integration time at runtime was added. Every argument between 3 and 255 sets the ATIME-register. The formula is: integration time = (256-ATIME) 2,78 ms, so with the default value of 219 we get (256-219) 2,78 = 102,86 ms. That means a smaller ATIME makes the integration time longer and more photons are captured, which might be usable for (very) low light conditions, because otherwise the sensor will saturate too early. The opposite is valid for a bigger ATIME value. The change of this value only makes sense for: users who need to change the sensitivity, if the sensor resides behind dark glass or want to contribute to the development of a new LUX-calculation in the driver. If we get enough feedback, this could lead to an improvement on the software side. Feel free to open (or search for) an issue, if you have measured the APDS9960 against other devices with different ATIME-values at different light levels. This is not a trivial task though. Breakout Boards ~ Where to get ~ 2\u20ac at AliExpress ~ $8 at Adafruit APDS-9960 Datasheet","title":"APDS-9960 light and gesture sensor"},{"location":"APDS-9960/#apds-9960-light-and-gesture-sensor","text":"This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_APDS9960 #define USE_APDS9960 // Enable APDS9960 Proximity Sensor (+4k7 code) #endif Broadcom APDS-9960 is a digital RGB, ambient light, proximity and gesture sensor device in a single 8-pin package. The device has an I2C compatible interface providing red, green, blue, clear (RGBC), proximity and gesture sensing with IR LED. The RGB and ambient light sensing feature detects light intensity under various lighting conditions and through various attentuation materials including darkened glass. In addition, the integrated UV-IR blocking filter enables accurate ambient light and correlated color temperature sensing.","title":"APDS-9960 light and gesture sensor"},{"location":"APDS-9960/#configuration","text":"","title":"Configuration"},{"location":"APDS-9960/#commands","text":"Command Value Description Sensor27 Show APDS9960 gesture/RGBC mode Sensor27 0 / off Disable APDS9960 gesture mode/Enable RGBC mode Sensor27 1 / on Enable APDS9960 gesture mode/Disable RGBC mode Sensor27 2 / on Enable APDS9960 gesture mode/Disable RGBC mode with half gain Sensor27 3 ...255 Set ATIME register for different integration times","title":"Commands"},{"location":"APDS-9960/#example-rules","text":"Device will be in RGBC mode until something is close to it, then it switches into gesture mode for 60 seconds. Rule on APDS9960#Proximity=250 do backlog Sensor27 1; RuleTimer1 60 endon on Rules#Timer=1 do Sensor27 0 endon Relay ON when ambient light is below 100 lux. Rule on APDS9960#Ambient<100 do POWER ON endon Control ON/OFF, brightness and color temperature with gestures Rule on APDS9960#Long=1 do power toggle endon on APDS9960#Up=1 do dimmer + endon on APDS9960#Down=1 do dimmer - endon on APDS9960#Left=1 do ct + endon on APDS9960#Right=1 do ct - endon","title":"Example Rules"},{"location":"APDS-9960/#known-issues","text":"The different PCB\u2019s on the market seem to differ quite substantially regarding to their electrical characteristics. We have at least one case report, where this led to a malfunction on an ESP8266-board within Tasmota but in another library too. The exact technical reason can only be suspected, but it is probably related to electrical noise and/or power consumption. In the case from above the sensor measured an incorrect high proximity value, which resulted in repeated triggering of a \"LONG\" gesture. The solution was to decrease the gain factor for proximity and gesture. Therefore the argument 2 ( sensor27 2 ) was introduced to change this at runtime. If you experience gesture sensing problems you could try this out, but if you measure proximity values <25 with nothing in front of the sensor (e.g. web interface after sensor27 0 ), then there is very likely another problem. It can be assumed, that the gesture sensitivity will suffer with reduced gain, so first try option 1 (=default). Beside that better wiring and maybe an additional capacitor over VCC and GROUND might be helpful. The measurement of the light level is briefly described in the datasheet and the open-source-libraries use the ambient-light-value directly from the sensor or calculate a LUX-value from RGB. Both variants are usable and differentiate between low and strong light, but the absolute values are questionable and at the moment we have an uncalibrated sensor. All known solutions use a fixed integration time, which is more or less the same as a fixed exposure time in photography. In contrast the TSL2561-library uses various integration times and maybe this is possible on the APDS9960 too. To eventually achieve this in the future, the option to set this integration time at runtime was added. Every argument between 3 and 255 sets the ATIME-register. The formula is: integration time = (256-ATIME) 2,78 ms, so with the default value of 219 we get (256-219) 2,78 = 102,86 ms. That means a smaller ATIME makes the integration time longer and more photons are captured, which might be usable for (very) low light conditions, because otherwise the sensor will saturate too early. The opposite is valid for a bigger ATIME value. The change of this value only makes sense for: users who need to change the sensitivity, if the sensor resides behind dark glass or want to contribute to the development of a new LUX-calculation in the driver. If we get enough feedback, this could lead to an improvement on the software side. Feel free to open (or search for) an issue, if you have measured the APDS9960 against other devices with different ATIME-values at different light levels. This is not a trivial task though.","title":"Known Issues"},{"location":"APDS-9960/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"API/","text":"Basic API information ~ Tasmota can easily be extended by developers using provided function pointers as callback Ids. This document lists the available callback function Ids. Read Sensor API for more information. \u00bd Callback availability can be checked by searching for either XdrvCall, XsnsCall, XdspCall, XnrgCall and XlgtCall. Driver, Sensor, Energy and Light Callback Ids ~ The following table lists Callback Ids and their availability for a Driver, Sensor or Energy service. Callback Id Bool xdrv xsns xnrg xlgt Description FUNC_SETTINGS_OVERRIDE x Override start-up settings FUNC_PIN_STATE x 1 2 At GPIO configuration FUNC_MODULE_INIT x 1 2 Init module specific parameters FUNC_PRE_INIT 1 2 Once GPIO have been established FUNC_INIT 1 3 2 At end of initialisation FUNC_LOOP 1 2 In main loop FUNC_EVERY_50_MSECOND 1 2 FUNC_EVERY_100_MSECOND 1 2 FUNC_EVERY_200_MSECOND x FUNC_EVERY_250_MSECOND 1 3 2 FUNC_EVERY_SECOND 1 2 FUNC_SAVE_AT_MIDNIGHT x At midnight FUNC_SAVE_BEFORE_RESTART 2 1 Just before a planned restart FUNC_AFTER_TELEPERIOD 2 1 At end of teleperiod FUNC_JSON_APPEND 2 1 3 Extend teleperiod JSON text FUNC_WEB_SENSOR 2 1 3 Add sensor data to web GUI FUNC_COMMAND x 1 2 3 4 When a command is not recognized FUNC_COMMAND_DRIVER x x When command Driver<id> is executed FUNC_COMMAND_SENSOR x x When command Sensor<id> is executed FUNC_MQTT_SUBSCRIBE x At end of MQTT subscriptions FUNC_MQTT_INIT x Once at end of MQTT connection FUNC_MQTT_DATA x x Before decoding command FUNC_SET_POWER x Before setting relays FUNC_SET_DEVICE_POWER x x Set relay FUNC_SHOW_SENSOR x When FUNC_JSON_APPEND completes FUNC_ANY_KEY x FUNC_ENERGY_EVERY_SECOND x FUNC_ENERGY_RESET x FUNC_RULES_PROCESS x x Process specific rule FUNC_SERIAL x 1 2 3 Process serial data FUNC_FREE_MEM x Show free memory for debugging FUNC_BUTTON_PRESSED x x When a button is pressed FUNC_WEB_ADD_BUTTON 1 2 Add a Configuration Button to GUI FUNC_WEB_ADD_MAIN_BUTTON 1 2 Add a main button to GUI FUNC_WEB_ADD_HANDLER 1 2 Add a webserver handler FUNC_SET_CHANNELS 2 1 FUNC_SET_SCHEME x The numbers represent the sequence of execution Display Call back Ids ~ The following table lists all Callback Ids for a Display service. Callback Id Bool Description FUNC_DISPLAY_INIT_DRIVER FUNC_DISPLAY_INIT FUNC_DISPLAY_EVERY_50_MSECOND FUNC_DISPLAY_EVERY_SECOND FUNC_DISPLAY_MODEL x FUNC_DISPLAY_MODE FUNC_DISPLAY_POWER FUNC_DISPLAY_CLEAR FUNC_DISPLAY_DRAW_FRAME FUNC_DISPLAY_DRAW_HLINE FUNC_DISPLAY_DRAW_VLINE FUNC_DISPLAY_DRAW_LINE FUNC_DISPLAY_DRAW_CIRCLE FUNC_DISPLAY_FILL_CIRCLE FUNC_DISPLAY_DRAW_RECTANGLE FUNC_DISPLAY_FILL_RECTANGLE FUNC_DISPLAY_TEXT_SIZE FUNC_DISPLAY_FONT_SIZE FUNC_DISPLAY_ROTATION FUNC_DISPLAY_DRAW_STRING FUNC_DISPLAY_ONOFF Init sequence ~ The following list shows a typical callback init sequence CFG : Loaded from flash at FB , Count 1581 xdrv - FUNC_SETTINGS_OVERRIDE xdrv - FUNC_PIN_STATE xsns - FUNC_PIN_STATE xdrv - FUNC_MODULE_INIT xlgt - FUNC_MODULE_INIT xdrv - FUNC_PRE_INIT xnrg - FUNC_PRE_INIT SRC : Restart xdrv - FUNC_SET_POWER xlgt - FUNC_SET_CHANNELS xdrv - FUNC_SET_DEVICE_POWER Project tasmota Wemos 2 Version 7.0 . 0.3 ( tasmota )- STAGE xdrv - FUNC_INIT xsns - FUNC_INIT I2C : ADS1115 found at 0x48 xdrv - FUNC_LOOP xsns - FUNC_LOOP xdrv - FUNC_EVERY_50_MSECOND xlgt - FUNC_SET_CHANNELS xsns - FUNC_EVERY_50_MSECOND xdrv - FUNC_EVERY_100_MSECOND xsns - FUNC_EVERY_100_MSECOND xdrv - FUNC_EVERY_250_MSECOND xsns - FUNC_EVERY_250_MSECOND xdrv - FUNC_EVERY_SECOND xsns - FUNC_EVERY_SECOND WIF : Attempting connection ... WIF : Network ( re ) scan started ... WIF : Attempting connection ... WIF : Attempting connection ... WIF : Attempting connection ... WIF : Network 0 , AP1 , SSId indebuurt1 , Channel 1 , BSSId 24 : D3 : F2 : 97 : C0 : A1 , RSSI - 86 , Encryption 1 WIF : Network 1 , AP2 , SSId indebuurt2 , Channel 5 , BSSId A0 : AB : 1 B : 7 D : 42 : AC , RSSI - 42 , Encryption 1 WIF : Network 2 , AP -, SSId indebuurt3 , Channel 12 , BSSId 60 : E3 : 27 : 58 : 77 : E6 , RSSI - 84 , Encryption 1 WIF : Connecting to AP2 indebuurt2 in mode 11 N as wemos2 ... WIF : Attempting connection ... WIF : Attempting connection ... WIF : Attempting connection ... WIF : Connected xdrv - FUNC_WEB_ADD_HANDLER xsns - FUNC_WEB_ADD_HANDLER HTP : Web server active on wemos2 with IP address 192.168 . 2.191 NTP : Drift 0 , ( UTC ) Wed Nov 06 13 : 57 : 08 2019 , ( DST ) Sun Mar 31 02 : 00 : 00 2019 , ( STD ) Sun Oct 27 03 : 00 : 00 2019 APP : Boot Count 500 MQT : Attempting connection ... MQT : Connected MQT : tele /wemos2/ LWT = Online ( retained ) MQT : cmnd /wemos2/ POWER = MQT : Subscribe to cmnd /wemos2/ # MQT : Subscribe to cmnd /sonoffs/ # MQT : Subscribe to cmnd /DVES_15568C_fb/ # xdrv - FUNC_MQTT_SUBSCRIBE MQT : tele /wemos2/INFO1 = {\"Module\":\"Generic\",\"Version\":\"7.0.0.3(tasmota)\",\"FallbackTopic\":\"cmnd/DVES_15568C_fb/\",\"GroupTopic\":\"cmnd/sonoffs/ \"} MQT: tele/wemos2/INFO2 = {\" WebServerMode \":\" Admin \",\" Hostname \":\" wemos2 \",\" IPAddress \":\" 192.168 . 2.191 \"} MQT: tele/wemos2/INFO3 = {\" RestartReason \":\" Software / System restart \"} MQT: stat/wemos2/RESULT = {\" POWER1 \":\" OFF \"} MQT: stat/wemos2/POWER1 = OFF MQT: stat/wemos2/RESULT = {\" POWER2 \":\" ON \" } MQT : stat /wemos2/ POWER2 = ON xdrv - FUNC_MQTT_INIT CFG : Saved to flash at FA , Count 1582 , Bytes 4096","title":"Basic API information"},{"location":"API/#basic-api-information","text":"Tasmota can easily be extended by developers using provided function pointers as callback Ids. This document lists the available callback function Ids. Read Sensor API for more information. \u00bd Callback availability can be checked by searching for either XdrvCall, XsnsCall, XdspCall, XnrgCall and XlgtCall.","title":"Basic API information"},{"location":"API/#driver-sensor-energy-and-light-callback-ids","text":"The following table lists Callback Ids and their availability for a Driver, Sensor or Energy service. Callback Id Bool xdrv xsns xnrg xlgt Description FUNC_SETTINGS_OVERRIDE x Override start-up settings FUNC_PIN_STATE x 1 2 At GPIO configuration FUNC_MODULE_INIT x 1 2 Init module specific parameters FUNC_PRE_INIT 1 2 Once GPIO have been established FUNC_INIT 1 3 2 At end of initialisation FUNC_LOOP 1 2 In main loop FUNC_EVERY_50_MSECOND 1 2 FUNC_EVERY_100_MSECOND 1 2 FUNC_EVERY_200_MSECOND x FUNC_EVERY_250_MSECOND 1 3 2 FUNC_EVERY_SECOND 1 2 FUNC_SAVE_AT_MIDNIGHT x At midnight FUNC_SAVE_BEFORE_RESTART 2 1 Just before a planned restart FUNC_AFTER_TELEPERIOD 2 1 At end of teleperiod FUNC_JSON_APPEND 2 1 3 Extend teleperiod JSON text FUNC_WEB_SENSOR 2 1 3 Add sensor data to web GUI FUNC_COMMAND x 1 2 3 4 When a command is not recognized FUNC_COMMAND_DRIVER x x When command Driver<id> is executed FUNC_COMMAND_SENSOR x x When command Sensor<id> is executed FUNC_MQTT_SUBSCRIBE x At end of MQTT subscriptions FUNC_MQTT_INIT x Once at end of MQTT connection FUNC_MQTT_DATA x x Before decoding command FUNC_SET_POWER x Before setting relays FUNC_SET_DEVICE_POWER x x Set relay FUNC_SHOW_SENSOR x When FUNC_JSON_APPEND completes FUNC_ANY_KEY x FUNC_ENERGY_EVERY_SECOND x FUNC_ENERGY_RESET x FUNC_RULES_PROCESS x x Process specific rule FUNC_SERIAL x 1 2 3 Process serial data FUNC_FREE_MEM x Show free memory for debugging FUNC_BUTTON_PRESSED x x When a button is pressed FUNC_WEB_ADD_BUTTON 1 2 Add a Configuration Button to GUI FUNC_WEB_ADD_MAIN_BUTTON 1 2 Add a main button to GUI FUNC_WEB_ADD_HANDLER 1 2 Add a webserver handler FUNC_SET_CHANNELS 2 1 FUNC_SET_SCHEME x The numbers represent the sequence of execution","title":"Driver, Sensor, Energy and Light Callback Ids"},{"location":"API/#display-call-back-ids","text":"The following table lists all Callback Ids for a Display service. Callback Id Bool Description FUNC_DISPLAY_INIT_DRIVER FUNC_DISPLAY_INIT FUNC_DISPLAY_EVERY_50_MSECOND FUNC_DISPLAY_EVERY_SECOND FUNC_DISPLAY_MODEL x FUNC_DISPLAY_MODE FUNC_DISPLAY_POWER FUNC_DISPLAY_CLEAR FUNC_DISPLAY_DRAW_FRAME FUNC_DISPLAY_DRAW_HLINE FUNC_DISPLAY_DRAW_VLINE FUNC_DISPLAY_DRAW_LINE FUNC_DISPLAY_DRAW_CIRCLE FUNC_DISPLAY_FILL_CIRCLE FUNC_DISPLAY_DRAW_RECTANGLE FUNC_DISPLAY_FILL_RECTANGLE FUNC_DISPLAY_TEXT_SIZE FUNC_DISPLAY_FONT_SIZE FUNC_DISPLAY_ROTATION FUNC_DISPLAY_DRAW_STRING FUNC_DISPLAY_ONOFF","title":"Display Call back Ids"},{"location":"API/#init-sequence","text":"The following list shows a typical callback init sequence CFG : Loaded from flash at FB , Count 1581 xdrv - FUNC_SETTINGS_OVERRIDE xdrv - FUNC_PIN_STATE xsns - FUNC_PIN_STATE xdrv - FUNC_MODULE_INIT xlgt - FUNC_MODULE_INIT xdrv - FUNC_PRE_INIT xnrg - FUNC_PRE_INIT SRC : Restart xdrv - FUNC_SET_POWER xlgt - FUNC_SET_CHANNELS xdrv - FUNC_SET_DEVICE_POWER Project tasmota Wemos 2 Version 7.0 . 0.3 ( tasmota )- STAGE xdrv - FUNC_INIT xsns - FUNC_INIT I2C : ADS1115 found at 0x48 xdrv - FUNC_LOOP xsns - FUNC_LOOP xdrv - FUNC_EVERY_50_MSECOND xlgt - FUNC_SET_CHANNELS xsns - FUNC_EVERY_50_MSECOND xdrv - FUNC_EVERY_100_MSECOND xsns - FUNC_EVERY_100_MSECOND xdrv - FUNC_EVERY_250_MSECOND xsns - FUNC_EVERY_250_MSECOND xdrv - FUNC_EVERY_SECOND xsns - FUNC_EVERY_SECOND WIF : Attempting connection ... WIF : Network ( re ) scan started ... WIF : Attempting connection ... WIF : Attempting connection ... WIF : Attempting connection ... WIF : Network 0 , AP1 , SSId indebuurt1 , Channel 1 , BSSId 24 : D3 : F2 : 97 : C0 : A1 , RSSI - 86 , Encryption 1 WIF : Network 1 , AP2 , SSId indebuurt2 , Channel 5 , BSSId A0 : AB : 1 B : 7 D : 42 : AC , RSSI - 42 , Encryption 1 WIF : Network 2 , AP -, SSId indebuurt3 , Channel 12 , BSSId 60 : E3 : 27 : 58 : 77 : E6 , RSSI - 84 , Encryption 1 WIF : Connecting to AP2 indebuurt2 in mode 11 N as wemos2 ... WIF : Attempting connection ... WIF : Attempting connection ... WIF : Attempting connection ... WIF : Connected xdrv - FUNC_WEB_ADD_HANDLER xsns - FUNC_WEB_ADD_HANDLER HTP : Web server active on wemos2 with IP address 192.168 . 2.191 NTP : Drift 0 , ( UTC ) Wed Nov 06 13 : 57 : 08 2019 , ( DST ) Sun Mar 31 02 : 00 : 00 2019 , ( STD ) Sun Oct 27 03 : 00 : 00 2019 APP : Boot Count 500 MQT : Attempting connection ... MQT : Connected MQT : tele /wemos2/ LWT = Online ( retained ) MQT : cmnd /wemos2/ POWER = MQT : Subscribe to cmnd /wemos2/ # MQT : Subscribe to cmnd /sonoffs/ # MQT : Subscribe to cmnd /DVES_15568C_fb/ # xdrv - FUNC_MQTT_SUBSCRIBE MQT : tele /wemos2/INFO1 = {\"Module\":\"Generic\",\"Version\":\"7.0.0.3(tasmota)\",\"FallbackTopic\":\"cmnd/DVES_15568C_fb/\",\"GroupTopic\":\"cmnd/sonoffs/ \"} MQT: tele/wemos2/INFO2 = {\" WebServerMode \":\" Admin \",\" Hostname \":\" wemos2 \",\" IPAddress \":\" 192.168 . 2.191 \"} MQT: tele/wemos2/INFO3 = {\" RestartReason \":\" Software / System restart \"} MQT: stat/wemos2/RESULT = {\" POWER1 \":\" OFF \"} MQT: stat/wemos2/POWER1 = OFF MQT: stat/wemos2/RESULT = {\" POWER2 \":\" ON \" } MQT : stat /wemos2/ POWER2 = ON xdrv - FUNC_MQTT_INIT CFG : Saved to flash at FA , Count 1582 , Bytes 4096","title":"Init sequence"},{"location":"AS3935/","text":"AS3935 Franklin Lightning sensor ~ This feature is included only in tasmota-sensors.bin The AS3935 is a programmable fully integrated Lightning Sensor IC that detects the presence and approach of potentially hazardous lightning activity in the vicinity and provides an estimation on the distance to the head of the storm. The embedded lightning algorithm checks the incoming signal pattern to reject the potential man-made disturbers. Tasmota driver includes: support for all AS3935 Parameters support of all related commands for configuration support of NF-Auto Function to auto Threshold the Noise Reduction support of Auto Disturber support of calibrating the internal OSC with switchable Caps Configuration ~ Wiring ~ AS3935 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy IRQ GPIOz Warning \"Sensor uses a software interrupt. Make sure that the connection with the IRQ pin is stable to prevent flicker.\" Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) GPIOz to AS3935 (202) Note for I2C Use You will need to wire up all of the associated pins for the different boards. - Always connect CS and MISO to GND. - If \"SI\" is present, you need to connect to VCC. See some wiring on the Board pictures below. I2C wiring After a reboot the driver will detect AS3935 automatically. and in MQTT topic when an Event occurs: {\"Time\":\"2020-01-01T17:07:07\",\"AS3935\":{\"Event\":4,\"Distance\":12,\"Energy\":58622,\"Stage\":1}} Commands and Use ~ Console Commands Description values Bitlength AS3935power Power On/Off the Device 0/1 (On/Off) (1 Bit) AS3935setnf Noise Floor Level value from 0-7 (3 Bit) AS3935setml Minimum number of lightning 1, 5, 9, 16 (2 bit) AS3935default load default for Sensor and Settings no argument AS3935setgain Set Indoor/Outdoor Indoors/Outdoors (Ascii) AS3935settunecaps Internal Tuning Cap. value from 0-15 (4 Bits) AS3935setrej Spike rejection value from 0-15 (4 Bits) AS3935setwdth Watchdog threshold value from 0-15 (4 Bits) AS3935setminstage min stage that could be come with NFautotune value from 0-15: 0-7 Indoors, 8-15 Outdoors (4 Bits) AS3935disturber Set Disturber 0/1 (On/Off) (1 Bit) AS3935autonf Set Auto Tune for Noise Level 0/1 (On/Off) (1 Bit) AS3935autodisturber Set Auto-Disturber 0/1 (On/Off) (1 Bit) AS3935autonfmax Auto Tune with INDOOR and OUTDOOR 0/1 (On/Off) (1 Bit) AS3935lightevent mqtt messages only for lightning events 0/1 (On/Off) (1 Bit) AS3935noirqevent suppress mqtt \"IRQ with no Event\" Messages 0/1 (On/Off) (1 Bit) AS3935settings show all settings no argument AS3935calibrate auto calibrate the internal Capacitors no argument AS3935disttime time for reset Disturber in auto-mode 0-15 min. (4 Bit) AS3935nftime time for auto-Nf treshhold 0-15 min (4 Bit) Note for AS3935Calibrate Normally you don't need the calibrate function. If you buy the AS3935, the module has a sticker on it with the calibrated cap. Use AS3935Settunecaps for setting up this value. if the calibration fails, it is possible that you have a board with the wrong caps on it! (some CJMCU-Boards) CJMCU Board Mqtt Events: ~ No. Description Suppress with Command AS3935lightevent Suppress with Command AS3935noirqevent 0 no event 1 Lightning with Distance detected 2 Lightning out of Distance 3 Distance cannot be determined 4 Storm is Overhead 5 Noise level too high * 6 Disturber detected * 7 Irq with no Event detected * 8 Irq Pin flicker detected 9 Device is Powerd Off NF setting table: ~ Setting table of the NF-noise sensitivity and stages: Stages NF-LEV AFE-GB uVrms Sensitivity Stage 0 000 Indoors 28 highly sensitive Stage 1 001 Indoors 45 Stage 2 010 Indoors 62 Stage 3 011 Indoors 78 Stage 4 100 Indoors 95 Stage 5 101 Indoors 112 Stage 6 110 Indoors 130 Stage 7 111 Indoors 146 Stage 8 000 Outdoors 390 Stage 9 001 Outdoors 630 Stage 10 010 Outdoors 860 Stage 11 011 Outdoors 1100 Stage 12 100 Outdoors 1330 Stage 13 101 Outdoors 1570 Stage 14 110 Outdoors 1800 Stage 15 111 Outdoors 2000 less sensitive Hint and Tips take a stabilized power supply. keep a distance of at least 200 mm from the ESP and the AS3395 be careful with \"ready to Use\" devices like Sonoff, etc. they don't have a good power supply inside. use a Ferrit clamp filter on the sensor cable. wire all related Pins for I2C use. You can find some troubleshooting tips in the Tasmota GitHub discussion . Breakout Boards and Wiring for I2C use: ~ PlayingwithFusion Board: Sparkfun Board V2.0: Embedded Adventures Board: CJMCU Board: GY-AS3935 Board: Warning \"Some type of this sensor have wrong capacitors (100pF and 1000pF) installed and the calibration fails. The correct caps are 680pF and 270pF.\" Datasheet: ~ Datasheet from Mouser Web Site","title":"AS3935 Franklin Lightning sensor"},{"location":"AS3935/#as3935-franklin-lightning-sensor","text":"This feature is included only in tasmota-sensors.bin The AS3935 is a programmable fully integrated Lightning Sensor IC that detects the presence and approach of potentially hazardous lightning activity in the vicinity and provides an estimation on the distance to the head of the storm. The embedded lightning algorithm checks the incoming signal pattern to reject the potential man-made disturbers. Tasmota driver includes: support for all AS3935 Parameters support of all related commands for configuration support of NF-Auto Function to auto Threshold the Noise Reduction support of Auto Disturber support of calibrating the internal OSC with switchable Caps","title":"AS3935 Franklin Lightning sensor"},{"location":"AS3935/#configuration","text":"","title":"Configuration"},{"location":"AS3935/#wiring","text":"AS3935 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy IRQ GPIOz Warning \"Sensor uses a software interrupt. Make sure that the connection with the IRQ pin is stable to prevent flicker.\"","title":"Wiring"},{"location":"AS3935/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) GPIOz to AS3935 (202) Note for I2C Use You will need to wire up all of the associated pins for the different boards. - Always connect CS and MISO to GND. - If \"SI\" is present, you need to connect to VCC. See some wiring on the Board pictures below. I2C wiring After a reboot the driver will detect AS3935 automatically. and in MQTT topic when an Event occurs: {\"Time\":\"2020-01-01T17:07:07\",\"AS3935\":{\"Event\":4,\"Distance\":12,\"Energy\":58622,\"Stage\":1}}","title":"Tasmota Settings"},{"location":"AS3935/#commands-and-use","text":"Console Commands Description values Bitlength AS3935power Power On/Off the Device 0/1 (On/Off) (1 Bit) AS3935setnf Noise Floor Level value from 0-7 (3 Bit) AS3935setml Minimum number of lightning 1, 5, 9, 16 (2 bit) AS3935default load default for Sensor and Settings no argument AS3935setgain Set Indoor/Outdoor Indoors/Outdoors (Ascii) AS3935settunecaps Internal Tuning Cap. value from 0-15 (4 Bits) AS3935setrej Spike rejection value from 0-15 (4 Bits) AS3935setwdth Watchdog threshold value from 0-15 (4 Bits) AS3935setminstage min stage that could be come with NFautotune value from 0-15: 0-7 Indoors, 8-15 Outdoors (4 Bits) AS3935disturber Set Disturber 0/1 (On/Off) (1 Bit) AS3935autonf Set Auto Tune for Noise Level 0/1 (On/Off) (1 Bit) AS3935autodisturber Set Auto-Disturber 0/1 (On/Off) (1 Bit) AS3935autonfmax Auto Tune with INDOOR and OUTDOOR 0/1 (On/Off) (1 Bit) AS3935lightevent mqtt messages only for lightning events 0/1 (On/Off) (1 Bit) AS3935noirqevent suppress mqtt \"IRQ with no Event\" Messages 0/1 (On/Off) (1 Bit) AS3935settings show all settings no argument AS3935calibrate auto calibrate the internal Capacitors no argument AS3935disttime time for reset Disturber in auto-mode 0-15 min. (4 Bit) AS3935nftime time for auto-Nf treshhold 0-15 min (4 Bit) Note for AS3935Calibrate Normally you don't need the calibrate function. If you buy the AS3935, the module has a sticker on it with the calibrated cap. Use AS3935Settunecaps for setting up this value. if the calibration fails, it is possible that you have a board with the wrong caps on it! (some CJMCU-Boards) CJMCU Board","title":"Commands and Use"},{"location":"AS3935/#mqtt-events","text":"No. Description Suppress with Command AS3935lightevent Suppress with Command AS3935noirqevent 0 no event 1 Lightning with Distance detected 2 Lightning out of Distance 3 Distance cannot be determined 4 Storm is Overhead 5 Noise level too high * 6 Disturber detected * 7 Irq with no Event detected * 8 Irq Pin flicker detected 9 Device is Powerd Off","title":"Mqtt Events:"},{"location":"AS3935/#nf-setting-table","text":"Setting table of the NF-noise sensitivity and stages: Stages NF-LEV AFE-GB uVrms Sensitivity Stage 0 000 Indoors 28 highly sensitive Stage 1 001 Indoors 45 Stage 2 010 Indoors 62 Stage 3 011 Indoors 78 Stage 4 100 Indoors 95 Stage 5 101 Indoors 112 Stage 6 110 Indoors 130 Stage 7 111 Indoors 146 Stage 8 000 Outdoors 390 Stage 9 001 Outdoors 630 Stage 10 010 Outdoors 860 Stage 11 011 Outdoors 1100 Stage 12 100 Outdoors 1330 Stage 13 101 Outdoors 1570 Stage 14 110 Outdoors 1800 Stage 15 111 Outdoors 2000 less sensitive Hint and Tips take a stabilized power supply. keep a distance of at least 200 mm from the ESP and the AS3395 be careful with \"ready to Use\" devices like Sonoff, etc. they don't have a good power supply inside. use a Ferrit clamp filter on the sensor cable. wire all related Pins for I2C use. You can find some troubleshooting tips in the Tasmota GitHub discussion .","title":"NF setting table:"},{"location":"AS3935/#breakout-boards-and-wiring-for-i2c-use","text":"","title":"Breakout Boards and Wiring for I2C use:"},{"location":"AS3935/#datasheet","text":"Datasheet from Mouser Web Site","title":"Datasheet:"},{"location":"AWS-IoT-cert/","text":"This page contains deprecated information. We advise to use the AWS IoT password based authentication . New simplified and automated configuration We now provide easy to use AWS CloudFormation templates to generate the private key and sign the certificate. The manual method is now in Appendix This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_MQTT_TLS #define USE_MQTT_TLS #define USE_MQTT_TLS_CA_CERT // Optional but highly recommended #endif #ifndef USE_MQTT_AWS_IOT #define USE_MQTT_AWS_IOT #endif #ifdef USE_DISCOVERY #undef USE_DISCOVERY #endif As of Tasmota version 6.6.0.3, the device-specific credentials are no longer restricted to being set at compile time only. You can now use the same firmware for all your devices. AWS IoT credentials can be set through the Console at runtime and are stored in flash memory. Credentials will survive firmware updates and OTA. Credentials will not survive a full Flash reset Reset 5 or Reset 6 nor will it survive a System Parameter Flash reset Reset 3 Benefits ~ AWS IoT provides secure, bi-directional communication between Internet-connected devices such as sensors, actuators, embedded micro-controllers. This basically allows to communicate in both direction from the cloud using MQTT over secure channels using TLS. 1. More Alexa controls It's actually easy to develop smarthome Alexa skills, so that you can control your whole house. Currently you can only use the local Philips Hue/Wemo emulation - limited to lights and switches. You can imagine for instance controlling your Sonoff RF Bridge and send IR codes to your TV. Alexa skills need to communicate back to your devices, which is easy using MQTT and AWS IoT 2. No need for a local gateway Of course you can do it with a local gateway like Raspberry PI using many of the open-source solutions (Domoticz...). You can also do it entirely from the cloud without the hassle of managing and updating a local gateway. On top of it, AWS IoT provides tools to collect and archive your data, automate (AWS IoT things). Maximum security Keep in mind that AWS IoT is based with 'security first' in mind. All the data in AWS IoT is your data and is not shared with anyone else. Communication is done over TLS 1.2 tunnels, using client certificates to authenticate each device. Up to now it was challenging to enable TLS on ESP8266 because of the high memory requirements of TLS. Thanks to the switch of Arduino to BearSSL and aggressive optimization, the amount of memory needed is as low as 6.0k during normal operation, and an additional 6.6k during connection (TLS handshake). This makes it totally doable with standard 'Tasmota' firmware with Web and Hue emulation activated. You should see more than 20k of memory still available. Caveats ~ AWS IoT requires each Tasmota device to have its own distinct Private Key and Certificate (~800 bytes). Although you could imagine to use the same Private Key in all your devices, this is considered as a very bad practice. You are warned! During TLS handshake, a secondary stack of 5.3k is allocated on the heap to allow BearSSL to have enough stack room. Memory is freed at the end of the handshake. Allocating such big chunks of memory can cause issues when heap fragmentation gets too high. If you see memory going below 15KB, you may experience crashes. Cost AWS provides a Free Tier that allows you to use some services for free up to a specific level. For example, it allows you to have 50 devices connecting 24 hours a day exchanging 300 messages per day. For a typical house, there is a good chance the service costs you nothing (the first year). How to configure? ~ AWS IoT requires a distinct Private Key and Certificate per Tasmota device. Currently you need to custom compile your Tasmota firmware and burn the Key and Certificate in your firmware. We will later explore how to configure them separately. Here is a simple guide. 0. Open an AWS Account ~ If you don't have already one, just follow the guide: https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/ 1. Prerequisites ~ You will need to install/compile the following: Complete environment to compile Tasmota, ex: PlatformIO (PlatformIO) Recent version of openssl 2. Enable AWS IoT in Tasmota ~ Using your favorite IDE, create user_config_override.h and add the required compilation directives as documented at the top of this article. Note: TLS handshake takes ~1.2s on ESP8266 @80MHz. You may choose to switch to 160MHz if the power supply of your device supports it. If you do so, handshake time should be ~0.7s. Compile the firmware and ensure it completes successfully. This step is only to check compilation goes well. Your firmware is still not usable since it does not contain the Private Key + Certificate. 3. Flash your device ~ Flash your device the normal way; either through serial or OTA. If you use OTA, first flash a sonoff-minimal firmware, then your target firmware. 4. Configure AWS IoT Policy (to be done once) ~ Open the AWS Console and select the target region. In the example below we will use (EU) Frankfurt (eu-central-1). Download the CloudFormation template Tasmota-MqttPolicy and use it in AWS CloudFormation. Or click on the link for the region you have chosen: Region Code Launch US East (N. Virginia) us-east-1 EU (Frankfurt) eu-central-1 EU (Paris) eu-west-3 At the Create Stack screen, click Next . At the Specify stack details screen, keep all default parameters and click Next . At the Configure stack options screen, keep all default parameters and click Next . At the Review TasmotaMqttPolicy screen, scroll down and click Create Stack . The stack usually takes less than 2 minutes to complete. Wait for it to reach CREATE_COMPLETE state. If you have left the parameter RetentionPolicy to Retain , then you can delete this CloudFormation stack (it will not delete the Policy). Click on the Delete button. After less than 2 minutes, the stack should have reached the state DELETE_COMPLETE 5. Create an AWS IoT Thing with Private Key and Certificate (once per Tasmota device) ~ The provided AWS CloudFormation template will create the required resources to create: One AWS IoT Thing One Private key One Certificate signed by AWS IoT Temporary resources (AWS Lambda functions, AWS IAM resources) that you can delete once the Tasmota thing is created. Open the AWS Console and select the target region. In the example below we will use (EU) Frankfurt (eu-central-1). Download the CloudFormation template Tasmota-Thing and use it in AWS CloudFormation. Or click on the link for the region you have chosen: Region Code Launch US East (N. Virginia) us-east-1 EU (Frankfurt) eu-central-1 EU (Paris) eu-west-3 At the Create Stack screen, click Next . At the Specify stack details screen, keep all default parameters and click Next . Note: you can change the name of the Thing in AWS IoT by specifying the parameter ThingParamName. At the Configure stack options screen, keep all default parameters and click Next . At the Review Tasmota-91 screen, scroll down, check the box I acknowledge that AWS CloudFormation might create IAM resources. and click Create Stack . The stack usually takes less than 4 minutes to complete. Wait for it to reach CREATE_COMPLETE state. You need to copy & paste the contents of the Outputs tab of the CloudFormation stack: MqttHost , TlsKey1 , TlsKey2 Keep a copy of those parameters in a file, you might need them again. Cleaning : to avoid having CloudFormation templates piling up in your console, you can delete them. The created resources will remain, if you have left the parameter RetentionPolicy to Retain . 6. Configure Tasmota device ~ This is the last step, you need to configure the MQTT parameters. The easiest way is through the web console. We will only cut and paste parameters from the Outputs tab of the CloudFormation console. Configure the AWS EndPoint Copy and paste in the web console the content of MqttHost Example: Backlog MqttHost <your_endpoint>-ats.iot.eu-central-1.amazonaws.com; MqttPort 8883 This will trigger a reboot of the device. Optional, change the topic to distinguish the devices from each others: Topic sonoff/Tasmota-01 Check that the key store is empty Type the following command: TLSKey hh : mm : ss CMD : TLSKey hh : mm : ss MQT : stat/<topic>/ RESULT = { \"TLSKey1\" :- 1 , \"TLSKey2\" :- 1 } If both values are -1 , it means it does not contain any key. If you need to reset the key store, use the command TLSKey 0 . Configure the Private Key and Certificate AWS IoT credentials are composed of two distinct parts, first a Private Key - this is the secret that will allow your device to prove it is who it pretends to be. Consider this as sensitive as a password. The Private Key is exactly 32 bytes (256 bits). The second part is the Certificate delivered by AWS IoT. Tasmota will also need it to authenticate to the AWS IoT endpoint. Both credentials must be stored in Tasmota Flash memory, in that order, using the new TLSKey command. TlsKey1 stores the Private Key. TlsKey2 stores the Certificate. There is no command to retrieve the private key from a Tasmota device, but keep in mind this secret information can easily be dumped via Serial if somebody gets physical access to the device (ESP8266 does not contain any secure storage area). Simply Copy and Paste the two commands from TlsKey1 and TlsKey2 . TLSKey1 <secret_key_secret_key_secret_key>= TLSKey2 MIIC<certificate_very_long_string>= TLSKey1 and TLSKey2 must be entered in that order. If successful, you should see a message similar to: hh : mm : ss MQT : stat /<topic>/ RESULT = { \"TLSKey1\" : 32 , \"TLSKey2\" : 641 } You need to check that both values are not \"-1\". The value for \"TLSKey1\" should always be 32. The value for \"TLSKey2\" varies depending on several parameters, and should be within the 640-700 bytes range. Connect to AWS IoT Once the TLSKey1 and TLSKey2 are entered, Tasmota will try to connect to AWS IoT. Keep in mind that AWS IoT does not support 'retained' messages. Whatever the 'retained' configuration in Tasmota, messages are always published as 'retained=false'. Here is an example of output you should see: 00 : 00 : 04 HTP : Web server active on sonoff - 4585 with IP address 192.168 . 1.59 00 : 00 : 04 UPP : Multicast ( re ) joined 21 : 28 : 25 MQT : Attempting connection ... 21 : 28 : 25 MQT : AWS IoT endpoint : xxxxxxxxxxxxx - ats . iot . eu - central - 1 . amazonaws . com 21 : 28 : 26 MQT : AWS IoT connected in 1279 ms 21 : 28 : 26 MQT : Connected 21 : 28 : 26 MQT : tele /tasmota/ LWT = Online 21 : 28 : 26 MQT : cmnd /tasmota/ POWER = 21 : 28 : 26 MQT : tele /tasmota/ INFO1 = { \"Module\" : \"Sonoff Basic\" , \"Version\" : \"6.5.0.14(sonoff)\" , \"FallbackTopic\" : \"cmnd/DVES_67B1E9_fb/\" , \"GroupTopic\" : \"sonoffs\" } 7. Check end-to-end communication ~ In the AWS IoT console, click on \" Test \" in the left panel. In the \" Subscription topic \" field, type +/sonoff/# then click on \" Subscribe to topic \". This will display all MQTT messages received. Type a command in the Web Tasmota console, you should see MQTT message flow. Enjoy! 8. Cleaning ~ Cleaning : to avoid having CloudFormation templates piling up in your console, you can delete them. The created resources will remain, if you have left the parameter RetentionPolicy to Retain . 9. Troubleshooting ~ TLSError shows any error at the TLS level. See here for most common error codes. For implementation details, see here ~ Appendix: Manual configuration ~ 1. Prerequisites ~ You will need to install/compile the following: Complete environment to compile Tasmota, ex: PlatformIO (PlatformIO) Recent version of openssl 2. Configure AWS IoT (to be done once) ~ Open the AWS Console. Click on \" Services \" and select \" IoT Core \". Select the AWS Region where you want to locate your data, for ex: \" (EU) Frankfurt \". Now we need to create a security policy to allow your Tasmota devices to connect to AWS IoT, publish and subscribe to topics. On the left panel, click on \" Secure \" > \" Policies \". Click on the \" Create \" button in the upper right corner. Enter in the \" Name \" field, enter the name of your policy, for ex: \" TasmotaMqttPolicy \". Then click on \" Advanced mode \" Cut and paste the policy below. Click on \" Create \" in the lower right corner. { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [ \"iot:Connect\", \"iot:Publish\", \"iot:Subscribe\", \"iot:Receive\" ], \"Resource\": \"*\" } ] } 3. Create a Private Key and Certificate (once per Tasmota device) ~ Do not use the default AWS IoT feature to generate your private key online. It creates a 2048 bits RSA key. Instead we are using elliptic curves keys - they are much smaller in memory than RSA keys (this saves ~1k of memory) and the handshake is significantly faster. First create an ECC private key for your device (as described in this Blog ). Keep you private key in a safe place. $ openssl ecparam -name prime256v1 -genkey -out tasmota-01.key Next, using this private key, create a certificate signing request (CSR). When asked enter the certificate details. This is not really used later, you can just enter a 2 letters country code like \" EU \" and leave all other fields blank (type 8 times enter). $ openssl req -new -sha256 -key tasmota-01.key -nodes -out tasmota-01.csr You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter '.' , the field will be left blank. ----- Country Name ( 2 letter code ) [] :EU <enter> State or Province Name ( full name ) [] : <enter> Locality Name ( eg, city ) [] : <enter> Organization Name ( eg, company ) [] : <enter> Organizational Unit Name ( eg, section ) [] : <enter> Common Name ( eg, fully qualified host name ) [] : <enter> Email Address [] : <enter> Please enter the following 'extra' attributes to be sent with your certificate request A challenge password [] : <enter> Next ask AWS IoT to sign your key with its certificate. On the left panel, click on \" Secure \" > \" Certificates \". Click on \" Create a certificate \". Then choose the \" Create with CSR \" button, locate your CSR file from above. Click on \" Upload file \". Download the certificate file, click on \" Download \", save the file as \" tasmota-01.cert.pem \". Important : don't forget to click on the \" Activate \" to activate the certificate. Your Private Key and Certificates are ready to use. Now we need to register the Tasmota Device. 4. Write down your AWS IoT endpoint (same for all devices) ~ Click on \" Settings \" in the left panel. You should see a field called \" Custom endpoint \". Write down the endpoint domain name. It should look like this (if you have chosen the Frankfurt region: <xxxxxxxxxxxxxx>-ats.iot.eu-central-1.amazonaws.com This is your MQTT endpoint, the port is 8883 - MQTT over TLS. 5. Register the device in AWS IoT (once per Tasmota device) ~ Now on the left pane, click on \" Manage \" > \" Things \". Click on \" Register a thing \", then \" Create a single thing \". Give your device a name like \" Tasmota-01 \". Scroll down and click \" Next \" at the botton right. Then click on \" Create thing without a certificate \". Now we need to associate the certificate created earlier to your device. In the left panel, click back on \" Secure \" > \" Certificates \". Select the certificate created earlier. In the next pane, click on \" Actions \" in the upper right part. First select \" Attach policy \", check \" TasmotaMqttPolicy \" and \" Attach \". Click again on \" Actions \" and select \" Attach thing \", check \" Tasmota-01 \" and \" Attach \". Your setup is done in AWS IoT. Let's proceed to the custom firmware. 8. Prepare your AWS IoT credentials ~ You will now need to convert your AWS IoT credentials to Tasmota commands. Credentials are composed of two distinct parts, first a Private Key - this is the secret that will allow your device to prove it is who it pretends to be. Consider this as sensitive as a password. The Private Key is exactly 32 bytes (256 bits). The second part is the Certificate delivered by AWS IoT. Tasmota will also need it to authenticate to the AWS IoT endpoint. Both credentials must be stored in Tasmota Flash memory, in that order, using the new TLSKey command. a. First check that the key store is empty Type the following command: TLSKey hh : mm : ss CMD : TLSKey hh : mm : ss MQT : stat / tasmota / RESULT = { \"TLSKey1\" :- 1 , \"TLSKey2\" :- 1 } If both values are -1 , it means it does not contain any key. If you need to reset the key store, use the command TLSKey 0 . b. Convert the Private Key We will extract the 32 bytes Private key from tasmota-01.key generated above. 1-line method, use the following command: (fake key below) openssl ec -in tasmota-01.key -inform PEM -outform DER | openssl asn1parse -inform DER | head -3 | tail -1 | awk -F':' '{ print $4 }' | xxd -r -p | base64 | echo \"TLSKey1 $(</dev/stdin)\" Example: openssl ec -in tasmota-01.key -inform PEM -outform DER | openssl asn1parse -inform DER | head -3 | tail -1 | awk -F':' '{ print $4 }' | xxd -r -p | base64 | echo \"TLSKey1 $(</dev/stdin)\" read EC key writing EC key TLSKey1 UvBgyCuPr/lKSgwumf/8o/mIsKQPBHn3ZZAGZl4ui9E= Cut and paste the command starting with TLSKey1 ... into the Tasmota Web Console or through MQTT. hh : mm : ss CMD : TLSKey1 UvBgyCuPr / lKSgwumf / 8 o / mIsKQPBHn3ZZAGZl4ui9E = hh : mm : ss MQT : stat / tasmota / RESULT = { \"TLSKey1\" : 32 , \"TLSKey2\" :- 1 } Alternative method: Convert the Private Key file from PEM to DER (binary format): openssl ec -in tasmota-01.key -inform PEM -outform DER -out tasmota-01.key.der Dump the ASN.1 format from the DER file: openssl asn1parse - inform DER - in tasmota -01. key . der 0 : d = 0 hl = 2 l = 119 cons : SEQUENCE 2 : d = 1 hl = 2 l = 1 prim : INTEGER : 01 5 : d = 1 hl = 2 l = 32 prim : OCTET STRING [ HEX DUMP ] : 52F 060 C82B8FAFF94A4A0C2E99FFFCA3F988B0A40F0479F7659006665E2E8BD1 39 : d = 1 hl = 2 l = 10 cons : cont [ 0 ] 41 : d = 2 hl = 2 l = 8 prim : OBJECT : prime256v1 51 : d = 1 hl = 2 l = 68 cons : cont [ 1 ] 53 : d = 2 hl = 2 l = 66 prim : BIT STRING Then convert the byte stream after [HEX DUMP] to base64 and use it with the TLSKey1 command. c. Convert the Certificate Similarly you will need to convert the file \" tasmota-01.cert.pem \" generated above to a Tasmota command. 1-line version, use the following command: openssl x509 -in tasmota-01.cert.pem -inform PEM -outform DER | base64 | echo \"TLSKey2 $(</dev/stdin)\" Example: (fake certificate) openssl x509 -in tasmota-01.cert.pem -inform PEM -outform DER | base64 | echo \"TLSKey2 $(</dev/stdin)\" TLSKey2 MIICfTCCAWWgAwIBAgIUMPd6KefJYqwIHxzgCk1kEXIjHhkwDQYJKoZIhvcNAQELBQAwTTFLMEkGA1UECwxCQW1hem9uIFdlYiBTZXJ2aWNlcyBPPUFtYXpvbi5jb20gSW5jLiBMPVNlYXR0bGUgU1Q9V2FzaGluZ3RvbiBDPVVTMB4XDTE5MDgwNDE5MjI1NVoXDTQ5MTIzMTIzNTk1OVowDTELMAkGA1UEBhMCRVUwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASCzFZFhPXBbr6G6gbhT/rGXROhN5AHdwhxfpY55xi3c1W3TBuvUdZYdU2Urc9t4ces9Nz3UcF1xfMBvIpVqMVco2AwXjAfBgNVHSMEGDAWgBT3n7seZ1eHUIcZCcuwn0fkEad77TAdBgNVHQ4EFgQUUruspk3ohBJB8buA8qq9kQIZUs0wDAYDVR0TAQH/BAIwADAOBgNVHQ8BAf8EBAMCB4AwDQYJKoZIhvcNAQELBQADggEBAFPKpVjaowYY3taAcKsSxfwkwzglI2eUlnmSdnu6WZkNEdiYpx8QVYb+miJnIyTVaE3bzkTr4PvObwf4Vs92uMtIQ5BuU1lj8EdfsZAs6uA1rqfQIl0n7ty3bErtVb3d+uUBm4C1b9mtbQS45itfrTvzWEoLuWflUxAFqyYVmNPNHTfPFLjAP9dcpWk+388pRl3jkGo1qiFrEp+ucQMtkqwn3lfVXlRFuGY6GxKg2lBWvqW5CuHaBhFjeT63pqUmjj76VrBk/Vp9BMjIJ3a1omuW3ZUGCPdXUVqj4/m2pXoYIGW7l/fZpfV4piKOW1tcxeX/iBdgPUL1XUMbCtBybbc= Copy and paste the last line starting with TLSKey2 ... into the Web Tasmota Console or through MQTT. Note: you cannot use this command through Serial, it is bigger than the max serial buffer (520 bytes). hh : mm : ss CMD : TLSKey2 MIICfTCCAWWgAwIBAgIUMPd6KefJYqwIHxzgCk1kEXIjHhkwDQYJKoZIhvcNAQELBQAwTTFLMEkGA1UECwxCQW1hem9uIFdlYiBTZXJ2aWNlcyBPPUFtYXpvbi5jb20gSW5jLiBMPVNlYXR0bGUgU1Q9V2FzaGluZ3RvbiBDPVVTMB4XDTE5MDgwNDE5MjI1NVoXDTQ5MTIzMTIzNTk1OVowDTELMAkGA1UEBhMCRVUwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASCzFZFhPXBbr6G6gbhT /rGXROhN5AHdwhxfpY55xi3c1W3TBuvUdZYdU2Urc9t4ces9Nz3UcF1xfMBvIpVqMVco2AwXjAfBgNVHSMEGDAWgBT3n7seZ1eHUIcZCcuwn0fkEad77TAdBgNVHQ4EFgQUUruspk3ohBJB8buA8qq9kQIZUs0wDAYDVR0TAQH/ BAIwADAOBgNVHQ8BAf8EBAMCB4AwDQYJKoZIhvcNAQELBQ hh : mm : ss MQT : stat /tasmota/IR2/ RESULT = { \"TLSKey1\" : 32 , \"TLSKey2\" : 641 } You need to check that both values are not \"-1\". The value for \"TLSKey1\" should always be 32. The value for \"TLSKey2\" varies depending on several parameters, and should be within the 640-700 bytes range. Alternative version: Convert your certificate from PEM to DER (binary) format: openssl x509 -in tasmota-01.cert.pem -inform PEM -outform DER -out tasmota-01.cert.der Then convert the Certificate to plain base64 in a single line (use -A flag): openssl base64 -e -in tasmota-01.cert.der -A -out tasmota-01.cert.b64 Then use the command TSLKey2 <base64> and replace <base64> with the content of tasmota-01.cert.b64 .","title":"AWS IoT cert"},{"location":"AWS-IoT-cert/#benefits","text":"AWS IoT provides secure, bi-directional communication between Internet-connected devices such as sensors, actuators, embedded micro-controllers. This basically allows to communicate in both direction from the cloud using MQTT over secure channels using TLS.","title":"Benefits"},{"location":"AWS-IoT-cert/#caveats","text":"AWS IoT requires each Tasmota device to have its own distinct Private Key and Certificate (~800 bytes). Although you could imagine to use the same Private Key in all your devices, this is considered as a very bad practice. You are warned! During TLS handshake, a secondary stack of 5.3k is allocated on the heap to allow BearSSL to have enough stack room. Memory is freed at the end of the handshake. Allocating such big chunks of memory can cause issues when heap fragmentation gets too high. If you see memory going below 15KB, you may experience crashes.","title":"Caveats"},{"location":"AWS-IoT-cert/#how-to-configure","text":"AWS IoT requires a distinct Private Key and Certificate per Tasmota device. Currently you need to custom compile your Tasmota firmware and burn the Key and Certificate in your firmware. We will later explore how to configure them separately. Here is a simple guide.","title":"How to configure?"},{"location":"AWS-IoT-cert/#0-open-an-aws-account","text":"If you don't have already one, just follow the guide: https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/","title":"0. Open an AWS Account"},{"location":"AWS-IoT-cert/#1-prerequisites","text":"You will need to install/compile the following: Complete environment to compile Tasmota, ex: PlatformIO (PlatformIO) Recent version of openssl","title":"1. Prerequisites"},{"location":"AWS-IoT-cert/#2-enable-aws-iot-in-tasmota","text":"Using your favorite IDE, create user_config_override.h and add the required compilation directives as documented at the top of this article. Note: TLS handshake takes ~1.2s on ESP8266 @80MHz. You may choose to switch to 160MHz if the power supply of your device supports it. If you do so, handshake time should be ~0.7s. Compile the firmware and ensure it completes successfully. This step is only to check compilation goes well. Your firmware is still not usable since it does not contain the Private Key + Certificate.","title":"2. Enable AWS IoT in Tasmota"},{"location":"AWS-IoT-cert/#3-flash-your-device","text":"Flash your device the normal way; either through serial or OTA. If you use OTA, first flash a sonoff-minimal firmware, then your target firmware.","title":"3. Flash your device"},{"location":"AWS-IoT-cert/#4-configure-aws-iot-policy-to-be-done-once","text":"Open the AWS Console and select the target region. In the example below we will use (EU) Frankfurt (eu-central-1). Download the CloudFormation template Tasmota-MqttPolicy and use it in AWS CloudFormation. Or click on the link for the region you have chosen: Region Code Launch US East (N. Virginia) us-east-1 EU (Frankfurt) eu-central-1 EU (Paris) eu-west-3 At the Create Stack screen, click Next . At the Specify stack details screen, keep all default parameters and click Next . At the Configure stack options screen, keep all default parameters and click Next . At the Review TasmotaMqttPolicy screen, scroll down and click Create Stack . The stack usually takes less than 2 minutes to complete. Wait for it to reach CREATE_COMPLETE state. If you have left the parameter RetentionPolicy to Retain , then you can delete this CloudFormation stack (it will not delete the Policy). Click on the Delete button. After less than 2 minutes, the stack should have reached the state DELETE_COMPLETE","title":"4. Configure AWS IoT Policy (to be done once)"},{"location":"AWS-IoT-cert/#5-create-an-aws-iot-thing-with-private-key-and-certificate-once-per-tasmota-device","text":"The provided AWS CloudFormation template will create the required resources to create: One AWS IoT Thing One Private key One Certificate signed by AWS IoT Temporary resources (AWS Lambda functions, AWS IAM resources) that you can delete once the Tasmota thing is created. Open the AWS Console and select the target region. In the example below we will use (EU) Frankfurt (eu-central-1). Download the CloudFormation template Tasmota-Thing and use it in AWS CloudFormation. Or click on the link for the region you have chosen: Region Code Launch US East (N. Virginia) us-east-1 EU (Frankfurt) eu-central-1 EU (Paris) eu-west-3 At the Create Stack screen, click Next . At the Specify stack details screen, keep all default parameters and click Next . Note: you can change the name of the Thing in AWS IoT by specifying the parameter ThingParamName. At the Configure stack options screen, keep all default parameters and click Next . At the Review Tasmota-91 screen, scroll down, check the box I acknowledge that AWS CloudFormation might create IAM resources. and click Create Stack . The stack usually takes less than 4 minutes to complete. Wait for it to reach CREATE_COMPLETE state. You need to copy & paste the contents of the Outputs tab of the CloudFormation stack: MqttHost , TlsKey1 , TlsKey2 Keep a copy of those parameters in a file, you might need them again. Cleaning : to avoid having CloudFormation templates piling up in your console, you can delete them. The created resources will remain, if you have left the parameter RetentionPolicy to Retain .","title":"5. Create an AWS IoT Thing with Private Key and Certificate (once per Tasmota device)"},{"location":"AWS-IoT-cert/#6-configure-tasmota-device","text":"This is the last step, you need to configure the MQTT parameters. The easiest way is through the web console. We will only cut and paste parameters from the Outputs tab of the CloudFormation console.","title":"6. Configure Tasmota device"},{"location":"AWS-IoT-cert/#7-check-end-to-end-communication","text":"In the AWS IoT console, click on \" Test \" in the left panel. In the \" Subscription topic \" field, type +/sonoff/# then click on \" Subscribe to topic \". This will display all MQTT messages received. Type a command in the Web Tasmota console, you should see MQTT message flow. Enjoy!","title":"7. Check end-to-end communication"},{"location":"AWS-IoT-cert/#8-cleaning","text":"Cleaning : to avoid having CloudFormation templates piling up in your console, you can delete them. The created resources will remain, if you have left the parameter RetentionPolicy to Retain .","title":"8. Cleaning"},{"location":"AWS-IoT-cert/#9-troubleshooting","text":"TLSError shows any error at the TLS level. See here for most common error codes.","title":"9. Troubleshooting"},{"location":"AWS-IoT-cert/#for-implementation-details-see-here","text":"","title":"For implementation details, see here"},{"location":"AWS-IoT-cert/#appendix-manual-configuration","text":"","title":"Appendix: Manual configuration"},{"location":"AWS-IoT-cert/#1-prerequisites_1","text":"You will need to install/compile the following: Complete environment to compile Tasmota, ex: PlatformIO (PlatformIO) Recent version of openssl","title":"1. Prerequisites"},{"location":"AWS-IoT-cert/#2-configure-aws-iot-to-be-done-once","text":"Open the AWS Console. Click on \" Services \" and select \" IoT Core \". Select the AWS Region where you want to locate your data, for ex: \" (EU) Frankfurt \". Now we need to create a security policy to allow your Tasmota devices to connect to AWS IoT, publish and subscribe to topics. On the left panel, click on \" Secure \" > \" Policies \". Click on the \" Create \" button in the upper right corner. Enter in the \" Name \" field, enter the name of your policy, for ex: \" TasmotaMqttPolicy \". Then click on \" Advanced mode \" Cut and paste the policy below. Click on \" Create \" in the lower right corner. { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [ \"iot:Connect\", \"iot:Publish\", \"iot:Subscribe\", \"iot:Receive\" ], \"Resource\": \"*\" } ] }","title":"2. Configure AWS IoT (to be done once)"},{"location":"AWS-IoT-cert/#3-create-a-private-key-and-certificate-once-per-tasmota-device","text":"Do not use the default AWS IoT feature to generate your private key online. It creates a 2048 bits RSA key. Instead we are using elliptic curves keys - they are much smaller in memory than RSA keys (this saves ~1k of memory) and the handshake is significantly faster. First create an ECC private key for your device (as described in this Blog ). Keep you private key in a safe place. $ openssl ecparam -name prime256v1 -genkey -out tasmota-01.key Next, using this private key, create a certificate signing request (CSR). When asked enter the certificate details. This is not really used later, you can just enter a 2 letters country code like \" EU \" and leave all other fields blank (type 8 times enter). $ openssl req -new -sha256 -key tasmota-01.key -nodes -out tasmota-01.csr You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter '.' , the field will be left blank. ----- Country Name ( 2 letter code ) [] :EU <enter> State or Province Name ( full name ) [] : <enter> Locality Name ( eg, city ) [] : <enter> Organization Name ( eg, company ) [] : <enter> Organizational Unit Name ( eg, section ) [] : <enter> Common Name ( eg, fully qualified host name ) [] : <enter> Email Address [] : <enter> Please enter the following 'extra' attributes to be sent with your certificate request A challenge password [] : <enter> Next ask AWS IoT to sign your key with its certificate. On the left panel, click on \" Secure \" > \" Certificates \". Click on \" Create a certificate \". Then choose the \" Create with CSR \" button, locate your CSR file from above. Click on \" Upload file \". Download the certificate file, click on \" Download \", save the file as \" tasmota-01.cert.pem \". Important : don't forget to click on the \" Activate \" to activate the certificate. Your Private Key and Certificates are ready to use. Now we need to register the Tasmota Device.","title":"3. Create a Private Key and Certificate (once per Tasmota device)"},{"location":"AWS-IoT-cert/#4-write-down-your-aws-iot-endpoint-same-for-all-devices","text":"Click on \" Settings \" in the left panel. You should see a field called \" Custom endpoint \". Write down the endpoint domain name. It should look like this (if you have chosen the Frankfurt region: <xxxxxxxxxxxxxx>-ats.iot.eu-central-1.amazonaws.com This is your MQTT endpoint, the port is 8883 - MQTT over TLS.","title":"4. Write down your AWS IoT endpoint (same for all devices)"},{"location":"AWS-IoT-cert/#5-register-the-device-in-aws-iot-once-per-tasmota-device","text":"Now on the left pane, click on \" Manage \" > \" Things \". Click on \" Register a thing \", then \" Create a single thing \". Give your device a name like \" Tasmota-01 \". Scroll down and click \" Next \" at the botton right. Then click on \" Create thing without a certificate \". Now we need to associate the certificate created earlier to your device. In the left panel, click back on \" Secure \" > \" Certificates \". Select the certificate created earlier. In the next pane, click on \" Actions \" in the upper right part. First select \" Attach policy \", check \" TasmotaMqttPolicy \" and \" Attach \". Click again on \" Actions \" and select \" Attach thing \", check \" Tasmota-01 \" and \" Attach \". Your setup is done in AWS IoT. Let's proceed to the custom firmware.","title":"5. Register the device in AWS IoT (once per Tasmota device)"},{"location":"AWS-IoT-cert/#8-prepare-your-aws-iot-credentials","text":"You will now need to convert your AWS IoT credentials to Tasmota commands. Credentials are composed of two distinct parts, first a Private Key - this is the secret that will allow your device to prove it is who it pretends to be. Consider this as sensitive as a password. The Private Key is exactly 32 bytes (256 bits). The second part is the Certificate delivered by AWS IoT. Tasmota will also need it to authenticate to the AWS IoT endpoint. Both credentials must be stored in Tasmota Flash memory, in that order, using the new TLSKey command.","title":"8. Prepare your AWS IoT credentials"},{"location":"AWS-IoT/","text":"Tip New simplified configuration, since AWS IoT doesn't require private certificates anymore and can use password authentication. Requires v8.5.0.1 or higher. The certificate based authentication is kept for reference. New simplified and automated configuration We now provide easy to use AWS CloudFormation templates to generate the private key and sign the certificate. The manual method is now in Appendix This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_MQTT_TLS #define USE_MQTT_TLS #define USE_MQTT_TLS_CA_CERT // Optional but highly recommended #endif #ifndef USE_MQTT_AWS_IOT_LIGHT #define USE_MQTT_AWS_IOT_LIGHT #endif #ifdef USE_DISCOVERY #undef USE_DISCOVERY #endif As of Tasmota version 8.5.0.1, device-specific private key and certificate are no more required. We introduces AWS_IOT_LIGHT to use password based authentication. Legacy private certificate authentication can be found here . Benefits ~ AWS IoT provides secure, bi-directional communication between Internet-connected devices such as sensors, actuators, embedded micro-controllers. This basically allows to communicate in both direction from the cloud using MQTT over secure channels using TLS. 1. More Alexa controls It's actually easy to develop smarthome Alexa skills, so that you can control your whole house. Currently you can only use the local Philips Hue/Wemo emulation - limited to lights and switches. You can imagine for instance controlling your Sonoff RF Bridge and send IR codes to your TV. Alexa skills need to communicate back to your devices, which is easy using MQTT and AWS IoT 2. No need for a local gateway Of course you can do it with a local gateway like Raspberry PI using many of the open-source solutions (Domoticz...). You can also do it entirely from the cloud without the hassle of managing and updating a local gateway. On top of it, AWS IoT provides tools to collect and archive your data, automate (AWS IoT things). Maximum security Keep in mind that AWS IoT is based with 'security first' in mind. All the data in AWS IoT is your data and is not shared with anyone else. Communication is done over TLS 1.2 tunnels. Thanks to the switch of Arduino to BearSSL and aggressive optimization, the amount of memory needed is as low as 6.0k during normal operation, and an additional 6.6k during connection (TLS handshake). This makes it totally doable with standard 'Tasmota' firmware with Web and Hue emulation activated. You should see more than 20k of memory still available. Caveats ~ During TLS handshake, a secondary stack of 4.8k is allocated on the heap to allow BearSSL to have enough stack room. Memory is freed at the end of the handshake. Allocating such big chunks of memory can cause issues when heap fragmentation gets too high. If you see memory going below 15KB, you may experience crashes. Cost AWS provides a Free Tier that allows you to use some services for free up to a specific level. For example, it allows you to have 50 devices connecting 24 hours a day exchanging 300 messages per day. For a typical house, there is a good chance the service costs you nothing (the first year). How to configure? ~ AWS IoT now works with Password authentication. Although it is not a good practice to use the same password for all your devices, it is technically working and the easiest way to start with Tasmota and AWS IoT. Here is a simple guide. 0. Open an AWS Account ~ If you don't have already one, just follow the guide: https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/ 1. Prerequisites ~ You will need to install/compile the following: Complete environment to compile Tasmota, ex: PlatformIO (PlatformIO) 2. Enable AWS IoT in Tasmota ~ Using your favorite IDE, create user_config_override.h and add the required compilation directives as documented at the top of this article. Note: TLS handshake takes ~1.2s on ESP8266 @80MHz. You may choose to switch to 160MHz if the power supply of your device supports it. If you do so, handshake time should be ~0.7s. Compile the firmware and ensure it completes successfully. This step is only to check compilation goes well. Your firmware is still not usable since it does not contain the Private Key + Certificate. 3. Flash your device ~ Flash your device the normal way; either through serial or OTA. If you use OTA, first flash a sonoff-minimal firmware, then your target firmware. 4. Configure AWS IoT Policy (to be done once) ~ Open the AWS Console and select the target region. In the example below we will use (EU) Frankfurt (eu-central-1). Download the CloudFormation template TasmotaAuth and use it in AWS CloudFormation. Or click on the link for the region you have chosen: Region Code Launch US East (N. Virginia) us-east-1 EU (Frankfurt) eu-central-1 EU (Paris) eu-west-3 At the Create Stack screen, click Next . At the Specify stack details screen, keep all default parameters and click Next . At the Configure stack options screen, keep all default parameters and click Next . At the Review TasmotaMqttPolicy screen, scroll down and click Create Stack . The stack usually takes less than 1 minute to complete. Wait for it to reach CREATE_COMPLETE state. Copy the commands under BackLogCommand , you will need it to configure Tasmota devices. If you have left the parameter RetentionPolicy to Retain , then you can delete this CloudFormation stack (it will not delete the Policy). Click on the Delete button. After less than 2 minutes, the stack should have reached the state DELETE_COMPLETE 6. Configure Tasmota device ~ This is the last step, you need to configure the MQTT parameters. The easiest way is through the web console. We will only cut and paste parameters from the Outputs tab of the CloudFormation console. Example: BackLog SetOption3 1 ; SetOption103 1 ; MqttHost a ........... . u-ats . iot . eu-central-1 . amazonaws . com ; MqttPort 443 ; MqttUser tasmota ? x-amz-customauthorizer-name = TasmotaAuth ; MqttPassword YknLuSd2tBY2HodwI / 7RqA == 11 : 28 : 44 CMD : BackLog SetOption3 1 ; SetOption103 1 ; MqttHost a ........... . u-ats . iot . eu-central-1 . amazonaws . com ; MqttPort 443 ; MqttUser tasmota ? x-amz-customauthorizer-name = TasmotaAuth ; MqttPassword YknLuSd2tBY2HodwI / 7RqA == 11 : 28 : 44 MQT : stat / tasmota_4B3316 / RESULT = { \"SetOption3\":\"ON\" } 11 : 28 : 44 MQT : stat / tasmota_4B3316 / RESULT = { \"SetOption103\":\"ON\" } 11 : 28 : 45 MQT : stat / tasmota_4B3316 / RESULT = { \"MqttHost\":\"a...........u-ats.iot.eu-central-1.amazonaws.com\" } 11 : 28 : 45 MQT : stat / tasmota_4B3316 / RESULT = { \"MqttPort\":443 } 11 : 28 : 45 MQT : stat / tasmota_4B3316 / RESULT = { \"MqttUser\":\"tasmota?x-amz-customauthorizer-name=TasmotaAuth\" } 11 : 28 : 45 MQT : stat / tasmota_4B3316 / RESULT = { \"MqttPassword\":\"YknLuSd2tBY2HodwI/7RqA==\" } 11 : 28 : 47 APP : Restarting Connect to AWS IoT Once the MQTTHost and MQTTPort are configured, Tasmota will try to connect to AWS IoT. Keep in mind that AWS IoT does not support 'retained' messages. Whatever the 'retained' configuration in Tasmota, messages are always published as 'retained=false'. Here is an example of output you should see: 00 : 00 : 04 HTP : Web server active on sonoff - 4585 with IP address 192.168 . 1.59 00 : 00 : 04 UPP : Multicast ( re ) joined 21 : 28 : 25 MQT : Attempting connection ... 21 : 28 : 25 MQT : AWS IoT endpoint : xxxxxxxxxxxxx - ats . iot . eu - central - 1 . amazonaws . com 21 : 28 : 26 MQT : AWS IoT connected in 1279 ms 21 : 28 : 26 MQT : Connected 21 : 28 : 26 MQT : tele /tasmota/ LWT = Online 21 : 28 : 26 MQT : cmnd /tasmota/ POWER = 21 : 28 : 26 MQT : tele /tasmota/ INFO1 = { \"Module\" : \"Sonoff Basic\" , \"Version\" : \"9.0.0.2(sonoff)\" , \"FallbackTopic\" : \"cmnd/DVES_67B1E9_fb/\" , \"GroupTopic\" : \"sonoffs\" } 7. Check end-to-end communication ~ In the AWS IoT console, click on \" Test \" in the left panel. In the \" Subscription topic \" field, type +/sonoff/# then click on \" Subscribe to topic \". This will display all MQTT messages received. Type a command in the Web Tasmota console, you should see MQTT message flow. Enjoy! 8. Cleaning ~ Cleaning : to avoid having CloudFormation templates piling up in your console, you can delete them. The created resources will remain, if you have left the parameter RetentionPolicy to Retain . 9. Troubleshooting ~ TLSError shows any error at the TLS level. See here for most common error codes. For implementation details, see here ~","title":"AWS IoT"},{"location":"AWS-IoT/#benefits","text":"AWS IoT provides secure, bi-directional communication between Internet-connected devices such as sensors, actuators, embedded micro-controllers. This basically allows to communicate in both direction from the cloud using MQTT over secure channels using TLS.","title":"Benefits"},{"location":"AWS-IoT/#caveats","text":"During TLS handshake, a secondary stack of 4.8k is allocated on the heap to allow BearSSL to have enough stack room. Memory is freed at the end of the handshake. Allocating such big chunks of memory can cause issues when heap fragmentation gets too high. If you see memory going below 15KB, you may experience crashes.","title":"Caveats"},{"location":"AWS-IoT/#how-to-configure","text":"AWS IoT now works with Password authentication. Although it is not a good practice to use the same password for all your devices, it is technically working and the easiest way to start with Tasmota and AWS IoT. Here is a simple guide.","title":"How to configure?"},{"location":"AWS-IoT/#0-open-an-aws-account","text":"If you don't have already one, just follow the guide: https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/","title":"0. Open an AWS Account"},{"location":"AWS-IoT/#1-prerequisites","text":"You will need to install/compile the following: Complete environment to compile Tasmota, ex: PlatformIO (PlatformIO)","title":"1. Prerequisites"},{"location":"AWS-IoT/#2-enable-aws-iot-in-tasmota","text":"Using your favorite IDE, create user_config_override.h and add the required compilation directives as documented at the top of this article. Note: TLS handshake takes ~1.2s on ESP8266 @80MHz. You may choose to switch to 160MHz if the power supply of your device supports it. If you do so, handshake time should be ~0.7s. Compile the firmware and ensure it completes successfully. This step is only to check compilation goes well. Your firmware is still not usable since it does not contain the Private Key + Certificate.","title":"2. Enable AWS IoT in Tasmota"},{"location":"AWS-IoT/#3-flash-your-device","text":"Flash your device the normal way; either through serial or OTA. If you use OTA, first flash a sonoff-minimal firmware, then your target firmware.","title":"3. Flash your device"},{"location":"AWS-IoT/#4-configure-aws-iot-policy-to-be-done-once","text":"Open the AWS Console and select the target region. In the example below we will use (EU) Frankfurt (eu-central-1). Download the CloudFormation template TasmotaAuth and use it in AWS CloudFormation. Or click on the link for the region you have chosen: Region Code Launch US East (N. Virginia) us-east-1 EU (Frankfurt) eu-central-1 EU (Paris) eu-west-3 At the Create Stack screen, click Next . At the Specify stack details screen, keep all default parameters and click Next . At the Configure stack options screen, keep all default parameters and click Next . At the Review TasmotaMqttPolicy screen, scroll down and click Create Stack . The stack usually takes less than 1 minute to complete. Wait for it to reach CREATE_COMPLETE state. Copy the commands under BackLogCommand , you will need it to configure Tasmota devices. If you have left the parameter RetentionPolicy to Retain , then you can delete this CloudFormation stack (it will not delete the Policy). Click on the Delete button. After less than 2 minutes, the stack should have reached the state DELETE_COMPLETE","title":"4. Configure AWS IoT Policy (to be done once)"},{"location":"AWS-IoT/#6-configure-tasmota-device","text":"This is the last step, you need to configure the MQTT parameters. The easiest way is through the web console. We will only cut and paste parameters from the Outputs tab of the CloudFormation console. Example: BackLog SetOption3 1 ; SetOption103 1 ; MqttHost a ........... . u-ats . iot . eu-central-1 . amazonaws . com ; MqttPort 443 ; MqttUser tasmota ? x-amz-customauthorizer-name = TasmotaAuth ; MqttPassword YknLuSd2tBY2HodwI / 7RqA == 11 : 28 : 44 CMD : BackLog SetOption3 1 ; SetOption103 1 ; MqttHost a ........... . u-ats . iot . eu-central-1 . amazonaws . com ; MqttPort 443 ; MqttUser tasmota ? x-amz-customauthorizer-name = TasmotaAuth ; MqttPassword YknLuSd2tBY2HodwI / 7RqA == 11 : 28 : 44 MQT : stat / tasmota_4B3316 / RESULT = { \"SetOption3\":\"ON\" } 11 : 28 : 44 MQT : stat / tasmota_4B3316 / RESULT = { \"SetOption103\":\"ON\" } 11 : 28 : 45 MQT : stat / tasmota_4B3316 / RESULT = { \"MqttHost\":\"a...........u-ats.iot.eu-central-1.amazonaws.com\" } 11 : 28 : 45 MQT : stat / tasmota_4B3316 / RESULT = { \"MqttPort\":443 } 11 : 28 : 45 MQT : stat / tasmota_4B3316 / RESULT = { \"MqttUser\":\"tasmota?x-amz-customauthorizer-name=TasmotaAuth\" } 11 : 28 : 45 MQT : stat / tasmota_4B3316 / RESULT = { \"MqttPassword\":\"YknLuSd2tBY2HodwI/7RqA==\" } 11 : 28 : 47 APP : Restarting","title":"6. Configure Tasmota device"},{"location":"AWS-IoT/#7-check-end-to-end-communication","text":"In the AWS IoT console, click on \" Test \" in the left panel. In the \" Subscription topic \" field, type +/sonoff/# then click on \" Subscribe to topic \". This will display all MQTT messages received. Type a command in the Web Tasmota console, you should see MQTT message flow. Enjoy!","title":"7. Check end-to-end communication"},{"location":"AWS-IoT/#8-cleaning","text":"Cleaning : to avoid having CloudFormation templates piling up in your console, you can delete them. The created resources will remain, if you have left the parameter RetentionPolicy to Retain .","title":"8. Cleaning"},{"location":"AWS-IoT/#9-troubleshooting","text":"TLSError shows any error at the TLS level. See here for most common error codes.","title":"9. Troubleshooting"},{"location":"AWS-IoT/#for-implementation-details-see-here","text":"","title":"For implementation details, see here"},{"location":"AZ-7798/","text":"AZ7798 CO 2 meter ~ This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_AZ7798 #define USE_AZ7798 // Add support for AZ-Instrument 7798 CO2 datalogger (+1k6 code) #endif The AZ7798 CO 2 Meter/Datalogger appears to be made by AZ Instrument , but other branded versions exist. The CO 2 meter is already provided with a PC interface in the form of a logic-level (3V3) serial port, accessible through a 2.5mm stereo jack on the back. The Wemos D1 Mini is connected to this serial port instead, and the PC interface is no longer available. Configuration ~ Connecting the AZ7798 to a Wemos D1 Mini ~ The Wemos D1 Mini is fitted inside the meter enclosure. This requires the enclosure to be opened. There are four screws. Two of the screws are hidden behind the type label. Use the tip of a small knife to cut holes in the label. There are also two clips at the top of the enclosure. To release those, gently pry apart the bottom of the enclosure a small amount. The grey band between the two halves can now be lifted up and pushed aside a little and expose the clips near the top. A push with a flat-blade screwdriver will then release the clips. Once the enclosure is opened, disconnect the two serial port wires from the socket on the back panel. The black wire (0V) can remain connected. Now connect these two wires to TX and RX of the Wemos D1 Mini. Wemos D1 Mini AZ7798 TX wire with stripe RX wire without stripe The power supply for the Wemos D1 Mini is taken directly from the power supply for the meter, which is a 5V external power supply. Solder two wires to the incoming power supply and connect the other ends to the 5V and G terminals on the Wemos D1 Mini. Make a small right-angle bracket for mounting the Wemos D1 Mini to the meter board. Use double-sided tape to hold everything together. Tasmota Settings ~ In the Configuration -> Configure Module page assign: D1 TX to AZ Tx (117) D3 RX to AZ Rx (118) After reboot of the device the AZ7798 measurements are shown.","title":"AZ7798 CO<sub>2</sub> meter"},{"location":"AZ-7798/#az7798-co2-meter","text":"This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_AZ7798 #define USE_AZ7798 // Add support for AZ-Instrument 7798 CO2 datalogger (+1k6 code) #endif The AZ7798 CO 2 Meter/Datalogger appears to be made by AZ Instrument , but other branded versions exist. The CO 2 meter is already provided with a PC interface in the form of a logic-level (3V3) serial port, accessible through a 2.5mm stereo jack on the back. The Wemos D1 Mini is connected to this serial port instead, and the PC interface is no longer available.","title":"AZ7798 CO2 meter"},{"location":"AZ-7798/#configuration","text":"","title":"Configuration"},{"location":"AZ-7798/#connecting-the-az7798-to-a-wemos-d1-mini","text":"The Wemos D1 Mini is fitted inside the meter enclosure. This requires the enclosure to be opened. There are four screws. Two of the screws are hidden behind the type label. Use the tip of a small knife to cut holes in the label. There are also two clips at the top of the enclosure. To release those, gently pry apart the bottom of the enclosure a small amount. The grey band between the two halves can now be lifted up and pushed aside a little and expose the clips near the top. A push with a flat-blade screwdriver will then release the clips. Once the enclosure is opened, disconnect the two serial port wires from the socket on the back panel. The black wire (0V) can remain connected. Now connect these two wires to TX and RX of the Wemos D1 Mini. Wemos D1 Mini AZ7798 TX wire with stripe RX wire without stripe The power supply for the Wemos D1 Mini is taken directly from the power supply for the meter, which is a 5V external power supply. Solder two wires to the incoming power supply and connect the other ends to the 5V and G terminals on the Wemos D1 Mini. Make a small right-angle bracket for mounting the Wemos D1 Mini to the meter board. Use double-sided tape to hold everything together.","title":"Connecting the AZ7798 to a Wemos D1 Mini"},{"location":"AZ-7798/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: D1 TX to AZ Tx (117) D3 RX to AZ Rx (118) After reboot of the device the AZ7798 measurements are shown.","title":"Tasmota Settings"},{"location":"About/","text":"If you don't have the willingness to tinker and learn... TURN BACK!. Tasmota is not a commercial product and support is limited. You have to be willing to research and solve potential problems yourself. Tasmota is an open source firmware for ESP8266 based devices created and maintained by Theo Arends . Everything began as Sonoff-MQTT-OTA with a commit on 25th January 2016. by Theo Arendst. Its goal was to provide ESP8266 based ITEAD Sonoff devices with MQTT and 'Over the Air' or OTA firmware. What started as a simple way to hack a cloud bound Sonoff Basic (one of the first cheap and accessible smart home devices in the market) into a locally controlled device has grown into a fully fledged ecosystem for virtually any ESP8266 based device. Contribute ~ Any contribution helps our team and makes Tasmota better for the entire community! Everybody is welcome and invited to contribute to Tasmota Project by: providing Pull Requests (Features, Proof of Concepts, Language files or Fixes) testing new released features and report issues donating to acquire hardware for testing and implementing or out of gratitude contributing missing documentation for features and devices Credits ~ People helping to keep the show on the road: David Lang providing initial issue resolution and code optimizations Heiko Krupp for his IRSend, HTU21, SI70xx and Wemo/Hue emulation drivers Wiktor Schmidt for Travis CI implementation Thom Dietrich for PlatformIO optimizations Marinus van den Broek for his EspEasy groundwork Pete Ba for more user friendly energy monitor calibration Lobradov providing compile optimization tips Flexiti for his initial timer implementation reloxx13 for his TasmoAdmin management tool Joachim Banzhaf for his TSL2561 library and driver Gijs Noorlander for his MHZ19, SenseAir and updated PubSubClient drivers Erik Montnemery for his HomeAssistant Discovery concept and many code tuning tips Federico Leoni for continued HomeAssistant Discovery support Aidan Mountford for his HSB support Daniel Ztolnai for his Serial Bridge implementation Gerhard Mutz for multiple sensor & display drivers, Sunrise/Sunset, and scripting Nuno Ferreira for his HC-SR04 driver Adrian Scillato for his (security) fixes and implementing and maintaining KNX Gennaro Tortone for implementing and maintaining Eastron drivers Raymond Mouthaan for managing Wemos Wiki information Norbert Richter for his decode-config.py tool Andre Thomas for providing thehackbox OTA support and daily development builds Joel Stein, digiblur and Shantur Rathore for their Tuya research and driver Frogmore42 for providing many issue answers Jason2866 for platformio support and providing many issue answers Blakadder for managing the new document site and providing template management Stephan Hadinger for refactoring light driver, enhancing HueEmulation and Zigbee support tmo for designing the official Tasmota logo Stefan Bode for his Shutter and Deep sleep drivers Jacek Zi\u00f3\u0142kowski for his TDM management tool and Tasmotizer flashing tool Christian Staars for NRF24L01 and HM-10 Bluetooth sensor support Paul Diem for UDP Group communication support J\u00f6rg Sch\u00fcler-Maroldt for his initial ESP32 port Many more providing Tips, Wips, Pocs, PRs and Donations License ~ This program is licensed under GPL-3.0","title":"About"},{"location":"About/#contribute","text":"Any contribution helps our team and makes Tasmota better for the entire community! Everybody is welcome and invited to contribute to Tasmota Project by: providing Pull Requests (Features, Proof of Concepts, Language files or Fixes) testing new released features and report issues donating to acquire hardware for testing and implementing or out of gratitude contributing missing documentation for features and devices","title":"Contribute"},{"location":"About/#credits","text":"People helping to keep the show on the road: David Lang providing initial issue resolution and code optimizations Heiko Krupp for his IRSend, HTU21, SI70xx and Wemo/Hue emulation drivers Wiktor Schmidt for Travis CI implementation Thom Dietrich for PlatformIO optimizations Marinus van den Broek for his EspEasy groundwork Pete Ba for more user friendly energy monitor calibration Lobradov providing compile optimization tips Flexiti for his initial timer implementation reloxx13 for his TasmoAdmin management tool Joachim Banzhaf for his TSL2561 library and driver Gijs Noorlander for his MHZ19, SenseAir and updated PubSubClient drivers Erik Montnemery for his HomeAssistant Discovery concept and many code tuning tips Federico Leoni for continued HomeAssistant Discovery support Aidan Mountford for his HSB support Daniel Ztolnai for his Serial Bridge implementation Gerhard Mutz for multiple sensor & display drivers, Sunrise/Sunset, and scripting Nuno Ferreira for his HC-SR04 driver Adrian Scillato for his (security) fixes and implementing and maintaining KNX Gennaro Tortone for implementing and maintaining Eastron drivers Raymond Mouthaan for managing Wemos Wiki information Norbert Richter for his decode-config.py tool Andre Thomas for providing thehackbox OTA support and daily development builds Joel Stein, digiblur and Shantur Rathore for their Tuya research and driver Frogmore42 for providing many issue answers Jason2866 for platformio support and providing many issue answers Blakadder for managing the new document site and providing template management Stephan Hadinger for refactoring light driver, enhancing HueEmulation and Zigbee support tmo for designing the official Tasmota logo Stefan Bode for his Shutter and Deep sleep drivers Jacek Zi\u00f3\u0142kowski for his TDM management tool and Tasmotizer flashing tool Christian Staars for NRF24L01 and HM-10 Bluetooth sensor support Paul Diem for UDP Group communication support J\u00f6rg Sch\u00fcler-Maroldt for his initial ESP32 port Many more providing Tips, Wips, Pocs, PRs and Donations","title":"Credits"},{"location":"About/#license","text":"This program is licensed under GPL-3.0","title":"License"},{"location":"Alexa/","text":"This feature is included only in builds: tasmota and tasmota-sensors To use in other builds you must compile your own build . Add the following to user_config_override.h : #ifndef EMULATION #define EMULATION EMUL_NONE // [ Emulation ] Select Belkin WeMo ( single relay / light ) or Hue Bridge emulation ( multi relay / light ) ( EMUL_NONE , EMUL_WEMO or EMUL_HUE ) #endif EMUL_NONE = disables emulation EMUL_WEMO = enables Belking WeMo emulation EMUL_HUE = enables Hue Bridge emulation Connecting to Alexa ~ You can interact with Tasmota using Amazon Alexa through its Echo devices . In Configuration - Configure Other page in the webUI select emulation type. Warning Alexa Hue integration requires a physical Alexa device. The app alone is not enough. Belkin WeMo Emulation Use Belkin WeMo for devices with a single relay or Hue Bridge for devices with one or more relays or for lights. Tasmota devices will be discovered by the Alexa app. You do not need to install the Wemo app or enable the Wemo skill in Alexa. Just tell Alexa to discover devices of the appropriate type (plug, switch, etc.) and when it asks what brand device, scroll to the end and choose \"Other\". Hue Bridge Emulation For control of lights, color control (introduced in version 6.5.0.9), on/off, and dimming is supported. Enable Hue Bridge emulation and perform a device discovery in the Alexa app. No skill needs to be added to Alexa. Select Hue Bridge V1 as the device type. Relays and lights with friendly names beginning with a dollar sign ( $ ) will cause Tasmota to not \"announce\" them (i.e., be hidden) to Alexa. If they were previously discovered, they will still continue to work. As there are only four friendly names provided in Tasmota, if FriendlyName4 begins with $ , component 4 and all higher numbered discoverable components will not be discovered by Alexa. Hue Bridge emulation does not support sensors.","title":"Alexa"},{"location":"Alexa/#connecting-to-alexa","text":"You can interact with Tasmota using Amazon Alexa through its Echo devices . In Configuration - Configure Other page in the webUI select emulation type. Warning Alexa Hue integration requires a physical Alexa device. The app alone is not enough.","title":"Connecting to Alexa"},{"location":"BH1750/","text":"BH1750 ambient light sensor ~ This feature is included only in tasmota-sensors.bin The BH1750 is a digital ambient light sensor module which uses I 2 C to communicate. The BH1750 provides you with a digital value in lux (Lx) over a range of 1 - 65535 lx. See datasheet for more information. Configuration ~ Wiring ~ BH1750 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) After a reboot the driver will detect BH1750 automatically and display Illuminance. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-11-03T20:45:37\" , \"BH1750\" :{ \"Illuminance\" : 79 }} Commands ~ Command Parameters Sensor10 0..2 = choose sensor resolution ( 0 = high (default) , 1 = high2, 2 = low) 31..254 = set measurement time (default = 69 ) Breakout Boards ~","title":"BH1750 ambient light sensor"},{"location":"BH1750/#bh1750-ambient-light-sensor","text":"This feature is included only in tasmota-sensors.bin The BH1750 is a digital ambient light sensor module which uses I 2 C to communicate. The BH1750 provides you with a digital value in lux (Lx) over a range of 1 - 65535 lx. See datasheet for more information.","title":"BH1750 ambient light sensor"},{"location":"BH1750/#configuration","text":"","title":"Configuration"},{"location":"BH1750/#wiring","text":"BH1750 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"BH1750/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) After a reboot the driver will detect BH1750 automatically and display Illuminance. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-11-03T20:45:37\" , \"BH1750\" :{ \"Illuminance\" : 79 }}","title":"Tasmota Settings"},{"location":"BH1750/#commands","text":"Command Parameters Sensor10 0..2 = choose sensor resolution ( 0 = high (default) , 1 = high2, 2 = low) 31..254 = set measurement time (default = 69 )","title":"Commands"},{"location":"BH1750/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"BLEGenericDriver/","text":"Bluetooth Low Energy in Tasmota on ESP32 using the native radio: Enabling the driver ~ You must be building for ESP32 - ESP8266 has no native BLE capability. To enable the driver, this must be defined: #define USE_BLE_ESP32 Be aware, enabling of the native BLE on ESP32 has an impact on wifi performance. Although later SDK helped a bit, expect more lag on the web interface and on MQTT. If only controlling BLE devices, then scanning can be disabled, which will minimise wifi impact. This is compiled by default in the Sensors firmware, but you still need to enable BLE using the web interface configure BLE button or setoption115 1. Driver features ~ When the BLE_ESP32 driver is enabled and BLE is enabled, Tasmota will by default scan for nearby BLE devices every 20s. ALL BLE devices are noted and displayed in the Configure BLE page. To see an updaqted list, you must refresh the page. Devices you may 'find' include BLE sensors (e.g. the 'MI' range), fitness watches, iBeacons, Toothbrushes, Scales, etc. You will also see some random MAC addresses appearing - these are Mobile phones which use a random MAC address when advertiseing - for example they regularly advertise Covid contact tracing information. Unfortunately, there is no easy way to exclude these, but indeed the BLE driver enables you to catch some of the contact tracing information. Scanning can be configued to be 'passive' (default), or 'Active'. In 'Active' mode, tasmota queries the dveices for some additional information (e.g. the name of the device) The driver also allows you to perform simple active operations, like reading a characteristic, writing a characteristic, and registering for a notification. When performing these operaitons, the BLE_ESP32 driver connects to the device, performs the operation, and then disconnects. Operations can take between 1 and 10 seconds, and BLE is not necessarily reliable, so expect failures. BLE commands summary: ~ Command Parameters BLEMode Change the operational mode of the BLE driver. BLEMode0 = disable regular BLE scans. BLEMode1 = BLE scan on command only. BLEMode2 = regular BLE scanning (default). BLEScan Cause/Configure BLE a scan BLEScan0 0..1 = enable or disable Active scanning. (an active scan will gather extra data from devices, including name) BLEScan = Trigger a 20s scan now if in BLEMode1 BLEScan n = Trigger a scan now for n seconds if in BLEMode1 BLEDetails Display details about recevied adverts BLEDetails0 = disable showing of details. BLEDetails1 mac|alias = show the next advert from device mac BLEAlias Set Alias names for devices. A device may be referred to by it's alias in subsequent commands BLEAlias mac=alias mac=alias ... = set one or more aliases from devices. BLEAlias2 = clear all aliases. BLEName Read or write the name of a BLE device. BLEName mac|alias = read the name of a device using 1800/2A00. BLEName mac|alias = write the name of a device using 1800/2A00 - many devices are read only. BLEDevices Cause a list of known devices to be sent on MQTT, or Empty the list of known devices. BLEDevices0 = clear the known devices list. BLEDevices = Cause the known devices list to be published on stat/TASName/BLE. BLEMaxAge Set the timeout for device adverts. BLEMaxAge n = set the devices timeout to n seconds. BLEMaxAge = display the device timeout. BLEOp Perform a simple active BLE operation (read/write/notify). BLEOp0 = trigger publish of operations in progress to MQTT at stat/TASName/BLE. BLEOp (parameters) = queue a BLE operation Paramaters:0 m:mac BLEDebug Set BLE debug level. BLEDebug = show extra debug information BLEDebug0 = suppress extra debug BLE commands detailed description ~ BLEOp command This is the command you would use to perform simple active operations against a device. Command Parameters and description BLEOp0 Lists operations currently in queue. BLEOp|BLEOp1 Sets details about an operation and queue it. Full syntax is BLEOp1 m:MAC|Alias s:svc c:characteristic n:notifychar w:hextowrite u:unique r go Everything after svc is optional. BLEOp2 Queues an operation setup with BLEOp1 if you did not state go . returns: Done , FailCreate , FailNoOp , FailQueue , InvalidIndex , {\"opid\":opid,\"u\":unique} Example 1: Write operation Write 03 to service 3e135142-654f-9090-134a-a6ff5bb77046 with characteristic 3fa4585a-ce4a-3bad-db4b-b8df8179ea09 and unique 1234 (32 bit number) and wait for a notification from d0e8434d-cd29-0996-af41-6c90f4e0eb2a BLEOp1 M:001A22092CDB s:3e135142-654f-9090-134a-a6ff5bb77046 c:3fa4585a-ce4a-3bad-db4b-b8df8179ea09 w:03 n:d0e8434d-cd29-0996-af41-6c90f4e0eb2a u:1234 go Example 2: Read operation Read from service 3e135142-654f-9090-134a-a6ff5bb77046 with characteristic 3fa4585a-ce4a-3bad-db4b-b8df8179ea09 BLEOp1 M:001A22092CDB s:3e135142-654f-9090-134a-a6ff5bb77046 c:3fa4585a-ce4a-3bad-db4b-b8df8179ea09 r u:1235 go When a BLEOp0 is sent, the following MQTT is published: MQT : tele /%topic%/ BLE = { \"BLEOperation\" :{ \"opid\" : \"0\" , \"stat\" : \"1\" , \"state\" : \"START\" , \"MAC\" : \"001A22092CDB\" , \"svc\" : \"3e135142-654f-9090-134a-a6ff5bb77046\" , \"char\" : \"3fa4585a-ce4a-3bad-db4b-b8df8179ea09\" , \"notifychar\" : \"d0e8434d-cd29-0996-af41-6c90f4e0eb2a\" , \"wrote\" : \"03\" }} When the operation is done/failed, the data is sent to MQTT again. A failure may look like: MQT : tele /%topic%/ BLE = { \"BLEOperation\" :{ \"opid\" : \"0\" , \"stat\" : \"-11\" , \"state\" : \"FAILCONNECT\" , \"MAC\" : \"001A22092CDB\" , \"svc\" : \"3e135142-654f-9090-134a-a6ff5bb77046\" , \"char\" : \"3fa4585a-ce4a-3bad-db4b-b8df8179ea09\" , \"notifychar\" : \"d0e8434d-cd29-0996-af41-6c90f4e0eb2a\" , \"wrote\" : \"03\" }} A success: MQT : tele /%topic%/ BLE = { \"BLEOperation\" :{ \"opid\" : \"1\" , \"stat\" : \"7\" , \"state\" : \"NOTIFIED\" , \"MAC\" : \"001A22092CDB\" , \"svc\" : \"3e135142-654f-9090-134a-a6ff5bb77046\" , \"char\" : \"3fa4585a-ce4a-3bad-db4b-b8df8179ea09\" , \"notifychar\" : \"d0e8434d-cd29-0996-af41-6c90f4e0eb2a\" , \"wrote\" : \"03\" , \"notify\" : \"020109000429\" }} JSON on BLE topic ~ The list of active BLE devices is a JSON object published on tele/%topic%/BLE . The JSON object has active as the 1st level key. The 2nd level object use the MAC address of devices key. Each sub-object contains the device name as n , the RSSI as r and optionally the alias of the device as a : tele / tasmota_esp32 / BLE = { \"Time\" : \"2021-01-10T19:57:54\" , \"BLEDevices\" : { \"total\" : 11 , \"001A22092FB7\" : { \"i\" : 0 , \"n\" : \"CC-RT-M-BLE\" , \"r\" :- 86 }, \"4C65A8DAF607\" : { \"i\" : 1 , \"n\" : \"MJ_HT_V1\" , \"r\" :- 84 }, \"001B66C0CF4C\" : { \"i\" : 2 , \"n\" : \"HD 450BT\" , \"r\" :- 80 }, \"001A22092CDB\" : { \"i\" : 3 , \"n\" : \"CC-RT-M-BLE\" , \"r\" :- 86 }, \"A4C1387FC1E1\" : { \"i\" : 4 , \"n\" : \"LYWSD03MMC\" , \"r\" :- 70 }, \"001A22092C9A\" : { \"i\" : 5 , \"n\" : \"CC-RT-M-BLE\" , \"r\" :- 87 }, \"A4C1386A1E24\" : { \"i\" : 6 , \"n\" : \"LYWSD03MMC\" , \"r\" :- 73 }, \"142BC286F794\" : { \"i\" : 7 , \"r\" :- 53 }, \"D6E0138D9201\" : { \"i\" : 8 , \"n\" : \"Charge 3\" , \"r\" :- 87 }, \"21BF2683F8A9\" : { \"i\" : 9 , \"r\" :- 51 }, \"10758BBEF8E0\" : { \"i\" : 10 , \"r\" :- 96 } } } if requested via the command BLEDevices , it is published on stat/ When BLEDetails is enabled, a JSON with details as 1st level key is published with the following format: MQT : tele /%topic%/ BLE = { \"details\" :{ \"mac\" : \"001A22092C9A\" , \"p\" : \"0C0943432D52542D4D2D424C450CFF0000000000000000000000\" , \"uuid\" : \"servicedata\" , \"uuid2\" : \"servicedata\" , } } if some details were overwritten (2 advrets arrived before the MQTT could be sent), then \"lost\":true will also appear. Usage notes ~ BLEMode1 : If you use BLEMode1, then both iBeacon and MI32 will stop receiving adverts (unless you manually trigger a scan with BLEScan0). However, you CAN still send BLEOp commands, and expect it to connect and operate. BLEScan1 0/1 : Note that for some devices, the advertisement data received is different for passive and active mode. BLEOp : It will fail to add an operation to the queue if 10 are already queued. However, the queue management could be enhanced, so probably best to serialise any operations from a driver (e.g. the MI32 driver uses Operations to read the battery level on some sensors. It queues one operation, and waits for that to finish before queuing another). This leaves room for both other drivers, and also user operations to be queued. If an external application is adding operations, the same should be applied - queue one, and wait for it to succeed or fail before adding another. We could reasonably expect the driver to work with up to 6 operations in progress - but if one source of operations steals all 6 slots at once, it will affect others who may be wanting to perform operations. Normal operations against BLE devices will be very variable with regard to the time taken. E.g. with the connection timeout set to 30s, you can expect an operation against a device which cannot be reached to take 30s. Since all operations are performed serially, any single operation may take up to 3 minutes to fail (e.g. if there were 6 in progress). We COULD alleviate this by running multiple BLE clients at the same time. The driver has been designed so that this could be possible in the future, but first we must establish it\u2019s true stability in use. High level driver based on BLE_ESP32 ~ xdrv_47_BLE_ESP32 is designed to be used by other upper-level drivers which need to use BLE advertisements or interact with BLE devices. xsns_62_MI_ESP32_BLE_ESP32.ino and xsns_52_ibeacon_BLE_ESP32.ino are example of such driver. Such a driver must depend on BLE_ESP32 feature and code whuld be wrapped within : #ifdef USE_BLE_ESP32 #ifdef USE_your_driver_name // your driver code #endif // #ifdef USE_your_driver_name #endif // #ifdef USE_BLE_ESP32 All functions and constants are in namespace BLE_ESP32:: Receiving advertisements: ~ Create a function like: int MyDriverNameAdvertismentCallback ( BLE_ESP32 :: ble_advertisment_t * pStruct ) { // the NimBLE advertisement ... BLEAdvertisedDevice * advertisedDevice = pStruct -> advertisedDevice ; // some things are already extracted : int RSSI = pStruct -> RSSI ; const uint8_t * addr = pStruct -> addr ; const char * name = pStruct -> name ; AddLog_P ( LOG_LEVEL_DEBUG , PSTR ( \"Adv received for %s ( %s )\" ), (( std :: string ) advertisedDevice -> getAddress ()) . c_str (), name ); return 0 ; } From the callback, or anything you call from the callback, don\u2019t do anything directly with Tasmota globals, or call any MQTT functions or standard log functions! Register this callback with BLE_ESP32::registerForAdvertismentCallbacks(\"MyDriverName\", MyDriverNameAdvertismentCallback); Performing Read, Write on a device, and/or requesting the next Notify: The BLE operations are controlled by a structure BLE_ESP32::generic_sensor_t *op Creating a new functions: // ALWAYS use this function to create a new one . int res = BLE_ESP32 :: newOperation (& op ); // Queue with this . int res = BLE_ESP32 :: extQueueOperation (& op ); if (! res ) { // if it fails to add to the queue, do please delete it BLE_ESP32 : : freeOperation ( & op ); AddLog_P(LOG_LEVEL_ERROR,PSTR(\"Failed to queue new operation - deleted\")) ; } Operations are added to a limited queue, and performed serially. BLE is quite SLOW, so you can expect some seconds before a response. Also, we don\u2019t hurry things. Operations are only transferred from the queue to the active Operation once per second. Similarly, completed operations are only examine once per seconds. Whilst an operation is in progress, Adverts will stop coming in. Operations have a status, +ve -> in progress or success. -ve -> failed. You can get the name of a status from BLE_ESP32::getStateString(state) . States are defined in the header file as GEN_STATE_XXXX . A generic function for running an operation may be: int genericOpCompleteFn ( BLE_ESP32 :: generic_sensor_t * op ){ if ( op -> state <= GEN_STATE_FAILED ){ AddLog_P ( LOG_LEVEL_ERROR , PSTR ( \"Operation failed with state %s \" , BLE_ESP32 :: getStateString ( op -> state )); return 0 ; } // Do something with your shiny data which was read If ( op -> readlen ){ If ( ! op -> readtruncated ){ } } // Do something with your shiny data which was notified If ( op -> notifylen ){ If ( ! op -> notifytruncated ){ } } // note : the op will be deleted automatically once all calls are over . return 0 ; } int myspecialdatamodifyer ( BLE_ESP32 :: generic_sensor_t * op ){ // change the data to write based on the data read . } #define OPTYPE_READ 0 #define OPTYPE_READMODIFYWRITE 1 bool BLEOperation ( utin8_t * addr , int optype , const char * svc , const char * charactistic , const char * notifychar = nullptr , const uint8_t * data = nullptr , int datalen = 0 ) { if ( ! svc || ! svc [ 0 ]){ return 0 ; } BLE_ESP32 :: generic_sensor_t * op = nullptr ; // ALWAYS use this function to create a new one . int res = BLE_ESP32 :: newOperation ( & op ); if ( ! res ){ AddLog_P ( LOG_LEVEL_ERROR , PSTR ( \"Can't get a newOperation from BLE\" )); return 0 ; } else { AddLog_P ( LOG_LEVEL_DEBUG , PSTR ( \"got a newOperation from BLE\" )); } op -> addr = NimBLEAddress ( addr ); bool havechar = false ; op -> serviceUUID = NimBLEUUID ( svc ); if ( charactistic && charactistic [ 0 ]){ havechar = true ; op -> characteristicUUID = NimBLEUUID ( charactistic ); } if ( notifychar && notifychar [ 0 ]){ op -> notificationCharacteristicUUID = NimBLEUUID ( notifychar ); } // if we have data , assume this is a write operation if ( data && datalen ) { op -> writelen = datalen ; memcpy ( op -> dataToWrite , data , datalen ); } else { // else if we have a RW characteristic , must be a read operation if ( ! datalen && havechar ){ op -> readlen = 1 ; // if we don 't set readlen, then it won' t read } } // the only times we intercept between read and write if ( optype == OPTYPE_READMODIFYWRITE ){ op -> readlen = 1 ; // if we don 't set readlen, then it won' t read op -> readmodifywritecallback = ( void * ) myspecialdatamodifyer ; } // this op will call us back on complete or failure . op -> completecallback = ( void * ) genericOpCompleteFn ; // you can use context to indicate anything you like . uint32_t context = 0 ; op -> context = ( void * ) context ; res = BLE_ESP32 :: extQueueOperation ( & op ); if ( ! res ){ // if it fails to add to the queue , do please delete it BLE_ESP32 :: freeOperation ( & op ); AddLog_P ( LOG_LEVEL_ERROR , PSTR ( \"Failed to queue new operation - deleted\" )); } return res ; } Other callbacks: ~ You can register to know when a scan ends, and also for ALL operations: void registerForOpCallbacks ( const char * tag , BLE_ESP32 :: OPCOMPLETE_CALLBACK * pFn ); void registerForScanCallbacks ( const char * tag , BLE_ESP32 :: SCANCOMPLETE_CALLBACK * pFn ); These are not normally required for a driver. Other functions: ~ Interpreting an address supplied by the user: int BLE_ESP32::getAddr(uint8_t *dest, char *src); Where dest must be uint8_t addr[6]; Returns: 0 for invalid/not found, 1 for MAC parsed, 2 for Alias found. This will interpret AABBCCDDEEFF or AA:BB:CC:DD:EE:FF or an alias set with BLEAlias . Establishing if a device is still present, or get it\u2019s age: int BLE_ESP32::devicePresent(uint8_t*mac); Where mac is the BINARY mac address as uint8_t mac[6] Returns: 0 for the device having timed out, or age in seconds.","title":"BLEGenericDriver"},{"location":"BLEGenericDriver/#enabling-the-driver","text":"You must be building for ESP32 - ESP8266 has no native BLE capability. To enable the driver, this must be defined: #define USE_BLE_ESP32 Be aware, enabling of the native BLE on ESP32 has an impact on wifi performance. Although later SDK helped a bit, expect more lag on the web interface and on MQTT. If only controlling BLE devices, then scanning can be disabled, which will minimise wifi impact. This is compiled by default in the Sensors firmware, but you still need to enable BLE using the web interface configure BLE button or setoption115 1.","title":"Enabling the driver"},{"location":"BLEGenericDriver/#driver-features","text":"When the BLE_ESP32 driver is enabled and BLE is enabled, Tasmota will by default scan for nearby BLE devices every 20s. ALL BLE devices are noted and displayed in the Configure BLE page. To see an updaqted list, you must refresh the page. Devices you may 'find' include BLE sensors (e.g. the 'MI' range), fitness watches, iBeacons, Toothbrushes, Scales, etc. You will also see some random MAC addresses appearing - these are Mobile phones which use a random MAC address when advertiseing - for example they regularly advertise Covid contact tracing information. Unfortunately, there is no easy way to exclude these, but indeed the BLE driver enables you to catch some of the contact tracing information. Scanning can be configued to be 'passive' (default), or 'Active'. In 'Active' mode, tasmota queries the dveices for some additional information (e.g. the name of the device) The driver also allows you to perform simple active operations, like reading a characteristic, writing a characteristic, and registering for a notification. When performing these operaitons, the BLE_ESP32 driver connects to the device, performs the operation, and then disconnects. Operations can take between 1 and 10 seconds, and BLE is not necessarily reliable, so expect failures.","title":"Driver features"},{"location":"BLEGenericDriver/#ble-commands-summary","text":"Command Parameters BLEMode Change the operational mode of the BLE driver. BLEMode0 = disable regular BLE scans. BLEMode1 = BLE scan on command only. BLEMode2 = regular BLE scanning (default). BLEScan Cause/Configure BLE a scan BLEScan0 0..1 = enable or disable Active scanning. (an active scan will gather extra data from devices, including name) BLEScan = Trigger a 20s scan now if in BLEMode1 BLEScan n = Trigger a scan now for n seconds if in BLEMode1 BLEDetails Display details about recevied adverts BLEDetails0 = disable showing of details. BLEDetails1 mac|alias = show the next advert from device mac BLEAlias Set Alias names for devices. A device may be referred to by it's alias in subsequent commands BLEAlias mac=alias mac=alias ... = set one or more aliases from devices. BLEAlias2 = clear all aliases. BLEName Read or write the name of a BLE device. BLEName mac|alias = read the name of a device using 1800/2A00. BLEName mac|alias = write the name of a device using 1800/2A00 - many devices are read only. BLEDevices Cause a list of known devices to be sent on MQTT, or Empty the list of known devices. BLEDevices0 = clear the known devices list. BLEDevices = Cause the known devices list to be published on stat/TASName/BLE. BLEMaxAge Set the timeout for device adverts. BLEMaxAge n = set the devices timeout to n seconds. BLEMaxAge = display the device timeout. BLEOp Perform a simple active BLE operation (read/write/notify). BLEOp0 = trigger publish of operations in progress to MQTT at stat/TASName/BLE. BLEOp (parameters) = queue a BLE operation Paramaters:0 m:mac BLEDebug Set BLE debug level. BLEDebug = show extra debug information BLEDebug0 = suppress extra debug","title":"BLE commands summary:"},{"location":"BLEGenericDriver/#ble-commands-detailed-description","text":"","title":"BLE commands detailed description"},{"location":"BLEGenericDriver/#json-on-ble-topic","text":"The list of active BLE devices is a JSON object published on tele/%topic%/BLE . The JSON object has active as the 1st level key. The 2nd level object use the MAC address of devices key. Each sub-object contains the device name as n , the RSSI as r and optionally the alias of the device as a : tele / tasmota_esp32 / BLE = { \"Time\" : \"2021-01-10T19:57:54\" , \"BLEDevices\" : { \"total\" : 11 , \"001A22092FB7\" : { \"i\" : 0 , \"n\" : \"CC-RT-M-BLE\" , \"r\" :- 86 }, \"4C65A8DAF607\" : { \"i\" : 1 , \"n\" : \"MJ_HT_V1\" , \"r\" :- 84 }, \"001B66C0CF4C\" : { \"i\" : 2 , \"n\" : \"HD 450BT\" , \"r\" :- 80 }, \"001A22092CDB\" : { \"i\" : 3 , \"n\" : \"CC-RT-M-BLE\" , \"r\" :- 86 }, \"A4C1387FC1E1\" : { \"i\" : 4 , \"n\" : \"LYWSD03MMC\" , \"r\" :- 70 }, \"001A22092C9A\" : { \"i\" : 5 , \"n\" : \"CC-RT-M-BLE\" , \"r\" :- 87 }, \"A4C1386A1E24\" : { \"i\" : 6 , \"n\" : \"LYWSD03MMC\" , \"r\" :- 73 }, \"142BC286F794\" : { \"i\" : 7 , \"r\" :- 53 }, \"D6E0138D9201\" : { \"i\" : 8 , \"n\" : \"Charge 3\" , \"r\" :- 87 }, \"21BF2683F8A9\" : { \"i\" : 9 , \"r\" :- 51 }, \"10758BBEF8E0\" : { \"i\" : 10 , \"r\" :- 96 } } } if requested via the command BLEDevices , it is published on stat/ When BLEDetails is enabled, a JSON with details as 1st level key is published with the following format: MQT : tele /%topic%/ BLE = { \"details\" :{ \"mac\" : \"001A22092C9A\" , \"p\" : \"0C0943432D52542D4D2D424C450CFF0000000000000000000000\" , \"uuid\" : \"servicedata\" , \"uuid2\" : \"servicedata\" , } } if some details were overwritten (2 advrets arrived before the MQTT could be sent), then \"lost\":true will also appear.","title":"JSON on BLE topic"},{"location":"BLEGenericDriver/#usage-notes","text":"BLEMode1 : If you use BLEMode1, then both iBeacon and MI32 will stop receiving adverts (unless you manually trigger a scan with BLEScan0). However, you CAN still send BLEOp commands, and expect it to connect and operate. BLEScan1 0/1 : Note that for some devices, the advertisement data received is different for passive and active mode. BLEOp : It will fail to add an operation to the queue if 10 are already queued. However, the queue management could be enhanced, so probably best to serialise any operations from a driver (e.g. the MI32 driver uses Operations to read the battery level on some sensors. It queues one operation, and waits for that to finish before queuing another). This leaves room for both other drivers, and also user operations to be queued. If an external application is adding operations, the same should be applied - queue one, and wait for it to succeed or fail before adding another. We could reasonably expect the driver to work with up to 6 operations in progress - but if one source of operations steals all 6 slots at once, it will affect others who may be wanting to perform operations. Normal operations against BLE devices will be very variable with regard to the time taken. E.g. with the connection timeout set to 30s, you can expect an operation against a device which cannot be reached to take 30s. Since all operations are performed serially, any single operation may take up to 3 minutes to fail (e.g. if there were 6 in progress). We COULD alleviate this by running multiple BLE clients at the same time. The driver has been designed so that this could be possible in the future, but first we must establish it\u2019s true stability in use.","title":"Usage notes"},{"location":"BLEGenericDriver/#high-level-driver-based-on-ble_esp32","text":"xdrv_47_BLE_ESP32 is designed to be used by other upper-level drivers which need to use BLE advertisements or interact with BLE devices. xsns_62_MI_ESP32_BLE_ESP32.ino and xsns_52_ibeacon_BLE_ESP32.ino are example of such driver. Such a driver must depend on BLE_ESP32 feature and code whuld be wrapped within : #ifdef USE_BLE_ESP32 #ifdef USE_your_driver_name // your driver code #endif // #ifdef USE_your_driver_name #endif // #ifdef USE_BLE_ESP32 All functions and constants are in namespace BLE_ESP32::","title":"High level driver based on BLE_ESP32"},{"location":"BLEGenericDriver/#receiving-advertisements","text":"Create a function like: int MyDriverNameAdvertismentCallback ( BLE_ESP32 :: ble_advertisment_t * pStruct ) { // the NimBLE advertisement ... BLEAdvertisedDevice * advertisedDevice = pStruct -> advertisedDevice ; // some things are already extracted : int RSSI = pStruct -> RSSI ; const uint8_t * addr = pStruct -> addr ; const char * name = pStruct -> name ; AddLog_P ( LOG_LEVEL_DEBUG , PSTR ( \"Adv received for %s ( %s )\" ), (( std :: string ) advertisedDevice -> getAddress ()) . c_str (), name ); return 0 ; } From the callback, or anything you call from the callback, don\u2019t do anything directly with Tasmota globals, or call any MQTT functions or standard log functions! Register this callback with BLE_ESP32::registerForAdvertismentCallbacks(\"MyDriverName\", MyDriverNameAdvertismentCallback); Performing Read, Write on a device, and/or requesting the next Notify: The BLE operations are controlled by a structure BLE_ESP32::generic_sensor_t *op Creating a new functions: // ALWAYS use this function to create a new one . int res = BLE_ESP32 :: newOperation (& op ); // Queue with this . int res = BLE_ESP32 :: extQueueOperation (& op ); if (! res ) { // if it fails to add to the queue, do please delete it BLE_ESP32 : : freeOperation ( & op ); AddLog_P(LOG_LEVEL_ERROR,PSTR(\"Failed to queue new operation - deleted\")) ; } Operations are added to a limited queue, and performed serially. BLE is quite SLOW, so you can expect some seconds before a response. Also, we don\u2019t hurry things. Operations are only transferred from the queue to the active Operation once per second. Similarly, completed operations are only examine once per seconds. Whilst an operation is in progress, Adverts will stop coming in. Operations have a status, +ve -> in progress or success. -ve -> failed. You can get the name of a status from BLE_ESP32::getStateString(state) . States are defined in the header file as GEN_STATE_XXXX . A generic function for running an operation may be: int genericOpCompleteFn ( BLE_ESP32 :: generic_sensor_t * op ){ if ( op -> state <= GEN_STATE_FAILED ){ AddLog_P ( LOG_LEVEL_ERROR , PSTR ( \"Operation failed with state %s \" , BLE_ESP32 :: getStateString ( op -> state )); return 0 ; } // Do something with your shiny data which was read If ( op -> readlen ){ If ( ! op -> readtruncated ){ } } // Do something with your shiny data which was notified If ( op -> notifylen ){ If ( ! op -> notifytruncated ){ } } // note : the op will be deleted automatically once all calls are over . return 0 ; } int myspecialdatamodifyer ( BLE_ESP32 :: generic_sensor_t * op ){ // change the data to write based on the data read . } #define OPTYPE_READ 0 #define OPTYPE_READMODIFYWRITE 1 bool BLEOperation ( utin8_t * addr , int optype , const char * svc , const char * charactistic , const char * notifychar = nullptr , const uint8_t * data = nullptr , int datalen = 0 ) { if ( ! svc || ! svc [ 0 ]){ return 0 ; } BLE_ESP32 :: generic_sensor_t * op = nullptr ; // ALWAYS use this function to create a new one . int res = BLE_ESP32 :: newOperation ( & op ); if ( ! res ){ AddLog_P ( LOG_LEVEL_ERROR , PSTR ( \"Can't get a newOperation from BLE\" )); return 0 ; } else { AddLog_P ( LOG_LEVEL_DEBUG , PSTR ( \"got a newOperation from BLE\" )); } op -> addr = NimBLEAddress ( addr ); bool havechar = false ; op -> serviceUUID = NimBLEUUID ( svc ); if ( charactistic && charactistic [ 0 ]){ havechar = true ; op -> characteristicUUID = NimBLEUUID ( charactistic ); } if ( notifychar && notifychar [ 0 ]){ op -> notificationCharacteristicUUID = NimBLEUUID ( notifychar ); } // if we have data , assume this is a write operation if ( data && datalen ) { op -> writelen = datalen ; memcpy ( op -> dataToWrite , data , datalen ); } else { // else if we have a RW characteristic , must be a read operation if ( ! datalen && havechar ){ op -> readlen = 1 ; // if we don 't set readlen, then it won' t read } } // the only times we intercept between read and write if ( optype == OPTYPE_READMODIFYWRITE ){ op -> readlen = 1 ; // if we don 't set readlen, then it won' t read op -> readmodifywritecallback = ( void * ) myspecialdatamodifyer ; } // this op will call us back on complete or failure . op -> completecallback = ( void * ) genericOpCompleteFn ; // you can use context to indicate anything you like . uint32_t context = 0 ; op -> context = ( void * ) context ; res = BLE_ESP32 :: extQueueOperation ( & op ); if ( ! res ){ // if it fails to add to the queue , do please delete it BLE_ESP32 :: freeOperation ( & op ); AddLog_P ( LOG_LEVEL_ERROR , PSTR ( \"Failed to queue new operation - deleted\" )); } return res ; }","title":"Receiving advertisements:"},{"location":"BLEGenericDriver/#other-callbacks","text":"You can register to know when a scan ends, and also for ALL operations: void registerForOpCallbacks ( const char * tag , BLE_ESP32 :: OPCOMPLETE_CALLBACK * pFn ); void registerForScanCallbacks ( const char * tag , BLE_ESP32 :: SCANCOMPLETE_CALLBACK * pFn ); These are not normally required for a driver.","title":"Other callbacks:"},{"location":"BLEGenericDriver/#other-functions","text":"","title":"Other functions:"},{"location":"BME280/","text":"This feature is included only in tasmota-sensors.bin BME280 sensor, an environmental sensor with temperature, barometric pressure and humidity\" See BME280 Temperature, Humidity and Pressure Sensor for more information. BME280 driver also supports BMP085 , BMP180 and BMP280 sensors. Configuration ~ Wiring ~ BME280 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy Note If you are using breakout boards which break out pins CSB please ensure that you connect this pin to VCC to ensure that the chip stays in I 2 C mode. This is due to some manufacturers of breakout boards add pull-up resistors to allow for SPI compatibility (some would default to SPI, others to I 2 C)_ Connect the SDO pin to GND or VCC to ensure required I 2 C address is used by the chip - Again some manufacturers add resistors to provide external bias but due to them wanting to retain SPI compatibility such pulldown resistors may not be sufficient to ensure that the pin levels are at the correct transition during power-up / reset state._ Since the chip supports both SPI and I 2 C, but in Tasmota only I 2 C is supported you want to make sure that the chip is in I 2 C mode during reset/power-on and remain in that state during operation otherwise unexpected behaviour may result when the Tasmota firmware polls the chip for sensor data. Sonoff Basic wiring After a reboot the driver will detect BME280 automatically and display temperature, humidity and pressure measured. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-11-03T19:34:28\" , \"BME280\" : { \"Temperature\" : 21.7 , \"Humidity\" : 66.6 , \"Pressure\" : 988.6 }, \"PressureUnit\" : \"hPa\" , \"TempUnit\" : \"C\" } From v6.1.2.20 you can use multiple BMP Sensors ( #4195 ) Limit is 2 sensors and you have to change the address of one sensor. Than connect your sensor SCL and SDA parallel to the device. BME280 address change example: Commands ~ TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device. Breakout boards ~ Do NOT buy Breakout boards which supports 5V too. The onboard vreg will heat the PCB and you get false too high readings","title":"BME280 temperature, humidity and pressure sensor"},{"location":"BME280/#configuration","text":"","title":"Configuration"},{"location":"BME280/#wiring","text":"BME280 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy Note If you are using breakout boards which break out pins CSB please ensure that you connect this pin to VCC to ensure that the chip stays in I 2 C mode. This is due to some manufacturers of breakout boards add pull-up resistors to allow for SPI compatibility (some would default to SPI, others to I 2 C)_ Connect the SDO pin to GND or VCC to ensure required I 2 C address is used by the chip - Again some manufacturers add resistors to provide external bias but due to them wanting to retain SPI compatibility such pulldown resistors may not be sufficient to ensure that the pin levels are at the correct transition during power-up / reset state._ Since the chip supports both SPI and I 2 C, but in Tasmota only I 2 C is supported you want to make sure that the chip is in I 2 C mode during reset/power-on and remain in that state during operation otherwise unexpected behaviour may result when the Tasmota firmware polls the chip for sensor data. Sonoff Basic wiring After a reboot the driver will detect BME280 automatically and display temperature, humidity and pressure measured. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-11-03T19:34:28\" , \"BME280\" : { \"Temperature\" : 21.7 , \"Humidity\" : 66.6 , \"Pressure\" : 988.6 }, \"PressureUnit\" : \"hPa\" , \"TempUnit\" : \"C\" } From v6.1.2.20 you can use multiple BMP Sensors ( #4195 ) Limit is 2 sensors and you have to change the address of one sensor. Than connect your sensor SCL and SDA parallel to the device. BME280 address change example:","title":"Wiring"},{"location":"BME280/#commands","text":"TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device.","title":"Commands"},{"location":"BME280/#breakout-boards","text":"Do NOT buy Breakout boards which supports 5V too. The onboard vreg will heat the PCB and you get false too high readings","title":"Breakout boards"},{"location":"BME680/","text":"This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_BME680 #define USE_BME680 // Enable support for BME680 sensor using Bosch BME680 library (+4k code) #endif BME680 sensor, an environmental I 2 C sensor with temperature, humidity, barometric pressure and gas. The BME680 takes those sensors to the next step in that it contains a small MOX sensor. The heated metal oxide changes resistance based on the volatile organic compounds (VOC) in the air, so it can be used to detect gasses & alcohols such as Ethanol, Alcohol and Carbon Monoxide, and perform air quality measurements. Note it will give you one resistance value, with overall VOC content, but it cannot differentiate gasses or alcohols. See BME680 - Temperature, Humidity, Pressure and Gas Sensor for more information. Configuration ~ Wiring ~ BME680 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) After a reboot the driver will detect BME680 automatically and display temperature, humidity, pressure and gas resistance measured. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-11-03T21:25:53\" , \"BME680\" : { \"Temperature\" : 27.7 , \"Humidity\" : 65.2 , \"Pressure\" : 989 , \"Gas\" : 346.24 }, \"PressureUnit\" : \"hPa\" , \"TempUnit\" : \"C\" } Commands ~ TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device. Breakout Boards ~ Buy from: - Adafruit - AliExpress","title":"BME680 temperature, humidity, pressure and gas sensor"},{"location":"BME680/#configuration","text":"","title":"Configuration"},{"location":"BME680/#wiring","text":"BME680 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"BME680/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) After a reboot the driver will detect BME680 automatically and display temperature, humidity, pressure and gas resistance measured. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-11-03T21:25:53\" , \"BME680\" : { \"Temperature\" : 27.7 , \"Humidity\" : 65.2 , \"Pressure\" : 989 , \"Gas\" : 346.24 }, \"PressureUnit\" : \"hPa\" , \"TempUnit\" : \"C\" }","title":"Tasmota Settings"},{"location":"BME680/#commands","text":"TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device.","title":"Commands"},{"location":"BME680/#breakout-boards","text":"Buy from: - Adafruit - AliExpress","title":"Breakout Boards"},{"location":"BMP280/","text":"","title":"BMP280"},{"location":"Blinds-and-Shutters/","text":"Shutters and Blinds ~ Control blinds and roller shades connected to regular ON/OFF motors or stepper motors Only available in normal Tasmota.bin! Before starting you have to enable shutter support with SetOption80 1 Commands ~ Complete list of commands is available at Blinds, Shutters and Roller Shades Commands . Shutter Modes ~ There are five shutter modes which define how the relays operate. Additionally you can define PulseTime on any relay to change the relay into a pulse relay where the pulse changes start/stop. We recommend at least for Shutter mode 1 to define an Interlock setting. The examples below are for a ShutterRelay1 1 configuration (using Relay1 and Relay2). Shutter mode 1 - Normal Operation First relay: OFF/DOWN, Second relay: OFF/UP Interlock 1,2 (Interlocked relay pair) Interlock ON Shutter mode 2 - Circuit Safe First relay: ON/OFF, Second relay: UP/DOWN Interlock OFF Shutter mode 3 - Garage Motors First relay: OFF/DOWN PULSE, Second relay: OFF/UP PULSE Shutter mode 4 - Stepper Motors First relay: ON/OFF, Second relay: UP/DOWN PWM: Stepper signal, COUNTER: Stepper position signal PWM and COUNTER defined Shutter mode 5 - Servo Motors (PWM position based servo) First relay: ON/OFF, Second relay: UP/DOWN (optional not used) PWM: Stepper signal PWMfrequency 200 ( This is mandatory for most relay to get correct PWM duty cylces) SetOption15 0 (required to store value and make it reboot save) Wiring diagrams for Normal, Stepper motor, and Short Circuit-Safe configurations are available at the end of this page. Even if the shutter does not have two motors, three wires have to be connected. Note After setting the options for shutter mode, the device must be rebooted. Otherwise, the sliders won't be available in the web UI, and the ShutterOpenDuration<x> and ShutterCloseDuration<x> commands will report \"Shutter unknown\". Issue ShutterRelay<x> 1 command and check in console which ShutterMode is displayed: Issue Status 13 command and check in console how the shutter is defined Shutter accuracy digits : 1 Shutter 0 ( Relay : 1 ) : Init . Pos : 20000 [ 100 % ] , Open Vel . : 100 Close Vel . : 100 , Max Way : 20000 , Opentime 10.0 [ s ] , Closetime 10.0 [ s ] , CoedffCalc : c0 : 0 , c1 200 , c2 : 200 , c3 : 0 , c4 : 0 , binmask 3 , is inverted 1 , < span style = \"font-weight:bold;color:lime\" > ShutterMode 0 </ span > , motordelay 0 Operation ~ Turning a device relay on or off directly (i.e., using Power ) will function to affect a shutter's movement. In momentary mode (i.e., stepper motor), the relays start or stop the motor. The driver takes care of the direction and proper update of the shutter position. The shutter reports its position and can also be sent to a dedicated position. ShutterPosition 0 means the shutter is closed and ShutterPosition 100 means the shutter is open. If you need the position values reversed ( 0 = open, 100 = closed), define and calibrate your shutter as documented below . Then tell Tasmota to reverse the shutter position meaning via the ShutterInvert<x> 1 command. All internal calculations are the same (the log output is the same). Only the interaction with the user and other systems changes. Now ShutterPosition<x> 0 will open the shutter and ShutterPosition<x> 100 will close the shutter. By default, only Shutter1 is enabled when SetOption80 1 is invoked. A maximum of four shutters per device are supported. To enable additional shutters, ShutterRelay<x> <value> must be executed for each additional shutter. Additional shutter declarations must be sequentially numbered, and without gaps (i.e., second shutter is 2, next shutter 3 and finally shutter 4). Disabling a shutter in the middle of the defined set of shutters will disable all other higher numbered shutters. If the disabled shutter is restored, the higher numbered shutters previously declared will also be restored. When a shutter is added or removed, a list of the active shutters, with their parameters, is output to the log. If you intend to remove shutters, explicitly remove each one beginning with the highest numbered shutter. With four shutters, eight Relay<x> components are needed. If manual operation switches ( Switch<x> or Button<x> pairs) are also used, additional input GPIO are required. The ESP82xx device may not have enough free GPIO to support all the shutter connections required. A GPIO expander such as a PCF8574 or MCP230xx can be used with additional effort. Using manual operation Switch<x> pairs may require setting SwitchMode<x> 4 (inverse follow) for proper switch behavior. Any shutter positioning can be locked ShutterLock<x> 1 . Once executed an ongoing movement is finished while further positioning commands like ShutterOpen<x> , ShutterClose<x> , ShutterStop<x> , ShutterPosition<x> , ... as well as web UI buttons, web UI sliders, and shutter buttons are disabled. This can be used to lock an outdoor blind in case of high wind or rain. You may also disable shutter positioning games by your children. Shutter positioning can be unlocked using ShutterLock<x> 0 . Please be aware that the shutter can still be moved by direct relay control (i.e., Power<x> ), or physical switches and buttons. Use the ShutterButton<x> command prior to ShutterLock to be able to lock buttons. Calibration ~ Shutter calibration video tutorial Start your shutter in a closed position preferably. Set internal position to closed with ShutterSetClose<x> . Set the time needed to open the shutter completely with ShutterOpenDuration<x> . If the shutter opens more than needed, move it to the desired position with ShutterSetPosition<x> then set the position to fully open (100) with ShutterSetOpen<x> and decrease the open time. Set the time needed to close the shutters with ShutterCloseDuration<x> . If the shutter does not close completely, open again and adjust close time. If it runs too long, move it back to desired closed position with ShutterSetPosition<x> , reset to 0 with ShutterSetClose<x> and decrease open time. Alternate between opening and closing the shutter until you find out the exact times needed to get the same positions multiple times Now set the 50% open position of the shutter. Some shutters need some time from totally closed until they begin moving the bottom-most part and opening. This often results in a shutter that is less than 50% open when the shutter has been operating for 50% of the set time. This can be corrected by using ShutterSetHalfway<x> . Use this procedure to calibrate the half-open position: ShutterClose<x> (confirm that the shutter is completely closed) ShutterSetHalfway<x> 50 (reset to default) Move the shutter to actual 50% open position. Use ShutterPosition<x> to inquire the shutter's current position and record the value. This value is a percentage of the total opening (e.g., 63 = 63% of opening). ShutterClose<x> ShutterSetHalfway<x> 63 (using the value from step #4 above) Restart 1 After calibration is complete, you might want to enable an additional 1 second motor movement with ShutterEnableEndStopTime<x> 1 when the shutter is asked to move to its end positions (0% and 100%). With this you can guarantee that end positions are still reached in case of inaccuracies. Take care to disable this with ShutterEnableEndStopTime<x> 0 before further open or close duration measurements. Increasing Calibration Granularity If you desire that the %-opening closely match what ShutterPosition<x> and web UI indicate, there is a granular calibration matrix available. Ensure that ShutterClose<x> and ShutterOpen<x> moves the shutter more or less to the limit positions and follow this procedure: ShutterSetHalfway<x> 50 (reset to default) ShutterCalibration<x> 30 50 70 90 100 Restart 1 ShutterClose<x> Move the shutter to each of the following opening percentages and measure the shutter's position for each. ShutterPosition<x> 30 (e.g., measurement = 15 ) ShutterPosition<x> 50 (e.g., measurement = 50 ) ShutterPosition<x> 70 (e.g., measurement = 100 ) ShutterPosition<x> 90 (e.g., measurement = 150 ) ShutterPosition<x> 100 (e.g., measurement = 180 ) Finally, enter the position measurements as the calibration values: ShutterCalibration<x> 15 50 100 150 180 ShutterCalibration<x> takes position measurements ( not the time it takes to move). During calibration you position the shutter to an indicated percentage (e.g., 30% ) of opening and measure the shutter position (e.g., 15 ). Use the same unit of measure for all your measurements (e.g., centimeters, inches, steps, etc.). After calibration ShutterPosition<x> 30 will move to 30% opening which will correspond to the position you provided ( 15 ). Notice that there is no calibration for the 10% position. On many shutters, there is no movement during the initial phase (i.e., nearly 10% of total time). Therefore the opening could be 0 . This measurement would cause an execution DIV 0 exception. Therefore the first calibration point is 30%. In most cases this is not a large opening so the calibration will be near enough. Yes, until ~10%, the position will be a bit \"off\" but not enough for concern. Motor Movement Delays ~ Some motors need up to one second after power is turned on before they start moving. You can confirm if you are having this issue if opening and closing as a single action works properly but doing this in smaller steps result in a shift of the position. Shutterposition<x> 30 Measure the shutter position. This is the reference_position Shutterposition<x> 80 Measure the shutter position. This is the max_position Shutterposition<x> 30 Return the shutter to starting position. This must be the same position as measured in step #1 ( reference_position ). If not, ShutterCloseDuration must be adjusted. Shutterposition<x> 50 Shutterposition<x> 70 Shutterposition<x> 80 If you do not reach max_position you have a motor delay problem. Measure the shutter position. This is the real_max . Use this value in the calculation below. ShutterMotorDelay<x> <delay> Motor <delay> calculation - fine tune in 0.05 second increments (e.g. 0.65 ) as required. <delay> = ((max_position-real_max) / 2) / (((100/80) * max_position) / ShutterOpenDuration) Close the shutter and repeat this procedure until the motor delay is set properly. Button Control ~ When shutter is running in default ShutterMode 0 , you already have basic control over the shutter movement using switches or buttons in the module configuration to directly drive the shutter relays. For short circuit safe operation ShutterMode 1 direct control of the relays will not give you a nice user interface since you have to 1st set the direction with one switch or button and 2nd switch on the power by the other switch or button. To have shutter mode independent button control over the shutter and not over its relays one can use the ShutterButton<x> command. It also introduces some more features, see below: ShutterButton<x> <button> <func> <mqtt> This assigns a Tasmota button <button> to control your shutter <x> having functionality <func> . The Tasmota button <button> must already be configured in the module configuration. You can assign multiple buttons to a single shutter. Any button can only control one shutter (beside the <mqtt> broadcast feature, see description below). Any press of the button while the shutter is moving will immediately stop the shutter. One can remove all button control for shutter <x> by ShutterButton<x> 0 . The assigned button can have one of the following functionalities: Setup for an \"up\" button: ShutterButton<x> <button> up <mqtt> Single press will move shutter to 100%, double press to 50% and tripple press to 74%. Holding the button for more than the hold time ( SetOption32 ) moves all shutters with same <grouptopic> to 100% when <mqtt> is equal to 1 . When <mqtt> is equal to 0 hold action of this button is same as single press. Setup for a \"down\" button: ShutterButton<x> <button> down <mqtt> Single press will move shutter to 0%, double press to 50% and triple press to 24%. Holding the button for more than the hold time (SetOption32) moves all shutters with same <grouptopic> to 0% when <mqtt> is equal to 1 . When <mqtt> is equal to 0 hold action of this button is same as single press. Setup for an \"updown\" button: ShutterButton<x> <button> updown <mqtt> Single press will move shutter to 100%, double press down to 0% and triple press to 50%. No hold action and no other shutter control by MQTT, <mqtt> is don't care here. Setup for an \"toggle\" button: ShutterButton<x> <button> toggle <mqtt> Single press will toggle shutter, double press will move it to 50%. No hold action and no other shutter control by MQTT, <mqtt> is don't care here. More advanced control of the button press actions is given by the following ShutterButton<x> command syntax: ShutterButton<x> <button> <p1> <p2> <p3> <ph> <m1> <m2> <m3> <mh> <mi> <button> 1..4 : Button number, 0/- : disable buttons for this shutter <p1> 0..100 : single press position, t : toggle, - : disable <p2> 0..100 : double press position, t : toggle, - : disable <p3> 0..100 : tripple press position, t : toggle, - : disable <ph> 0..100 : hold press position, t : toggle, - : disable <m1> 1 : enable single press position MQTT broadcast, 0/- : disable <m2> 1 : enable double press position MQTT broadcast, 0/- : disable <m3> 1 : enable tripple press position MQTT broadcast, 0/- : disable <mh> 1 : enable hold press position MQTT broadcast, 0/- : disable <mi> 1 : enable MQTT broadcast to all shutter indices, 0/- : disable Parameters are optional. When missing, all subsequent parameters are set to disable . By a button single press the shutter is set to position <p1> . Double press will drive the shutter to position <p2> and triple press to position <p3> . Holding the button for more than the SetOption32 time sets the shutter position to <ph> . Any button action <p1> to <ph> can be disabled by setting the parameter to - . Independent from configuration <p1> to <ph> any press of the button while the shutter is moving will immediately stop the shutter. Global steering of all your shutters at home is supported by additional MQTT broadcast. By any button action a corresponding MQTT command can be initiated to the <grouptopic> of the device. For single press this can be enabled by <m1> equal to 1 , disabling is indicated by - . Double to hold MQTT configurations are given by <m2> to <mh> , correspondingly. When <mi> is equal to - only cmnd/<grouptopic>/Shutterposition<x> <p1..h> is fired. When <mi> is equal to 1 , <x> = 1..4 is used to control any shutter number of a Tasmota device having same <grouptopic> . Example ShutterButton<x> <button> 100 50 74 100 0 0 0 1 1 is same as ShutterButton<x> <button> up 1 . ShutterButton<x> <button> 0 50 24 0 0 0 0 1 1 is same as ShutterButton<x> <button> down 1 . ShutterButton<x> <button> 100 0 50 - 0 0 0 0 0 is same as ShutterButton<x> <button> updown 0 . ShutterButton<x> <button> t 50 - - 0 0 0 0 0 is same as ShutterButton<x> <button> toggle 0 . Module WiFi setup, restart, upgrade and reset according to Buttons and Switches are supported \"child and fool proof\" only when no button restriction ( SetOption1 ) is given and when all configured shutter buttons of that shutter are pressed 5x, 6x, 7x times or hold long simultaneously. Remote Control ~ Use any other Tasmota device with buttons or switches to control remotely a shutter using rules. Similar behavior as direct button control can be achieved by applying ShutterStopClose, ShutterStopOpen, ShutterStopToggle, ShutterStopPosition commands. They stop shutter movement if it is in motion and otherwise execute close, open, toggle or position commands. Example Run this rule on another Tasmota device with a switch configured. rule1 on switch1#state=2 do publish cmnd/%shutter-topic%/ShutterStopToggle endon Specific Configuration ~ Pulse Motor Support ~ There are shutters that have two relays but only need a pulse to start or stop. Depending on the current situation a pulse will stop the shutter or send it into a specific direction. To use these kinds of shutters a PulseTime must be defined on each relay. The minimum setting that seems to make it work consistently is 2 . A setting of 1 does not work. If the shutter moves too fast and does not react to a stop command, increase the setting to 3 or 4 . Stepper Motor Support ~ Stepper motors can also be used to operate shutters and blinds. Additionally you can operate sliding doors with this configuration. Servo Motor Support ~ Servos are small devices with typical 180\u00b0 or 360\" rotation movement. The position will be drived by the PWM duty cycle time. This will all automatically calculated Smooth RAMP-UP and RAMP-DOWN Support ~ Servos and Steppers also have a velocity control. With ShutterMotorDelay<x> 1.5 you can define a 1.5second soft start/stop before the device reaches it final moving speed. Usefull for moving heavy items like doors. using Pulse Motors ~ Normal wire configuration with a PCF as digital I/O Short Circuit safe wire configuration with a PCF as digital I/O using Stepper Motors ~ Stepper motors can be used to operate shutters and blinds. The configuration is very similar to the Circuit Safe (Shuttermode 1) configuration. To operate a stepper motor requires driver module such as the A4988 and uses EN (enable), DIR (direction), STP (Stepper) for controls. If everything is defined correctly Shuttermode 3 will be reported at boot time. Tasmota supports a maximum of four shutters with one stepper motor per shutter simultaneously. In very rare conditions where two or more shutters simultaneously move the last mm it can happen than one shutter moves to far. Stepper drivers configuration tutorials: A4988 DRV8825 TMC2208 Modifying a 28BYJ-48 12V stepper motor from unipolar to bipolar tutorial Bill of Materials Example configuration EN and DIR are on Relay1i and Relay2 respectively. Please be aware to use the inverse relay for the enable signal. The STP signal is assigned as a PWM<x> component where <x> matches the number of the shutter (e.g., PWM1 for Shutter1 ). The shutter feature adjusts the PWM frequency to operate the motor for proper shutter operation. The stepper motor frequency setting is a global setting all PWM components on the device. This means that all shutters on the device will operate at the same speed. Therefore no PWM devices other than shutters can be connected to the same Tasmota device. The frequency of the PWM can be changed from 1000Hz to any value up to 10,000Hz. The command ShutterFrequency globally changes this. Be aware that most 12V operated motors cannot work faster than 2,000Hz. 5,000Hz.10,000Hz is possible by increasing the supplied voltage to 24V and use ShutterMotorDelay to allow a slow speed up/speed down. The maximum voltage of the A4988 is 36V. The TMC2208 is much more silent than the others but also significant slower and does not like high frequencies. For example, the speed at 24V is half o A4988 Finally a GPIO must be assigned as Counter1 . This counter is used to keep track of the steps and send the stepper to the correct position. The Counter1 GPIO must be connected to the PWM1 GPIO. Otherwise the stepper and your shutter will run continually or freeze up randomly. Only bipolar stepper motors may be used (see above). You must properly configure the stepper motor driver (see above). ShutterOpenDuration and ShutterCloseDuration can be different. Shutter with Stepper motors always match positions exact. There is no need to vary ShutterOpenDuration and ShutterCloseDuration . Anyhow, if you decrease ShutterCloseDuration the Shutter will close with a higher speed on a virtual higher ShutterFrequency if possible. Same vice versa. You can define a soft start/stop by defining a ShutterMotorDelay . This causes the driver to ramp the speed up and down during the defined duration. The change of the ShutterMotorDelay does NOT change the distance the shutter makes. This is very convenient to trim the accelerate and decelerate rate without changing the distance. Wemos Pin GPIO Component Stepper Signal D1 5 Relay1i EN D2 4 Relay2 DIR D3 0 PWM1 STP D4 2 Counter1 STP a) Set ShutterMode 3 Backlog PulseTime1 0; PulseTime2 0 // for relay Relay1i and Relay2 Interlock OFF // this is a global variable for all Relays or at least the RELAYS NOT in the Interlock group PWM1 and COUNTER1 defined b) Enable Shutters SetOption80 1 // this is a global variable for all Shutters c) Configure Shutter 1 and test ShutterMode 1 is working ShutterRelay1 1 // for relay Relay1i and Relay2 d) Set the stepper motor speed (optional setting) ShutterFrequency 1500 // this is a global variable for all steppers (1000rpm by default) e) Set at least a small ramp-up/ramp down period 1.0 second (optional) ShutterMotorDelay1 1.0 // Stepper do not like infinite momentum. Ramp up/down speed allow much higher frequencies. f) Restart Tasmota Restart 1 g) Test the shutter ShutterOpen1 ShutterStop1 // to stop the STEPPER1 ShutterClose1 ShutterInvert1 // to change the direction of rotation of the STEPPER1 h) Perform the shutter calibration Configuration for additional shutters You must first set up the first shutter and only then the next. Wemos Pin GPIO Component Stepper Signal D5 14 Relay3i EN D6 12 Relay4 DIR D7 13 PWM2 STP D8 15 Counter2 STP a) Set ShutterMode 3 Backlog PulseTime3 0; PulseTime4 0 // for relay Relay3i and Relay4 PWM2 and COUNTER2 defined c) Configure Shutter 2 and test ShutterMode 1 is working ShutterRelay2 3 // for relay Relay3i and Relay4 b) Restart Tasmota Restart 1 d) Test the shutter ShutterOpen2 ShutterStop2 // to stop the STEPPER2 ShutterClose2 ShutterInvert2 // to change the direction of rotation of the STEPPER2 e) Perform the shutter calibration Motor Wiring Diagrams One Shutter - Diagram v412: simple universal setup. For example, the control of horizontal curtain or vertical shutters, blinds adjuster or window opener, pet feeders, opening of a water tap for watering the lawn, rotating table for subject photography, opening the ventilation flap, PTZ camera, 3D Scanner Table, linear Actuator. - Diagram v414: parallel setup is to run two parallel steppers motors from the same controller. For example, to control a large and heavy hanging screen for an LCD projector, or two curtains at once on one large window. - Diagram v416: minimum setup size. For example, for small curtains located in a limited space. 2 Shutters - Diagram v422: parallel setup is to run two shutters and independent control of two stepper motors from one controller. For example, to control two independent curtains. - Diagram v424: big parallel setup is to run two shutters and independent control of two pairs of stepper motors from one controller. For example, to control four curtains on one very large window. Bill of Materials ESP8266 Boards: Wemos D1 mini NodeMCU ESP-01S Stepper motors (NEMA 17): Standard 5:1 Planetary Gearbox Stepper motors (28BYJ-48): Standard Stepper Drivers: A4988 DRV8825 TMC 2208 Stepper Motor Control Development Boards: x1 board x2 board DC-DC Step Down Power Supply Module: MP1584EN LM2596 XL4015 Power Supplies (AC-DC): DC 12V 2.5A DC 12V 4A DC 24v 4A Aluminum Capacitors: 35V 100UF 35V 10UF Motor Testing PWM Signal Generator: 1 type 2 type using Sonoff Dual R2 ~ If using a Sonoff Dual R2, use the following Template: {\"NAME\":\"Sonoff Dual R2\",\"GPIO\":[17,255,0,255,0,22,18,0,21,56,0,0,0],\"FLAG\":0,\"BASE\":39} Checklist Ensure that the first relay opens the shutter Ensure that the second relay closes the shutter Set ShutterRelay<x> Set ShutterOpenDuration<x> Set ShutterCloseDuration<x> Set ShutterSetHalfway<x> (optional) Set ShutterInvert<x> (optional) Set ShutterInvertWebButtons<x> (optional) (eg. useful for horizontal awnings) If the shutter uses a pulse motor instead of a motors with one wire for each direction (i.e., duration based), define PulseTime<x> 2 on both relays. The driver's behavior will change to a pulse motor that needs pulses to start and stop. Rules Tasmota rule triggers: Shutter<x>#Position is triggered at start, during and at the end of movement reporting actual position ( %value% =0-100) Shutter<x>#Direction is triggered at start, during and at the end of movement reporting actual direction ( %value% : -1 =close direction, 0 =no movement, 1 =open direction) Shutter<x>#Target is triggered at start, during and at the end of movement reporting current target ( %value% 0-100) Shutter#Moving is triggered during movement and just before moving (shutter independently). If VAR<x> is set to 99 then this trigger will be executed BEFORE the shutter starts. You can start the shutter after rule execution by setting VAR<x> to 0 or wait 10seconds before the timeout kicks in. After the movement with shutter#moved the VAR must be set back to 99 and the initial rule must be enabled again. The initial rule has to be defined to run ONCE. EXAMPLE: power3 on and wait 2sec before start. After movement: power off rule1 on shutter#moving=1 do backlog power3 on;delay 20;var1 0 endon rule1 5 rule2 on shutter#moved do backlog power3 off;var1 99;rule1 5 endon rule2 1 Shutter#Moved is triggered at end of movement (shutter independently) Shutter<x>#Button<button>=0 is triggered when button is hold Shutter<x>#Button<button>=<n> is triggered when button is pressed n times Shutter<x>#Button0=0 is triggered when all buttons of that shutter are hold simultaneously Shutter<x>#Button0=<n> is triggered when all buttons of that shutter are pressed simultaneously n times Examples Publish a message with the position of the shutter: Rule1 ON Shutter1#Position DO Publish status/%topic%/level {\"%value%\"} ENDON Open/Close or set a specific position for a shutter. This example drives the second shutter to the same position as the first shutter: Rule1 ON Shutter1#Position DO ShutterPosition2 %value%\" ENDON Jarolift Shutter Support ~ Jarolift shutters operates by the 3 commands up/stop/down. Compile with the KeeLoq Option and provide the extracted master keys to communicate. Please see KeeLoq description how to do that. After this create a rule to allow the shutter to control the Jarolift devices. Shutter must be in ShutterMode 0. Rule1 On Power1#state=0 DO KeeloqSendButton 4 endon On Power2#state=0 DO KeeloqSendButton 4 endon on Power1#state=1 DO KeeloqSendButton 8 endon on Power2#State=1 DO KeeloqSendButton 2 endon Venetian Blind Support ~ A 2nd shutter can be configured to support the adjustment of the horizontal tilt. After movement the tilt will be restored if blind is not fully opened or closed via an additional rule. Custom build with following options is needed: #define USE_EXPRESSION #define SUPPORT_IF_STATEMENT Configuration of 2nd shutter: ShutterRelay2 1 // setup 2nd shutter at same relay as shutter 1 ShutterOpenDuration2 1.4 // adjust to real duration ShutterCloseDuration2 1.4 // adjust to real duration Add rule (requires rules with Conditional Rules enabled : Rule1 on Shutter2 #Position DO mem1 %value% ENDON on Shutter1#Position DO var2 %value% ENDON on Shutter1#Direction!=0 DO var1 %value% ENDON on Shutter1#Direction=0 DO IF (var1==1) var1 0; IF (var2!=100) ShutterSetOpen2; shutterposition2 %mem1% ENDIF ENDIF ENDON on Shutter1#Direction=0 DO IF (var1==-1) var1 0; IF (var2!=0) ShutterSetClose2; shutterposition2 %mem1% ENDIF ENDIF ENDON","title":"Shutters and Blinds"},{"location":"Blinds-and-Shutters/#shutters-and-blinds","text":"Control blinds and roller shades connected to regular ON/OFF motors or stepper motors Only available in normal Tasmota.bin! Before starting you have to enable shutter support with SetOption80 1","title":"Shutters and Blinds"},{"location":"Blinds-and-Shutters/#commands","text":"Complete list of commands is available at Blinds, Shutters and Roller Shades Commands .","title":"Commands"},{"location":"Blinds-and-Shutters/#shutter-modes","text":"There are five shutter modes which define how the relays operate. Additionally you can define PulseTime on any relay to change the relay into a pulse relay where the pulse changes start/stop. We recommend at least for Shutter mode 1 to define an Interlock setting. The examples below are for a ShutterRelay1 1 configuration (using Relay1 and Relay2). Shutter mode 1 - Normal Operation First relay: OFF/DOWN, Second relay: OFF/UP Interlock 1,2 (Interlocked relay pair) Interlock ON Shutter mode 2 - Circuit Safe First relay: ON/OFF, Second relay: UP/DOWN Interlock OFF Shutter mode 3 - Garage Motors First relay: OFF/DOWN PULSE, Second relay: OFF/UP PULSE Shutter mode 4 - Stepper Motors First relay: ON/OFF, Second relay: UP/DOWN PWM: Stepper signal, COUNTER: Stepper position signal PWM and COUNTER defined Shutter mode 5 - Servo Motors (PWM position based servo) First relay: ON/OFF, Second relay: UP/DOWN (optional not used) PWM: Stepper signal PWMfrequency 200 ( This is mandatory for most relay to get correct PWM duty cylces) SetOption15 0 (required to store value and make it reboot save) Wiring diagrams for Normal, Stepper motor, and Short Circuit-Safe configurations are available at the end of this page. Even if the shutter does not have two motors, three wires have to be connected. Note After setting the options for shutter mode, the device must be rebooted. Otherwise, the sliders won't be available in the web UI, and the ShutterOpenDuration<x> and ShutterCloseDuration<x> commands will report \"Shutter unknown\". Issue ShutterRelay<x> 1 command and check in console which ShutterMode is displayed: Issue Status 13 command and check in console how the shutter is defined Shutter accuracy digits : 1 Shutter 0 ( Relay : 1 ) : Init . Pos : 20000 [ 100 % ] , Open Vel . : 100 Close Vel . : 100 , Max Way : 20000 , Opentime 10.0 [ s ] , Closetime 10.0 [ s ] , CoedffCalc : c0 : 0 , c1 200 , c2 : 200 , c3 : 0 , c4 : 0 , binmask 3 , is inverted 1 , < span style = \"font-weight:bold;color:lime\" > ShutterMode 0 </ span > , motordelay 0","title":"Shutter Modes"},{"location":"Blinds-and-Shutters/#operation","text":"Turning a device relay on or off directly (i.e., using Power ) will function to affect a shutter's movement. In momentary mode (i.e., stepper motor), the relays start or stop the motor. The driver takes care of the direction and proper update of the shutter position. The shutter reports its position and can also be sent to a dedicated position. ShutterPosition 0 means the shutter is closed and ShutterPosition 100 means the shutter is open. If you need the position values reversed ( 0 = open, 100 = closed), define and calibrate your shutter as documented below . Then tell Tasmota to reverse the shutter position meaning via the ShutterInvert<x> 1 command. All internal calculations are the same (the log output is the same). Only the interaction with the user and other systems changes. Now ShutterPosition<x> 0 will open the shutter and ShutterPosition<x> 100 will close the shutter. By default, only Shutter1 is enabled when SetOption80 1 is invoked. A maximum of four shutters per device are supported. To enable additional shutters, ShutterRelay<x> <value> must be executed for each additional shutter. Additional shutter declarations must be sequentially numbered, and without gaps (i.e., second shutter is 2, next shutter 3 and finally shutter 4). Disabling a shutter in the middle of the defined set of shutters will disable all other higher numbered shutters. If the disabled shutter is restored, the higher numbered shutters previously declared will also be restored. When a shutter is added or removed, a list of the active shutters, with their parameters, is output to the log. If you intend to remove shutters, explicitly remove each one beginning with the highest numbered shutter. With four shutters, eight Relay<x> components are needed. If manual operation switches ( Switch<x> or Button<x> pairs) are also used, additional input GPIO are required. The ESP82xx device may not have enough free GPIO to support all the shutter connections required. A GPIO expander such as a PCF8574 or MCP230xx can be used with additional effort. Using manual operation Switch<x> pairs may require setting SwitchMode<x> 4 (inverse follow) for proper switch behavior. Any shutter positioning can be locked ShutterLock<x> 1 . Once executed an ongoing movement is finished while further positioning commands like ShutterOpen<x> , ShutterClose<x> , ShutterStop<x> , ShutterPosition<x> , ... as well as web UI buttons, web UI sliders, and shutter buttons are disabled. This can be used to lock an outdoor blind in case of high wind or rain. You may also disable shutter positioning games by your children. Shutter positioning can be unlocked using ShutterLock<x> 0 . Please be aware that the shutter can still be moved by direct relay control (i.e., Power<x> ), or physical switches and buttons. Use the ShutterButton<x> command prior to ShutterLock to be able to lock buttons.","title":"Operation"},{"location":"Blinds-and-Shutters/#calibration","text":"Shutter calibration video tutorial Start your shutter in a closed position preferably. Set internal position to closed with ShutterSetClose<x> . Set the time needed to open the shutter completely with ShutterOpenDuration<x> . If the shutter opens more than needed, move it to the desired position with ShutterSetPosition<x> then set the position to fully open (100) with ShutterSetOpen<x> and decrease the open time. Set the time needed to close the shutters with ShutterCloseDuration<x> . If the shutter does not close completely, open again and adjust close time. If it runs too long, move it back to desired closed position with ShutterSetPosition<x> , reset to 0 with ShutterSetClose<x> and decrease open time. Alternate between opening and closing the shutter until you find out the exact times needed to get the same positions multiple times Now set the 50% open position of the shutter. Some shutters need some time from totally closed until they begin moving the bottom-most part and opening. This often results in a shutter that is less than 50% open when the shutter has been operating for 50% of the set time. This can be corrected by using ShutterSetHalfway<x> . Use this procedure to calibrate the half-open position: ShutterClose<x> (confirm that the shutter is completely closed) ShutterSetHalfway<x> 50 (reset to default) Move the shutter to actual 50% open position. Use ShutterPosition<x> to inquire the shutter's current position and record the value. This value is a percentage of the total opening (e.g., 63 = 63% of opening). ShutterClose<x> ShutterSetHalfway<x> 63 (using the value from step #4 above) Restart 1 After calibration is complete, you might want to enable an additional 1 second motor movement with ShutterEnableEndStopTime<x> 1 when the shutter is asked to move to its end positions (0% and 100%). With this you can guarantee that end positions are still reached in case of inaccuracies. Take care to disable this with ShutterEnableEndStopTime<x> 0 before further open or close duration measurements.","title":"Calibration"},{"location":"Blinds-and-Shutters/#motor-movement-delays","text":"Some motors need up to one second after power is turned on before they start moving. You can confirm if you are having this issue if opening and closing as a single action works properly but doing this in smaller steps result in a shift of the position. Shutterposition<x> 30 Measure the shutter position. This is the reference_position Shutterposition<x> 80 Measure the shutter position. This is the max_position Shutterposition<x> 30 Return the shutter to starting position. This must be the same position as measured in step #1 ( reference_position ). If not, ShutterCloseDuration must be adjusted. Shutterposition<x> 50 Shutterposition<x> 70 Shutterposition<x> 80 If you do not reach max_position you have a motor delay problem. Measure the shutter position. This is the real_max . Use this value in the calculation below. ShutterMotorDelay<x> <delay> Motor <delay> calculation - fine tune in 0.05 second increments (e.g. 0.65 ) as required. <delay> = ((max_position-real_max) / 2) / (((100/80) * max_position) / ShutterOpenDuration) Close the shutter and repeat this procedure until the motor delay is set properly.","title":"Motor Movement Delays"},{"location":"Blinds-and-Shutters/#button-control","text":"When shutter is running in default ShutterMode 0 , you already have basic control over the shutter movement using switches or buttons in the module configuration to directly drive the shutter relays. For short circuit safe operation ShutterMode 1 direct control of the relays will not give you a nice user interface since you have to 1st set the direction with one switch or button and 2nd switch on the power by the other switch or button. To have shutter mode independent button control over the shutter and not over its relays one can use the ShutterButton<x> command. It also introduces some more features, see below: ShutterButton<x> <button> <func> <mqtt> This assigns a Tasmota button <button> to control your shutter <x> having functionality <func> . The Tasmota button <button> must already be configured in the module configuration. You can assign multiple buttons to a single shutter. Any button can only control one shutter (beside the <mqtt> broadcast feature, see description below). Any press of the button while the shutter is moving will immediately stop the shutter. One can remove all button control for shutter <x> by ShutterButton<x> 0 . The assigned button can have one of the following functionalities: Setup for an \"up\" button: ShutterButton<x> <button> up <mqtt> Single press will move shutter to 100%, double press to 50% and tripple press to 74%. Holding the button for more than the hold time ( SetOption32 ) moves all shutters with same <grouptopic> to 100% when <mqtt> is equal to 1 . When <mqtt> is equal to 0 hold action of this button is same as single press. Setup for a \"down\" button: ShutterButton<x> <button> down <mqtt> Single press will move shutter to 0%, double press to 50% and triple press to 24%. Holding the button for more than the hold time (SetOption32) moves all shutters with same <grouptopic> to 0% when <mqtt> is equal to 1 . When <mqtt> is equal to 0 hold action of this button is same as single press. Setup for an \"updown\" button: ShutterButton<x> <button> updown <mqtt> Single press will move shutter to 100%, double press down to 0% and triple press to 50%. No hold action and no other shutter control by MQTT, <mqtt> is don't care here. Setup for an \"toggle\" button: ShutterButton<x> <button> toggle <mqtt> Single press will toggle shutter, double press will move it to 50%. No hold action and no other shutter control by MQTT, <mqtt> is don't care here. More advanced control of the button press actions is given by the following ShutterButton<x> command syntax: ShutterButton<x> <button> <p1> <p2> <p3> <ph> <m1> <m2> <m3> <mh> <mi> <button> 1..4 : Button number, 0/- : disable buttons for this shutter <p1> 0..100 : single press position, t : toggle, - : disable <p2> 0..100 : double press position, t : toggle, - : disable <p3> 0..100 : tripple press position, t : toggle, - : disable <ph> 0..100 : hold press position, t : toggle, - : disable <m1> 1 : enable single press position MQTT broadcast, 0/- : disable <m2> 1 : enable double press position MQTT broadcast, 0/- : disable <m3> 1 : enable tripple press position MQTT broadcast, 0/- : disable <mh> 1 : enable hold press position MQTT broadcast, 0/- : disable <mi> 1 : enable MQTT broadcast to all shutter indices, 0/- : disable Parameters are optional. When missing, all subsequent parameters are set to disable . By a button single press the shutter is set to position <p1> . Double press will drive the shutter to position <p2> and triple press to position <p3> . Holding the button for more than the SetOption32 time sets the shutter position to <ph> . Any button action <p1> to <ph> can be disabled by setting the parameter to - . Independent from configuration <p1> to <ph> any press of the button while the shutter is moving will immediately stop the shutter. Global steering of all your shutters at home is supported by additional MQTT broadcast. By any button action a corresponding MQTT command can be initiated to the <grouptopic> of the device. For single press this can be enabled by <m1> equal to 1 , disabling is indicated by - . Double to hold MQTT configurations are given by <m2> to <mh> , correspondingly. When <mi> is equal to - only cmnd/<grouptopic>/Shutterposition<x> <p1..h> is fired. When <mi> is equal to 1 , <x> = 1..4 is used to control any shutter number of a Tasmota device having same <grouptopic> . Example ShutterButton<x> <button> 100 50 74 100 0 0 0 1 1 is same as ShutterButton<x> <button> up 1 . ShutterButton<x> <button> 0 50 24 0 0 0 0 1 1 is same as ShutterButton<x> <button> down 1 . ShutterButton<x> <button> 100 0 50 - 0 0 0 0 0 is same as ShutterButton<x> <button> updown 0 . ShutterButton<x> <button> t 50 - - 0 0 0 0 0 is same as ShutterButton<x> <button> toggle 0 . Module WiFi setup, restart, upgrade and reset according to Buttons and Switches are supported \"child and fool proof\" only when no button restriction ( SetOption1 ) is given and when all configured shutter buttons of that shutter are pressed 5x, 6x, 7x times or hold long simultaneously.","title":"Button Control"},{"location":"Blinds-and-Shutters/#remote-control","text":"Use any other Tasmota device with buttons or switches to control remotely a shutter using rules. Similar behavior as direct button control can be achieved by applying ShutterStopClose, ShutterStopOpen, ShutterStopToggle, ShutterStopPosition commands. They stop shutter movement if it is in motion and otherwise execute close, open, toggle or position commands. Example Run this rule on another Tasmota device with a switch configured. rule1 on switch1#state=2 do publish cmnd/%shutter-topic%/ShutterStopToggle endon","title":"Remote Control"},{"location":"Blinds-and-Shutters/#specific-configuration","text":"","title":"Specific Configuration"},{"location":"Blinds-and-Shutters/#pulse-motor-support","text":"There are shutters that have two relays but only need a pulse to start or stop. Depending on the current situation a pulse will stop the shutter or send it into a specific direction. To use these kinds of shutters a PulseTime must be defined on each relay. The minimum setting that seems to make it work consistently is 2 . A setting of 1 does not work. If the shutter moves too fast and does not react to a stop command, increase the setting to 3 or 4 .","title":"Pulse Motor Support"},{"location":"Blinds-and-Shutters/#stepper-motor-support","text":"Stepper motors can also be used to operate shutters and blinds. Additionally you can operate sliding doors with this configuration.","title":"Stepper Motor Support"},{"location":"Blinds-and-Shutters/#servo-motor-support","text":"Servos are small devices with typical 180\u00b0 or 360\" rotation movement. The position will be drived by the PWM duty cycle time. This will all automatically calculated","title":"Servo Motor Support"},{"location":"Blinds-and-Shutters/#smooth-ramp-up-and-ramp-down-support","text":"Servos and Steppers also have a velocity control. With ShutterMotorDelay<x> 1.5 you can define a 1.5second soft start/stop before the device reaches it final moving speed. Usefull for moving heavy items like doors.","title":"Smooth RAMP-UP and RAMP-DOWN Support"},{"location":"Blinds-and-Shutters/#using-pulse-motors","text":"","title":"using Pulse Motors"},{"location":"Blinds-and-Shutters/#using-stepper-motors","text":"Stepper motors can be used to operate shutters and blinds. The configuration is very similar to the Circuit Safe (Shuttermode 1) configuration. To operate a stepper motor requires driver module such as the A4988 and uses EN (enable), DIR (direction), STP (Stepper) for controls. If everything is defined correctly Shuttermode 3 will be reported at boot time. Tasmota supports a maximum of four shutters with one stepper motor per shutter simultaneously. In very rare conditions where two or more shutters simultaneously move the last mm it can happen than one shutter moves to far. Stepper drivers configuration tutorials: A4988 DRV8825 TMC2208 Modifying a 28BYJ-48 12V stepper motor from unipolar to bipolar tutorial Bill of Materials","title":"using Stepper Motors"},{"location":"Blinds-and-Shutters/#using-sonoff-dual-r2","text":"If using a Sonoff Dual R2, use the following Template: {\"NAME\":\"Sonoff Dual R2\",\"GPIO\":[17,255,0,255,0,22,18,0,21,56,0,0,0],\"FLAG\":0,\"BASE\":39}","title":"using Sonoff Dual R2"},{"location":"Blinds-and-Shutters/#jarolift-shutter-support","text":"Jarolift shutters operates by the 3 commands up/stop/down. Compile with the KeeLoq Option and provide the extracted master keys to communicate. Please see KeeLoq description how to do that. After this create a rule to allow the shutter to control the Jarolift devices. Shutter must be in ShutterMode 0. Rule1 On Power1#state=0 DO KeeloqSendButton 4 endon On Power2#state=0 DO KeeloqSendButton 4 endon on Power1#state=1 DO KeeloqSendButton 8 endon on Power2#State=1 DO KeeloqSendButton 2 endon","title":"Jarolift Shutter Support"},{"location":"Blinds-and-Shutters/#venetian-blind-support","text":"A 2nd shutter can be configured to support the adjustment of the horizontal tilt. After movement the tilt will be restored if blind is not fully opened or closed via an additional rule. Custom build with following options is needed: #define USE_EXPRESSION #define SUPPORT_IF_STATEMENT Configuration of 2nd shutter: ShutterRelay2 1 // setup 2nd shutter at same relay as shutter 1 ShutterOpenDuration2 1.4 // adjust to real duration ShutterCloseDuration2 1.4 // adjust to real duration Add rule (requires rules with Conditional Rules enabled : Rule1 on Shutter2 #Position DO mem1 %value% ENDON on Shutter1#Position DO var2 %value% ENDON on Shutter1#Direction!=0 DO var1 %value% ENDON on Shutter1#Direction=0 DO IF (var1==1) var1 0; IF (var2!=100) ShutterSetOpen2; shutterposition2 %mem1% ENDIF ENDIF ENDON on Shutter1#Direction=0 DO IF (var1==-1) var1 0; IF (var2!=0) ShutterSetClose2; shutterposition2 %mem1% ENDIF ENDIF ENDON","title":"Venetian Blind Support"},{"location":"Builds/","text":"There are many available features programmed into Tasmota. Not all devices need all of the available features. ESP based devices have a limited amount of memory available. To ensure that there is enough memory available to flash the firmware, it is best to keep the total size as small as possible, and definitely under 625K total to ensure OTA updates are possible. For this reason, Tasmota makes available the ability to create different firmware binary files to suit each particular device's requirements (e.g., sensors) and each application's needs (e.g., Rules, Timers, etc.). Once features such as support for sensors, rules, timers, etc. is compiled into the firmware binary, the features themselves can be configured at run-time, or, for some features, configured at compile time as well. Many times one just needs to download a pre-compiled binary and perform the necessary run-time configuration. It is not necessary to compile your own binary if these pre-compiled builds meet your needs. These available files provide a simpler approach to get up and going with Tasmota quickly. The binary files available on GitHub are for the current master release version only. These master release binaries are also available from the OTA server . However, the latest development branch code binaries are only available from the development OTA server . Features that are not available in any official release build have to be enabled in source code and compiled yourself. Read more about compiling your own build . Tip You might find some of the features you need included in one of our unofficial experimental builds over at https://github.com/tasmota/binaries . Firmware Variants ~ tasmota.bin supports most features. THIS IS THE RECOMMENDED BINARY tasmota-BG.bin to tasmota-TW.bin the same features as tasmota.bin with localized language support. (Note: tasmota-UK.bin is for the Ukrainian language) tasmota-sensors.bin enables many features as tasmota.bin - not all - and includes support for connectable sensors tasmota-lite.bin has a stripped down feature set. This reduces the required CPU cycles in order to reduce power draw to allow devices with a weak power supply to run reliably. Note This is similar to the pre-compiled Tasmota binary that comes bundled with Tuya-Convert. If you used Tuya-Convert to flash your device, it is strongly recommended to update to tasmota.bin . Otherwise some crucial features (e.g., energy monitoring, auto-discovery, etc.) will not work. tasmota-minimal.bin is a specialised build to subsequently allow OTA uploads. This version should NOT be used for initial installation! tasmota-knx.bin includes KNX support but omits some features. If you need additional features, compile your own firmware (e.g., Gitpod ). tasmota-display.bin built for connecting displays but omits some features such as energy monitoring. If you need additional features, compile your own firmware (e.g., Gitpod ). tasmota-ir.bin provides almost all IRremoteESP8266 protocols. If you need additional features, compile your own firmware (e.g., Gitpod ) to compile ircustom . tasmota-zbbridge.bin built speciically for Sonoff Zigbee Bridge device. Available Features and Sensors ~ List of all included or excluded features is maintained in BUILDS.md at the Tasmota GitHub","title":"Builds"},{"location":"Builds/#firmware-variants","text":"tasmota.bin supports most features. THIS IS THE RECOMMENDED BINARY tasmota-BG.bin to tasmota-TW.bin the same features as tasmota.bin with localized language support. (Note: tasmota-UK.bin is for the Ukrainian language) tasmota-sensors.bin enables many features as tasmota.bin - not all - and includes support for connectable sensors tasmota-lite.bin has a stripped down feature set. This reduces the required CPU cycles in order to reduce power draw to allow devices with a weak power supply to run reliably. Note This is similar to the pre-compiled Tasmota binary that comes bundled with Tuya-Convert. If you used Tuya-Convert to flash your device, it is strongly recommended to update to tasmota.bin . Otherwise some crucial features (e.g., energy monitoring, auto-discovery, etc.) will not work. tasmota-minimal.bin is a specialised build to subsequently allow OTA uploads. This version should NOT be used for initial installation! tasmota-knx.bin includes KNX support but omits some features. If you need additional features, compile your own firmware (e.g., Gitpod ). tasmota-display.bin built for connecting displays but omits some features such as energy monitoring. If you need additional features, compile your own firmware (e.g., Gitpod ). tasmota-ir.bin provides almost all IRremoteESP8266 protocols. If you need additional features, compile your own firmware (e.g., Gitpod ) to compile ircustom . tasmota-zbbridge.bin built speciically for Sonoff Zigbee Bridge device.","title":"Firmware Variants"},{"location":"Builds/#available-features-and-sensors","text":"List of all included or excluded features is maintained in BUILDS.md at the Tasmota GitHub","title":"Available Features and Sensors"},{"location":"Buttons-and-Switches/","text":"Buttons and switches: why the difference and how to configure them A typical device usually has at least one button (exception being bulbs and some lights) to control the power state(s). Additional buttons and switches can be wired to a free GPIO and configured in Module or Template settings. Note Other than relays/lights, Tasmota does not publish the state of components (switches, buttons, sensors, etc.) in real-time. State of components is transmitted automatically each TelePeriod via the SENSORS message. Button vs. Switch ~ A button (also called a push-button) is a momentary or non-latching switch which causes a temporary change in the state of an electrical circuit only while the switch is pressed. An automatic mechanism (i.e. a spring) returns the switch to its default position immediately afterwards, restoring the initial circuit condition. A switch (more precisely a latching or toggle switch), when activated by the user, remains in that state until activated again. Learn more about buttons and switches in this video . Both have a similar function, but Tasmota distinguishes between a \"Button\" and a \"Switch\" in other ways. Switch ~ In Tasmota a Switch is any switch or push-button additionally connected to a free GPIO. Some possibilities include: mechanical toggle switch - also called a rocker switch capacitive touch switch reed switch PIR sensor - even though it's technically a sensor it is configured as a switch in Tasmota mechanical push-button By default a switch toggles the corresponding power state (f.e. Switch1 controls Power1 ). Every time the switch gets flipped the power state of the relay toggles. To detach switches Warning If you define a switch with a number higher than available power outputs it will default to controlling Power1 . Example: Switch4 on a device with Power1 and Power2 will control Power1 . And now, to make everything completely confusing: A push-button can be configured as a Switch and a toggle switch can be configured as a Button . Configuring a toggle switch as a Button is not recommended! SwitchMode ~ To change the behavior of a physical input peripheral configured as a Tasmota Switch<x> component, whether a toggle switch or a momentary switch (i.e., a push-button), use the SwitchMode command. If there is more than one Switch<x> component, use SwitchMode<x> where <x> is the number of your switch from the Tasmota GPIO configuration. SwitchMode, as the name implies, applies ONLY to GPIO configured in Tasmota as a Switch<x> component . SwitchMode has NO impact on the behavior of GPIO configured as Button<x> components . SwitchMode sets the desired behavior of a Switch<x> component based on whether it's a switch or a push-button (i.e., a momentary switch) that is physically connected to the GPIO. SwitchMode 0 Default mode Set switch to toggle mode ( 0 = TOGGLE , 1 = TOGGLE ). Tasmota sends TOGGLE command each time the state of the circuit changes (closing or opening). In case of a push button attached Tasmota will send a TOGGLE command when pressed and another TOGGLE command when released. Example When the button is pressed, toggle the power to ring the doorbell; when the button is released, ring the doorbell again. SwitchMode 1 Set switch to follow mode ( 0 = OFF , 1 = ON ) At the time when the circuit is closed, Tasmota will send ON and opening the circuit sends OFF . Tip You want to use SwitchMode 1 when connecting a toggle switch (e.g. a classic light switch) to your device. This way the \"software switch\" will mirror the state of the \"hardware switch\". If the real switch is in the \"ON\" position, the state in Tasmota is ON as well. SwitchMode 2 Set switch to inverted follow mode ( 0 = ON , 1 = OFF ) At the time when the circuit is closed, Tasmota will send OFF and opening the circuit sends ON . Tip When connecting a momentary switch (i.e., a push-button) you will want to use SwitchMode 3..7 . SwitchMode 3 Set inverted push-button mode ( 0 = OFF ( default ), 1 = TOGGLE ) Tasmota will send a TOGGLE command when the button is pressed (closing the circuit). When the button is released (opening the circuit) nothing will happen. Default state is OFF and when pressed it's ON. (This trigger is known as rising-edge ) SwitchMode 4 Set push-button mode ( 0 = TOGGLE , 1 = ON ( default )) Tasmota will send a TOGGLE command when the button is released (opening the circuit). When pressing the button (closing the circuit) nothing will happen. Default state is ON and when pressed it's OFF. (This trigger is known as falling-edge ) SwitchMode 5 Set push-button with long press mode ( 0 = TOGGLE , 1 = ON ( default ), long press = HOLD ) Tasmota will send a TOGGLE command when the button is released (opening the circuit). When pressing the button (closing the circuit) nothing will happen. Default state is ON and when pressed it's OFF. When held for the time set in SetOption32 ( default = 4s ), Tasmota sends HOLD (use Switch<x>#state=3 in rules). SwitchMode 6 Set inverted push-button with long press mode ( 0 = OFF ( default ), 1 = TOGGLE , long press = HOLD ) Tasmota will send a TOGGLE command when the button pressed (closing the circuit). When the button is released (opening the circuit) nothing will happen. Default state is OFF and when pressed it's ON. When held for the time set in SetOption32 ( default = 4s ), Tasmota sends HOLD (use Switch<x>#state=3 in rules). Long press or hold can be used in conjunction with rules to create additional features or to control another Tasmota device SwitchMode 7 Set toggle push-button mode. Same as SwitchMode 0 . SwitchMode 8 Set switch to multi change toggle mode ( 0 = TOGGLE , 1 = TOGGLE , 2x change = HOLD ). Same as SwitchMode 0 but when the state of the circuit changes within 0.5s twice no TOGGLE commands are send but Tasmota sends HOLD (use Switch<x>#state=3 in rules). Warning When you change switch states fast (within 0.5s) some extra actions can be triggered using rules. ON/OFFpower state is only changed when there is no second switch change within 0.5s. SwitchMode 9 Set switch to multi change follow mode ( 0 = OFF , 1 = ON , 2x change = HOLD ) Same as SwitchMode 1 but when the state of the circuit changes within 0.5s twice no OFF/ON commands are send but Tasmota sends HOLD (use Switch<x>#state=3 in rules). Warning When you change switch states fast (within 0.5s) some extra actions can be triggered using rules. ON/OFFpower state is only changed when there is no second switch change within 0.5s. SwitchMode 10 Set switch to multi change inverted follow mode ( 0 = ON , 1 = OFF , 2x change = HOLD ) Same as SwitchMode 2 but when the state of the circuit changes within 0.5s twice no ON/OFF commands are send but Tasmota sends HOLD (use Switch<x>#state=3 in rules). Warning When you change switch states fast (within 0.5s) some extra actions can be triggered using rules. ON/OFFpower state is only changed when there is no second switch change within 0.5s. SwitchMode 11 Set switch to pushbutton with dimmer mode incl. double press feature Note Setoption32 must be smaller than 64, when you use switchmode 11 and 12 !! Tasmota will send a TOGGLE command when the button is pressed for a short time and then is released (use Switch<x>#state=2 in rules). When pressing the button (closing the circuit) for a long time (set in SetOption32 ), Tasmota will send repeated INC_DEC (increment or decrement the dimmer) commands for as long as the button is pressed (use Switch<x>#state=4 in rules). Two different CLEAR commands are available. An immediate CLEAR command is send upon button release - no delay (use Switch<x>#state=7 in rules). Releasing the button also starts an internal timer (time is set in SetOption32 ). When released for the time set in SetOption32 , Tasmota will send a 'delayed' CLEAR command (use Switch<x>#state=6 in rules). If the button is pressed again before the timeout, Tasmota will send an INV command. The INV command is for the controlling software (Home Assistant) to switch between incrementing and decrementing the dimmer (use Switch<x>#state=5 in rules). If button is pressed twice (within time set in SetOption32 ), Tasmota will send a DOUBLE command. Note that this doesn't change behaviour of other switch states. So along with the DOUBLE command, TOGGLE command will also be fired twice upon a double press (use Switch<x>#state=8 in rules). Tip The dimmer mode has several use cases: In conjunction with rules to create additional features or to control another Tasmota device. In conjunction with ControllerX (HA Appdeamon app) to implement easy toggle and dimming of smart lights, with an 'in wall' hw Tasmota switch. Turn a media player on and off and to control the volume of a media player with one switch. SwitchMode 12 Set switch to inverted pushbutton with dimmer mode incl. double press feature. Same as Switchmode 11 but with inverted behaviour. Note Setoption32 must be smaller than 64, when you use switchmode 11 and 12 !! SwitchMode 13 Set switch to \"push to on\" mode ( 1 = ON , 0 = nothing ) Tasmota will send an ON command when the button pressed (closing the circuit). When the button is released (opening the circuit) nothing will happen. Switch off using PulseTime . SwitchMode 14 Set switch to inverted \"push to on\" mode ( 0 = ON , 1 = nothing ) This mode is useful with PIR sensors SwitchMode 15 Send only MQTT message on switch change Button ~ For Tasmota, a Button is typically a momentary push-button (or a capacitive touch button in some light switches). By default a button toggles the corresponding power state. Every time the button gets pressed a relay or light changes its Power state (ON or OFF). Besides toggling the Power state, a button is also used to activate multi press button functions , to do long press (HOLD) actions, or send messages to different MQTT topics. A push-to-make button should use a Button<x> component while a push-to-break button should use Button<x>i (i.e., inverted). To ignore default button behaviour of controlling power outputs you can: use SetOption73 1 use ButtonTopic define a rule which triggers on Button<x>#State . Take note: If the rule trigger only certain states, default behaviour is supressed only for those states. Make Button1 publish its value to cmnd/custom-topic/BUTTON and not control Power1 Backlog ButtonTopic 0 Rule1 on Button1 # state do Publish cmnd / custom - topic / BUTTON % value % endon Rule1 1 Multi-Press Functions ~ Multipress functions for 2 and more presses cannot be changed using SetOptions or rules. Danger If you have changed ButtonTopic , SetOption1 , SetOption11 or SetOption13 some of the listed functionality will be changed or removed. Note Button1 can directly control up to five relays. The number of the activated relay corresponds to the number of button presses and this feature is not present in the other buttons. When ButtonTopic is set to default 0 a button will always send its state for rules. 1 short press Toggles the power state. This will blink the LED once and send an MQTT status message like stat/tasmota/POWER = ON or another one like stat/tasmota/BUTTON<x> = {\"ACTION\":\"SINGLE\"} when SetOption73 is enabled. The button state for rules is 2 ( 10 if Setoption73 is enabled). 2 short presses When using Button1 toggles the second power state (if available on the device). This will blink the LED twice and send an MQTT status message like stat/tasmota/POWER2 = ON or another one like stat/tasmota/BUTTON<x> = {\"ACTION\":\"DOUBLE\"} when SetOption73 is enabled. The button state for rules is 11 . 3 short presses When using Button1 toggles the third power state (if available on the device). This will blink the LED three times and send an MQTT status message like stat/tasmota/POWER3 = ON or another one like stat/tasmota/BUTTON<x> = {\"ACTION\":\"TRIPLE\"} when SetOption73 is enabled. The button state for rules is 12 . 4 short presses When using Button1 toggles the fourth power state (if available on the device). This will blink the LED for times and send an MQTT status message like stat/tasmota/POWER4 = ON or another one like stat/tasmota/BUTTON<x> = {\"ACTION\":\"QUAD\"} when SetOption73 is enabled. The button state for rules is 13 . 5 short presses When using Button1 toggles the fifth power state (if available on the device). This will blink the LED five times and send an MQTT status message like stat/tasmota/POWER5 = ON or another one like stat/tasmota/BUTTON<x> = {\"ACTION\":\"PENTA\"} when SetOption73 is enabled. The button state for rules is 14 . 6 short presses Start WifiConfig 2 . Can be disabled using SetOption1 1 Long press There are two separate functions associated with a button long press based on how long it is held: When held continuously for 40 seconds (Configurable with SetOption32 , value is 10x the configured hold time) Tasmota will reset to firmware defaults and restart. If enabled, button pressed for 4 seconds (Configurable with SetOption32 ) creates a HOLD action and send an MQTT status message like stat/tasmota/BUTTON<x> = {\"ACTION\":\"HOLD\"} when SetOption73 is enabled. The button state for rules is 3 . If ButtonRetain has been enabled the MQTT message will also contain the MQTT retain flag. Danger When a button is configured as inverted or with a Switchmode that keeps it as ON while depressed it activates the reset to firmware defaults function. Change the Button configuration or SwitchMode to avoid repeated reset to defaults or use Setoption1 1 to disable that function. Warning If you define a button with a number higher than available power outputs it will default to controlling Power1 . Example: Button4 on a device with Power1 and Power2 will control Power1 . ButtonTopic ~ ButtonTopic 0 Default option By default a button controls the corresponding power state and doesn't send any MQTT messages itself. No MQTT message will be published on account of the new button state. The message you see in console is the new power state that is controlled and not the button state. ButtonTopic 1 Sets MQTT button topic to device %topic%. When changing the state of the button an MQTT message is sent to the device topic with the payload according to SwitchMode set. Example Device topic tasmota with SwitchMode 3 yields the following message: MQT: cmnd/tasmota/POWER = ON Notice the cmnd instead of the stat at the beginning. This is the same as sending an MQTT command to this device, the device power state will be set to the defined state. ButtonTopic <value> Set button topic to a custom topic (32 characters max). This will send an MQTT message to a custom defined topic similarly to option 1. Example For example, we set the topic to tasmota02 with ButtonTopic tasmota02 . With SwitchMode 1 the device yields the following message: MQT: cmnd/tasmota02/POWER = TOGGLE If you have another device with the topic tasmota02 this action will toggle its power state while not affecting anything on the tasmota device. ButtonTopic Summary ButtonTopic 0 controls the power state directly. ButtonTopic 1 sends an MQTT message to the device topic. This sets the state of the devices power state accordingly. ButtonTopic <value> sends an MQTT message command to the custom topic. This does not change the state of the devices power state. When a Button is set to a different topic than 0 is not possible to use Button#State as a trigger for rules. Changing Default Functionality ~ If a ButtonTopic (and if SetOption1 1 ) or SwitchTopic 1 is defined (and SwitchMode is set to 5 or 6 ) and a button is pressed longer than defined Key Hold Time ( SetOption32 default 4 seconds) an MQTT message like cmnd/%topic%/POWER HOLD will be sent. HOLD can be changed with StateText4 . Command SetOption11 allows for swapping the functionality between the SINGLE and DOUBLE press of the push button. These changes result in the following: Example You can control a ceiling fan from a Sonoff Touch: If your standard topic of Sonoff Touch is light and the ceiling fan topic is ceilingfan issue these commands on the Sonoff Touch to activate the double press feature. ButtonTopic ceilingfan SetOption11 1 All of the above is easier accomplished using Rules ! AC Frequency Detection Switch ~ Some devices, such as BlitzWolf BW-SS5 or Moes MS-104B , use mains frequency detection on their switch inputs. Whenever the connected switch or button is pressed there are 50/60 Hz pulses on the switch input. Inside the switch there's a frequency detection circuit which is connected to a GPIO of the ESP8266 chip which counts those pulses. Prior to Tasmota 8.4 this kind of switching was handled using Counter sensors and scripting which is now simplified. You can imagine this algorithm as a leaking bucket. Every pulse adds water to the bucket (little more than leaking out in a cycle), but the water is dripping countinously. If the bucket is full, we will treat the switch on. If there's no pulses, the bucket will be empty, and the we will turn off the switch. The size of the bucket is the debouncing time which controls the sensitivity of the algorithm. If the mains frequency is 50 Hz, a whole AC wave is 20 msec long (for 60 Hz it's about 17 msec; 1000 / frequeny if we want the result in milliseconds). The exact frequency is not really important, because we add more water for every pulse. After you have assigned a Switch<x> to the GPIO connected to the AC frequency detection circuit use the 'SwitchDebounce' command to set the number of pulses required for the switch to be recognized as on or off. For example: SwitchDebounce 69 will turn the switch on after three pulses and turn it off after three missing ones (3 * 20 msec is 60 and the last digit must be 9 to activate the AC detection). You will probably have to experiment with the values depending on your AC frequency and the devices frequency detection implementation. Once the feature is enabled you can use this switch as any regular switch! Detach Switches Based On.. ~ SetOption114 ~ Only in Tasmota 9.1+ When SetOption114 1 all switches are detached from their respective relays and will send MQTT messages instead in the form of {\"Switch<x>\":{\"Action\":\"<state>\"}} . Example When switch one is toggle to \"ON\": {\"Switch1\":{\"Action\":\"ON\"}} Rules ~ Use rules to send messages to different MQTT topics or send commands to other Tasmota devices when switch state (defined by SwitchMode ) changes. To ignore the default behaviour define a rule which triggers on Switch<x> for all state changes or on Switch<x>#State for specific state changes. If a rule matches only certain states, default switch behaviour is suppressed only for those states. Example Make Switch1 publish any value change to cmnd/custom-topic/SWITCH1 and not control Power1 Backlog SwitchMode 1 ; SwitchTopic 0 Backlog Rule1 on Switch1 # state do Publish cmnd /% topic %/ SWITCH1 % value % endon ; Rule1 1 SwitchTopic ~ Warning When using SwitchTopic 1 or 2 (or ButtonTopic 1 or 2 ) and your MQTT broker becomes unavailable, Tasmota falls back to default SwitchTopic 0 (or ButtonTopic 0 ), which is not optimal. To avoid this, we recommend using first two options instead. If you still need to use SwitchTopic read on! SwitchTopic 0 Default mode By default a switch controls the corresponding power state and doesn't send any MQTT messages itself. No MQTT message will be published on account of the new switch state. The message you see in console is the new power state that is controlled and not the switch state. SwitchTopic 1 Sets MQTT switch topic to device %topic% When changing the state of the switch an MQTT message is sent to the device topic with the payload according to SwitchMode set. Example Device topic tasmota with SwitchMode 3 yields the following message: MQT: cmnd/tasmota/POWER = TOGGLE Notice the cmnd instead of the stat at the beginning. This is the same as sending an MQTT commands to this device, the device power state will be set to the defined state. SwitchTopic <value> Set switch topic to a custom topic (32 characters max) This will send an MQTT message to a custom defined topic similarly to option 1. In the following example, we set the topic to tasmota02 with SwitchTopic tasmota02 . Example Device topic tasmota with SwitchMode 1 and custom topic tasmota02 yields the following message: MQT: cmnd/tasmota02/POWER = ON If you have another device with the topic tasmota02 this action will turn on its power while not affecting anything on the tasmota device. SwitchTopic Summary SwitchTopic 0 controls the power state directly. SwitchTopic 1 sends an MQTT message to the device topic. This sets the state of the devices power accordingly. SwitchTopic <value> sends an MQTT message command to the custom topic. This does not change the state of the devices power. For a practical application of everything mentioned in this article read about this excellent LEGO nightstand switch project .","title":"Buttons and Switches"},{"location":"Buttons-and-Switches/#button-vs-switch","text":"A button (also called a push-button) is a momentary or non-latching switch which causes a temporary change in the state of an electrical circuit only while the switch is pressed. An automatic mechanism (i.e. a spring) returns the switch to its default position immediately afterwards, restoring the initial circuit condition. A switch (more precisely a latching or toggle switch), when activated by the user, remains in that state until activated again. Learn more about buttons and switches in this video . Both have a similar function, but Tasmota distinguishes between a \"Button\" and a \"Switch\" in other ways.","title":"Button vs. Switch"},{"location":"Buttons-and-Switches/#switch","text":"In Tasmota a Switch is any switch or push-button additionally connected to a free GPIO. Some possibilities include: mechanical toggle switch - also called a rocker switch capacitive touch switch reed switch PIR sensor - even though it's technically a sensor it is configured as a switch in Tasmota mechanical push-button By default a switch toggles the corresponding power state (f.e. Switch1 controls Power1 ). Every time the switch gets flipped the power state of the relay toggles. To detach switches Warning If you define a switch with a number higher than available power outputs it will default to controlling Power1 . Example: Switch4 on a device with Power1 and Power2 will control Power1 . And now, to make everything completely confusing: A push-button can be configured as a Switch and a toggle switch can be configured as a Button . Configuring a toggle switch as a Button is not recommended!","title":"Switch"},{"location":"Buttons-and-Switches/#switchmode","text":"To change the behavior of a physical input peripheral configured as a Tasmota Switch<x> component, whether a toggle switch or a momentary switch (i.e., a push-button), use the SwitchMode command. If there is more than one Switch<x> component, use SwitchMode<x> where <x> is the number of your switch from the Tasmota GPIO configuration. SwitchMode, as the name implies, applies ONLY to GPIO configured in Tasmota as a Switch<x> component . SwitchMode has NO impact on the behavior of GPIO configured as Button<x> components . SwitchMode sets the desired behavior of a Switch<x> component based on whether it's a switch or a push-button (i.e., a momentary switch) that is physically connected to the GPIO. SwitchMode 0 Default mode Set switch to toggle mode ( 0 = TOGGLE , 1 = TOGGLE ). Tasmota sends TOGGLE command each time the state of the circuit changes (closing or opening). In case of a push button attached Tasmota will send a TOGGLE command when pressed and another TOGGLE command when released. Example When the button is pressed, toggle the power to ring the doorbell; when the button is released, ring the doorbell again. SwitchMode 1 Set switch to follow mode ( 0 = OFF , 1 = ON ) At the time when the circuit is closed, Tasmota will send ON and opening the circuit sends OFF . Tip You want to use SwitchMode 1 when connecting a toggle switch (e.g. a classic light switch) to your device. This way the \"software switch\" will mirror the state of the \"hardware switch\". If the real switch is in the \"ON\" position, the state in Tasmota is ON as well. SwitchMode 2 Set switch to inverted follow mode ( 0 = ON , 1 = OFF ) At the time when the circuit is closed, Tasmota will send OFF and opening the circuit sends ON . Tip When connecting a momentary switch (i.e., a push-button) you will want to use SwitchMode 3..7 . SwitchMode 3 Set inverted push-button mode ( 0 = OFF ( default ), 1 = TOGGLE ) Tasmota will send a TOGGLE command when the button is pressed (closing the circuit). When the button is released (opening the circuit) nothing will happen. Default state is OFF and when pressed it's ON. (This trigger is known as rising-edge ) SwitchMode 4 Set push-button mode ( 0 = TOGGLE , 1 = ON ( default )) Tasmota will send a TOGGLE command when the button is released (opening the circuit). When pressing the button (closing the circuit) nothing will happen. Default state is ON and when pressed it's OFF. (This trigger is known as falling-edge ) SwitchMode 5 Set push-button with long press mode ( 0 = TOGGLE , 1 = ON ( default ), long press = HOLD ) Tasmota will send a TOGGLE command when the button is released (opening the circuit). When pressing the button (closing the circuit) nothing will happen. Default state is ON and when pressed it's OFF. When held for the time set in SetOption32 ( default = 4s ), Tasmota sends HOLD (use Switch<x>#state=3 in rules). SwitchMode 6 Set inverted push-button with long press mode ( 0 = OFF ( default ), 1 = TOGGLE , long press = HOLD ) Tasmota will send a TOGGLE command when the button pressed (closing the circuit). When the button is released (opening the circuit) nothing will happen. Default state is OFF and when pressed it's ON. When held for the time set in SetOption32 ( default = 4s ), Tasmota sends HOLD (use Switch<x>#state=3 in rules). Long press or hold can be used in conjunction with rules to create additional features or to control another Tasmota device SwitchMode 7 Set toggle push-button mode. Same as SwitchMode 0 . SwitchMode 8 Set switch to multi change toggle mode ( 0 = TOGGLE , 1 = TOGGLE , 2x change = HOLD ). Same as SwitchMode 0 but when the state of the circuit changes within 0.5s twice no TOGGLE commands are send but Tasmota sends HOLD (use Switch<x>#state=3 in rules). Warning When you change switch states fast (within 0.5s) some extra actions can be triggered using rules. ON/OFFpower state is only changed when there is no second switch change within 0.5s. SwitchMode 9 Set switch to multi change follow mode ( 0 = OFF , 1 = ON , 2x change = HOLD ) Same as SwitchMode 1 but when the state of the circuit changes within 0.5s twice no OFF/ON commands are send but Tasmota sends HOLD (use Switch<x>#state=3 in rules). Warning When you change switch states fast (within 0.5s) some extra actions can be triggered using rules. ON/OFFpower state is only changed when there is no second switch change within 0.5s. SwitchMode 10 Set switch to multi change inverted follow mode ( 0 = ON , 1 = OFF , 2x change = HOLD ) Same as SwitchMode 2 but when the state of the circuit changes within 0.5s twice no ON/OFF commands are send but Tasmota sends HOLD (use Switch<x>#state=3 in rules). Warning When you change switch states fast (within 0.5s) some extra actions can be triggered using rules. ON/OFFpower state is only changed when there is no second switch change within 0.5s. SwitchMode 11 Set switch to pushbutton with dimmer mode incl. double press feature Note Setoption32 must be smaller than 64, when you use switchmode 11 and 12 !! Tasmota will send a TOGGLE command when the button is pressed for a short time and then is released (use Switch<x>#state=2 in rules). When pressing the button (closing the circuit) for a long time (set in SetOption32 ), Tasmota will send repeated INC_DEC (increment or decrement the dimmer) commands for as long as the button is pressed (use Switch<x>#state=4 in rules). Two different CLEAR commands are available. An immediate CLEAR command is send upon button release - no delay (use Switch<x>#state=7 in rules). Releasing the button also starts an internal timer (time is set in SetOption32 ). When released for the time set in SetOption32 , Tasmota will send a 'delayed' CLEAR command (use Switch<x>#state=6 in rules). If the button is pressed again before the timeout, Tasmota will send an INV command. The INV command is for the controlling software (Home Assistant) to switch between incrementing and decrementing the dimmer (use Switch<x>#state=5 in rules). If button is pressed twice (within time set in SetOption32 ), Tasmota will send a DOUBLE command. Note that this doesn't change behaviour of other switch states. So along with the DOUBLE command, TOGGLE command will also be fired twice upon a double press (use Switch<x>#state=8 in rules). Tip The dimmer mode has several use cases: In conjunction with rules to create additional features or to control another Tasmota device. In conjunction with ControllerX (HA Appdeamon app) to implement easy toggle and dimming of smart lights, with an 'in wall' hw Tasmota switch. Turn a media player on and off and to control the volume of a media player with one switch. SwitchMode 12 Set switch to inverted pushbutton with dimmer mode incl. double press feature. Same as Switchmode 11 but with inverted behaviour. Note Setoption32 must be smaller than 64, when you use switchmode 11 and 12 !! SwitchMode 13 Set switch to \"push to on\" mode ( 1 = ON , 0 = nothing ) Tasmota will send an ON command when the button pressed (closing the circuit). When the button is released (opening the circuit) nothing will happen. Switch off using PulseTime . SwitchMode 14 Set switch to inverted \"push to on\" mode ( 0 = ON , 1 = nothing ) This mode is useful with PIR sensors SwitchMode 15 Send only MQTT message on switch change","title":"SwitchMode"},{"location":"Buttons-and-Switches/#button","text":"For Tasmota, a Button is typically a momentary push-button (or a capacitive touch button in some light switches). By default a button toggles the corresponding power state. Every time the button gets pressed a relay or light changes its Power state (ON or OFF). Besides toggling the Power state, a button is also used to activate multi press button functions , to do long press (HOLD) actions, or send messages to different MQTT topics. A push-to-make button should use a Button<x> component while a push-to-break button should use Button<x>i (i.e., inverted). To ignore default button behaviour of controlling power outputs you can: use SetOption73 1 use ButtonTopic define a rule which triggers on Button<x>#State . Take note: If the rule trigger only certain states, default behaviour is supressed only for those states. Make Button1 publish its value to cmnd/custom-topic/BUTTON and not control Power1 Backlog ButtonTopic 0 Rule1 on Button1 # state do Publish cmnd / custom - topic / BUTTON % value % endon Rule1 1","title":"Button"},{"location":"Buttons-and-Switches/#multi-press-functions","text":"Multipress functions for 2 and more presses cannot be changed using SetOptions or rules. Danger If you have changed ButtonTopic , SetOption1 , SetOption11 or SetOption13 some of the listed functionality will be changed or removed. Note Button1 can directly control up to five relays. The number of the activated relay corresponds to the number of button presses and this feature is not present in the other buttons. When ButtonTopic is set to default 0 a button will always send its state for rules.","title":"Multi-Press Functions"},{"location":"Buttons-and-Switches/#buttontopic","text":"ButtonTopic 0 Default option By default a button controls the corresponding power state and doesn't send any MQTT messages itself. No MQTT message will be published on account of the new button state. The message you see in console is the new power state that is controlled and not the button state. ButtonTopic 1 Sets MQTT button topic to device %topic%. When changing the state of the button an MQTT message is sent to the device topic with the payload according to SwitchMode set. Example Device topic tasmota with SwitchMode 3 yields the following message: MQT: cmnd/tasmota/POWER = ON Notice the cmnd instead of the stat at the beginning. This is the same as sending an MQTT command to this device, the device power state will be set to the defined state. ButtonTopic <value> Set button topic to a custom topic (32 characters max). This will send an MQTT message to a custom defined topic similarly to option 1. Example For example, we set the topic to tasmota02 with ButtonTopic tasmota02 . With SwitchMode 1 the device yields the following message: MQT: cmnd/tasmota02/POWER = TOGGLE If you have another device with the topic tasmota02 this action will toggle its power state while not affecting anything on the tasmota device.","title":"ButtonTopic"},{"location":"Buttons-and-Switches/#changing-default-functionality","text":"If a ButtonTopic (and if SetOption1 1 ) or SwitchTopic 1 is defined (and SwitchMode is set to 5 or 6 ) and a button is pressed longer than defined Key Hold Time ( SetOption32 default 4 seconds) an MQTT message like cmnd/%topic%/POWER HOLD will be sent. HOLD can be changed with StateText4 . Command SetOption11 allows for swapping the functionality between the SINGLE and DOUBLE press of the push button. These changes result in the following:","title":"Changing Default Functionality"},{"location":"Buttons-and-Switches/#ac-frequency-detection-switch","text":"Some devices, such as BlitzWolf BW-SS5 or Moes MS-104B , use mains frequency detection on their switch inputs. Whenever the connected switch or button is pressed there are 50/60 Hz pulses on the switch input. Inside the switch there's a frequency detection circuit which is connected to a GPIO of the ESP8266 chip which counts those pulses. Prior to Tasmota 8.4 this kind of switching was handled using Counter sensors and scripting which is now simplified. You can imagine this algorithm as a leaking bucket. Every pulse adds water to the bucket (little more than leaking out in a cycle), but the water is dripping countinously. If the bucket is full, we will treat the switch on. If there's no pulses, the bucket will be empty, and the we will turn off the switch. The size of the bucket is the debouncing time which controls the sensitivity of the algorithm. If the mains frequency is 50 Hz, a whole AC wave is 20 msec long (for 60 Hz it's about 17 msec; 1000 / frequeny if we want the result in milliseconds). The exact frequency is not really important, because we add more water for every pulse. After you have assigned a Switch<x> to the GPIO connected to the AC frequency detection circuit use the 'SwitchDebounce' command to set the number of pulses required for the switch to be recognized as on or off. For example: SwitchDebounce 69 will turn the switch on after three pulses and turn it off after three missing ones (3 * 20 msec is 60 and the last digit must be 9 to activate the AC detection). You will probably have to experiment with the values depending on your AC frequency and the devices frequency detection implementation. Once the feature is enabled you can use this switch as any regular switch!","title":"AC Frequency Detection Switch"},{"location":"Buttons-and-Switches/#detach-switches-based-on","text":"","title":"Detach Switches Based On.."},{"location":"Buttons-and-Switches/#setoption114","text":"Only in Tasmota 9.1+ When SetOption114 1 all switches are detached from their respective relays and will send MQTT messages instead in the form of {\"Switch<x>\":{\"Action\":\"<state>\"}} . Example When switch one is toggle to \"ON\": {\"Switch1\":{\"Action\":\"ON\"}}","title":"SetOption114"},{"location":"Buttons-and-Switches/#rules","text":"Use rules to send messages to different MQTT topics or send commands to other Tasmota devices when switch state (defined by SwitchMode ) changes. To ignore the default behaviour define a rule which triggers on Switch<x> for all state changes or on Switch<x>#State for specific state changes. If a rule matches only certain states, default switch behaviour is suppressed only for those states. Example Make Switch1 publish any value change to cmnd/custom-topic/SWITCH1 and not control Power1 Backlog SwitchMode 1 ; SwitchTopic 0 Backlog Rule1 on Switch1 # state do Publish cmnd /% topic %/ SWITCH1 % value % endon ; Rule1 1","title":"Rules"},{"location":"Buttons-and-Switches/#switchtopic","text":"Warning When using SwitchTopic 1 or 2 (or ButtonTopic 1 or 2 ) and your MQTT broker becomes unavailable, Tasmota falls back to default SwitchTopic 0 (or ButtonTopic 0 ), which is not optimal. To avoid this, we recommend using first two options instead. If you still need to use SwitchTopic read on! SwitchTopic 0 Default mode By default a switch controls the corresponding power state and doesn't send any MQTT messages itself. No MQTT message will be published on account of the new switch state. The message you see in console is the new power state that is controlled and not the switch state. SwitchTopic 1 Sets MQTT switch topic to device %topic% When changing the state of the switch an MQTT message is sent to the device topic with the payload according to SwitchMode set. Example Device topic tasmota with SwitchMode 3 yields the following message: MQT: cmnd/tasmota/POWER = TOGGLE Notice the cmnd instead of the stat at the beginning. This is the same as sending an MQTT commands to this device, the device power state will be set to the defined state. SwitchTopic <value> Set switch topic to a custom topic (32 characters max) This will send an MQTT message to a custom defined topic similarly to option 1. In the following example, we set the topic to tasmota02 with SwitchTopic tasmota02 . Example Device topic tasmota with SwitchMode 1 and custom topic tasmota02 yields the following message: MQT: cmnd/tasmota02/POWER = ON If you have another device with the topic tasmota02 this action will turn on its power while not affecting anything on the tasmota device.","title":"SwitchTopic"},{"location":"Buzzer/","text":"Tasmota gives you the option to control the sound pattern of a buzzer. Note A device LED can be assigned as a Buzzer component to display a blink pattern. Buzzer command ~ Parameters for the Buzzer command can be <count>,<beep>,<silence>,<tune> all parameters are optional. (default is 1,1,1 (one 100 millisecond beep)) . <count> number of beeps -1 for infinite, -2 to follow state of LED1;\u00bb v8.1.0.6 <beep> duration of one beep in 100 millisecond steps <silence> duration of silence between beeps 100 millisecond steps <tune> is a 32-bit bitmask where a 1 bit beeps and a 0 bit is silence according to <beep> and <silence> , respectively. The tune is played from most significant bit (MSB) to least significant bit (LSB). Leading and trailing 0 bits are ignored. If <tune> is specified, <count> is ignored ( <count> for <tune> supported in \u00bb v8.1.0.6). If <tune> is 0 , it is ignored. Examples: 3 - Beep three times with 100 milliseconds duration and 100 milliseconds pause 2,3 - Beep twice with 300 milliseconds duration and 100 milliseconds pause 2,3,4 - Beep twice with 300 milliseconds duration and 400 milliseconds pause 1,2,3,0xF54 (0000 0000 0000 0000 0000 1111 0101 0100). Each 1 bit beeps for 200 milliseconds and each bounded 0 bit pauses for 300 milliseconds 0 = stop active buzzer cycle \u2003\u00bb v6.6.0.18","title":"Buzzer"},{"location":"Buzzer/#buzzer-command","text":"Parameters for the Buzzer command can be <count>,<beep>,<silence>,<tune> all parameters are optional. (default is 1,1,1 (one 100 millisecond beep)) . <count> number of beeps -1 for infinite, -2 to follow state of LED1;\u00bb v8.1.0.6 <beep> duration of one beep in 100 millisecond steps <silence> duration of silence between beeps 100 millisecond steps <tune> is a 32-bit bitmask where a 1 bit beeps and a 0 bit is silence according to <beep> and <silence> , respectively. The tune is played from most significant bit (MSB) to least significant bit (LSB). Leading and trailing 0 bits are ignored. If <tune> is specified, <count> is ignored ( <count> for <tune> supported in \u00bb v8.1.0.6). If <tune> is 0 , it is ignored. Examples: 3 - Beep three times with 100 milliseconds duration and 100 milliseconds pause 2,3 - Beep twice with 300 milliseconds duration and 100 milliseconds pause 2,3,4 - Beep twice with 300 milliseconds duration and 400 milliseconds pause 1,2,3,0xF54 (0000 0000 0000 0000 0000 1111 0101 0100). Each 1 bit beeps for 200 milliseconds and each bounded 0 bit pauses for 300 milliseconds 0 = stop active buzzer cycle \u2003\u00bb v6.6.0.18","title":"Buzzer command"},{"location":"CC2530/","text":"CC253x Zigbee module ~ The CC2530 or CC2531 is a system-on-chip (SoC) for Zigbee communication Any Texas Instruments CC2530 or CC2531 chip based module can serve as a coordinator if it has Z-Stack firmware flashed . See list of supported modules with their pinouts and flashing instructions since they are different for each device. Info You cannot use a CC2531 in USB mode! Flash it with CC2530 firmware and it will work in serial mode. You will have to wire it for serial communication using TX and RX pins, USB port cannot be used for communicating with the CC2531 chip. Wi-Fi Adapter ~ Using an ESP82xx device such as a Wemos D1 Mini or a NodeMCU to flash the CC2530 is a lower cost alternative than using a single purpose CC_DEBUGGER . In normal operation two free GPIOs are needed for the serial communication with the CC2530. Custom PCBs ~ These PCBs make all the connections required to flash the CC2530 and to run Z2T: SuperHouse.tv Jon Oxer created a custom PCB to connect a Wemos D1 Mini and a CC2530 board (with or without CC2591). Complete module H4NC User h4nc created a custom PCB to connect a NodeMCU and a CC2530 board. You can also get a complete Z2T module with case, pre-flashed and ready to configure and deploy. Configuration ~ Flash Zigbee Adapter ~ Zigbee2Tasmota requires a TI CC2530 based module flashed with Z-Stack CC2530 firmware file from Koen Kanters . Due to memory constraints of the CC2530, you can only pair 16 devices to a coordinator ( See details ). Note There is an alternative firmware allowing for Zigbee routers to create a mesh network and go beyond 16 devices. This is currently not tested nor supported by Zigbee2Tasmota. It may be added later. Flashing options: Flashing with CCLoader and ESP8266 (recommended) Flashing with CCLib and ESP8266 Flash with a dedicated CC Debugger and PC Flash Tasmota ~ Once the flashing process completes, you can re-use the ESP82xx and flash Tasmota with Zigbee2Tasmota enabled firmware. Otherwise, you can use any ESP82xx device. Zigbee feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #define USE_ZIGBEE Optional Run the ESP at 160MHz instead of 80MHz which ensures higher reliability in serial communication with CC2530. In platformio_override.ini uncomment line 51: board_build.f_cpu = 160000000L If you find that your Zigbee2Tasmota operation is unstable, you may have an ESP82xx device that cannot operate reliably at the higher frequency. If you are using hardware serial (see below) and you still have unreliability, try compiling for 80MHz (reverse the options above) and flash the ESP82xx device again to see if operating at a lower frequency improves stability. Running at 80MHz will impact software serial communications so hardware serial is highly recommended if running the ESP82xx at 80MHz. Flash the newly compiled binary usig the normal flashing process . Connect CC2530 to Tasmota ~ If you are using your ESP82xx device to flash the Zigbee adapter as described in tutorials you may want to leave these connections in place in case you ever need to update Zigbee firmware. If not, any of the free GPIOs can be used. It is recommended that hardware serial pins be used (GPIO1/GPIO3 or GPIO13[Rx]/GPIO15[Tx]) Due to ESP82xx GPIO pin constraints, GPIO15 can only be used as serial Tx. The interface between the ESP82xx Wi-Fi device and the Zigbee module uses high speed serial. Tip Tasmota also provides serial communications emulation through software (i.e., software serial). This allows any GPIO to be used. TasmotaSerial version 2.4.x (PR #6377 ) has improved the reliability of software serial making it feasible for use in this application. However, if you have an option to use hardware serial, choose that. Z2T uses software serial by default to allow for serial logging on GPIO1/GPIO3 Use SerialLog 0 to enable hardware serial on GPIO13[Rx]/GPIO15[Tx] . Recommended wiring: ESP Device Tasmota Zigbee Module GPIO13 Zigbee RX (166) CC_TXD (A.K.A. P0_3) GPIO15 Zigbee TX (165) CC_RXD (A.K.A. P0_2) 3V3 VCC GND GND Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIO13 to Zigbee RX (166) GPIO15 to Zigbee TX (165) You can quickly configure Tasmota using a custom template instead. Use this one for the recommended wiring scheme: { \"NAME\" : \"Zigbee\" , \"GPIO\" :[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 166 , 0 , 165 , 0 ], \"FLAG\" : 0 , \"BASE\" : 18 } First Run ~ When the Tasmota device boots, Zigbee2Tasmota will wait for 15 seconds before initializing the CC2530. This time allows for Wi-Fi and MQTT to connect (hopefully). First boot: MQT : tele /%topic%/ RESULT = { \"ZbState\" :{ \"Status\" : 1 , \"Message\" : \"CC2530 booted\" , \"RestartReason\" : \"Watchdog\" , \"MajorRel\" : 2 , \"MinorRel\" : 6 }} MQT : tele /%topic%/ RESULT = { \"ZbState\" :{ \"Status\" : 50 , \"MajorRel\" : 2 , \"MinorRel\" : 6 , \"MaintRel\" : 3 , \"Revision\" : 20190608 }} MQT : tele /%topic%/ RESULT = { \"ZbState\" :{ \"Status\" : 2 , \"Message\" : \"Reseting configuration\" }} MQT : tele /%topic%/ RESULT = { \"ZbState\" :{ \"Status\" : 3 , \"Message\" : \"Configured, starting coordinator\" }} MQT : tele /%topic%/ RESULT = { \"ZbState\" :{ \"Status\" : 51 , \"IEEEAddr\" : \"0x00124B00199DF06F\" , \"ShortAddr\" : \"0x0000\" , \"DeviceType\" : 7 , \"DeviceState\" : 9 , \"NumAssocDevices\" : 0 }} MQT : tele /tasmota/Zigbee_home/ RESULT = { \"ZbState\" :{ \"Status\" : 0 , \"Message\" : \"Started\" }} ZIG : Zigbee started ZIG : No zigbee devices data in Flash Zigbee will automatically boot the CC2530 device, configure the device and wait for Zigbee messages. Normal boot looks like: MQT : tele /%topic%/ RESULT = { \"ZbState\" :{ \"Status\" : 1 , \"Message\" : \"CC2530 booted\" , \"RestartReason\" : \"Watchdog\" , \"MajorRel\" : 2 , \"MinorRel\" : 6 }} MQT : tele /%topic%/ RESULT = { \"ZbState\" :{ \"Status\" : 50 , \"MajorRel\" : 2 , \"MinorRel\" : 6 , \"MaintRel\" : 3 , \"Revision\" : 20190608 }} MQT : tele /%topic%/ RESULT = { \"ZbState\" :{ \"Status\" : 3 , \"Message\" : \"Configured, starting coordinator\" }} MQT : tele /%topic%/ RESULT = { \"ZbState\" :{ \"Status\" : 51 , \"IEEEAddr\" : \"0x00124B00199DF06F\" , \"ShortAddr\" : \"0x0000\" , \"DeviceType\" : 7 , \"DeviceState\" : 9 , \"NumAssocDevices\" : 0 }} MQT : tele /%topic%/ RESULT = { \"ZbState\" :{ \"Status\" : 0 , \"Message\" : \"Started\" }} ZIG : Zigbee started ZIG : Zigbee devices data in Flash ( 516 bytes ) You can force a factory reset of your CC2530 with ZigbeeReset 1 and reboot","title":"CC253x Zigbee module"},{"location":"CC2530/#cc253x-zigbee-module","text":"The CC2530 or CC2531 is a system-on-chip (SoC) for Zigbee communication Any Texas Instruments CC2530 or CC2531 chip based module can serve as a coordinator if it has Z-Stack firmware flashed . See list of supported modules with their pinouts and flashing instructions since they are different for each device. Info You cannot use a CC2531 in USB mode! Flash it with CC2530 firmware and it will work in serial mode. You will have to wire it for serial communication using TX and RX pins, USB port cannot be used for communicating with the CC2531 chip.","title":"CC253x Zigbee module"},{"location":"CC2530/#wi-fi-adapter","text":"Using an ESP82xx device such as a Wemos D1 Mini or a NodeMCU to flash the CC2530 is a lower cost alternative than using a single purpose CC_DEBUGGER . In normal operation two free GPIOs are needed for the serial communication with the CC2530.","title":"Wi-Fi Adapter"},{"location":"CC2530/#custom-pcbs","text":"These PCBs make all the connections required to flash the CC2530 and to run Z2T:","title":"Custom PCBs"},{"location":"CC2530/#configuration","text":"","title":"Configuration"},{"location":"CC2530/#flash-zigbee-adapter","text":"Zigbee2Tasmota requires a TI CC2530 based module flashed with Z-Stack CC2530 firmware file from Koen Kanters . Due to memory constraints of the CC2530, you can only pair 16 devices to a coordinator ( See details ). Note There is an alternative firmware allowing for Zigbee routers to create a mesh network and go beyond 16 devices. This is currently not tested nor supported by Zigbee2Tasmota. It may be added later. Flashing options: Flashing with CCLoader and ESP8266 (recommended) Flashing with CCLib and ESP8266 Flash with a dedicated CC Debugger and PC","title":"Flash Zigbee Adapter"},{"location":"CC2530/#flash-tasmota","text":"Once the flashing process completes, you can re-use the ESP82xx and flash Tasmota with Zigbee2Tasmota enabled firmware. Otherwise, you can use any ESP82xx device. Zigbee feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #define USE_ZIGBEE","title":"Flash Tasmota"},{"location":"CC2530/#connect-cc2530-to-tasmota","text":"If you are using your ESP82xx device to flash the Zigbee adapter as described in tutorials you may want to leave these connections in place in case you ever need to update Zigbee firmware. If not, any of the free GPIOs can be used. It is recommended that hardware serial pins be used (GPIO1/GPIO3 or GPIO13[Rx]/GPIO15[Tx]) Due to ESP82xx GPIO pin constraints, GPIO15 can only be used as serial Tx. The interface between the ESP82xx Wi-Fi device and the Zigbee module uses high speed serial. Tip Tasmota also provides serial communications emulation through software (i.e., software serial). This allows any GPIO to be used. TasmotaSerial version 2.4.x (PR #6377 ) has improved the reliability of software serial making it feasible for use in this application. However, if you have an option to use hardware serial, choose that. Z2T uses software serial by default to allow for serial logging on GPIO1/GPIO3 Use SerialLog 0 to enable hardware serial on GPIO13[Rx]/GPIO15[Tx] . Recommended wiring: ESP Device Tasmota Zigbee Module GPIO13 Zigbee RX (166) CC_TXD (A.K.A. P0_3) GPIO15 Zigbee TX (165) CC_RXD (A.K.A. P0_2) 3V3 VCC GND GND","title":"Connect CC2530 to Tasmota"},{"location":"CC2530/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIO13 to Zigbee RX (166) GPIO15 to Zigbee TX (165) You can quickly configure Tasmota using a custom template instead. Use this one for the recommended wiring scheme: { \"NAME\" : \"Zigbee\" , \"GPIO\" :[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 166 , 0 , 165 , 0 ], \"FLAG\" : 0 , \"BASE\" : 18 }","title":"Tasmota Settings"},{"location":"CC2530/#first-run","text":"When the Tasmota device boots, Zigbee2Tasmota will wait for 15 seconds before initializing the CC2530. This time allows for Wi-Fi and MQTT to connect (hopefully). First boot: MQT : tele /%topic%/ RESULT = { \"ZbState\" :{ \"Status\" : 1 , \"Message\" : \"CC2530 booted\" , \"RestartReason\" : \"Watchdog\" , \"MajorRel\" : 2 , \"MinorRel\" : 6 }} MQT : tele /%topic%/ RESULT = { \"ZbState\" :{ \"Status\" : 50 , \"MajorRel\" : 2 , \"MinorRel\" : 6 , \"MaintRel\" : 3 , \"Revision\" : 20190608 }} MQT : tele /%topic%/ RESULT = { \"ZbState\" :{ \"Status\" : 2 , \"Message\" : \"Reseting configuration\" }} MQT : tele /%topic%/ RESULT = { \"ZbState\" :{ \"Status\" : 3 , \"Message\" : \"Configured, starting coordinator\" }} MQT : tele /%topic%/ RESULT = { \"ZbState\" :{ \"Status\" : 51 , \"IEEEAddr\" : \"0x00124B00199DF06F\" , \"ShortAddr\" : \"0x0000\" , \"DeviceType\" : 7 , \"DeviceState\" : 9 , \"NumAssocDevices\" : 0 }} MQT : tele /tasmota/Zigbee_home/ RESULT = { \"ZbState\" :{ \"Status\" : 0 , \"Message\" : \"Started\" }} ZIG : Zigbee started ZIG : No zigbee devices data in Flash Zigbee will automatically boot the CC2530 device, configure the device and wait for Zigbee messages. Normal boot looks like: MQT : tele /%topic%/ RESULT = { \"ZbState\" :{ \"Status\" : 1 , \"Message\" : \"CC2530 booted\" , \"RestartReason\" : \"Watchdog\" , \"MajorRel\" : 2 , \"MinorRel\" : 6 }} MQT : tele /%topic%/ RESULT = { \"ZbState\" :{ \"Status\" : 50 , \"MajorRel\" : 2 , \"MinorRel\" : 6 , \"MaintRel\" : 3 , \"Revision\" : 20190608 }} MQT : tele /%topic%/ RESULT = { \"ZbState\" :{ \"Status\" : 3 , \"Message\" : \"Configured, starting coordinator\" }} MQT : tele /%topic%/ RESULT = { \"ZbState\" :{ \"Status\" : 51 , \"IEEEAddr\" : \"0x00124B00199DF06F\" , \"ShortAddr\" : \"0x0000\" , \"DeviceType\" : 7 , \"DeviceState\" : 9 , \"NumAssocDevices\" : 0 }} MQT : tele /%topic%/ RESULT = { \"ZbState\" :{ \"Status\" : 0 , \"Message\" : \"Started\" }} ZIG : Zigbee started ZIG : Zigbee devices data in Flash ( 516 bytes ) You can force a factory reset of your CC2530 with ZigbeeReset 1 and reboot","title":"First Run"},{"location":"CCLoader/","text":"development version feature This is a port of the CCLoader utility from RedBearLab in form of a driver for Tasmota. The main difference is, that now only one ESP8266 is needed to do all the tasks. As a result OTA-upgrades are possible too. The driver is tested for a CC2531, but should work on every CC25xx-device, that is supported by the original CCLoader. The wiring to the debug pins (= programming pins) of the CC25xx boards stays the same. It is possible to leave all wires connected (VCC,GND,RX,TX). In the current version of the Tasmota driver the pins are hardcoded and could be changed easily in the code: int CCL_RESET = 14; //GPIO14=D5 on NodeMCU/WeMos D1 Mini int CCL_DD = 4; //GPIO4=D2 on NodeMCU/WeMos D1 Mini int CCL_DC = 5; //GPIO5=D1 on NodeMCU/WeMos D1 Mini The driver must be enabled manually for a self compiled Tasmota binary. #define USE_CCLOADER After reboot the connected CC25xx chip will be reported in the console and the WebUI. Then chose Firmware Upgrade in the WebUI. Now download the correct firmware as a .bin-file, if you haven't done already. Do not use a .hex-file. These can be found for various chips here: https://github.com/arendst/Tasmota/tree/development/tools Select Ugprade by file upload , like you would do for a OTA upgrade of the Tasmota firmware. If a CC25xx chip was successfully detected and the selected file passes a (very minimalistic) check, this will trigger the upload to the CC25xx. This will start the upgrade, which will take several seconds. The progress will be printed to the console and after the finish, the device gets rebooted. A power cycle is recommended. That\u2019s it. Now it might be a good time to upload a Zigbee- or HM1x-firmware to your ESP8266.","title":"CCLoader"},{"location":"Codes-for-IR-Remotes/","text":"The IR Codes can be used with any devicewith an IR sender. The codes will also fit other devices from same manufacturer or series. Please try out... Feel free to contribute this list TV's ~ IR Codes TV Panasonic TX65FXW784 ~ Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"PANASONIC\",\"Bits\":48,\"Data\":\"0x100BCBD\"}} Example IRsend Command: IRsend {\"Protocol\":\"PANASONIC\",\"Bits\":48,\"Data\":0x100BCBD} 0x40040100BCBD=\"ON/OFF\" 0x400401004C4D=\"Mute\" 0x400401000405=\"Vol+\" 0x400401008485=\"Vol-\" 0x400401002C2D=\"P+\" 0x40040100ACAD=\"P-\" 0x400401007273=\"Left\" 0x40040100F2F3=\"Right\" 0x400401005253=\"Up\" 0x40040100D2D3=\"Down\" 0x400401009293=\"OK\" 0x400401004A4B=\"Menu\" 0x400401000E0F=\"Red\" 0x400401004E4F=\"Yellow\" 0x400401008E8F=\"Green\" 0x40040100CECF=\"Blue\" 0x40040100ECED=\"Last View\" 0x400401206D4C=\"My App\" 0x400401904FDE=\"Netflix\" 0x40040190F160=\"Apps\" 0x400401900392=\"Play\" 0x400401908312=\"Pause\" 0x4004019043D2=\"Stop\" 0x40040190C352=\"Forward\" 0x4004019023B2=\"Back\" 0x400401000809=\"Key 1\" 0x400401008889=\"Key 2\" 0x400401004849=\"Key 3\" 0x40040100C8C9=\"Key 4\" 0x400401002829=\"Key 5\" 0x40040100A8A9=\"Key 6\" 0x400401006869=\"Key 7\" 0x40040100E8E9=\"Key 8\" 0x400401001819=\"Key 9\" 0x400401009899=\"Key 0\" 0x40040190BB2A=\"Title forward\" 0x400401903BAA=\"Title back\" 0x40040190A332=\"Record\" 0x40040190E170=\"Guide\" 0x40040100CBCA=\"Exit\" 0x400401002B2A=\"Back\" 0x40040190E574=\"Option\" 0x400401009C9D=\"Info\" 0x400401400C4D=\"TV\" 0x40040100A0A1=\"AV\" 0x40040180C041=\"Text\" 0x40040180A021=\"STTL\" 0x400401000A0B=\"Picture\" 0x400401003534=\"Help\" IR Remote Codes Sony KDL-EX540 ~ Common buttons should work across multiple models Input {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xA50\"} Power On {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x750\"} Power Off {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xF50\"} Power Toggle {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xA90\"} Vol + {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x490\"} Vol - {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xC90\"} Mute {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x290\"} Ch + {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x090\"} Ch - {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x890\"} Theatre Mode {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x03EE\"} Play/Pause {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x2CE9\"} Stop {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x0CE9\"} Rew {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x6CE9\"} Fwd {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x1CE9\"} Sync Menu {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x0D58\"} Prev {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x1EE9\"} Next {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x5EE9\"} i-Manual {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x6F58\"} Scene {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x0F58\"} Aspect {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x5E25\"} Digital/Analog {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x58EE\"} PIP {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x7725\"} Internet Video {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x4F58\"} Favourite {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x37EE\"} Guide {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x6D25\"} Info {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x5D0\"} Return {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x62E9\"} Options {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x36E9\"} Home {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x070\"} Up {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x2F0\"} Down {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xAF0\"} Left {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x2D0\"} Right {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xCD0\"} Enter {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xA70\"} Red {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x52E9\"} Green {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x32E9\"} Yellow {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x72E9\"} Blue {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x12E9\"} 1 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x010\"} 2 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x810\"} 3 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x410\"} 4 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xC10\"} 5 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x210\"} 6 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xA10\"} 7 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x610\"} 8 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xE10\"} 9 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x110\"} Text {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xFD0\"} 0 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x110\"} Subtitles {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x0AE9\"} Audio Track {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xE90\"} HDMI 1 {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x2D58\"} HDMI 2 {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x6D58\"} HDMI 3 {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x1D58\"} HDMI 4 {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x5D58\"} Video 1 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x030\"} Video 2 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x830\"} Video 3/Component 1 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x430\"} PC {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xC30\"} Digital TV {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x25EE\"} IR Codes TV LG 55UH8509 ~ Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x20DF10EF\"}} Example IRsend Command: IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x20DF10EF} or with mosquitto_pub: mosquitto_pub -q 2 -t cmnd/sonoffIRBridge_1/IRSend -m '{\"protocol\": \"NEC\",\"bits\": 32, \"data\": 0x20DF10EF}' 0x20DF10EF=\"ON/OFF\" 0x20DF0FF0=\"TV\" 0x20DF9E61=\"Ratio\" 0x20DFD02F=\"Input\" 0x20DFA956=\"Energy\" 0x20DF8877=\"Key 1\" 0x20DF48B7=\"Key 2\" 0x20DFC837=\"Key 3\" 0x20DF28D7=\"Key 4\" 0x20DFA857=\"Key 5\" 0x20DF6897=\"Key 6\" 0x20DFE817=\"Key 7\" 0x20DF18E7=\"Key 8\" 0x20DF9867=\"Key 9\" 0x20DFCA35=\"List\" 0x20DF08F7=\"Key 0\" 0x20DF58A7=\"Q.View\" 0x20DF40BF=\"Vol+\" 0x20DFC03F=\"Vol-\" 0x20DFCE31=\"Vol-\" 0x20DF7887=\"Fav\" 0x20DF3BC4=\"3D\" 0x20DF906F=\"Mute\" 0x20DF00FF=\"P+\" 0x20DF807F=\"P-\" 0x20DFC23D=\"Settings\" 0x20DF55AA=\"Info\" 0x20DFA25D=\"Q.Menu\" 0x20DFE01F=\"Left\" 0x20DF609F=\"Right\" 0x20DF02FD=\"Up\" 0x20DF827D=\"Down\" 0x20DF22DD=\"OK\" 0x20DF14EB=\"Back\" 0x20DFD52A=\"Guide\" 0x20DFDA25=\"Exit\" 0x20DF4EB1=\"Red\" 0x20DF8E71=\"Green\" 0x20DFC639=\"Yellow\" 0x20DF8679=\"Blue\" 0x20DF04FB=\"Text\" 0x20DF847B=\"T.Opt\" 0x20DF9C63=\"Subtitle\" 0x20DF8D72=\"Stop\" 0x20DF0DF2=\"Play\" 0x20DF5DA2=\"Pause\" 0x20DFF10E=\"Backward\" 0x20DF718E=\"Forward\" 0x20DF7E81=\"Simplink\" 0x20DF8976=\"AD\" 0x20DF0CF3=\"AV Mode\" 0x20DF3EC1=\"Live TV\" 0x20DF42BD=\"Live TV\" 0x20DF35CA=\"Status\" 0x20DF50AF=\"Audio Language\" 0x20DF57A8=\"Shortmenu\" 0x20DF5AA5=\"AV\" 0x20DF5EA1=\"online manual\" 0x20DF619E=\"Volume to 50\" 0x20DF21DE=\"Volume to 80\" 0x20DFE11E=\"Volume to 100\" 0x20DF6B94=\"Radio/TV\" 0x20DF708F=\"doze function\" 0x20DFA35C=\"Display off\" 0x20DFD728=\"Standby\" 0x20DF23DC=\"Power on\" 0x20DFB44B=\"Settings of remote\" 0x20DF956A=\"Program guide\" 0x20DFF00F=\"Radio/TV\" 0x20DF738C=\"HDMI 1\" 0x20DF33CC=\"HDMI 2\" 0x20DF9768=\"HDMI 3\" 0x20DFFD02=\"Component\" 0x20DFF50A=\"Live Zoom\" 0x20DFF20D=\"Input info\" 0x20DFB24D=\"Picture mode\" 0x20DF09F6=\"Recordings\" 0x20DF4AB5=\"Audio mode\" 0x20DF7B84=\"Register magic remote\" 0x20DFAE51=\"directly register magic remote\" 0x20DF1CE3=\"Subtitles\" 0x20DFCC33=\"Presentation in shop\" 0x20DFBD42=\"Start recording\" 0x20DFAD52=\"LG TV Plus\" 0x20DFDD22=\"Sports mode\" 0x20DF1EE1=\"Search\" 0x20DFDF20=\"Warning: instart\" 0x20DF7F80=\"Warning: Poweronly\" 0x20DFFF00=\"Warning: Easy adjust\" 0x20DF5FA0=\"Warning: instop\" 0x20DF5FA0=\"Enter Password\" 0x20DF3FC0=\"Warning: Reset to factory\" Set-top Boxes ~ IR Codes for VU+ Duo2 ~ Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"RC6\",\"Bits\":36,\"Data\":\"0x8052900C\"} Example IRsend Command: IRsend {\"Protocol\":\"RC6\",\"Bits\":36,\"Data\":0x8052900C} 0xC8052900C=\"ON/OFF\" 0xC8052100D=\"Mute\" 0xC80529010=\"Vol+\" 0xC80521011=\"Vol-\" 0xC80529020=\"P+\" 0xC80529021=\"P+\" 0xC8052105A=\"Left\" 0xC8052905B=\"Right\" 0xC80529058=\"Up\" 0xC80529059=\"Down\" 0xC8052905C=\"OK\" 0xC80529054=\"Men\" 0xC8052906D=\"Red\" 0xC8052906F=\"Yellow\" 0xC8052906E=\"Green\" 0xC80529070=\"Blue\" 0xC8052902D=\"Play/Pause\" 0xC80529031=\"Stop\" 0xC80529028=\"Forward\" 0xC80529029=\"Back\" 0xC80529001=\"Key 1\" 0xC80529002=\"Key 2\" 0xC80529003=\"Key 3\" 0xC80529004=\"Key 4\" 0xC80529005=\"Key 5\" 0xC80529006=\"Key 6\" 0xC80529007=\"Key 7\" 0xC80529008=\"Key 8\" 0xC80529009=\"Key 9\" 0xC80529000=\"Key 0\" 0xC805290BB=\"Key <\" 0xC805290BC=\"Key >\" 0xC80529037=\"Record\" 0xC805290CC=\"EPG\" 0xC80529055=\"Exit\" 0xC805290E5=\"Audio\" 0xC805290F2=\"Radio\" 0xC805290E4=\"TV\" 0xC80521049=\"Context\" 0xC80529081=\"Help\" IR Remote Codes AppleTV Gen4 ~ Up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E15080\"} Down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E13080\"} Left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E19080\"} Right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E16080\"} Ok {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E13A80\"} Menu {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E1C080\"} Play/Pause {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E1FA80\"} Home {\"Protocol\":\"NEC\",\"Bits\":0,\"Data\":\"0xFFFFFFFFFFFFFFFF\"} IR Remote Codes Humax HMS-1000T DVB-T2 DVR PAL 4-Tune ~ Power {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000800FF\"} TV Apps {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008D22D\"} Text {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00087689\"} Wide {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008728D\"} Play {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000816E9\"} Pause {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000846B9\"} Rew {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008A659\"} Fwd {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000826D9\"} Stop {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008C639\"} Record {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00088679\"} Search {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008E21D\"} Plus {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000842BD\"} Exit {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00086897\"} Back {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008827D\"} Up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00088877\"} Down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008A857\"} Left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000848B7\"} Right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000828D7\"} Enter {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008C837\"} Vol + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008F807\"} Vol - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000802FD\"} Mute {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000818E7\"} Home {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008708F\"} Guide {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008D827\"} Ch + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000808F7\"} Ch - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008F00F\"} Red {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000838C7\"} Green {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008B847\"} Yellow {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000858A7\"} Blue {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00087887\"} 1 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008C03F\"} 2 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000820DF\"} 3 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008A05F\"} 4 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008609F\"} 5 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008E01F\"} 6 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000810EF\"} 7 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008906F\"} 8 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000850AF\"} 9 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008D02F\"} 0 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000830CF\"} TV/Radio {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008B04F\"} IR Remote Codes FetchTV Mini(Hybroad H626T) ~ Power Toggle {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662BA45\"} Keyboard Select {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26624CB3\"} Ch + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26627B84\"} Ch - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662DB24\"} TV Guide {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266207F8\"} Red {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662738C\"} Green {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662936C\"} Yellow {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662E31C\"} Blue {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266213EC\"} Info {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26628B74\"} Search {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26622CD3\"} Apps {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662CC33\"} Menu {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26629B64\"} Up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26629B64\"} Down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266223DC\"} Left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662837C\"} Right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662C33C\"} Enter {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26621CE3\"} Back {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662AB54\"} Exit {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266227D8\"} Rew {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662BB44\"} Play/Pause {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26625BA4\"} Fwd {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26625BA4\"} Stop {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662B34C\"} Record {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26624BB4\"} 1 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266240BF\"} 2 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662C03F\"} 3 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266220DF\"} 4 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662A05F\"} 5 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662609F\"} 6 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662E01F\"} 7 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266210EF\"} 8 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662906F\"} 9 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266250AF\"} 0 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662D02F\"} Smart Reveiver VX/CX ~ button code on/off {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF30CF\",\"DataLSB\":\"0x00FF0CF3\",\"Repeat\":0} mute {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFB04F\",\"DataLSB\":\"0x00FF0DF2\",\"Repeat\":0} FORMAT {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF1CE3\",\"DataLSB\":\"0x00FF38C7\",\"Repeat\":0} 16:9 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFC13E\",\"DataLSB\":\"0x00FF837C\",\"Repeat\":0} AUDIO {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFFA05\",\"DataLSB\":\"0x00FF5FA0\",\"Repeat\":0} 1 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF807F\",\"DataLSB\":\"0x00FF01FE\",\"Repeat\":0} 2 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF40BF\",\"DataLSB\":\"0x00FF02FD\",\"Repeat\":0} 3 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFC03F\",\"DataLSB\":\"0x00FF03FC\",\"Repeat\":0} 4 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF20DF\",\"DataLSB\":\"0x00FF04FB\",\"Repeat\":0} 5 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFA05F\",\"DataLSB\":\"0x00FF05FA\",\"Repeat\":0} 6 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF609F\",\"DataLSB\":\"0x00FF06F9\",\"Repeat\":0} 7 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFE01F\",\"DataLSB\":\"0x00FF07F8\",\"Repeat\":0} 8 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF10EF\",\"DataLSB\":\"0x00FF08F7\",\"Repeat\":0} 9 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF906F\",\"DataLSB\":\"0x00FF09F6\",\"Repeat\":0} TV/R {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFA25D\",\"DataLSB\":\"0x00FF45BA\",\"Repeat\":0} 0 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\",\"DataLSB\":\"0x00FF00FF\",\"Repeat\":0} RECALL {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF19E6\",\"DataLSB\":\"0x00FF9867\",\"Repeat\":0} volume + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF5AA5\",\"DataLSB\":\"0x00FF5AA5\",\"Repeat\":0} volume - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFDA25\",\"DataLSB\":\"0x00FF5BA4\",\"Repeat\":0} P - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFBA45\",\"DataLSB\":\"0x00FF5DA2\",\"Repeat\":0} P + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF3AC5\",\"DataLSB\":\"0x00FF5CA3\",\"Repeat\":0} red {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFEC13\",\"DataLSB\":\"0x00FF37C8\",\"Repeat\":0} green {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF6C93\",\"DataLSB\":\"0x00FF36C9\",\"Repeat\":0} yellow {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF4CB3\",\"DataLSB\":\"0x00FF32CD\",\"Repeat\":0} blue {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF2CD3\",\"DataLSB\":\"0x00FF34CB\",\"Repeat\":0} MENU {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF4AB5\",\"DataLSB\":\"0x00FF52AD\",\"Repeat\":0} BACK {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF44BB\",\"DataLSB\":\"0x00FF22DD\",\"Repeat\":0} EXIT {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFB44B\",\"DataLSB\":\"0x00FF2DD2\",\"Repeat\":0} up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF04FB\",\"DataLSB\":\"0x00FF20DF\",\"Repeat\":0} left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF8877\",\"DataLSB\":\"0x00FF11EE\",\"Repeat\":0} OK {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFEA15\",\"DataLSB\":\"0x00FF57A8\",\"Repeat\":0} right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF08F7\",\"DataLSB\":\"0x00FF10EF\",\"Repeat\":0} down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF847B\",\"DataLSB\":\"0x00FF21DE\",\"Repeat\":0} INFO {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF34CB\",\"DataLSB\":\"0x00FF2CD3\",\"Repeat\":0} FAV {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF8679\",\"DataLSB\":\"0x00FF619E\",\"Repeat\":0} TXT {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF7A85\",\"DataLSB\":\"0x00FF5EA1\",\"Repeat\":0} EPG {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF06F9\",\"DataLSB\":\"0x00FF609F\",\"Repeat\":0} FR {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF8976\",\"DataLSB\":\"0x00FF916E\",\"Repeat\":0} REC {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF619E\",\"DataLSB\":\"0x00FF8679\",\"Repeat\":0} FF {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF29D6\",\"DataLSB\":\"0x00FF946B\",\"Repeat\":0} PREV {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF09F6\",\"DataLSB\":\"0x00FF906F\",\"Repeat\":0} Play/Pause {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFE916\",\"DataLSB\":\"0x00FF9768\",\"Repeat\":0} NEXT {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFC936\",\"DataLSB\":\"0x00FF936C\",\"Repeat\":0} (none left) {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF4BB4\",\"DataLSB\":\"0x00FFD22D\",\"Repeat\":0} STOP {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF718E\",\"DataLSB\":\"0x00FF8E71\",\"Repeat\":0} (none right) {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF8976\",\"DataLSB\":\"0x00FF916E\",\"Repeat\":0} USB {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFFB04\",\"DataLSB\":\"0x00FFDF20\",\"Repeat\":0} HELP {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF54AB\",\"DataLSB\":\"0x00FF2AD5\",\"Repeat\":0} DVD {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFDB24\",\"DataLSB\":\"0x00FFDB24\",\"Repeat\":0} BD/DVD players ~ IR Remote Codes Sony BD-S1500 ~ Common buttons should work across multiple models Eject {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x68B47\"} Power {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xA8B47\"} Red {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xE6B47\"} Green {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x16B47\"} Yellow {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x96B47\"} Bue {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x66B47\"} Top Menu {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x34B47\"} Popup/Menu {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x94B47\"} Return {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xC2B47\"} Options {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xFCB47\"} Home {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x42B47\"} Up {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x9CB47\"} Down {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x5CB47\"} Left {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xDCB47\"} Right {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x3CB47\"} Enter {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xBCB47\"} Favourites {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xBCB47\"} Netflix {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xD2B47\"} Play {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x58B47\"} Pause {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x98B47\"} Rew {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xD8B47\"} Fwd {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x38B47\"} Prev {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xEAB47\"} Next {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x6AB47\"} Stop {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x18B47\"} Subtitles {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xC6B47\"} Audio Track {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x26B47\"} Vol + {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x490\"} Vol - {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xC90\"} Mute {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x290\"} Projectors ~ IR Remote Codes Acer K132 ~ IR Remote Codes for Acer K132 projector (and possibly other models using a remote with Model No. M1820) ON/OFF {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8E11E\"} * Freeze {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8718E\"} * Hide {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8F10E\"} * Ratio {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C806F9\"} * Zoom {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8D12E\"} * Mode {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C801FE\"} * Source {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C831CE\"} * Back {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C832CD\"} * Up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C841BE\"} * Down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8A15E\"} * Left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8C13E\"} * Right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8817E\"} * Enter {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8B24D\"} * Menu {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C821DE\"} * Vol+ {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8C639\"} * Vol- {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C826D9\"} * Sound {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8AD52\"} * Mute {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C88679\"} Soundbars ~ IR Codes Soundbar Panasonic SCALL70T ~ Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"PANASONIC\",\"Bits\":48,\"Data\":\"0x40040500BCB9\"}} Example IRsend Command: IRsend {\"Protocol\":\"PANASONIC\",\"Bits\":48,\"Data\":0x40040500BCB9} 0x40040500BCB9=\"ON/OFF\" 0x400405004C49=\"Mute\" 0x400405000401=\"Vol+\" 0x400405008481=\"Vol-\" 0x40040538DFE2=\"OK\" 0x400405383F02=\"Up\" 0x40040538BF82=\"Down\" 0x40040538AD90=\"Setup\" 0x400405280D20=\"Sound\" 0x400405380538=\"Bluetooth\" 0x400405006164=\"Input\" IR Codes Soundcore Infini Pro ~ Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0xFD256897\"}} Example IRsend Command: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0xFD256897\"} 0xFD2502FD=\"ON/OFF\" 0xFD2518E7=\"Mute\" 0xFD2508F7=\"Input\" 0xFD259867=\"Bluetooth\" 0xFD2548B7=\"TV\" 0xFD256897=\"Vol+\" 0xFD2558A7=\"Vol-\" 0xFD258A75=\"Previous\" 0xFD250AF5=\"Next\" 0xFD25C837=\"Play/Pause\" 0xFD2554AB=\"Movie\" 0xFD255CA3=\"Music\" 0xFD2552AD=\"Voice\" 0xFD2532CD=\"Bass-\" 0xFD258877=\"Bass+\" 0xFD2538C7=\"Surround\" Vacuum Cleaners ~ IR Codes Vacuum Cleaner Ecovacs Deebot Slim2 ~ Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFD02F\"}} Example IRsend Command: IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x00FFD02F} 0x00FFD02F=\"Automatic Mode/Pause\" 0x00FF609F=\"Edge Cleaning\" 0x00FF40BF=\"Spot Cleaning\" 0x00FF708F=\"Back to Charging Base\" 0x00FFC837=\"Forward\" 0x00FFE01F=\"Left\" 0x00FFF00F=\"Right\" 0x00FFC03F=\"Back/Turn around\" Ventilation ~ IR Codes Prana 150 energy recovery ventilation ~ See device https://prana.org.ua/models/prana_150 (Ukrainian) Example received Code: MQT: tele/sonoffir/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\"}} Example IRsend Command: IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\"} {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\"}=\"Power\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF807F\"}=\"Screen/LED Brightness\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF30CF\"}=\"Heat OFF\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF906F\"}=\"Heat ON\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF50AF\"}=\"Fan\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFA857\"}=\"Anti freeze\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFB04F\"}=\"Night Mode\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF708F\"}=\"Fan -\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF28D7\"}=\"Fan +\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF609F\"}=\"Night Mode Fan -\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF10EF\"}=\"Night Mode Fan +\" Christmas candle - Weihnachtsbeleuchtung ~ Krinner Lumix IR Remote ~ Remote control has two buttons and three channels. Button 1 is to switch on Button 0 is to switch off Double click on button 1 is flicker mode No usable protocol found yet, but raw mode does it. Example for HttpGetRequest and irsend sendHttpGetRequest(\"http://192.168.1.234/cm?cmnd=irsend5%200,2000,1000,%20400,1000,%20400,%20400,1000,1000,%20400,1000,%20400,%20400,1000,%20400,1000,%20400,1000,%20400,2000,5600\") off channel A irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1000, 400,1000, 400,2000,5600 on channel A irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,2000,5600 flicker channel A irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1100,1000, 400, 400,2000,5600 off channel B irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1000, 400,1000, 400,2000,5600 on channel B irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400,1000, 400,1000, 400, 400,2000,5600 flicker channel B irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1100,1000, 400, 400,2000,5600 off channel C irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1000, 400,1000, 400,2000,5600 on channel C irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,2000,5600 flicker channel C irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1100,1000, 400, 400,2000,5600 Vinkor Flameless Flickering Candles (and clones probably) ~ on {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED00FF\",\"Repeat\":0} off {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED40BF\",\"Repeat\":0} dim {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED08F7\",\"Repeat\":0} bright {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED48B7\",\"Repeat\":0} candle {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED30CF\",\"Repeat\":0} light {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED708F\",\"Repeat\":0} 2H {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED20DF\",\"Repeat\":0} 4H {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED609F\",\"Repeat\":0} 6H {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED10EF\",\"Repeat\":0} 8H {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED50AF\",\"Repeat\":0} LED Candles / LED Kerzen ~ Duni Warm White LED Candle / Duni Warmwei\u00df LED Kerzen ~ ON= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\"} OFF= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF807F\"} 4h= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF40BF\"} 8h= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFC03F\"} ModeCandle= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF20DF\"} ModeLight= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFA05F\"} ModeDark= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF906F\"} ModeBright= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFE01F\"} ModeMoon= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF10EF\"} ModeNightLight= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF609F\"} Duni Multicoloured LED Candle / Duni Mehrfarbige LED Kerzen ~ ON_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F48B7\",\"DataLSB\":\"0x01FE12ED\"} OFF_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F807F\",\"DataLSB\":\"0x01FE01FE\"} ModeSmooth_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F58A7\",\"DataLSB\":\"0x01FE1AE5\"} ModeNightLight_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F7887\",\"DataLSB\":\"0x01FE1EE1\"} ModeCandle_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F40BF\",\"DataLSB\":\"0x01FE02FD\"} ModeLight_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FC03F\",\"DataLSB\":\"0x01FE03FC\"} ModeTimer_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F20DF\",\"DataLSB\":\"0x01FE04FB\"} ModeDark_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FA05F\",\"DataLSB\":\"0x01FE05FA\"} ModeBright_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F609F\",\"DataLSB\":\"0x01FE06F9\"} ColorRed_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FE01F\",\"DataLSB\":\"0x01FE07F8\"} ColorGreen_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F10EF\",\"DataLSB\":\"0x01FE08F7\"} ColorBlue_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F906F\",\"DataLSB\":\"0x01FE09F6\"} ColorOrange_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F50AF\",\"DataLSB\":\"0x01FE0AF5\"} ColorLightGreen_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FD827\",\"DataLSB\":\"0x01FE1BE4\"} ColorLightBlue_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FF807\",\"DataLSB\":\"0x01FE1FE0\"} ColorViolet_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F30CF\",\"DataLSB\":\"0x01FE0CF3\"} ColorYellow_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FB04F\",\"DataLSB\":\"0x01FE0DF2\"} ColorBlueWhite_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F708F\",\"DataLSB\":\"0x01FE0EF1\"} ColorPink_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F00FF\",\"DataLSB\":\"0x01FE00FF\"} ColorYellowWhite_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FF00F\",\"DataLSB\":\"0x01FE0FF0\"} ColorWhite_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F9867\",\"DataLSB\":\"0x01FE19E6\"}","title":"Codes for IR Remotes"},{"location":"Codes-for-IR-Remotes/#tvs","text":"","title":"TV's"},{"location":"Codes-for-IR-Remotes/#ir-codes-tv-panasonic-tx65fxw784","text":"Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"PANASONIC\",\"Bits\":48,\"Data\":\"0x100BCBD\"}} Example IRsend Command: IRsend {\"Protocol\":\"PANASONIC\",\"Bits\":48,\"Data\":0x100BCBD} 0x40040100BCBD=\"ON/OFF\" 0x400401004C4D=\"Mute\" 0x400401000405=\"Vol+\" 0x400401008485=\"Vol-\" 0x400401002C2D=\"P+\" 0x40040100ACAD=\"P-\" 0x400401007273=\"Left\" 0x40040100F2F3=\"Right\" 0x400401005253=\"Up\" 0x40040100D2D3=\"Down\" 0x400401009293=\"OK\" 0x400401004A4B=\"Menu\" 0x400401000E0F=\"Red\" 0x400401004E4F=\"Yellow\" 0x400401008E8F=\"Green\" 0x40040100CECF=\"Blue\" 0x40040100ECED=\"Last View\" 0x400401206D4C=\"My App\" 0x400401904FDE=\"Netflix\" 0x40040190F160=\"Apps\" 0x400401900392=\"Play\" 0x400401908312=\"Pause\" 0x4004019043D2=\"Stop\" 0x40040190C352=\"Forward\" 0x4004019023B2=\"Back\" 0x400401000809=\"Key 1\" 0x400401008889=\"Key 2\" 0x400401004849=\"Key 3\" 0x40040100C8C9=\"Key 4\" 0x400401002829=\"Key 5\" 0x40040100A8A9=\"Key 6\" 0x400401006869=\"Key 7\" 0x40040100E8E9=\"Key 8\" 0x400401001819=\"Key 9\" 0x400401009899=\"Key 0\" 0x40040190BB2A=\"Title forward\" 0x400401903BAA=\"Title back\" 0x40040190A332=\"Record\" 0x40040190E170=\"Guide\" 0x40040100CBCA=\"Exit\" 0x400401002B2A=\"Back\" 0x40040190E574=\"Option\" 0x400401009C9D=\"Info\" 0x400401400C4D=\"TV\" 0x40040100A0A1=\"AV\" 0x40040180C041=\"Text\" 0x40040180A021=\"STTL\" 0x400401000A0B=\"Picture\" 0x400401003534=\"Help\"","title":"IR Codes TV Panasonic TX65FXW784"},{"location":"Codes-for-IR-Remotes/#ir-remote-codes-sony-kdl-ex540","text":"Common buttons should work across multiple models Input {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xA50\"} Power On {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x750\"} Power Off {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xF50\"} Power Toggle {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xA90\"} Vol + {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x490\"} Vol - {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xC90\"} Mute {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x290\"} Ch + {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x090\"} Ch - {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x890\"} Theatre Mode {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x03EE\"} Play/Pause {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x2CE9\"} Stop {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x0CE9\"} Rew {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x6CE9\"} Fwd {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x1CE9\"} Sync Menu {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x0D58\"} Prev {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x1EE9\"} Next {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x5EE9\"} i-Manual {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x6F58\"} Scene {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x0F58\"} Aspect {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x5E25\"} Digital/Analog {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x58EE\"} PIP {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x7725\"} Internet Video {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x4F58\"} Favourite {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x37EE\"} Guide {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x6D25\"} Info {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x5D0\"} Return {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x62E9\"} Options {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x36E9\"} Home {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x070\"} Up {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x2F0\"} Down {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xAF0\"} Left {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x2D0\"} Right {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xCD0\"} Enter {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xA70\"} Red {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x52E9\"} Green {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x32E9\"} Yellow {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x72E9\"} Blue {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x12E9\"} 1 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x010\"} 2 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x810\"} 3 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x410\"} 4 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xC10\"} 5 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x210\"} 6 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xA10\"} 7 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x610\"} 8 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xE10\"} 9 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x110\"} Text {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xFD0\"} 0 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x110\"} Subtitles {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x0AE9\"} Audio Track {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xE90\"} HDMI 1 {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x2D58\"} HDMI 2 {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x6D58\"} HDMI 3 {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x1D58\"} HDMI 4 {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x5D58\"} Video 1 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x030\"} Video 2 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x830\"} Video 3/Component 1 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x430\"} PC {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xC30\"} Digital TV {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x25EE\"}","title":"IR Remote Codes Sony KDL-EX540"},{"location":"Codes-for-IR-Remotes/#ir-codes-tv-lg-55uh8509","text":"Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x20DF10EF\"}} Example IRsend Command: IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x20DF10EF} or with mosquitto_pub: mosquitto_pub -q 2 -t cmnd/sonoffIRBridge_1/IRSend -m '{\"protocol\": \"NEC\",\"bits\": 32, \"data\": 0x20DF10EF}' 0x20DF10EF=\"ON/OFF\" 0x20DF0FF0=\"TV\" 0x20DF9E61=\"Ratio\" 0x20DFD02F=\"Input\" 0x20DFA956=\"Energy\" 0x20DF8877=\"Key 1\" 0x20DF48B7=\"Key 2\" 0x20DFC837=\"Key 3\" 0x20DF28D7=\"Key 4\" 0x20DFA857=\"Key 5\" 0x20DF6897=\"Key 6\" 0x20DFE817=\"Key 7\" 0x20DF18E7=\"Key 8\" 0x20DF9867=\"Key 9\" 0x20DFCA35=\"List\" 0x20DF08F7=\"Key 0\" 0x20DF58A7=\"Q.View\" 0x20DF40BF=\"Vol+\" 0x20DFC03F=\"Vol-\" 0x20DFCE31=\"Vol-\" 0x20DF7887=\"Fav\" 0x20DF3BC4=\"3D\" 0x20DF906F=\"Mute\" 0x20DF00FF=\"P+\" 0x20DF807F=\"P-\" 0x20DFC23D=\"Settings\" 0x20DF55AA=\"Info\" 0x20DFA25D=\"Q.Menu\" 0x20DFE01F=\"Left\" 0x20DF609F=\"Right\" 0x20DF02FD=\"Up\" 0x20DF827D=\"Down\" 0x20DF22DD=\"OK\" 0x20DF14EB=\"Back\" 0x20DFD52A=\"Guide\" 0x20DFDA25=\"Exit\" 0x20DF4EB1=\"Red\" 0x20DF8E71=\"Green\" 0x20DFC639=\"Yellow\" 0x20DF8679=\"Blue\" 0x20DF04FB=\"Text\" 0x20DF847B=\"T.Opt\" 0x20DF9C63=\"Subtitle\" 0x20DF8D72=\"Stop\" 0x20DF0DF2=\"Play\" 0x20DF5DA2=\"Pause\" 0x20DFF10E=\"Backward\" 0x20DF718E=\"Forward\" 0x20DF7E81=\"Simplink\" 0x20DF8976=\"AD\" 0x20DF0CF3=\"AV Mode\" 0x20DF3EC1=\"Live TV\" 0x20DF42BD=\"Live TV\" 0x20DF35CA=\"Status\" 0x20DF50AF=\"Audio Language\" 0x20DF57A8=\"Shortmenu\" 0x20DF5AA5=\"AV\" 0x20DF5EA1=\"online manual\" 0x20DF619E=\"Volume to 50\" 0x20DF21DE=\"Volume to 80\" 0x20DFE11E=\"Volume to 100\" 0x20DF6B94=\"Radio/TV\" 0x20DF708F=\"doze function\" 0x20DFA35C=\"Display off\" 0x20DFD728=\"Standby\" 0x20DF23DC=\"Power on\" 0x20DFB44B=\"Settings of remote\" 0x20DF956A=\"Program guide\" 0x20DFF00F=\"Radio/TV\" 0x20DF738C=\"HDMI 1\" 0x20DF33CC=\"HDMI 2\" 0x20DF9768=\"HDMI 3\" 0x20DFFD02=\"Component\" 0x20DFF50A=\"Live Zoom\" 0x20DFF20D=\"Input info\" 0x20DFB24D=\"Picture mode\" 0x20DF09F6=\"Recordings\" 0x20DF4AB5=\"Audio mode\" 0x20DF7B84=\"Register magic remote\" 0x20DFAE51=\"directly register magic remote\" 0x20DF1CE3=\"Subtitles\" 0x20DFCC33=\"Presentation in shop\" 0x20DFBD42=\"Start recording\" 0x20DFAD52=\"LG TV Plus\" 0x20DFDD22=\"Sports mode\" 0x20DF1EE1=\"Search\" 0x20DFDF20=\"Warning: instart\" 0x20DF7F80=\"Warning: Poweronly\" 0x20DFFF00=\"Warning: Easy adjust\" 0x20DF5FA0=\"Warning: instop\" 0x20DF5FA0=\"Enter Password\" 0x20DF3FC0=\"Warning: Reset to factory\"","title":"IR Codes TV LG 55UH8509"},{"location":"Codes-for-IR-Remotes/#set-top-boxes","text":"","title":"Set-top Boxes"},{"location":"Codes-for-IR-Remotes/#ir-codes-for-vu-duo2","text":"Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"RC6\",\"Bits\":36,\"Data\":\"0x8052900C\"} Example IRsend Command: IRsend {\"Protocol\":\"RC6\",\"Bits\":36,\"Data\":0x8052900C} 0xC8052900C=\"ON/OFF\" 0xC8052100D=\"Mute\" 0xC80529010=\"Vol+\" 0xC80521011=\"Vol-\" 0xC80529020=\"P+\" 0xC80529021=\"P+\" 0xC8052105A=\"Left\" 0xC8052905B=\"Right\" 0xC80529058=\"Up\" 0xC80529059=\"Down\" 0xC8052905C=\"OK\" 0xC80529054=\"Men\" 0xC8052906D=\"Red\" 0xC8052906F=\"Yellow\" 0xC8052906E=\"Green\" 0xC80529070=\"Blue\" 0xC8052902D=\"Play/Pause\" 0xC80529031=\"Stop\" 0xC80529028=\"Forward\" 0xC80529029=\"Back\" 0xC80529001=\"Key 1\" 0xC80529002=\"Key 2\" 0xC80529003=\"Key 3\" 0xC80529004=\"Key 4\" 0xC80529005=\"Key 5\" 0xC80529006=\"Key 6\" 0xC80529007=\"Key 7\" 0xC80529008=\"Key 8\" 0xC80529009=\"Key 9\" 0xC80529000=\"Key 0\" 0xC805290BB=\"Key <\" 0xC805290BC=\"Key >\" 0xC80529037=\"Record\" 0xC805290CC=\"EPG\" 0xC80529055=\"Exit\" 0xC805290E5=\"Audio\" 0xC805290F2=\"Radio\" 0xC805290E4=\"TV\" 0xC80521049=\"Context\" 0xC80529081=\"Help\"","title":"IR Codes for VU+ Duo2"},{"location":"Codes-for-IR-Remotes/#ir-remote-codes-appletv-gen4","text":"Up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E15080\"} Down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E13080\"} Left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E19080\"} Right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E16080\"} Ok {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E13A80\"} Menu {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E1C080\"} Play/Pause {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E1FA80\"} Home {\"Protocol\":\"NEC\",\"Bits\":0,\"Data\":\"0xFFFFFFFFFFFFFFFF\"}","title":"IR Remote Codes AppleTV Gen4"},{"location":"Codes-for-IR-Remotes/#ir-remote-codes-humax-hms-1000t-dvb-t2-dvr-pal-4-tune","text":"Power {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000800FF\"} TV Apps {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008D22D\"} Text {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00087689\"} Wide {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008728D\"} Play {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000816E9\"} Pause {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000846B9\"} Rew {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008A659\"} Fwd {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000826D9\"} Stop {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008C639\"} Record {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00088679\"} Search {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008E21D\"} Plus {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000842BD\"} Exit {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00086897\"} Back {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008827D\"} Up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00088877\"} Down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008A857\"} Left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000848B7\"} Right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000828D7\"} Enter {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008C837\"} Vol + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008F807\"} Vol - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000802FD\"} Mute {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000818E7\"} Home {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008708F\"} Guide {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008D827\"} Ch + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000808F7\"} Ch - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008F00F\"} Red {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000838C7\"} Green {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008B847\"} Yellow {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000858A7\"} Blue {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00087887\"} 1 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008C03F\"} 2 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000820DF\"} 3 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008A05F\"} 4 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008609F\"} 5 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008E01F\"} 6 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000810EF\"} 7 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008906F\"} 8 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000850AF\"} 9 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008D02F\"} 0 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000830CF\"} TV/Radio {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008B04F\"}","title":"IR Remote Codes Humax HMS-1000T DVB-T2 DVR PAL 4-Tune"},{"location":"Codes-for-IR-Remotes/#ir-remote-codes-fetchtv-minihybroad-h626t","text":"Power Toggle {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662BA45\"} Keyboard Select {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26624CB3\"} Ch + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26627B84\"} Ch - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662DB24\"} TV Guide {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266207F8\"} Red {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662738C\"} Green {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662936C\"} Yellow {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662E31C\"} Blue {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266213EC\"} Info {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26628B74\"} Search {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26622CD3\"} Apps {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662CC33\"} Menu {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26629B64\"} Up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26629B64\"} Down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266223DC\"} Left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662837C\"} Right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662C33C\"} Enter {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26621CE3\"} Back {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662AB54\"} Exit {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266227D8\"} Rew {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662BB44\"} Play/Pause {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26625BA4\"} Fwd {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26625BA4\"} Stop {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662B34C\"} Record {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26624BB4\"} 1 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266240BF\"} 2 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662C03F\"} 3 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266220DF\"} 4 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662A05F\"} 5 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662609F\"} 6 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662E01F\"} 7 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266210EF\"} 8 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662906F\"} 9 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266250AF\"} 0 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662D02F\"}","title":"IR Remote Codes FetchTV Mini(Hybroad H626T)"},{"location":"Codes-for-IR-Remotes/#smart-reveiver-vxcx","text":"button code on/off {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF30CF\",\"DataLSB\":\"0x00FF0CF3\",\"Repeat\":0} mute {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFB04F\",\"DataLSB\":\"0x00FF0DF2\",\"Repeat\":0} FORMAT {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF1CE3\",\"DataLSB\":\"0x00FF38C7\",\"Repeat\":0} 16:9 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFC13E\",\"DataLSB\":\"0x00FF837C\",\"Repeat\":0} AUDIO {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFFA05\",\"DataLSB\":\"0x00FF5FA0\",\"Repeat\":0} 1 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF807F\",\"DataLSB\":\"0x00FF01FE\",\"Repeat\":0} 2 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF40BF\",\"DataLSB\":\"0x00FF02FD\",\"Repeat\":0} 3 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFC03F\",\"DataLSB\":\"0x00FF03FC\",\"Repeat\":0} 4 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF20DF\",\"DataLSB\":\"0x00FF04FB\",\"Repeat\":0} 5 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFA05F\",\"DataLSB\":\"0x00FF05FA\",\"Repeat\":0} 6 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF609F\",\"DataLSB\":\"0x00FF06F9\",\"Repeat\":0} 7 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFE01F\",\"DataLSB\":\"0x00FF07F8\",\"Repeat\":0} 8 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF10EF\",\"DataLSB\":\"0x00FF08F7\",\"Repeat\":0} 9 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF906F\",\"DataLSB\":\"0x00FF09F6\",\"Repeat\":0} TV/R {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFA25D\",\"DataLSB\":\"0x00FF45BA\",\"Repeat\":0} 0 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\",\"DataLSB\":\"0x00FF00FF\",\"Repeat\":0} RECALL {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF19E6\",\"DataLSB\":\"0x00FF9867\",\"Repeat\":0} volume + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF5AA5\",\"DataLSB\":\"0x00FF5AA5\",\"Repeat\":0} volume - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFDA25\",\"DataLSB\":\"0x00FF5BA4\",\"Repeat\":0} P - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFBA45\",\"DataLSB\":\"0x00FF5DA2\",\"Repeat\":0} P + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF3AC5\",\"DataLSB\":\"0x00FF5CA3\",\"Repeat\":0} red {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFEC13\",\"DataLSB\":\"0x00FF37C8\",\"Repeat\":0} green {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF6C93\",\"DataLSB\":\"0x00FF36C9\",\"Repeat\":0} yellow {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF4CB3\",\"DataLSB\":\"0x00FF32CD\",\"Repeat\":0} blue {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF2CD3\",\"DataLSB\":\"0x00FF34CB\",\"Repeat\":0} MENU {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF4AB5\",\"DataLSB\":\"0x00FF52AD\",\"Repeat\":0} BACK {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF44BB\",\"DataLSB\":\"0x00FF22DD\",\"Repeat\":0} EXIT {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFB44B\",\"DataLSB\":\"0x00FF2DD2\",\"Repeat\":0} up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF04FB\",\"DataLSB\":\"0x00FF20DF\",\"Repeat\":0} left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF8877\",\"DataLSB\":\"0x00FF11EE\",\"Repeat\":0} OK {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFEA15\",\"DataLSB\":\"0x00FF57A8\",\"Repeat\":0} right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF08F7\",\"DataLSB\":\"0x00FF10EF\",\"Repeat\":0} down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF847B\",\"DataLSB\":\"0x00FF21DE\",\"Repeat\":0} INFO {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF34CB\",\"DataLSB\":\"0x00FF2CD3\",\"Repeat\":0} FAV {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF8679\",\"DataLSB\":\"0x00FF619E\",\"Repeat\":0} TXT {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF7A85\",\"DataLSB\":\"0x00FF5EA1\",\"Repeat\":0} EPG {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF06F9\",\"DataLSB\":\"0x00FF609F\",\"Repeat\":0} FR {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF8976\",\"DataLSB\":\"0x00FF916E\",\"Repeat\":0} REC {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF619E\",\"DataLSB\":\"0x00FF8679\",\"Repeat\":0} FF {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF29D6\",\"DataLSB\":\"0x00FF946B\",\"Repeat\":0} PREV {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF09F6\",\"DataLSB\":\"0x00FF906F\",\"Repeat\":0} Play/Pause {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFE916\",\"DataLSB\":\"0x00FF9768\",\"Repeat\":0} NEXT {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFC936\",\"DataLSB\":\"0x00FF936C\",\"Repeat\":0} (none left) {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF4BB4\",\"DataLSB\":\"0x00FFD22D\",\"Repeat\":0} STOP {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF718E\",\"DataLSB\":\"0x00FF8E71\",\"Repeat\":0} (none right) {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF8976\",\"DataLSB\":\"0x00FF916E\",\"Repeat\":0} USB {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFFB04\",\"DataLSB\":\"0x00FFDF20\",\"Repeat\":0} HELP {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF54AB\",\"DataLSB\":\"0x00FF2AD5\",\"Repeat\":0} DVD {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFDB24\",\"DataLSB\":\"0x00FFDB24\",\"Repeat\":0}","title":"Smart Reveiver VX/CX"},{"location":"Codes-for-IR-Remotes/#bddvd-players","text":"","title":"BD/DVD players"},{"location":"Codes-for-IR-Remotes/#ir-remote-codes-sony-bd-s1500","text":"Common buttons should work across multiple models Eject {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x68B47\"} Power {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xA8B47\"} Red {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xE6B47\"} Green {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x16B47\"} Yellow {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x96B47\"} Bue {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x66B47\"} Top Menu {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x34B47\"} Popup/Menu {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x94B47\"} Return {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xC2B47\"} Options {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xFCB47\"} Home {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x42B47\"} Up {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x9CB47\"} Down {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x5CB47\"} Left {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xDCB47\"} Right {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x3CB47\"} Enter {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xBCB47\"} Favourites {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xBCB47\"} Netflix {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xD2B47\"} Play {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x58B47\"} Pause {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x98B47\"} Rew {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xD8B47\"} Fwd {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x38B47\"} Prev {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xEAB47\"} Next {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x6AB47\"} Stop {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x18B47\"} Subtitles {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xC6B47\"} Audio Track {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x26B47\"} Vol + {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x490\"} Vol - {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xC90\"} Mute {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x290\"}","title":"IR Remote Codes Sony BD-S1500"},{"location":"Codes-for-IR-Remotes/#projectors","text":"","title":"Projectors"},{"location":"Codes-for-IR-Remotes/#ir-remote-codes-acer-k132","text":"IR Remote Codes for Acer K132 projector (and possibly other models using a remote with Model No. M1820) ON/OFF {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8E11E\"} * Freeze {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8718E\"} * Hide {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8F10E\"} * Ratio {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C806F9\"} * Zoom {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8D12E\"} * Mode {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C801FE\"} * Source {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C831CE\"} * Back {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C832CD\"} * Up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C841BE\"} * Down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8A15E\"} * Left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8C13E\"} * Right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8817E\"} * Enter {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8B24D\"} * Menu {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C821DE\"} * Vol+ {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8C639\"} * Vol- {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C826D9\"} * Sound {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8AD52\"} * Mute {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C88679\"}","title":"IR Remote Codes Acer K132"},{"location":"Codes-for-IR-Remotes/#soundbars","text":"","title":"Soundbars"},{"location":"Codes-for-IR-Remotes/#ir-codes-soundbar-panasonic-scall70t","text":"Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"PANASONIC\",\"Bits\":48,\"Data\":\"0x40040500BCB9\"}} Example IRsend Command: IRsend {\"Protocol\":\"PANASONIC\",\"Bits\":48,\"Data\":0x40040500BCB9} 0x40040500BCB9=\"ON/OFF\" 0x400405004C49=\"Mute\" 0x400405000401=\"Vol+\" 0x400405008481=\"Vol-\" 0x40040538DFE2=\"OK\" 0x400405383F02=\"Up\" 0x40040538BF82=\"Down\" 0x40040538AD90=\"Setup\" 0x400405280D20=\"Sound\" 0x400405380538=\"Bluetooth\" 0x400405006164=\"Input\"","title":"IR Codes Soundbar Panasonic SCALL70T"},{"location":"Codes-for-IR-Remotes/#ir-codes-soundcore-infini-pro","text":"Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0xFD256897\"}} Example IRsend Command: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0xFD256897\"} 0xFD2502FD=\"ON/OFF\" 0xFD2518E7=\"Mute\" 0xFD2508F7=\"Input\" 0xFD259867=\"Bluetooth\" 0xFD2548B7=\"TV\" 0xFD256897=\"Vol+\" 0xFD2558A7=\"Vol-\" 0xFD258A75=\"Previous\" 0xFD250AF5=\"Next\" 0xFD25C837=\"Play/Pause\" 0xFD2554AB=\"Movie\" 0xFD255CA3=\"Music\" 0xFD2552AD=\"Voice\" 0xFD2532CD=\"Bass-\" 0xFD258877=\"Bass+\" 0xFD2538C7=\"Surround\"","title":"IR Codes Soundcore Infini Pro"},{"location":"Codes-for-IR-Remotes/#vacuum-cleaners","text":"","title":"Vacuum Cleaners"},{"location":"Codes-for-IR-Remotes/#ir-codes-vacuum-cleaner-ecovacs-deebot-slim2","text":"Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFD02F\"}} Example IRsend Command: IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x00FFD02F} 0x00FFD02F=\"Automatic Mode/Pause\" 0x00FF609F=\"Edge Cleaning\" 0x00FF40BF=\"Spot Cleaning\" 0x00FF708F=\"Back to Charging Base\" 0x00FFC837=\"Forward\" 0x00FFE01F=\"Left\" 0x00FFF00F=\"Right\" 0x00FFC03F=\"Back/Turn around\"","title":"IR Codes Vacuum Cleaner Ecovacs Deebot Slim2"},{"location":"Codes-for-IR-Remotes/#ventilation","text":"","title":"Ventilation"},{"location":"Codes-for-IR-Remotes/#ir-codes-prana-150-energy-recovery-ventilation","text":"See device https://prana.org.ua/models/prana_150 (Ukrainian) Example received Code: MQT: tele/sonoffir/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\"}} Example IRsend Command: IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\"} {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\"}=\"Power\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF807F\"}=\"Screen/LED Brightness\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF30CF\"}=\"Heat OFF\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF906F\"}=\"Heat ON\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF50AF\"}=\"Fan\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFA857\"}=\"Anti freeze\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFB04F\"}=\"Night Mode\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF708F\"}=\"Fan -\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF28D7\"}=\"Fan +\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF609F\"}=\"Night Mode Fan -\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF10EF\"}=\"Night Mode Fan +\"","title":"IR Codes Prana 150 energy recovery ventilation"},{"location":"Codes-for-IR-Remotes/#christmas-candle-weihnachtsbeleuchtung","text":"","title":"Christmas candle - Weihnachtsbeleuchtung"},{"location":"Codes-for-IR-Remotes/#krinner-lumix-ir-remote","text":"Remote control has two buttons and three channels. Button 1 is to switch on Button 0 is to switch off Double click on button 1 is flicker mode No usable protocol found yet, but raw mode does it. Example for HttpGetRequest and irsend sendHttpGetRequest(\"http://192.168.1.234/cm?cmnd=irsend5%200,2000,1000,%20400,1000,%20400,%20400,1000,1000,%20400,1000,%20400,%20400,1000,%20400,1000,%20400,1000,%20400,2000,5600\") off channel A irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1000, 400,1000, 400,2000,5600 on channel A irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,2000,5600 flicker channel A irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1100,1000, 400, 400,2000,5600 off channel B irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1000, 400,1000, 400,2000,5600 on channel B irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400,1000, 400,1000, 400, 400,2000,5600 flicker channel B irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1100,1000, 400, 400,2000,5600 off channel C irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1000, 400,1000, 400,2000,5600 on channel C irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,2000,5600 flicker channel C irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1100,1000, 400, 400,2000,5600","title":"Krinner Lumix IR Remote"},{"location":"Codes-for-IR-Remotes/#vinkor-flameless-flickering-candles-and-clones-probably","text":"on {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED00FF\",\"Repeat\":0} off {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED40BF\",\"Repeat\":0} dim {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED08F7\",\"Repeat\":0} bright {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED48B7\",\"Repeat\":0} candle {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED30CF\",\"Repeat\":0} light {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED708F\",\"Repeat\":0} 2H {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED20DF\",\"Repeat\":0} 4H {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED609F\",\"Repeat\":0} 6H {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED10EF\",\"Repeat\":0} 8H {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED50AF\",\"Repeat\":0}","title":"Vinkor Flameless Flickering Candles (and clones probably)"},{"location":"Codes-for-IR-Remotes/#led-candles-led-kerzen","text":"","title":"LED Candles / LED Kerzen"},{"location":"Codes-for-IR-Remotes/#duni-warm-white-led-candle-duni-warmwei-led-kerzen","text":"ON= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\"} OFF= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF807F\"} 4h= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF40BF\"} 8h= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFC03F\"} ModeCandle= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF20DF\"} ModeLight= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFA05F\"} ModeDark= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF906F\"} ModeBright= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFE01F\"} ModeMoon= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF10EF\"} ModeNightLight= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF609F\"}","title":"Duni Warm White LED Candle / Duni Warmwei\u00df LED Kerzen"},{"location":"Codes-for-IR-Remotes/#duni-multicoloured-led-candle-duni-mehrfarbige-led-kerzen","text":"ON_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F48B7\",\"DataLSB\":\"0x01FE12ED\"} OFF_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F807F\",\"DataLSB\":\"0x01FE01FE\"} ModeSmooth_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F58A7\",\"DataLSB\":\"0x01FE1AE5\"} ModeNightLight_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F7887\",\"DataLSB\":\"0x01FE1EE1\"} ModeCandle_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F40BF\",\"DataLSB\":\"0x01FE02FD\"} ModeLight_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FC03F\",\"DataLSB\":\"0x01FE03FC\"} ModeTimer_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F20DF\",\"DataLSB\":\"0x01FE04FB\"} ModeDark_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FA05F\",\"DataLSB\":\"0x01FE05FA\"} ModeBright_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F609F\",\"DataLSB\":\"0x01FE06F9\"} ColorRed_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FE01F\",\"DataLSB\":\"0x01FE07F8\"} ColorGreen_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F10EF\",\"DataLSB\":\"0x01FE08F7\"} ColorBlue_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F906F\",\"DataLSB\":\"0x01FE09F6\"} ColorOrange_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F50AF\",\"DataLSB\":\"0x01FE0AF5\"} ColorLightGreen_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FD827\",\"DataLSB\":\"0x01FE1BE4\"} ColorLightBlue_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FF807\",\"DataLSB\":\"0x01FE1FE0\"} ColorViolet_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F30CF\",\"DataLSB\":\"0x01FE0CF3\"} ColorYellow_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FB04F\",\"DataLSB\":\"0x01FE0DF2\"} ColorBlueWhite_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F708F\",\"DataLSB\":\"0x01FE0EF1\"} ColorPink_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F00FF\",\"DataLSB\":\"0x01FE00FF\"} ColorYellowWhite_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FF00F\",\"DataLSB\":\"0x01FE0FF0\"} ColorWhite_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F9867\",\"DataLSB\":\"0x01FE19E6\"}","title":"Duni Multicoloured LED Candle / Duni Mehrfarbige LED Kerzen"},{"location":"Commands/","text":"Tasmota provides a powerful control interface using commands Commands can be issued using MQTT , web requests , webUI console and serial How to use ~ Every command used without a parameter (payload) returns the current setting . Power returns the status of first defined power output (usually Relay1)\" Instead of 0 you can use off or false and instead of 1 you can use on or true . Power ON turns first defined power output (usually Relay1) on Power1 1 also turns first defined power output (usually Relay1) on Power1 True also turns first defined power output (usually Relay1) on Replace <x> in a command with the appropriate index number. Leave it empty to use the first available. Power1 and Power both control first defined power output (usually Relay1) In commands with x..y value parameters use a number from x to y range. When a command mentions resetting to \"firmware default\" it means the setting will revert to the one in the flashed binary file. If you used user_config_override.h at compile time it will revert to those. Note Beside results initiated by a command (synchronous) you can get asynchronous results initiated by rule trigger, telemetry event, commands from other source or changed device values. Simply put, other messages may precede messages published as a result of your commands. Example A tele/%topic%/STATUS message (sent every 300 seconds by default) may appear exactly after you issue Power off command and before you receive stat/%topic%/RESULT = {\"POWER\":\"OFF\"} message. with MQTT ~ To send commands and view responses you'll need an MQTT client . Commands over MQTT are issued by using cmnd/%topic%/<command> <parameter> where %topic% is the topic of the device you're sending the command to. If there is no <parameter> (an empty MQTT message/payload), a query is sent for current status of the <command> . See MQTT article to find out more. with Web Requests ~ Commands can be executed via web (HTTP) requests, for example: http://<ip>/cm?cmnd=Power%20TOGGLE http://<ip>/cm?cmnd=Power%20On http://<ip>/cm?cmnd=Power%20off http://<ip>/cm?user=admin&password=joker&cmnd=Power%20Toggle Any spaces or special characters must be replaced with their ASCII hex codes . You must precede each hex code with % . Most used codes are: space = %20 and ; = %3B . Tip Use URLencoder.org to easily convert your commands. If you have set a password for web user interface access, this must be included (in plaintext) in the URL of the HTTP request, like so: http://<ip>/cm?user=<username>&password=<password>&cmnd=Power%20On in Console in the Web UI ~ Console menu in the web UI is a convenient place to send commands and it behaves similar to a terminal connection via serial bridge. Warning The GUI controls do not and can not have all the features and commands implemented. For precise and complete control use Console commands! over Serial Bridge ~ If you flashed the device via serial method you can connect to it with a terminal application (e.g. Termite or Arduino IDE Serial Monitor) to issue commands and follow responses. This is a practical way to do a Backlog setup of your new device. Serial interface is set to 115200 bps except for devices that require a different baudrate the Power of Backlog ~ Backlog command allows executing up to 30 consecutive commands with a single command line. Each command is separated by a semicolon (\";\"). Backlog is a useful feature to avoid numerous restarts when setting up a new device. You can use it to: Set up both Wi-Fi AP's Backlog SSID1 < myssid > ; Password1 < mypassword > ; SSID2 < myssid2 > ; Password2 < mypassword2 > Configure MQTT broker address, MQTT credentials, device topic and activate a few custom options Backlog MqttHost < yourhost > ; MqttUser < user > ; MqttPassword < password > ; Topic < customtopic > ; SetOption53 1 ; PowerRetain on For specific power control, using backlog like a script Backlog Status 1 ; Power2 on ; Delay 20 ; Power2 off ; Status 4 When using web requests (Don't forget to encode \"space\" as '%20' and \";\" as '%3B') http://<ip>/cm?user=admin&password=joker&cmnd=Backlog%20Power%20Toggle%3BPower1%20ff A Backlog command without an argument clears an possible existing Backlog queue. Example in case of command Backlog Power1 OFF; Delay 600; Power1 ON the usage of an additional Backlog command without any argument within the delay time of 1 minute will delete the whole queue Power1 OFF; Delay 600; Power1 ON . Therefore Power1 ON command will not be executed and the power would remain off. Commands List ~ Warning If you're using Tasmota versions earlier current release some of the commands might not work. Availability of some features and their associated commands depend on the firmware build. Please consult the builds table for a reference of which features are available for each firmware variant. Note Almost all settings using string parameters (except Rule and MqttFingerprint ) share a common area with max 698 chars, i.e. the total length of all these parameters is limited to this size (you will be noted if this limit is exceeded). Control ~ Command Parameters Backlog List of commands to be executed in sequence separated by ; See Using Backlog for examples. BlinkCount Number of relay toggles ( blinks ) (does not control the status LED) 0 = blink many times before restoring power state 1..32000 = set number of blinks (default = 10 ) BlinkTime 2..3600 set duration, in 0.1 second increments, to blink aka toggle Power (does not control the status LED) ButtonDebounce User control over button debounce timing 40..1000 = set button debounce time in milliseconds (default = 50 ) Buzzer 0 = stop active buzzer cycle <count>,<beep>,<silence>,<tune> = read more... 2,3 = Beep twice with 300 milliseconds duration and 100 milliseconds pause 2,3,4 = Beep twice with 300 milliseconds duration and 400 milliseconds pause 1,2,3,0xF54 (0000 0000 0000 0000 0000 1111 0101 0100). Each 1 bit beeps for 200 milliseconds and each bounded 0 bit pauses for 300 milliseconds -1 = infinite mode -2 = follow LED mode DevGroupName<x> 0 = clear device group <x> name and restart <value> = set device group <x> name and restart. Prior to 8.2.0.3, GroupTopic was used to specify the device group name DevGroupSend<x> <item>=<value>[ ...] = send an update to device group <x>. The device group name must have been previously set with DevGroupName<x>. Multiple item/value pairs can be specified separated by a space. Spaces in <value> must be escaped with a backslash (\\). The message sent is also processed on the local device as if it had been received from the network. For items with numeric values, <value> can be specified as @<operator>[<operand>] to send a value after performing an operation on the current value. <operator> can be + (add), - (subtract) or ^ (invert). If <operand> is not specified, it defaults to 0xffffffff for the invert operator and 1 for other operators. 2 = Light fade (0 = Off, 1 = On) 3 = Light speed (1..40) 4 = Light brightness (0..255) 5 = Light Scheme 6 = Light fixed color (0 = white (using CT channels), other values according to Color Command ) 7 = PWM dimmer low preset (0..255) 8 = PWM dimmer high preset (0..255) 9 = PWM dimmer power-on brightness (0..255) 128 = Relay Power - bitmask with bits set for relays to be powered on. The number of relays can be specified in bits 24 - 31. If the number of relays is not specified, only relay 1 is set 192 = Event - event name and arguments 193 = Command - command and arguments 224 = Light channels - comma separated list of brightness levels (0..255) for channels 1 - 5 (e.g. 255,128,0,0,0 will turn the red channel on at 100% and the green channel on at 50% on an RBG light) Examples: DevGroupSend 4=90 128=1 - send an update to set the light brightness to 90 and turn relay 1 on. DevGroupSend 193=Buzzer\\ 2,3 - send the Buzzer 2,3 command. DevGroupSend 6=@+ 4=@-10 - set the next fixed color and decrease the brightness by 10. DevGroupSend 128=^ - toggle all the relays. DevGroupShare <in>,<out> = set incoming and outgoing shared items (default = 0xffffffff,0xffffffff ) . <in> and <out> are bit masks where each mask is the sum of the values for the categories (listed below) to be shared. For example, to receive only power (1), light brightness (2) and light color (16) and send only power (1), enter the command DevGroupShare 19,1. 1 = Power 2 = Light brightness 4 = Light fade/speed 8 = Light scheme 16 = Light color 32 = Dimmer settings (presets) 64 = Event DevGroupStatus<x> Show the status of device group <x> including a list of the currently known members. FanSpeed Fan speed control (iFan02/iFan03 only) 0 = turn fan OFF 1..3 = set fan speed + = increase fan speed - = decrease fan speed Interlock Relay interlock mode and group selection. 0 = disable relay interlock for all relays (i.e., each relay is self-locking) (default) 1 = set interlock mode for selected relays Add up to 8 relays in 1 to 4 interlock groups, each separated by a space. For example 1,2 3,4 = Group Relay1 and Relay2 in group 1 and Relay3 and Relay4 in group 2 ( note the space between the two groups ) 1,2,3 = group Relay1, Relay2 and Relay3 in a single interlock group 1 3 2,4 = Relay1 is in group 1, Relay3 in group 2, Relay2 and Relay4 in group 3 LedMask Set a bitmask specifiying which relays control the LED indicator. Read more... <bitmask> = bitwise value representing each relay. Values may be entered as either hexadecimal or decimal values (e.g., 0xFFFF = 65535). 0xFFFF (= 1111 1111 1111 1111) All relays control the power LED (default) LedState must be enabled (i.e., != 0 ) in order for LedMask to take effect. LedPower LED power state as on or off 0 = turn LED OFF and set LedState 0 1 = turn LED ON and set LedState 8 2 = toggle LED and set LedState 0 (Use Backlog LedPower 0; SetOption31 1 to disable LED even when Wi-Fi or MQTT is not connected) LedPower<x> LED<x> power state control. Enabled only when LedLink(i) is configured 0 = turn LED OFF and set LedState 0 1 = turn LED ON and set LedState 0 2 = toggle LED and set LedState 0 LedState Manage LED state 0 = disable use of LED as much as possible 1 = show power state on LED (LED on when power on) (default) (inverted for Sonoff Touch/T1) 2 = show MQTT subscriptions as a LED blink 3 = show power state and MQTT subscriptions as a LED blink 4 = show MQTT publications as a LED blink 5 = show power state and MQTT publications as a LED blink 6 = show all MQTT messages as a LED blink 7 = show power state and MQTT messages as a LED blink 8 = LED on when Wi-Fi and MQTT are connected. Cannot be issued directly and is only activated when LedPower is switched from 0 to 1 due to a software function NoDelay Delay defined by SetOption34 is omitted for any command in a backlog sequence following immediately after NoDelay This must be used with care, and only for simple commands. Example Power0 Control the power state simultaneously for all power outputs on the device 0 / off = turn OFF 1 / on = turn ON 2 / toggle = if relay is ON switch to OFF and vice versa Power<x> Control the corresponding power state ( 1..8 ) (also restarts PulseTime)<x> 0 / off / false = turn OFF 1 / on / true = turn ON 2 / toggle = if power state is ON switch to OFF and vice versa 3 / blink = toggle power for BlinkCount times each BlinkTime duration (at the end of blink , power state is returned to pre-blink state) 4 / blinkoff = stop blink sequence and return power state to pre-blink state PowerOnState Control power state when the device is powered up . More information 0 / OFF = keep power(s) OFF after power up 1 / ON = turn power(s) ON after power up 2 / TOGGLE = toggle power(s) from last saved state 3 = switch power(s) to their last saved state (default) 4 = turn power(s) ON and disable further power control 5 = after a PulseTime period turn power(s) ON (acts as inverted PulseTime mode) PulseTime<x> Display the amount of PulseTime remaining on the corresponding Relay<x> <value> Set the duration to keep Relay<x> ON when Power<x> ON command is issued. After this amount of time, the power will be turned OFF . 0 / OFF = disable use of PulseTime for Relay<x> 1..111 = set PulseTime for Relay<x> in 0.1 second increments 112..64900 = set PulseTime for Relay<x>, offset by 100, in 1 second increments. Add 100 to desired interval in seconds, e.g., PulseTime 113 = 13 seconds and PulseTime 460 = 6 minutes (i.e., 360 seconds) SwitchDebounce User control over switch debounce timing and method 40..1000 = set switch debounce time in milliseconds (default = 50 ) . The granularity is 10 milliseconds, so the normally unnecessary last digit is used by the debouncing code to flag special handling: 0 = no special handling 1 = force_high: only a debounce time long LOW pulse could turn the switch off 2 = force_low: only a debounce time long HIGH pulse could turn the switch on 3 = force_high + force_low 4..8 = unused 9 = AC detection for switches / relays similar to MOES MS-104B / BlitzWolf SS5 etc. If the AC frequency is 50 Hz, SwitchDebounce 69 will turn on the switch after three pulses and off after three missing one. SwitchMode<x> Switch mode 0 = toggle (default) 1 = follow (0 = off, 1 = on) 2 = inverted follow (0 = on, 1 = off) 3 = pushbutton (default 1, 0 = toggle) 4 = inverted pushbutton (default 0, 1 = toggle) 5 = pushbutton with hold (default 1, 0 = toggle, Hold = hold) 6 = inverted pushbutton with hold (default 0, 1 = toggle, hold = hold) 7 = pushbutton toggle (0 = toggle, 1 = toggle) 8 = multi change toggle (0 = toggle, 1 = toggle, 2x change = hold) 9 = multi change follow (0 = off, 1 = on, 2x change = hold) 10 = inverted multi change follow (0 = on, 1 = off, 2x change = hold) 11 = pushbutton with dimmer mode 12 = inverted pushbutton with dimmer mode 13 = pushon mode (1 = on, switch off using PulseTime ) 14 = inverted pushon mode (0 = on, switch off using PulseTime ) SwitchText<x> Show current JSON label of Switch<x> ( 1..8 ). Only SwitchText shows value for all 8 switches <text> - replace default Switch<x> label in JSON messages with a custom text Webbutton<x> Change the name of the toggle buttons of the WEB UI. This command accepts spaces in the name See also SetOption1 - Set button multipress mode SetOption11 - Swap pushbutton single and double press functionality SetOption13 - Allow immediate action on single button press SetOption26 - Use indexes even when only one relay is present SetOption31 - Disable Wi-Fi LED status blinking SetOption32 - Set hold interval before sending HOLD action SetOption40 - Stop detecting any input change on button GPIO SetOption67 - Enable/Disable Buzzer SetOption73 - Decouple buttons from controlling power outputs Management ~ Command Parameters Delay 2..3600 = set delay between two backlog commands with 0.1 second increment DeepSleepTime Time to enter deep sleep mode 0 = disable deep sleep mode (default) 11..86400 = set deep sleep mode time period in seconds DeviceName Device name displayed in the webUI and used for HA autodiscovery. <value> = set device name (default = FriendlyName1 value) Emulation 0 = disable emulation (default) 1 = enable Belkin WeMo emulation for Alexa 2 = enable Hue Bridge emulation for Alexa FriendlyName<x> 1 = Reset friendly name to firmware default <value> = set friendly name (32 char limit) Gpios Show list of available components by name and index 255 / All Show list of all components by name and index Gpio Show current component assignments of the Module's configurable GPIO 255 / All Show component assignments for all the devices available GPIO Gpio<x> <component> = assign a component to Gpio<x> I2Cscan Scan I 2 C bus and show addresses for found devices I2CDriver Enable / Disable I 2 C sensor drivers. Read more... LogHost 1 = reset syslog host to firmware default ( SYS_LOG_HOST ) <value> = set syslog host LogPort 1 = reset syslog port to firmware default ( SYS_LOG_PORT ) 2..32766 = set syslog port Modules Show available modules by name and index Module Displays active module by name and index <value> = switch to module <value> and restart 0 = switch to defined template and restart Module2 Displays active fast reboot fallback module by name and index <value> = set fast reboot fallback module to <value> 0 = set fast reboot fallback module to defined template MqttLog 0 = disable logging via MQTT (default) 1 = show only error messages 2 = show error and info messages 3 = show error, info and debug messages 4 = show error, info and more debug messsages NtpServer<x> NTP server setup (x= 1..3 ) 0 = clear NtpServer<x> settings 1 = reset NtpServer<x> settings to firmware defaults <value> = set NtpServer<x> host or IP address (32 char limit) OtaUrl Display current OTA URL 1 = Reset OtaUrl to firmware default url = set address for OTA (100 char limit) Pwm<x> 0..1023 = set PWM value for channel PwmFrequency 1 = reset PWM frequency to 223Hz 100..4000 = set PWM frequency (100Hz to 4kHz) As of v8.3.0 the default frequency changed to 977Hz PwmRange 1 = reset maximum PWM range to 1023 255..1023 = set maximum PWM range Reset 1 = reset device settings to firmware defaults and restart 2 = erase flash, reset device settings to firmware defaults and restart 3 = erase System Parameter Area in flash (Wi-Fi calibration and related data) and restart 4 = reset device settings to firmware defaults but retain Wi-Fi credentials and restart 5 = erase all flash and reset parameters to firmware defaults but keep Wi-Fi settings and restart 6 = erase all flash and reset parameters to firmware defaults but keep Wi-Fi and MQTT settings and restart (Erase of flash can take a few seconds to complete and there is no output during the erase process on the serial or web console) 99 = reset device bootcount to zero Restart 1 = restart device with configuration saved to flash 2 = halt system (needs hardware reset or power cycle to restart) 99 = force restart device without configuration save For debug and testing stack trace dumps only: -1 = force an Exception (28) crash -2 = force a Soft WDT reset (after a freeze of 2 seconds) -3 = force an OS watchdog reset (after a freeze of 120 seconds, caution! ) SaveData 0 = save parameter changes only manually, e.g. with Restart 1 1 = save parameter changes every second (default) 2..3600 = save parameter changes every x second SerialLog Disable hardware serial bridge and 0 = disable serial logging 1 = show only error messages 2 = show error and info messages (default) 3 = show error, info and debug messages 4 = show error, info and more debug messages SerialLog will be disabled automatically 10 minutes after the device reboots. Sleep 0 = turn sleep off 1..250 = set sleep duration in milliseconds to enable energy saving (default = 50 ) State Display current device state and publish to %prefix%/%topic%/RESULT topic\u2003 Status = show abbreviated status information 0 = show all status information (1 - 11) 1 = show device parameters information 2 = show firmware information 3 = show logging and telemetry information 4 = show memory information 5 = show network information 6 = show MQTT information 7 = show time information 8 = show connected sensor information 9 = show power thresholds (only on modules with power monitoring) 10 = same as Status 8 (retained for backwards compatibility) 11 = show information equal to TelePeriod state message 12 = in case of crash to dump the call stack saved in RT memory SysLog 0 = disable syslog logging (default) 1 = show only error messages 2 = show error and info messages 3 = show error, info and debug messages 4 = show error, info and more debug messages Template Show current Template 0 = create template from active module x = create template from a supported module 255 = merge current module and template settings into new template { ... } = store template in a JSON payload Does not activate the template. To activate use Module 0 . Time 0 = enable NTP (default) 1 = format JSON message timestamp in ISO format 2 = format JSON message timestamp in both ISO and Epoch format 3 = format JSON message timestamp in Epoch format 4 = format JSON message timestamp in milliseconds <value> = disable NTP and set UTC time as epoch value if greater than 1451602800 (January 1, 2016) TimeSTD TimeDST Set policies for the beginning of daylight saving time (DST) and return back to standard time (STD)\u2003 0 = reset parameters to firmware defaults H , W , M , D , h , T H = hemisphere ( 0 = northern hemisphere / 1 = southern hemisphere) W = week ( 0 = last week of month, 1..4 = first .. fourth) M = month ( 1..12 ) D = day of week ( 1..7 1 = sunday 7 = saturday) h = hour ( 0..23 ) T = timezone ( -780..780 ) (offset from UTC in MINUTES - 780min / 60min=13hrs) Example: TIMEDST 1,1,10,1,2,660 _If timezone is NOT 99, DST is not used (even if displayed) see Timezone -13..+13 = set timezone offset from UTC in hours -13:00..+13:00 = set timezone offset from UTC in hours and minutes 99 = use timezone configured with TimeDST and TimeSTD Upgrade 1 = download firmware from OtaUrl and restart <value> = download firmware from OtaUrl if <value> is higher than device version Upload 1 = download firmware from OtaUrl and restart <value> = download firmware from OtaUrl if <value> is higher than device version WebLog 0 = disable web logging 1 = show only error messages 2 = show error and info messages (default) 3 = show error, info and debug messages 4 = show error, info and more debug messages See also SetOption68 - PWM Channel control SetOption76 - DeepSleep disable bootcount incrementing Wi-Fi ~ Command Parameters AP 0 = switch to other Wi-Fi Access Point 1 = select Wi-Fi Access Point 1 2 = select Wi-Fi Access Point 2 CORS \" = disable CORS (Cross Origin Resource Sharing) (default) * = enable CORS for all locations value = Enable CORS for location. This needs to be complete url ex: http://tasui.shantur.com Hostname 1 = reset hostname to MQTT_TOPIC-<4digits> and restart <value> = set hostname (32 char limit) and restart. If hostname contains % it will be reset to the default instead. If using MQTT to issue this command, if it is used with the device GroupTopic , the command will not be executed. IPAddress<x> Set networking IP ( XXX.XXX.XXX.XXX ) addresses IPAddress1 = set device IP address 0.0.0.0 = use dynamic IP address (DHCP) XXX.XXX.XXX.XXX = set static IP address IPAddress2 = set gateway IP address IPAddress3 = set subnet mask IPAddress4 = set DNS server IP address follow IPAddress commands with restart 1 to apply changes Password<x> <x> = 1..2 <value> = set AP<x> Wi-Fi password and restart 1 = reset AP<x> Wi-Fi password to firmware default ( STA_PASS1 or STA_PASS2 ) and restart Passwords are limited to 64 characters. Do not use special characters or white spaces in the password . Note that Password and Password1 are equivalent commands. Ping<x> <addr> <x> = 0..8 = the number of ICMP packets to send, 0 uses the default (4) <addr> = address to send Ping, either in numerical format 192.168.1.200 or domain name tasmota.com (requires #define USE_PING ) Example Ping4 192.168.1.203 : RSL: tele/tasmota_xxx/RESULT = {\"Ping\":{\"192.168.1.203\":{\"Reachable\":true,\"Success\":4,\"Timeout\":0,\"MinTime\":59,\"MaxTime\":167,\"AvgTime\":116}}} Ssid<x> <x> = 1..2 <value> = set AP<x> Wi-Fi SSID and restart 1 = reset AP<x> Wi-Fi SSID to firmware default ( STA_SSID1 or STA_SSID2 ) and restart SSID are limited to 32 characters. Do not use special characters or white spaces in the SSID WebColor<x> Configure Web GUI colors (x = 1..19 ) #RRGGBB = Set color for WebColor<x> 1 = Global text (Black) 2 = Global background (White) 3 = Form background (Greyish) 4 = Input text (Black) 5 = Input background (White) 6 = Console text (Black) 7 = Console background (White) 8 = Warning text (Red) 9 = Success text (Green) 10 = Button text (White) 11 = Button (Blueish) 12 = Button hovered over (Darker blueish) 13 = Restart/Reset/Delete button (Redish) 14 = Restart/Reset/Delete button hover (Darker reddish) 15 = Save button (Greenish) 16 = Save button hover (Darker greenish) 17 = Config timer tab text (White) 18 = Config timer tab background (Light grey) 19 = Module title and FriendlyName text (Whiteish) User themes WebPassword Show current web server password 0 = disable use of password for web UI 1 = reset password to firmware default ( WEB_PASSWORD ) <value> = set web UI password (32 char limit) for user WEB_USERNAME (Default WEB_USERNAME = admin ) WebRefresh Web page refresh 1000..10000 = set refresh time in milliseconds (default = 2345 ) WebSend Send a command to Tasmota host over http. If a command starts with a / it will be used as a link. [<host>:<port>,<user>:<password>] <command> <host> = hostname or IP address. <port> = port for the device if not the default 80 <user> = enter username of the device you're sending the command to <password> = enter password of the device you're sending the command to <command> = command and payload example 1: [<ip>] POWER1 ON sends http://<ip>/cm?cmnd=POWER1 ON example 2: WebSend [myserver.com] /fancy/data.php?log=1234 sends http://myserver.com/fancy/data.php?log=1234 WebSensor<x> Control display of sensor telemetry in the web UI 0 = Do not display sensor's telemetry 1 = Display sensor's telemetry ( default ) <x> = number corresponding to the sensor - listed in the sns section of the supported sensor spreadsheet <x> = 3 Energy telemetry Issue a Status 4 to obtain a list of sensor types enabled in the firmware loaded on the device. WebServer 0 = stop web server 1 = start web server in user mode 2 = start web server in admin mode WifiConfig 0 = disable Wi-Fi Manager and reboot (used with alternate AP) 2 = set Wi-Fi Manager as the current configuration tool and start Wi-Fi Manager (web server at 192.168.4.1) for 3 minutes, then reboot and try to connect Wi-Fi network 4 = retry other AP without rebooting (default) 5 = wait until selected AP is available again without rebooting 6 = Wi-Fi parameters can only be entered via commands in the serial console 7 = set Wi-Fi Manager (web server at 192.168.4.1) as the current configuration tool restricted to reset settings only. This setting is recommended for devices without an external control/reset button . \u2003 No longer supported 1 = set SmartConfig ( Android /iOS) for 3 minutes 3 = set WPS for 3 minutes WifiPower set Wi-Fi transmit power level in decibel-milliwatts (dBm) (default = 17 ) See also SetOption55 - mDNS service control SetOption56 - Wi-Fi network scan to select strongest signal on restart SetOption57 - Wi-Fi network re-scan, alternate AP MQTT ~ Command Parameters ButtonRetain 0 = disable use of MQTT retain flag (default) 1 = enable MQTT retain flag on button press ButtonTopic <value> = set MQTT button topic 0 = disable use of MQTT button topic 1 = set MQTT button topic to device %topic% 2 = reset MQTT button topic to firmware default ( MQTT_BUTTON_TOPIC ) (default = 0 ) If using MQTT to issue this command, if it is published to the device GroupTopic , the command will not be executed. FullTopic 1 = reset MQTT fulltopic to firmware default ( MQTT_FULLTOPIC ) and restart <value> = set MQTT fulltopic and restart. Use of optional %prefix%, %topic%, %hostname%, and %id% substitution tokens is allowed. If using MQTT to issue this command, if it is published to the device GroupTopic , you must ensure uniqueness of the resulting fulltopic on each destination device by using one or more of these substitution tokens. GroupTopic<x> 1 = reset MQTT group <x> topic to firmware default ( MQTT_GRPTOPIC ) and restart <value> = set MQTT group <x> topic and restart MqttClient 1 = reset MQTT client to firmware config ( MQTT_CLIENT_ID ) and restart <value> = set MQTT client and restart. You can use the %06X substitution token to replace with last six characters of MAC address. If using MQTT to issue this command, if it is used with the device GroupTopic , the command will not be executed. MqttFingerprint TLS needs to be enabled in firmware for this command \u2003 <value> = set current fingerprint as 20 space separated bytes (59 chars max) MqttHost 0 = clear MQTT host field and allow mDNS to find MQTT host 1 = reset MQTT host to firmware default ( MQTT_HOST ) and restart <value> = set MQTT host and restart (do NOT use .local ) MqttPassword 0 = clear MQTT password 1 = reset MQTT password to firmware default ( MQTT_PASS ) and restart <value> = set MQTT password and restart MqttPort 1 = reset MQTT port to firmware default ( MQTT_PORT ) and restart <value> = set MQTT port between 2 and 32766 and restart MqttRetry 10..32000 = set MQTT connection retry timer in seconds (default = 10 ) MqttUser 0 = clear MQTT user name 1 = reset MQTT user name to firmware default ( MQTT_USER ) and restart <value> = set MQTT user name and restart PowerRetain MQTT power retain state 0 / off = disable MQTT power retain on status update (default) 1 / on = enable MQTT power retain on status update Prefix1 1 = reset MQTT command subscription prefix to firmware default ( SUB_PREFIX ) and restart <value> = set MQTT command subscription prefix and restart Prefix2 1 = reset MQTT status prefix to firmware default ( PUB_PREFIX ) and restart <value> = set MQTT status prefix and restart Prefix3 1 = Reset MQTT telemetry prefix to firmware default ( PUB_PREFIX2 ) and restart <value> = set MQTT telemetry prefix and restart Publish <topic> <payload> = MQTT publish any topic and optional payload\u2003 Publish2 <topic> <payload> = MQTT publish any topic and optional payload with retain flag SensorRetain 0 = disable use of sensor MQTT retain flag (default) 1 = enable MQTT retain flag on message tele/%topic%/SENSOR StateText<x> <value> = set state text ( <x> = 1..4 ) 1 = OFF state text 2 = ON state text 3 = TOGGLE state text 4 = HOLD state text SwitchRetain 0 = disable use of MQTT retain flag (default) 1 = enable MQTT retain flag on switch press Subscribe Subscribes to an MQTT topic and assigns an Event name to it. <eventName>, <mqttTopic> [, <key>] = Read more... = list all topics currently subscribed SwitchTopic <value> = set MQTT switch topic 0 = disable use of MQTT switch topic 1 = set MQTT switch topic to device %topic% 2 = reset MQTT switch topic to firmware default ( MQTT_SWITCH_TOPIC ) (default = 0 ) Read more about this. If using MQTT to issue this command, if it is used with the device GroupTopic , the command will not be executed. TelePeriod See current value and force publish STATE message 0 = disable telemetry messages 1 = reset telemetry period to firmware default ( TELE_PERIOD ) 10..3600 = set telemetry period in seconds (default = 300 ) Topic 1 = reset MQTT topic to firmware default ( MQTT_TOPIC ) and restart <value> = set MQTT topic and ButtonTopic and restart. If using MQTT to issue this command, if it is used with the device GroupTopic , the command will not be executed. * Topic can not be identical to MqttClient ** Unsubscribe Unsubscribe from topics subscribed to with Subscribe = unsubscribe all topics <eventName> = unsubscribe from a specific MQTT topic See also SetOption3 - Disable//Enable MQTT SetOption4 - Return MQTT response as RESULT or %COMMAND% topic SetOption10 - Main topic change behavior Rules ~ Command Parameters Add<x> <value> = add value to Var<x> ( example ) CalcRes Current calculation resolution 0..7 = set number of decimal places to be used in Add , Sub , Mult and Scale Event Execute an event to trigger a rule as documented \u2003 Mem<x> Manage up to 16 variables stored on flash (x = 1..16 ) Mem returns all current values. Mem<x> returns the variable's current value. <value> = store a string value in a variable \" = clear stored value in Mem<x> Mult<x> <value> = multiply value to Var<x> ( example ) Rule<x> Rules. Read more... 0 = disable Rule<x> 1 = enable Rule<x> 2 = toggle Rule<x> 4 = disable one-shot detection (perform commands as long as trigger is met) 5 = enable one-shot (e.g., sometimes used for slow changing sensors like temperature) detection 6 = toggle one-shot detection 8 = disable stop-on-error after exception restart 9 = enable stop-on-error after exception restart 10 = toggle stop-on-error after exception restart <value> = define Rule<x> +<value> = append to Rule<x> \" = clear Rule<x> Rule set one-shot: Each rule within the rule set will trigger only once until the trigger condition returns to a false condition. For example, ON Energy#Power<3 : Without one-shot enabled, it will trigger anytime Energy#Power gets an update (i.e., the Power telemetry value changes) and the value is <3 . This can potentially trigger that rule multiple times. With one-shot enabled, the rule will trigger only the on the first transition to <3 and not again until the trigger value goes >=3 . In other words, the rule will trigger again, but it has to cross the conditional \"boundary\" before it will trigger again. Rule0 Same functionality as Rule<x> but affects all rulesets at once RuleTimer<x> Up to eight timers to be used as countdown event (x = 1..8 )\u2003 0..65535 = set countdown rule timer in seconds Scale<x> Scale value from a low and high limit to another low and high limits and save in Var<x> ( example ) v = value: the number to scale fl = fromLow: the lower bound of the value\u2019s current range fh = fromHigh: the upper bound of the value\u2019s current range tl = toLow: the lower bound of the value\u2019s target range th = toHigh: the upper bound of the value\u2019s target range Sub<x> <value> = subtract value to Var<x> ( example ) Var<x> Manage up to 16 variables stored in memory (x = 1..16 ) Var returns all current values. Var<x> returns the variable's current value. <string> = store a string value in a variable \" = clear stored value in Var<x> Timers ~ Command Parameters Latitude <value> = set latitude in decimal degrees format, e.g. -33.893681 Longitude <value> = set longitude in decimal degrees format, e.g. 18.619954 Timers Timers control 0 = disable all timers 1 = enable all timers 2 = toggle all timers Timer<x> Parameters for Timer<x> where x = 1..16 0 = clear parameters for Timer<x> 1..16 = copy Timer<y> parameters to Timer<x> { \"name\":value ; .. } = set all or individual parameters using JSON payload with names and values of data pairs from the table Information on sensors documented below is transmitted in the Tasmota telemetry message Sensors ~ Command Parameters AdcParam ADC analog input tuning parameters <sensor>, <param1>, <param2>, <param3>, <param4> <sensor> values: \u2003 2 = Temperature Steinhart-Hart thermistor equation parameters: <param1> = NTC Voltage bridge resistor in Ohms (default = 32000 ) <param2> = NTC Resistance in Ohms (default = 10000 ) <param3> = NTC Beta Coefficient (default = 3350 ) \u2003 3 = Light Lux equation parameters: <param1> = LDR Voltage bridge resistor in Ohms (default = 10000 ) <param2> = LDR Lux Scalar (default = 12518931 ) <param3> = LDR Lux Exponent (default = -1.4050 ) \u2003 6 = ADC linear range remapping parameters: <param1> = input range low value adcLow (default = 0 ) <param2> = input range high value adcHigh (default = 1023 ) <param3> = output range low value rangeLow (default = 0 ) <param4> = output range high value rangeHigh (default = 100 ) The range remapping perform the following calculation on the ADC value [0..1023] : Range = ((adcHigh - ADC) / (adcHigh - adcLow)) * (rangeLow - rangeHigh) + rangeHigh The calculation is performed in double resolution floating point but all 4 parameters as well as the range output are unsigned 16 bit integers. The calculation result must not exceed [0..65535]. Example to convert the ADC value on a D1-mini into millivolts (using the default resistor bridge of 220k/100k): AdcParam 6, 0, 1023, 0, 3200 \u2003 7 = CT POWER parameter adjustments: <param1> = ANALOG_CT_FLAGS (default 0 for a non-invasive current sensor). When value is >0 its sets the adcLow value as base for the measurement via OpAmp differential amplifier. <param2> = ANALOG_CT_MULTIPLIER ( 2146 = Default settings for a (AC) 20A/1V Current Transformer.) multiplier*100000 to convert raw ADC peak to peak range 0..1023 to RMS current in Amps. Value of 100000 corresponds to 1 <param3> = ANALOG_CT_VOLTAGE (default 2300) to convert current in Amps to apparent power in Watts using voltage in Volts*10. Value of 2200 corresponds to AC220V. For DC its Volt/1000. Eg. 12VDC = 0.012. AdcParam 7,406,3282,0.012 Altitude -30000..30000 = altitude in meters AmpRes Current sensor resolution 0..3 = maximum number of decimal places BH1750Resolution<x> BH1750 resolution mode. x = BH1750 sensor number ( 1..2 ) 0..2 = choose sensor resolution ( 0 = high (default) , 1 = high2, 2 = low) BH1750MTime<x> BH1750 Measurement Time value. x = BH1750 sensor number ( 1..2 ) 30..255 = set Measurement Time value. Not persistent after reboot. (default = 69 ) Counter<x> 0 = reset Counter<x> 1..64900 = preset Counter<x> -1..-64900 = decrease Counter<x> +1..+64900 = increase Counter<x> In order to define and use a Counter, * you must configure one of the free device GPIO as Counter<x> . Counter module configuration is using internal pull-up resistor while Counter n does not. * CounterDebounce 0 = turn off counter debounce 1..32000 = set counter debounce time in milliseconds. Counter is increased with every falling edge when CounterType =0 or time between successive falling edges is measured when CounterType =1. When CounterDebounceLow and CounterDebounceHigh are set to zero (default) only falling edges of the counter's GPIO are checked. Any CounterDebounceLow or CounterDebounceHigh unequal zero checks are carried out befor CounterDebounce check is done. As an example you can set CounterDebounce 500 to allow a minimum distance between to succesive valid falling edges equal to 500ms. CounterDebounceLow 0 = turn off counter debounce low 1..32000 = set counter debounce low time in milliseconds. Allow individual debounce times for low pulse widths to discard non valid falling edges. These are checked before legacy CounterDebounce checks distance between two valid falling edges. When unequal zero tasmota will check falling and rising edges on the counter's GPIO. For CounterDebounceLow any GPIO change from low to high hat happens after the GPIO was not low for at least CounterDebounceLow will be ignored. As an example you can set CounterDebounceLow 50 to allow a valid minimum distance between a falling and rising edge equal to 50ms while having a final CounterDebounce 500 check between to succesive valid falling edges equal to 500ms. CounterDebounceHigh 0 = turn off counter debounce high 1..32000 = set counter debounce high time in milliseconds. Allow individual debounce times for high pulse widths to discard non valid falling edges. These are checked before legacy CounterDebounce checks distance between two valid falling edges. When unequal zero tasmota will check falling and rising edges on the counter's GPIO. For CounterDebounceHigh any GPIO change from high to low hat happens after the GPIO was not high for at least CounterDebounceHigh will be ignored. As an example you can set CounterDebounceHigh 100 to allow a valid minimum distance between a rising and falling edge equal to 100ms while having a final CounterDebounce 500 check between to succesive valid falling edges equal to 500ms. CounterType<x> 0 = set Counter<x> as pulse Counter 1 = set Counter<x> as pulse Timer GlobalHum 0.0..100.0 = Set global Humidity for some Sensors that uses global Humidity. GlobalTemp -50.0..100.0 = Set global Temperature for some Sensors that uses global temperature. HumOffset -10.0..10.0 = Set calibraton offset value for reported humidity telemetry This setting affects all humidity sensors on the device. HumRes Humidity sensor resolution 0..3 = maximum number of decimal places PressRes Pressure sensor resolution 0..3 = maximum number of decimal places Sensor13 INA219 low voltage current sensor calibration mode Predefined modes to use with standard 0.1 ohm resistor: 0 = set INA219 calibration to max 32V and 2A 1 = set INA219 calibration to max 32V and 1A 2 = set INA219 calibration to max 16V and 0.4A 10 .. 255 : Define custom shunt resistor encoded as a decimal number RRM such that Rshunt = RR * 10^M milliohm Do not forget to choose a resistor adapted for the correct power dissipation and apply a 50% security margin ! Examples: 11 = 1 * 10^1 = 10 milliohm (Imax=32A => Pres=15W) 21 = 2 * 10^1 = 20 milliohm (Imax=16A => Pres=7W) 12 = 1 * 10^2 = 100 milliohm (default, Imax=3.2A => Pres=2W) 13 = 1 * 10^3 = 1000 milliohm = 1 ohm (Imax=0.320A => Pres=0,2W) Sensor15 Automatic Baseline Correction for MH-Z19B CO 2 sensor 0 = disabled 1 = enabled (default) 2 = start manual calibration from 400 ppm of CO 2 9 = reset sensor to factory defaults 1000 = sets measurement range to 1000ppm CO 2 2000 = sets measurement range to 2000ppm CO 2 3000 = sets measurement range to 3000ppm CO 2 5000 = sets measurement range to 5000ppm CO 2 Sensor18 PMSx003 particle dust sensor 0..32000 = control sensor polling interval to extend lifetime Sensor20 Nova Fitness SDS011 dust sensor. 1..255 = number of seconds before TelePeriod to poll the sensor Sensor27 APDS-9960 sensor commands 0 = enable light level and proximity sensor / disable gestures (default) 1 = enable gesture mode/ disable light level and proximity sensor 2 = enable gestures with half gain / disable light and proximity sensor 3..255 = Set ATIME register for different integration times Sensor29 MCP23008 / MCP23017 I 2 C GPIO Expander configuration. Read more... Reset<x> = reset all pins x = 1..6 1 = INPUT mode, no reporting, no pull-up 2 = INPUT mode, report on CHANGE, pull-up enabled 3 = INPUT mode, report on LOW, pull-up enabled 4 = INPUT mode, report on HIGH, pull-up enabled 5 = OUTPUT mode (if enabled by #define USE_MCP230xx_OUTPUT ) 6 = inverted OUTPUT mode (if enabled by #define USE_MCP230xx_OUTPUT ) pin,pinmode{,intpullup|outstate{,repmode}} Continue reading... Sensor34 HX711 load cell sensor calibration 1 = reset display to 0 2 = start calibration 2 <value> = set reference weight in grams and start calibration 3 = show reference weight in grams 3 <value> = set reference weight in grams 4 = show calibrated scale value 4 <value> = set calibrated scale value 5 = show max weight in gram 5 <value> = set max weight in grams 6 = show single item weight in grams 6 <value> = set single item weight in grams. Once the item weight is set, when items are added to the scale, the telemetry message will report Count as the number of items on the scale 7 = save current weight to be used as start weight on restart 8 0/1 \u2003 0 = disable JSON message on weight change over 4 grams \u2003 1 = enable JSON message on weight change (see below) 9 <value> = set minimum delta to trigger JSON message (see above). \u2003 0 = 4 grams (old default) \u2003 1..100 = set delta to 0-99 grams \u2003 101-255 = set delta to 110-1650 grams (10g increments) Sensor50 PAJ7620 gesture sensor 0 = sensor muted, no readings in Tasmota 1 = gesture mode 2 = proximity mode 3 = corner mode 4 = PIN mode 5 = cursor mode Sensor52 iBeacon driver with HM10 or HM17/HM16 1 and 2 = required only once to initialize the module u<x> = sets update interval in seconds (scan tags every <x> seconds) (default = 10) t<x> = set timeout interval in seconds (send RSSI=0 if tag is not detected after <x> seconds) (default = 30) d1 = enable debug mode (shows all serial traffic in console) d0 = disable debug mode_(default = 30)_ c = clears iBeacon list s AT+<command> = send native AT commands Sensor53 Smart Meter Interface r = reset the driver with a new descriptor specified with the Tasmota Scripting language. c<x> <value> = preset counter (x = 1..5 ) to value when the driver is set to counter mode d<x> = disable data decoding and dump meter (x = 1..5 ) data to the Console. This is used to decipher the meter's data format to define the variable encoding in the meter's descriptor. d0 = disable data dump mode and revert to decoding mode. Sensor54 INA226 Current Sensor 1 = rescan for devices and return the number found. 2 = save the configuration and restart 10 = return channel 1 shunt resistance and full scale current 11 <resistance> = set INA226 channel 1 shunt in ohms, floating point 12 <current> = set INA226 channel 1 full scale in amperes, floating point 20 = return channel 2 shunt resistance and full scale current 21 <resistance> = set INA226 channel 2 shunt in ohms, floating point 22 <current> = set INA226 channel 2 full scale in amperes, floating point 30 = return channel 1 shunt resistance and full scale current 31 <resistance> = set INA226 channel 1 shunt in ohms, floating point 32 <current> = set INA226 channel 1 full scale in amperes, floating point 40 = return channel 1 shunt resistance and full scale current 41 <resistance> = set INA226 channel 1 shunt in ohms, floating point 42 <current> = set INA226 channel 1 full scale in amperes, floating point Sensor60 GPS 0 = write to all available sectors, then restart and overwrite the older ones 1 = write to all available sectors, then restart and overwrite the older ones 2 = filter out horizontal drift noise 3 = turn off noise filter 4 = start recording, new data will be appended 5 = start new recording, old data will lost 6 = stop recording, download link will be visible in webUI 7 = send mqtt on new postion + TELE (consider to set TELE to a very high value) 8 = only TELE message 9 = start NTP server 10 = deactivate NTP server 11 = force update of Tasmota-system-UTC with every new GPS-time-message 12 = do not update of Tasmota-system-UTC with every new GPS-time-message 13 = set latitude and longitude in settings 14 = open virtual serial port over TCP, usable for u-center 15 = pause virtual serial port over TCP Sensor68 WindMeter sensor - Analog (pulse count) anemometer 1, <value> = set radius length in millimeters (measured from centre to the edge of one of the cups) 0..65535 (default = 61 mm) 2, <value> = set number of pulses for a complete turn 1..255 (default = 1 ) 3, <value> = set pulse counter debounce time in milliseconds 1..32000 (default = 10 ) 4, <value> = set speed compensation factor, a multiplication coefficient to adjust resulting speed -32.768..32.767 three decimal places (default = 1.180 ) 5, <value> = set minimum percentage change between current and last reported speed trigger a new tele message 0..100 , 255 = off (default = 255 ) Sensor78 EZO sensors - commands Ascii commands are sent directly to the sensor as-is. See your specific EZO device datasheet for the list of commands available. By default, the specific command is sent to all EZO devices that are found. If using multiple EZO sensors, and the command should be issued to a single device, the index can be specified as part of the command: Sensor78-# where # represent the index of the device (ex: Sensor78-1 i). For more details please see Tasmota's support for EZO devices . SpeedUnit TX20/TX23 and WindMeter anemometer speed unit 1 = m/s 2 = km/h 3 = kn 4 = mph 5 = ft/s 6 = yd/s TempRes Temperature sensor resolution 0..3 = maximum number of decimal places TempOffset -12.6..12.6 = Set calibraton offset value for reported temperature telemetry This setting affects all temperature sensors on the device. VoltRes Voltage sensor resolution 0..3 = maximum number of decimal places WattRes Power sensor resolution 0..3 = maximum number of decimal places WeightRes Load cell sensor resolution 0..3 = maximum number of decimal places See also SetOption8 - Show temperature in Celsius (default) or Fahrenheit SetOption18 - Set status of signal light paired with CO 2 sensor SetOption24 - Set pressure units Bluetooth Low Energy - BLE ~ Command Parameters BLEMode Change the operational mode of the BLE driver. BLEMode0 = disable regular BLE scans. BLEMode1 = BLE scan on command only. BLEMode2 = regular BLE scanning (default). BLEPeriod Set the period for publish of BLE data <value> = set interval in seconds BLEScan Cause/Configure BLE a scan BLEScan0 0..1 = enable or disable Active scanning. (an active scan will gather extra data from devices, including name) BLEScan = Trigger a 20s scan now if in BLEMode1 BLEScan n = Trigger a scan now for n seconds if in BLEMode1 BLEDetails Display details about recevied adverts BLEDetails0 = disable showing of details. BLEDetails1 mac|alias = show the next advert from device mac BLEAlias Set Alias names for devices. A device may be referred to by it's alias in subsequent commands BLEAlias mac=alias mac=alias ... = set one or more aliases from devices. BLEAlias2 = clear all aliases. BLEName Read or write the name of a BLE device. BLEName mac|alias = read the name of a device using 1800/2A00. BLEName mac|alias = write the name of a device using 1800/2A00 - many devices are read only. BLEDevices Cause a list of known devices to be sent on MQTT, or Empty the list of known devices. BLEDevices0 = clear the known devices list. BLEDevices = Cause the known devices list to be published on stat/TASName/BLE. BLEMaxAge Set the timeout for device adverts. BLEMaxAge n = set the devices timeout to n seconds. BLEMaxAge = display the device timeout. BLEOp Perform a simple active BLE operation (read/write/notify). see separate description in source code BLEDebug Set BLE debug level. BLEDebug = show extra debug information BLEDebug0 = suppress extra debug BLEAddrFilter Set BLE Address type filter. BLEAddrFilter = show filter level BLEAddrFilter n = set BLE address type filter 0..3 - default 3. Ignores BLE address types > filter value. Set 0 to ONLY see public addresses. BLE iBeacon (ESP32) ~ Command Parameters iBeacon Show or set enable for the iBeacon driver iBeacon = Display 0 iBeaconOnlyAliased Show or set OnlyAliased for the iBeacon driver iBeaconOnlyAliased = Display 0 iBeaconClear Clear iBeacon list iBeaconPeriod Display or Set the period for publish of iBeacon data iBeaconPeriod = display interval iBeaconPeriod ss = set interval in seconds iBeaconTimeout Display or Set the timeout for iBeacon devices iBeaconTimeout = display timeout iBeaconTimeout ss = set timeout in seconds BLE MI/Xiaomi sensors (ESP32) ~ Command Parameters MI32Period Display/Set the active scan and tele period for the MI32 driver. MI32Period = diisplay the period in seconds. MI32Period n = Set the MI driver active read and tele period to n seconds. MI32Time Set the time on a device. MI32Time n = set the time on the device in slot n. MI32Page Display/Set the sensors per page in the web view. MI32page = show sensors per page. MI32page n = Set sensors per page to n. MI32Battery Trigger an active read of battery values. MI32Battery = request the driver read the battery from all sensors which have active battery read requirements. MI32Unit Write the current Tasmota temperature unit to a sensor. MI32Unit s = set the Temp unit on sensor in slot s. MI32Key Add a decryption key. MI32Key hexkey = add a 44 character decryption key to the keys list. MI32Keys Add one or more decryption keys by mac or alias. MI32Keys = list keys. MI32Keys mac|alias=key mac|alias=key ... = add keys for mac MI32Block Block or unblock a sensor device. MI32Block = list blocked devices by mac. MI32Block mac|alias = Block one mac/alias. MI32Option Set a MI driver option. MI32Option0 0|1(default) = set 'alwaysagregate'. MI32Option1 0(default)|1 = set 'nosummary'. MI32Option2 0(default)|1 = set 'directBridgeMode'. MI32Option3 0|1(default) = set 'ignoreBogusBattery'. Power Monitoring ~ Command Parameters AmpRes Current sensor resolution 0..3 = maximum number of decimal places CurrentCal 1000..32000 (default = 3500 ) Set calibration offset value for reported Current telemetry Allows finer calibration for HLW8012, HJL01, and BL0937 energy monitoring devices CurrentHigh 0 = disable current high threshold (default) <value> = set current high threshold value in milliamps CurrentLow 0 = disable current low threshold (default) <value> = set current low threshold value in milliamps CurrentSet <value> = calibrate current to target value in mA EnergyRes Energy sensor resolution 0..5 = maximum number of decimal places EnergyReset<x> 0..42500 (for 3 , Total, upper limit is 4250000 ) in watt-hours (Wh) x = 1..5 1 <value> = ((p)re)set values for Today 2 <value> = ((p)re)set values for Yesterday 3 <value> = ((p)re)set values for Total 4 <standard> {, <off-peak> } = ((p)re)set tariff period values for Totals 5 <standard> {, <off-peak> } = ((p)re)set tariff period values for Exported FreqRes Frequency sensor resolution 0..3 = maximum number of decimal places FrequencySet <value> = calibrate frequency to a target value in Hz MaxPower 0 = disable use maximum power monitoring <value> = set maximum allowed power in watts MaxPowerHold 1 = set default time to 10 seconds to stay over MaxPower before power off <value> = set time in seconds to stay over MaxPower before power off MaxPowerWindow 1 = set default time to 30 seconds to stay power off before re-applying power up to 5 times <value> = set time in seconds to stay power off before re-applying power up to 5 times ModuleAddress Set the address of a PZEM module 1..3 = the last octet of the PZEM-004T serial address <address> = the last octet of the address on MODBUS PZEM energy monitoring modules Prior to setting the module address, the PZEM must be connected to both RX and TX, and AC voltage. Connect one PZEM at a time and issue this command. Repeat for each PZEM to be connected for multi-phase monitoring. The command without an argument cannot be used to read the address of the connected PZEM. PowerCal 1000..32000 (default = 12530 ) Set calibration offset value for reported Power telemetry reading Allows finer calibration for HLW8012, HJL01, and BL0937 energy monitoring devices PowerDelta<x> Set maximum delta of phase a<x> in energy monitoring devices to report on active power load change while the power is ON. PowerDelta will not report when the power turns off.\u2003 0 = disable reporting on power change 1..100 = set reporting on percentage power change to send an MQTT telemetry message 101..32000 = set reporting on absolute power change to send an MQTT telemetry message (offset by 100, e.g., 101 =1W, 207 =107W) PowerHigh 0 = disable power high threshold (default) <value> = set power high threshold value in watts to send an MQTT telemetry message PowerLow 0 = disable power low threshold (default) <value> = set power low threshold value in watts to send an MQTT telemetry message PowerSet <value> = calibrate power to a target value in watts\u2003 Status 8 = show power usage 9 = show power thresholds Tariff<x> P1 Smart Meter tariff configuration x = 1, 2, 9 1 STD,DST Start times for off-peak tariff 2 STD,DST End times for off-peak tariff 9 0/1 \u2003 0 = use Start/End times also on weekends. \u2003 1 = use off-peak tariff all weekend. STD and DST may be specified as: \u2003 <hour> = 0..23 or \u2003 <time> = 00:00..23:59 or \u2003 <minutes> = 0..1439 (since midnight) If both Tariff1 STD and Tariff2 STD are equal, all tariffs are disabled. VoltageCal Set calibration offset value for reported Voltage telemetry reading 1000..32000 (default = 1950 ) Allows finer calibration for HLW8012, HJL01, and BL0937 energy monitoring devices VoltageHigh 0 = disable voltage high threshold (default) <value> = set voltage high threshold value in V VoltageLow 0 = disable voltage low threshold (default) <value> = set voltage low threshold value in V VoltageSet <value> = calibrate voltage to a target value in V\u2003 VoltRes Voltage sensor resolution 0..3 = maximum number of decimal places WattRes Power sensor resolution 0..3 = maximum number of decimal places See Also SetOption21 - Energy monitoring when power is off SetOption33 - Configure power monitoring Max_Power_Retry count number SetOption39 - Control handling of invalid power measurements SetOption72 - Set reference used for total energy Light ~ Command Parameters Channel<x> 0..100 = set PWM channel dimmer value from 0 to 100%\u2003 + = increase by 10 - = decrease by 10 When SetOption68 is set to 1 Channel<x> will follow Power<x> numbering with Relays first then PWM. Example : 2 Relays and 3 PWM: Relay1 = Power1 ; Relay2 = Power2 ; PWM1 = Power3 and Channel3 ; PWM2 = Power4 and Channel4 ; PWM3 = Power5 and Channel5 Color<x> x = 1..6 \u2003 1 = Set color \u2003 2 = Set color adjusted to current Dimmer value \u2003 3 = Set clock seconds hand color ( Scheme 5 only) \u2003 4 = Set clock minutes hand color ( Scheme 5 only) \u2003 5 = Set clock hour hand color ( Scheme 5 only) \u2003 6 = Set clock hour marker color <value> r,g,b = set color by decimal value ( 0..255 ) #CWWW = set hex color value for CT lights #RRGGBB = set hex color value for RGB lights #RRGGBBWW = set hex color value for RGBW lights #RRGGBBCWWW = set hex color value for RGBCCT lights (5 PWM channels) Note : Just append an = instead of the remaining color codes, this way they wont get changed. For example a command like Color #00ff= would update the RGB part to disable red and enable geen, but would omit to update blue or any white channel. Set color to 1 = red 2 = green 3 = blue 4 = orange 5 = light green 6 = light blue 7 = amber 8 = cyan 9 = purple 10 = yellow 11 = pink 12 = white (using RGB channels) + = next color - = previous color CT 153..500 = set color temperature from 153 (cold) to 500 (warm) for CT lights + = increase CT value by 10 - = decrease CT value by 10 Dimmer 0..100 = set dimmer value from 0 to 100% + = increase by DimmerStep value (default = 10 ) - = decrease by DimmerStep value (default = 10 ) Dimmer<x> Commands available only when SetOption37 >= 128 ( #6819 ) <value> same as in Dimmer Dimmer0 <value> = set dimming for all channels Dimmer1 <value> = set dimming for RGB channels Dimmer2 <value> = set dimming for white channels DimmerRange Change dimming range. <dimmerMin>,<dimmerMax> = set the internal dimming range from minimum to maximum value (0..100, 0..100) Does not change Dimmer command behavior DimmerStep 1..50 - set Dimmer +/- step value. (default = 10 ) Fade 0 = do not use fade (default) 1 = use fade See also SetOption91 HsbColor <hue>,<sat>,<bri> = set color by hue, saturation and brightness HsbColor1 0..360 = set hue HsbColor2 0..100 = set saturation HsbColor3 0..100 = set brightness Led<x> #RRGGBB = set hex color value where <x> is the pixel number of the LED (applies only to addressable LEDs) LedPwmMode<x> Control status LED light mode (x = 0..4 ) 0 = digital on/off mode (default) 1 = PWM mode 2 = toggle between modes LedPwmOff 0..255 = set LED brightness when OFF LedPwmOn 0..255 = set LED brightness when ON LedTable 0 = do not use LED gamma correction (default \u00ab6.5.0.9) 1 = use gamma correction (default \u00bb6.5.0.9) Palette 0 = Clear color palette [...] = Set list of colors in RGB used by Color and Scheme commands with each color separated by a space. Example: Palette 255,0,0 0,255,0 255,255,153 to use only red, green, yellow colors Pixels 1..512 = set amount of pixels in strip or ring and reset Rotation (applies only to addressable LEDs) RGBWWTable Control lightintensity of unbalanced PWM channels PWM1,PWM2,PWM3,PWM4,PWM5 = channel range with values 0..255 (default = 255,255,255,255,255 ) Range adjustment is computed after Gamma correction. Rotation <value> = set amount of pixels to rotate (up to Pixels value) (applies only to addressable LEDs) Scheme Light effects + = next scheme - = previous scheme 0 = single color for LED light (default) 1 = start wake up sequence (same as Wakeup ) 2 = cycle up through colors using Speed option 3 = cycle down through colors using Speed option 4 = random cycle through colors using Speed and Fade Use <value>, <startcolor> if you want to set the starting color of selected scheme Following schemes are usable only with addressable LEDs, e.g. WS281X, Neopixel 5 = clock mode ( example ) 6 = candlelight pattern 7 = RGB pattern 8 = Christmas pattern 9 = Hanukkah pattern 10 = Kwanzaa pattern 11 = rainbow pattern 12 = fire pattern Speed 1..40 = set fade speed from fast 1 to very slow 40 + = increase speed - = decrease speed The Speed value represents the time in 0.5s to fade from 0 to 100% (or the reverse). Example: Speed 4 takes 2.0s to fade from full brightness to black, or 0.5s to move from 75% to 100%. Wakeup Start wake up sequence from OFF to stored Dimmer value 0..100 = Start wake up sequence from OFF to provided Dimmer value WakeupDuration 1..3000 = set wake up duration in seconds White 1..100 = set white channel brightness in single white channel lights (single W or RGBW lights) Width<x> x = 1..4 1 = 0..4 = LED group width ( Scheme 6..12 only) 2 = 0..32 = seconds hand width ( Scheme 5 only) 3 = 0..32 = minutes hand width ( Scheme 5 only) 4 = 0..32 = hour hand width ( Scheme 5 only) See also SetOption15 , SetOption16 , SetOption17 , SetOption20 , SetOption37 and SetOption68 TuyaMCU ~ Command Parameters TuyaEnum<x> Send value inside configured range to enum<x> (x = 0..4 ) <value> = a numerical value from range configured with TuyaEnumList TuyaEnumList <enum>,<range> = declare the range for a configured enum fnId <enum> = 1..4 <range> = 0..31 (starts counting from 0 ) TuyaMCU Used to map functions for TuyaMCU (54) module <fnId>,<dpId> = read more... <fnId>,0 = remove setting for fnId TuyaRGB Set RGB string format reported from TuyaMCU 0 = Type 1, 12 characters uppercase, for example: 00DF00DC0244 (default) 1 = Type 2, 12 characters lowercase, for example: 008003e8037a Type 2, 14 characters uppercase, for example: 00FF00FFFF6464 Type 2, 14 characters lowercase, for example: 00e420ffff6464 TuyaSend<x> Send data to MCU with TuyaMCU TuyaSend0 = send a query command to the MCU which returns MCU ID and dpId states if supported TuyaSend1 <dpId>,<boolean> = send boolean ( 0 / 1 ) data type to dpId (1 byte max length) TuyaSend2 <dpId>,<int> = send integer data to dpId (4 bytes max length) TuyaSend2 <dpId>,<0xAABBCCDD> = send 4 byte data to dpId (4 bytes max length) TuyaSend3 <dpId>,<value> = send any data type to dpId (unknown max length) TuyaSend4 <dpId>,<enum> = send enumerated ( 0 / 1 / 2 / 3 / 4 / 5 ) data type to dpId (1 byte max length) TuyaSend8 = request all dpId states if supported TuyaSend9 = toggle reporting of individual dpId changes to their own topic stat/%topic%/DPTYPE<x>ID<x> Device Groups ~ Command Parameters DevGroupName<x> 0 = clear device group <x> name and restart <value> = set device group <x> name and restart. Prior to 8.2.0.3, GroupTopic was used to specify the device group name. DevGroupSend<x> <item> = <value>[ ...] = send an update to device group <x>. The device group name must have been previously set with DevGroupName<x>. Multiple item/value pairs can be specified separated by a space. Spaces in <value> must be escaped with a backslash (\\). The message sent is also processed on the local device as if it had been received from the network. For items with numeric values, <value> can be specified as @<operator>[<operand>] to send a value after performing an operation on the current value. <operator> can be + (add), - (subtract) or ^ (invert). If <operand> is not specified, it defaults to 0xffffffff for the invert operator and 1 for other operators. Examples: DevGroupSend 4=90 128=1 - send an update to set the light brightness to 90 and turn relay 1 on. DevGroupSend 193=Buzzer\\\\ 2,3 - send the Buzzer 2,3 command. DevGroupSend 6=@+ 4=@-10 - set the next fixed color and decrease the brightness by 10. DevGroupSend 128=^ - toggle all the relays. 2 = Light fade (0 = Off, 1 = On) 3 = Light speed (1..40) 4 = Light brightness (0..255) 5 = Light Scheme 6 = Light fixed color (0 = white (using CT channels), other values according to Color ) 7 = PWM dimmer low preset (0..255) 8 = PWM dimmer high preset (0..255) 9 = PWM dimmer power-on brightness (0..255) 128 = Relay Power - bitmask with bits set for relays to be powered on. The number of relays can be specified in bits 24 - 31. If the number of relays is not specified, only relay 1 is set 192 = Event - event name and arguments 193 = Command - command and arguments 224 = Light channels - comma separated list of brightness levels (0..255) for channels 1 - 5 (e.g. 255,128,0,0,0 will turn the red channel on at 100% and the green channel on at 50% on an RBG light) DevGroupShare <in>,<out> = set incoming and outgoing shared items (default = 0xffffffff,0xffffffff ) <in> and <out> are bit masks where each mask is the sum of the values for the categories (listed below) to be shared. For example, to receive only power (1), light brightness (2) and light color (16) and send only power (1), enter the command DevGroupShare 19,1. 1 = Power 2 = Light brightness 4 = Light fade/speed 8 = Light scheme 16 = Light color 32 = Dimmer settings (presets) 64 = Event DevGroupStatus<x> Show the status of device group <x> including a list of the currently known members. SetOptions ~ Tip Instead of typing SetOption you can use shorter form of SO . so instead of SetOption19 1 you can use SO19 1 Command Parameters SetOption0 Save power state and use after restart (=SaveState) 0 = disable 1 = enable (default) SetOption1 Set button multipress mode to 0 = allow all button actions (default) 1 = restrict to single to penta press and hold actions (i.e., disable inadvertent reset due to long press) SetOption3 MQTT 0 = disable MQTT 1 = enable MQTT (default) SetOption4 Return MQTT response as 0 = RESULT topic (default) 1 = %COMMAND% topic SetOption8 Show temperature in 0 = Celsius (default) 1 = Fahrenheit SetOption10 When the device MQTT topic changes 0 = remove retained message on old topic LWT (default) 1 = send \"Offline\" to old topic LWT SetOption11 Swap button single and double press functionality 0 = disabled (default) 1 = enabled SetOption12 Configuration saving to flash option 0 = allow dynamic flash save slot rotation (default) 1 = use fixed eeprom flash slot SetOption13 Allow immediate action on single button press 0 = single, multi-press and hold button actions (default) 1 = only single press action for immediate response (i.e., disable multipress detection). Disable by holding for 4 x button hold time (see SetOption32 ). SetOption15 Set PWM control for LED lights 0 = basic PWM control 1 = control with Color or Dimmer commands (default) SetOption16 Set addressable LED Clock scheme parameter 0 = clock-wise mode (default) 1 = counter-clock-wise mode SetOption17 Show Color string as 0 = hex string (default) 1 = comma-separated decimal string SetOption18 Set status of signal light paired with CO 2 sensor 0 = disable light (default) 1 = enable light The light will be green below CO2_LOW and red above CO2_HIGH (transition yellow/orange between). The default levels are: 800ppm for low and 1200ppm for high but these can be set in user_config_override.h . SetOption19 Home Assistant automatic discovery. WARNING On version 6.4.1.x enabling may cause a watchdog reset if used on a device with a configured sensor 0 = disabled (default) 1 = enabled and also sets SetOption59 1 If you enable and then disable SetOption19 , doing so does not set SetOption59 = 0 and does not revert to default %prefix%/%topic%/ FullTopic SetOption20 Update of Dimmer/Color/CT without turning power on 0 = disabled (default) 1 = enabled SetOption21 Energy monitoring when power is off 0 = disabled (default) 1 = enabled SetOption24 Set pressure units 0 = hPa (default) 1 = mmHg SetOption26 Use indexes even when only one relay is present 0 = messages use POWER (default) 1 = messages use POWER1 SetOption28 RF received data format 0 = hex (default) 1 = decimal SetOption29 IR received data format 0 = hex (default) 1 = decimal SetOption30 Enforce Home Assistant auto-discovery as light 0 = relays are announced as a switch and PWM as a light (default) 1 = both relays and PWM are announced as light SetOption31 Set status LED blinking during Wi-Fi and MQTT connection problems. LedPower must be set to 0 for this feature to work 0 = Enabled (default) 1 = Disabled SetOption32 Number of 0.1 seconds to hold button before sending HOLD action message. 1..100 to set button hold time (default = 40 ) . This option also affects the time required to perform a firmware defaults reset (10x HOLD action time) SetOption33 Number of seconds for which the maximum power limit can be exceeded before the power is turned off 1..250 = set number of seconds (default = 5 ) SetOption34 0..255 = set Backlog inter-command delay in milliseconds (default = 200 ) SetOption36 Boot loop defaults restoration control. 0 = disable boot loop control 1..200 = set number of boot loops (a restart caused by any exception or watchdog timer within less than BOOT_LOOP_TIME (default 10 seconds) before beginning to restore settings (default = 1 ) . Once this number is reached, subsequent restarts will: 1 st restart: disable ESP8285 generic GPIOs interfering with flash SPI 2 nd restart: disable rules causing boot loop 3 rd restart: disable all rules 4 th restart: reset user defined GPIOs to disable any attached peripherals 5 th restart: reset module to Sonoff Basic (1) SetOption37 Color remapping for led channels, also provides an option for allowing independent handling of RGB and white channels. Setting changes require a device reboot. 0 = disabled 1..119 = according to this table 120..127 = invalid (results in same as 0 ) 128..255 = same as 0..127 but with independent channel handling enabled SetOption38 6..255 = set IRReceive protocol detection sensitivity minimizing UNKNOWN protocols SetOption39 Control handling of invalid power measurements. Read more... 0 = reset to default on next restart 1..255 = number of invalid power readings before reporting no load (default = 128 ) . SetOption40 Stop detecting input change on the button GPIO. Solves #5449 Active only when SetOption1 1 and SetOption13 0 . This disables all long press functionality. 0..250 = button hold time in 0.1 seconds after which button functionality is disabled. (default = 1 ) Example: Backlog SetOption1 1; SetOption13 0; SetOption40 10 = discard any button press over 1 second SetOption41 0 = Disable ARP (default) <x> = Force sending gratuitous ARP (Wi-Fi keep alive) every <x> seconds (default = 0 ) If <x> is below 100 it is the number of seconds, if <x> is above 100 , it is the number of minutes after substracting 100. Ex: 105 is every 5 minutes, while 90 is every 90 seconds. SetOption42 0..255 = set over-temperature (Celsius only) threshold resulting in power off on all energy monitoring devices (default = 90 ) SetOption43 Deprecated in favor of DimmerRange 0..255 = set maximum dimming value ( details ) (default = 100 ) Available for Tuya and PS_16_DZ dimmers SetOption51 Enable GPIO9 and GPIO10 component selections in Module Configuration WARNING Do not use on ESP8266 devices! 0 = disable (default) 1 = enable SetOption52 Control display of optional time offset from UTC in JSON payloads 0 = disable (default) 1 = enable SetOption53 Display hostname and IP address in GUI 0 = disable (default) 1 = enable SetOption54 Apply SetOption20 settings to commands from Tuya device 0 = disable (default) 1 = enable SetOption55 mDNS service 0 = disable (default) 1 = enable SetOption56 Wi-Fi network scan to select strongest signal on restart (network has to be visible) 0 = disable (default) 1 = enable SetOption57 Wi-Fi network re-scan every 44 minutes with alternate to +10dB stronger signal if detected (only visible networks) 0 = disable (default) 1 = enable SetOption58 IR Raw data in JSON payload 0 = disable (default) 1 = enable SetOption59 Send tele/%topic%/STATE in addition to stat/%topic%/RESULT for commands: State , Power and any command causing a light to be turned on. 0 = disable (default) 1 = enable SetOption60 Set sleep mode 0 = dynamic sleep (default) 1 = normal sleep SetOption61 Force local operation when ButtonTopic or SwitchTopic is set. 0 = disable (default) 1 = enable SetOption62 Set retain on Button or Switch hold messages 0 = disable (default) 1 = don't use retain flag on HOLD messages SetOption63 Set relay state feedback scan at restart ( #5594 , #5663 ) 0 = Scan power state at restart (default) 1 = Disable power state scanning at restart SetOption64 Switch between - or _ as sensor name separator 0 = sensor name index separator is - (hyphen) (default) 1 = sensor name index separator is _ (underscore) Affects DS18X20, DHT, BMP and SHT3X sensor names in tele messages SetOption65 Device recovery using fast power cycle detection 0 = enabled (default) 1 = disabled SetOption66 Set publishing TuyaReceived to MQTT 0 = disable publishing TuyaReceived over MQTT (default) 1 = enable publishing TuyaReceived over MQTT SetOption67 iFan03 Buzzer control 0 = disable Sonoff iFan03 buzzer (default) 1 = enable Sonoff iFan03 buzzer SetOption68 Multi-channel PWM instead of a single light 0 = Treat PWM as a single light (default) 1 = Treat PWM as separate channels. In this mode, use Power<x> to turn lights on and off, and Channel<x> to change the value of each channel. Color still works to set all channels at once. Requires restart after change SetOption69 Deprecated in favor of DimmerRange By default Tuya dimmers won't dim below 10% because some don't function very well that way. 0 = disable Tuya dimmer 10% lower limit 1 = enable Tuya dimmer 10% lower limit (default) SetOption71 Set DDS238 Modbus register for active energy 0 = set primary register (default) 1 = set alternate register SetOption72 Set reference used for total energy 0 = use firmware counter (default) 1 = use energy monitor (e.g., PZEM-0xx, SDM120, SDM630, DDS238, DDSU666) hardware counter SetOption73 Detach buttons from relays and send multi-press and hold MQTT messages instead 0 = disabled (default) 1 = enabled Example message: {\"Button1\":{\"Action\":\"SINGLE\"}} SetOption74 Enable internal pullup for single DS18x20 sensor 0 = disabled (default) 1 = internal pullup enabled SetOption75 Set grouptopic behaviour ( #6779 ) 0 = GroupTopic using FullTopic replacing %topic% (default) 1 = GroupTopic is cmnd/%grouptopic%/ SetOption76 Bootcount incrementing when DeepSleep is enabled ( #6930 ) 0 = disable bootcount incrementing (default) 1 = enable bootcount incrementing SetOption77 Do not power off if a slider is moved to far left 0 = disabled (default) 1 = enabled SetOption78 Version check on Tasmota upgrade 0 = enabled (default) 1 = disabled SetOption79 Reset counters at TelePeriod time 0 = disabled (default) 1 = enabled SetOption80 Blinds and shutters support 0 = disable blinds and shutters support (default) 1 = enable blinds and shutters support SetOption81 Set PCF8574 component behavior for all ports 0 = set as regular state (default) 1 = set as inverted state SetOption82 Reduce the CT range from 153..500 to 200.380 to accomodate with Alexa range 0 = CT ranges from 153 to 500 (default) 1 = CT ranges from 200 to 380 (although you can still set in from 153 to 500) SetOption83 Uses Zigbee device friendly name instead of 16 bits short addresses as JSON key when reporting values and commands 0 = JSON key as short address 1 = JSON key as friendly name See ZbName <device>,<name> SetOption84 (Experimental) When using AWS IoT, sends a device shadow update (alternative to retained) 0 = don't update device shadow (default) 1 = update device shadow Note: if the Topic contains '/' they are replaced with '_' SetOption85 Device group support 0 = disabled (default) 1 = enabled SetOption86 PWM Dimmer only! Turn brightness LED's off 5 seconds after last change 0 = disabled (default) 1 = enabled SetOption87 PWM Dimmer only! Turn red LED on when powered off 0 = disabled (default) 1 = enabled SetOption88 Make each relay part of a separate device group. Relay 1 updates are sent to/received from device group 1, relay 2 updates are sent to/received from device group 2, etc. For the PWM Dimmer module, make each button be associated with a different device group. 0 = disabled (default) 1 = enabled SetOption89 Configure MQTT topic for Zigbee devices (also see SensorRetain ) 0 = single tele/%topic%/SENSOR topic (default) 1 = unique device topic based on Zigbee device ShortAddr Example: tele/Zigbee/5ADF/SENSOR = {\"ZbReceived\":{\"0x5ADF\":{\"Dimmer\":254,\"Endpoint\":1,\"LinkQuality\":70}}} SetOption90 Disable sending MQTT with non-JSON messages 0 = send all MQTT (default) 1 = send only MQTT messages with JSON payloads SetOption91 Enable Fade at boot and power on. By default fading is not enabled at boot because of stuttering caused by wi-fi connection 0 = don't Fade at startup (default) 1 = Fade at startup SetOption92 Alternative to Module 38 : for Cold/Warm white bulbs, enable the second PWM as CT (Color Temp) instead of Warm White, as required for Philips-Xiaomi bulbs. 0 = normal Cold/Warm PWM (default) 1 = Brightness/CT PWM See PWM CT in Lights SetOption93 Control caching of compressed rules 0 = Disable memory caching of uncompressed rules 1 = Keep uncompressed rules in memory to avoid CPU load of uncompressing at each tick (default) SetOption94 Select MAX31855 or MAX6675 thermocouple support 0 = Use MAX31855 protocol (default) 1 = Use simpler MAX6675 protocol instead of MAX31855 SetOption97 Set TuyaMCU serial baudrate 0 = 9600 bps (default) 1 = 115200 bps SetOption98 Provide rotary dimmer rule triggers 0 = disabled (default) 1 = enabled (see Rules ) SetOption99 Enable zero-cross capable AC dimmer 0 = no zero-cross AC dimmer connected (default) 1 = zero-cross AC dimmer attached. Focus on raising edge and sync frequency SetOption100 remove Zigbee ZbReceived value from {\"ZbReceived\":{xxx:yyy}} JSON message 0 = disabled (default) 1 = enabled SetOption101 Add Zigbee source endpoint as suffix to attributes 0 = disabled (default) 1 = enabled e.g. Power3 instead of Power if sent from endpoint 3 . SetOption102 Set baudrate for Teleinfo communication 0 = 1200 (default) 1 = 9600 SetOption103 Set TLS mode 0 = disable TLS 1 = enable TLS SetOption104 Disable MQTT retained messages (some brokers don't support them) 0 = retained messages enabled (default) 1 = retained messages disabled SetOption105 White Blend Mode 0 = disabled (default) 1 = enabled SetOption106 Virtual CT channel (experimental feature) 0 = disabled (default) 1 = create a virtual second white channel using RGB channels _only if light is RGBW (4 channels), SetOption68 0 and SetOption37 < 128 SetOption107 Set virtual CT channel light type (experimental feature) 0 = Warm White 1 = Cold White SetOption108 0 = Teleinfo telemetry into Energy MQTT JSON (default) 1 = Teleinfo raw data only SetOption109 0 = (default) 1 = force gen1 Alexa mode, for Echo Dot 2nd gen devices only SetOption110 0 = (default) 1 = disable Zigbee auto-binding and auto-attribute reporting when pairing a new device. Use only if you want to manually configure devices SetOption111 0 = (default) 1 = use frequency output for buzzer pin instead of on/off signal, for piezo buzzers SetOption112 0 = (default) 1 = use friendly name in Zigbee topic (use with `SetOption89) SetOption113 works only with rotary dial button 0 = (default) 1 = set dimmer low on rotary dial after power off SetOption114 Detach switches from relays and send MQTT messages instead 0 = disabled (default) 1 = enabled Example result: {\"Switch1\":{\"Action\":\"ON\"}} SetOption115 Enable ESP32 MI32 BLE 0 = disabled (default) 1 = enabled SetOption116 Disable auto-query of zigbee light devices (avoids network storms with large groups) 0 = enabled (default) 1 = disabled SetOption117 Light fading at fixed duration instead of fixed slew rate 0 = disabled (default) 1 = enabled Serial Bridge ~ Both hardware and software Serial Bridge are supported. Hardware Serial Bridge uses GPIO1 (Tx) and GPIO3 (Rx) or GPIO13 (Tx) and GPIO15 (Rx) pins of your device. Software Serial Bridge can use any other GPIO to be configured as components Serial Tx and Serial Rx (or SerBr Tx and SerBr Rx ). If Tx and Rx components are not assigned in the Template or Module, GPIO1 and GPIO3 will be used. Note that changing serial logging ( SerialLog 0) will disable the hardware Serial Bridge. Information received by Tasmota over the serial bridge is captured automatically. Before data will be received, a properly formatted SerialSend<x> or SSerialSend<x> command must be executed. This must be done any time the device restarts (e.g., via a System#Boot triggered rule). This command is required in order to set how the expected serial data will be formatted and interpreted (i.e., which <x> option). A {\"SSerialReceived\":{\"Data\":\"<string>\"}} message will be posted. You can use a rule to process the string which will be contained in SSerialReceived#Data . Expect possible communication errors when additional sensors are configured. Command Parameters Baudrate 1 = set hardware serial bridge to default baud rate of 115200 bps <value> = set baud rate. The set rate will be a multiple of 300. The maximum baud rate possible is 19,660,500. SBaudrate 1 = set software serial bridge to default baud rate of 9600 bps <value> = set baud rate. The set rate will be a multiple of 300. The maximum baud rate possible is 19,660,500. SerialConfig value = set serial protocol using data/parity/stop conventional notation (example: 8N1 or 702 ) 0..23 = set serial protocol ( 3 equals 8N1 ) SerialDelimiter <value> = set serial delimiter to escape character code or ASCII character 1..127 = set serial delimiter to decimal ASCII 128 = only allow ASCII characters 32 to 127 in response text 129..255 = disable serial delimiter SerialSend<x> <string> Disable serial logging and send using hardware serial x = 1..5 1 = send appending \\n (newline) () 2 = send 3 = replace escape characters and send 4 = send as binary. Data in serial response messages is encoded as hex strings 5 = send as hex. Data in serial response messages is encoded as hex strings 6 = send as comma-delimited string of decimal numbers SSerialSend<x> <string> Send using software serial protocol x = 1..5 1 = send appending \\n (newline) () 2 = send 3 = replace escape characters and send 4 = send as binary data. Data in serial response messages is encoded as hex strings 5 = send as hex. Data in serial response messages is encoded as hex strings 6 = send as comma-delimited string of decimal numbers RF Bridge ~ Command Parameters RfCode Show last sent 24-bit user code 1..8388607 = send 24-bit user code #1..#7FFFFF = send 24-bit hexadecimal user code using RfSync, RfLow and RfHigh timing RfHigh 1 = reset high pulse time to 840 microseconds 2..32767 = set high pulse time in microseconds #2..#7FFF = set high pulse time in hexadecimal microseconds RfHost Show 16-bit host part of user code 1 = reset 16-bit host part of user code to 11802 (#2E1A) 2..32767 = set 16-bit host part of user code #2..7FFF = set 16-bit host part of user code in hexadecimal RfKey<x> Send learned or default RF data for RfKey<x> (x = 1 \u2013 16 ) 1 = send default RF data for RfKey<x> using RfSync, RfLow, RfHigh and RfHost parameters 2 = learn RF data for RfKey<x> 3 = unlearn RF data for RfKey<x> 4 = save RF data using RfSync, RfLow, RfHigh and last RfCode parameters 5 = show default or learned RF data 6 = send learned RF data RfLow 1 = reset low pulse time to 270 microseconds 2..32767 = set low pulse time in microseconds #2..#7FFF = set low pulse time in hexadecimal microseconds RfRaw This command only works when the firmware has been updated with Portisch firmware . Refer to the Portisch wiki for details. Learning and Decoding RF Codes with Portisch Firmware 0 = Set iTead default firmware support and messages (default on restart) 1 = set Portisch firmware support and messages 166 or AAA655 = start sniffing/reading RF signals disabling iTead default RF handling 167 or AAA755 = stop sniffing/reading RF signals enabling iTead default RF handling 168 or AAA855 = transmitting iTead default RF protocols 169 or AAA955 = start sniffing and learning predefined protocols 176 or AAB055 = bucket Transmitting using command 0xB0 177 or AAB155 = start Bucket sniffing using command 0xB1 192 or AAC000C055 = beep ( 00C0 is the length of the sound) 255 or AAFF55 = show Rf firmware version (result AA02FF means Version 02) <value> = hexadecimal data to be sent to RF chip. This must be immediately followed by the RfRaw 0 command (e.g., Backlog RfRaw <value>; RfRaw 0 RfSync 1 = reset start sync pulse time to 8470 microseconds 2..32767 = set start sync pulse time in microseconds #2..#7FFF = set start sync pulse time in hexadecimal microseconds See also SetOption28 - Set RF received data format RF Transciever ~ Command Parameters RfProtocol = returns an array of enabled protocols JSON 1...35 = sets enable protocols mask value a = set mask to all (case sensitive) 0 = turn all off RfProtocol<x> 1 = set specific protocol on RfProtocol<x> 0 = set specific protocol off RfSend <value> = code decimal or JSON. Data value is required and can be decimal or hexadecimal (using the 0x prefix), other values are optional. JSON {\"Data\":\"<value>\",\"Bits\":<value>,\"Protocol\":<value>,\"Pulse\":<value>} \"Data\":\"<value>\" = hexadecimal code \"Bits\":<value> = required number of data bits (default = 24 ) \"Protocol\":<value> = protocol number (default = 1 ) \"Repeat\":<value> = repeat value (default = 10 ) \"Pulse\":<value> = pulse value ( 350 = default for protocol 1) \u2003e.g., RFsend {\"Data\":\"0x7028DC\",\"Bits\":24,\"Protocol\":1,\"Pulse\":238} Decimal data, bits, protocol, repeat, pulse \u2003e.g., RFsend 7350492, 24, 1, 10, 238 or RFsend 0x7028DC, 24, 1, 10, 238 IR Remote ~ The standard Tasmota builds have reduced support for IR protocols: RC5 , RC6 and NEC . Use Tasmota-IR to have access to full protocols. Command Parameters IRsend <x> Send an IR remote control code as a decimal or hexadecimal string in a JSON payload. In order to send IR data, you must configure one of the free device GPIO as IRsend (8) . GPIO01 nor GPIO03 can be used. <x> [ optional ] = number of times the IR message is sent. If not specified or 0..1 , the message is sent only once (i.e., not repeated) (default) >1 = emulate a long-press on the remote control, sending the message <x> times, or sending a repeat message for specific protocols (like NEC) {\"Protocol\":\"<value>\",\"Bits\":<value>,\"Data\":<value>} \"Protocol\" (select one of the following): \"NEC\" \"RC5\" \"RC6\" \"Bits\":1..32 = required number of data bits for PANASONIC protocol this parameter is the the address, not the number of bits \"Data\":1..(2^32)-1 = data frame as 32 bit decimal. e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":2170978686} or \"Data\":0x1..0xFFFFFFFF = data frame as 32 bit hexadecimal. e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x8166817E} Alternatively, you can send IR remote control codes using RAW command encoding . Read more... Tasmota-IR enabled with all protocols Command Parameters IRsend <x> <x> [ optional ] = number of times the IR message is sent. If not specified or 0..1 , the message is sent only once (i.e., not repeated) (default) >1 = emulate a long-press on the remote control, sending the message <x> times, or sending a repeat message for specific protocols (like NEC) {\"Protocol\":\"<value>\",\"Bits\":<value>,\"Data\":<value>,\"DataLSB\":<value>,\"Repeat\":<value>} \"Protocol\" or \"Vendor\" (select one of the following): RC5, RC6, NEC, SONY, PANASONIC, JVC, SAMSUNG, WHYNTER, AIWA_RC_T501, LG, MITSUBISHI, DISH, SHARP, DENON, SHERWOOD, RCMM, SANYO_LC7461, RC5X, NEC (non-strict), NIKAI, MAGIQUEST, LASERTAG, CARRIER_AC, MITSUBISHI2, HITACHI_AC1, HITACHI_AC2, GICABLE, LUTRON, PIONEER, LG2, SAMSUNG36, LEGOPF, INAX, DAIKIN152 \"Bits\":1..64 = required number of data bits for PANASONIC protocol this parameter is the the address, not the number of bits \"Data\":0x1..0xFFFFFFFFFFFFFFFF = data frame as 64 bit hexadecimal. e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x8166817E} Or \"DataLSB\":0x1..0xFFFFFFFFFFFFFFFF = data frame as 64 bit hexadecimal with LSB (each byte with bits reversed). e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x8166817E} DataLSB comes handy with LSB-first (Least Significant Bit First) protocols like NEC, and makes decoding/encoding easier. \"Repeat\":0..<x> if 0 send the frame once, if >0 simulates a long press; Note: \"Repeat\":1 sends the message twice. Alternatively, you can send IR remote control codes using RAW command encoding . See also SetOption29 - Set IR received data format SetOption38 - Set IR received protocol sensitivity SetOption58 - IR Raw data in JSON payload IRhvac Send HVAC IR remote control code as JSON payload IRhvac {\"Vendor\":\"Mitsubishi_Heavy_152\", \"Power\":\"On\",\"Mode\":\"Hot\",\"FanSpeed\":3,\"Temp\":22.5} \"Protocol\" or \"Vendor\" (select one of the following): COOLIX, DAIKIN, KELVINATOR, MITSUBISHI_AC, GREE, ARGO, TROTEC, TOSHIBA_AC, FUJITSU_AC, MIDEA, HAIER_AC, HITACHI_AC, HAIER_AC_YRW02, WHIRLPOOL_AC, SAMSUNG_AC, ELECTRA_AC, PANASONIC_AC, DAIKIN2, VESTEL_AC, TECO, TCL112AC, MITSUBISHI_HEAVY_88, MITSUBISHI_HEAVY_152, DAIKIN216, SHARP_AC, GOODWEATHER, DAIKIN160, NEOCLIMA, DAIKIN176, DAIKIN128 \"Model\": Some HVAC have variants in protocols, this field allows to specify the variant, see detailed list . Fujitsu_AC : ARRAH2E|ARDB1 Panasonic_AC : LKE|NKE|DKE|JKE|CKP|RKR Whirlpool_AC : DG11J13A|DG11J104|DG11J1-04|DG11J191 \"Power\" : On, Yes, True, 1 Off, No, False, 0 \"Mode\" : Off, Stop Auto, Automatic Cool, Cooling Heat, Heating Dry, Drying, Dehumidify Fan, Fanonly, Fan_Only \"FanSpeed\" : Auto, Automatic Min, Minimum, Lowest, 1 Low, 2 Med, Medium, Mid, 3 High, Hi, 4 Max, Maximum, Highest, 5 \"SwingV\" : vertical swing of Fan Auto, Automatic, On, Swing Off, Stop Min, Minimum, Lowest, Bottom, Down Low Mid, Middle, Med, Medium, Centre, Center High, Hi Highest, Max, Maximum, Top, Up \"SwingH\" : horizontal swing of Fan Auto, Automatic, On, Swing Off, Stop LeftMax, Left Max, MaxLeft, Max Left, FarLeft, Far Left Left Mid, Middle, Med, Medium, Centre, Center Right RightMax, Right Max, MaxRight, Max Right, FarRight, Far Right Wide \"Celsius\" : temperature is in Celsius ( \"On\" ) of Farenheit ( \"Off\" ) \"Temp\" : Temperature, can be float if supported by protocol \"Quiet\" : Quiet mode ( \"On\" / \"Off\" ) \"Turbo\" : Turbo mode ( \"On\" / \"Off\" ) \"Econo\" : Econo mode ( \"On\" / \"Off\" ) \"Light\" : Light ( \"On\" / \"Off\" ) \"Filter\" : Filter active ( \"On\" / \"Off\" ) \"Clean\" : Clean mode ( \"On\" / \"Off\" ) \"Beep\" : Beep active ( \"On\" / \"Off\" ) \"Sleep\" : Timer in seconds \"StateMode\" : SendOnly (default) StoreOnly SendStore See also SetOption29 - Set IR received data format SetOption38 - Set IR received protocol sensitivity SetOption58 - IR Raw data in JSON payload Displays ~ Command Parameters Display Show current display setting as a JSON payload DisplayAddress 0..255 Set display module address DisplayDimmer 0 Turn the display off 1..100 Turn the display on 0..100 Set display luminosity (only on 8x8 Dot-Matrix displays) DisplayMode 0..5 Set to display predefined content according to display type DisplayModel Set display model: 1 = I 2 C LCD Display (default addresses 0x27 , 0x3F ) 2 = SSD1306 OLED 128x32/128x64/68x48 (default I 2 C addresses 0x3C , 0x3D ) 3 = HT16K33 8x8 Dot-Matrix 4 = ILI9341 TFT LCD 5 = 2.9 inch E-Paper Display 296x128 (software 3-wire SPI) 6 = 4.2 inch E-Paper Display 400x300 (software 3-wire SPI) 7 = SH1106 OLED 128x64 (default I 2 C address 0x3c ) 8 = ILI9488 TFT 480x320 (capacitive touch, hardware 3-wire SPI) 9 = SSD1351 color OLED 128x128 (hardware 3-wire SPI) 10 = RA8867 TFT LCD 1024x600 (capacitive touch, hardware 4-wire SPI) 11 = Common anode 7 segment display 12 = ST7789 240x240 TFT LCD (capacitive touch, SPI) DisplayRefresh 1..7 Set time in seconds to update predefined content when using DisplayMode \u2260 0 DisplaySize 1..4 Set display scale-up size (SSD1306 and ILI9341 only) DisplayRotate Set rotation angle 0 = 0\u00b0 1 = 90\u00b0 2 = 180\u00b0 3 = 270\u00b0 DisplayText <value> = See DisplayText use DisplayCols 1..44 Set number of display columns (for display modes>0) DisplayRows 1..32 Set number of display rows (for display modes>0) DisplayFont Specify the current font 0 use classic GFX font 1 = 12 2 = 24 3 = 8 (opt) 7 use RA8876 internal font DisplayWidth Specify the display width in pixels (SSD1306 only) DisplayHeight Specify the display height in pixels (SSD1306 only) Shutters ~ Command (x = 1..4 ) Parameters ShutterMode<x> 1..5 (default = 0 ) Defines the mode the shutter will operates the relays, steppers and/or servos. 0=autodetect based on INTERLOCK and GPIO defined. STATUS 13 shows the mode. 1 = normal two relay up/off down/off 2 = two relay on/off up/down 3 = one relay garage mode 4 = one relay plus stepper motor 5 = one relay and position servo ShutterButton<x> <button> <func> <mqtt> Assign a button to control the shutter. For more details please refer to Blinds and Shutters support <button> \u2003 0 : disable buttons for this shutter \u2003 1..4 : Button number <func> up / down / updown / toggle : function to assign to the button <mqtt> 1 / 0 : enable/disable MQTT publish for button hold action For example: To control shutter #1 by two buttons: Backlog ShutterButton1 1 up 1; ShutterButton1 2 down 1 assigns button #1 to act as an \"up\" button (1x press open, 2x press 50% position, 3x press 74% position) and button #2 to act as an \"down\" button (1x press close, 2x press 50% position, 3x press 24% position) for shutter #1 including MQTT publish. To control shutter #1 by a single button: ShutterButton1 1 updown 0 assigns button #1 to act as an \"up and down\" button (1x press up, 2x press down). To control shutter #1 by a single button: ShutterButton1 1 toggle 0 assigns button #1 to act as a \"toggle\" button (1x press toggle, 2x press 50% position). ShutterCalibration<x> Granular shutter position calibration. The measured opening position of the shutter at the 30, 50, 70, 90, and 100 percent opened locations. For example: ShutterCalibration<x> 23 38 56 74 82 ShutterChange -100..100 - change shutter position from current in % ShutterCloseDuration<x> 1..255 (default = 10 ) time, in seconds, it takes to fully close the shutter. A fraction of a second can be specified (e.g. 45.7 ). ShutterClose<x> Engage the relay to close the shutter. This action can be requested at any time. Number of shutter can be the index or the arguement ShutterFrequency<x> 0..10,000 Hz (default = 1000 ) the maximum frequency at which the stepper motor can operate reliably. Typically this is up to 2,000Hz with a 12V power supply and up to 5,000Hz with a 24V power supply. ShutterEnableEndStopTime<x> 0 = no additional shutter end stop time (default) 1 = 1 s additional shutter end stop time ShutterInvert<x> 0 = use default shutter positioning ( 0 = Closed, 100 = Open) 1 = invert shutter positioning ( 100 = Closed, 0 = Open) (e.g., if used with KNX) ShutterInvertWebButtons<x> 0 = use default button icons (\u25b2 for open, \u25bc for close) 1 = invert button icons (\u25bc for open, \u25b2 for close) (e.g., if used with horizontal awning: where open means rolling-down fabric material and close rolling-up in a protect position) ShutterLock<x> 0 = unlock shutter positioning (default) 1 = lock shutter positioning ShutterMotorDelay<x> 0.00 .. 12.75 (default = 0 ) time, in seconds, it takes the motor to start moving once power is turned on; i.e., motor lag time. When used with stepper motors, this setting defines the ramp up/down speed (i.e., acceleration/deceleration) before the motor reaches its target speed for gradual starting and stopping. ShutterOpenDuration<x> 1..255 (default = 10 ) time, in seconds, it takes to fully open the shutter. A fraction of a second can be specified (e.g. 45.7 ). ShutterOpen<x> Engage the relay to open the shutter. This action can be requested at any time. Number of shutter can be index or the arguement ShutterPosition<x> 0..100 , UP , DOWN , STOP A shutter position change can be requested at any time. The shutter will stop and revert or update to the requested position. The shutter's actual position will be saved after the movement is completed. In this case, the position will be restored during reboot. An interruption during shutter movement (e.g., a device restart) will lose the current position. ShutterMove<x> -100..100 Moves the shutter from the current position relativly in %. If the resulting position is below 0 or above 100 it will be capped. Command can also be executed during movement and will change the target position. ShutterPWMRange<x> 0..1023,0..1023 For servo motors the min and max position is defined by the length of the duty cycle signal. Because every servo is different the min and max PWM value must be set for each servo type. The value is also dependend on the PWMfrequency . Servos normally use 50..200 as PWMfrequency . ShutterRelay<x> <value> 0 = disable this and all higher numbered shutters Relay<value> component used to open the shutter. This relay's mate, the next higher numbered relay, closes the shutter. Depending on the shutter mode, the relays may need to be interlocked using the Interlock command. The ShutterRelay command must be executed first before any other shutter commands for Shutter<x> can be executed. ShutterSetClose<x> shutter closed position. ShutterPosition will be reset to fully closed value (e.g., 0 when ShutterInvert = 0 , 100 otherwise). ShutterSetOpen<x> shutter opened position. ShutterPosition will be reset to fully opened value (e.g., 100 when ShutterInvert = 0 , 0 otherwise). ShutterSetHalfway<x> 0..100 (default = 50 ) Define shutter half open position (in percent) ShutterStop<x> Disengage the relays to stop the shutter. Number of shutter can be the index or the argument ShutterStopClose<x> Stop the shutter when currently moving, close it otherwise ShutterStopOpen<x> Stop the shutter when currently moving, open it otherwise ShutterStopPosition<x> Stop the shutter when currently moving, set it to position 0..100 , UP , DOWN , STOP , TOGGLE otherwise ShutterStopToggle<x> Stop the shutter when currently moving, do ShutterToggle otherwise ShutterStopToggleDir<x> Stop the shutter when currently moving, do ShutterToggleDir otherwise ShutterToggle<x> Toggle the shutter - close the shutter when its position is >50, open it otherwise ShutterToggleDir<x> Toggle the shutter - close the shutter when it previously moved to open, open it otherwise See also SetOption80 - Enable shutter support Zigbee ~ See Zigbee article for more information Command Parameters <device> As <device> in following commands you can use interchangeably: <shortaddr> = short address of the Zigbee device on the network, example: 0x1234 <longaddr> = permanent IEEE address of the Zigbee device (64 bits), example: 0x00158D00041160C5 <index> = number of the device in the internal list (starts at 1), ideal for enumerating devices, example: 3 for third device in the list <name> = friendly name. Only when previously set with ZbName ZbBind Binds one Zigbee device to another device or to a group. This allows one device to directly send commands (f.e. a remote to a bulb) without any action on the coordinator. Command structure: {\"Device\":\"<device>\", \"Endpoint\":<endpoint>, \"Cluster\":<cluster>, \"ToDevice\":\"<to_device>\", \"ToEndpoint\":<to_endpoint>, \"ToGroup\":<to_group> } <device> = device sending messages (mandatory) <endpoint> = source endpoint (mandatory) <cluster> = source cluster id (mandatory) <to_device> = target device (optional) <to_endpoint> = target endpoint \u2003(optional if it can be inferred from ZbStatus3 ) <to_group> = target group id (optional) You must specify either \"ToDevice\" or \"ToGroup\" but not both Zigbee2Tasmota must know the IEEE address of target device, see ZbStatus2 to verify and ZbProbe to have Zigbee2Tasmota query the address ZbBindState<n> Asks the device for its internal binding states <device> the device to query <n> the start index for the request, 1 is the default. This is used to scan through all bindings. ZbConfig display the current Zigbee configuration Example or result: {\"ZbConfig\":{\"Channel\":11,\"PanID\":\"0x1A63\",\"ExtPanID\":\"0xCCCCCCCCCCCCCCCC\",\"KeyL\":\"0x0F0D0B0907050301\",\"KeyH\":\"0x0D0C0A0806040200\"}} ZbConfig <json> change the configuration and restart if any change was applied. Warning: change in configuration causes a reset of the CC2530/ZBBridge and requires devices to be re-paired. \"Channel\":<channel> : Zigbee radio channel (11-26) \"PanID\":<panid> : identifier of the Zigbee Network \"ExtPanID\":<extpanid> : unique identifier of the Zigbee Network (ExtPanID features are not supported in Z2T but this parameter needs to be set) \"KeyL\":<key_l>,\"KeyH\":<key_h> : 128 bits encryption key, split into 2 64 bits values (Low and High) \"TXRadio\":<txradio> : radion power in dBm (1-20) only for ZBBridge All parameters are optional and only the ones specified are changed. The command always displays the complete configuration after the change Example of command: ZbConfig {\"Channel\":22,\"PanID\":\"0x1A69\",\"ExtPanID\":\"0xDDCCCCCCCCCCCCCC\",\"KeyL\":\"0xFF0D0B0907050301\",\"KeyH\":\"0xED0C0A0806040200\"} The following command creates a highly secure Network key based on a hardware random generator: ZbConfig {\"KeyL\":\"\",\"KeyH\":\"\"} ZbData feature in development ZbForget Used for devices that are unused but still visible in ZbStatus <device> = Remove a device from the Tasmota flash memory. It does not un-pair the device nor deleting the device information in the CC2530/ZBBridge. ZbLeave <device> = request a device to leave the network ZbInfo <device> = display all information known about a device, equivalent to ZbStatus3 with a simpler JSON output ZbLight Sets or reads the light type to be emulated in Zigbee Hue Emulation with Alexa. <device>,<light_type> sets the light type using an integer 0..5 corresponding to the number of channels (from one channel (on/off) to 5 channel (RGBCCT) lights) <device>,-1 removes the device from Philips Hue emulation <device> displays the current status of the Light (Zigbee2Tasmota tracks all changes to the light) ZbListen<x> <group> (EZSP ZBBridge only)Listens to a multicast group address. By default EZSP will not report group messages unless you subscribe to the group. <x> : slot in the array of group addresses, 1..15 <group> : group address to listen to, 0..0xFFFF At start-up, Z2T automatically listns to groupe 0 in slot 0. CC2530 does not need this command and always report all group messages. ZbMap<n> Asks the device for its view of the Zigbee topology <device> the device to query <n> the start index for the request, 1 is the default. This is used to scan through all values since devices usually return only 3 values per request. ZbName Sets or reads the Zigbee device friendly name (up to 32 characters). <device>,<name> sets the new friendly name <device>, (empty name) clears the friendly name <device> displays the current friendly name Also see SetOption83 1 to enable friendly names as JSON keys instead of ShortAddr. ZbOccupancy Configure the time-out after \"Occupancy\":1 to send a synthetic \"Occupancy\":0 for Zigbee motion sensors <device>,<x> - set occupancy timeout for <device> Possible values for <x> 0 : no time-out, the device actually generates \"Occupancy\":0 n : the number of seconds. The possible values are 15, 30, 45, 60, 75, 90, 105, 120. If the number is different, it is rounded up -1 : apply the default of 90 seconds ZbPermitJoin Sets pairing mode for new device discovery 0 = disable pairing mode 1 = enable pairing mode for 60 seconds 99 = enable pairing until device reboots (CC2530 only) Leaving Zigbee network open to join will allow any Zigbee device to connect and retrieve your network encryption key. This can lead to a compromise of your Zigbee network. ZbPing <device> = test availability of Zigbee device. If the device is connected and not sleeping, you should receive a ZbPing message within the next second. Example: ZbPing 0x5ADF responds with: {\"ZbPing\":{\"Device\":\"0x5ADF\",\"IEEEAddr\":\"0x90FD9FFFFE03B051\"}} ZbSend Command structure: {\"Device\":\"<shortaddr>\", \"Endpoint\":\"<endpoint>\", \"Manuf\":<manuf>, \"Send\":{\"<sendcmd>\":<sendparam>}} <shortaddr> = short address of the Zigbee device on the network <endpoint> = target endpoint on the device ( understanding endpoints ) <manuf> = (optional) forces a specific ManufacturerId in the ZCL frame (required by some Xiaomi devices) \"<sendcmd>\":<sendparam> = command and parameters to send ( Zigbee Device Commands ) _Use ZbZNPSend to send a raw form low-level message on CC253x gateways _ Example: ZbSend { \"Device\":\"0x1234\", \"Endpoint\":\"0x03\", \"Send\":{\"Power\":\"on\"} } ZbStatus<x> Display Zigbee devices seen on the network since boot <device> (optional) = all devices This command provides three levels of increasing detail according to <x> ZbStatus1 Display Short Address, and Friendly Name ZbStatus2 Also include Manufacturer ID and Model ID ZbStatus3 Also include a list of endpoints and the clusterIds supported by each endpoint Example: ZbStatus3 1 requests all details for device number 1 Requested information may exceed maximum result size allowed by Tasmota. In this case, the output will be truncated. To get all of the desired information, request results for a specific device individually. ZbUnbind Unbinds one Zigbee device from another or from a group. {\"Device\":\"<device>\", \"Endpoint\":<endpoint>, \"Cluster\":<cluster>, \"ToDevice\":\"<to_device>\", \"ToEndpoint\":<to_endpoint>, \"ToGroup\":<to_group> } <device> = the device sending the messages (mandatory) <endpoint> = the source endpoint (mandatory) <cluster> = the source cluster id (mandatory) <to_device> = the target device (optional) <to_endpoint> = the target endpoint (optional if it can be inferred from ZbStatus3 ) <to_group> = the target group id (optional) You must specify either \"ToDevice\" or \"ToGroup\" but not both Zigbee2Tasmota must know the IEEE address of the target device, use ZbStatus2 to verify and ZbProbe to query the address. See also SetOption83 , SetOption89 , SetOption100 , SetOption101 Zigbee Debug Functions Do not use unless you know exactly what you are doing. Command Parameters ZbModelId Manually force the ModelId field of a Zigbee device. This is used to simulate devicesnot physically present on the network, for debugging only. <device>,<modelid> = set new ModelId <device>, = (empty modelid) clear ModelId <device> = display current ModelId (also displayed in ZbStatus2 ) ZbProbe <device> = probe a Zigbee device to get additional information including its IEEEaddress, vendor and model names, endpoints, and supported clusters per endpoint. Device probe is performed automatically when a new Zigbee device connects. Battery powered Zigbee devices can not be probed in general because they are usually in sleep mode. ZbRead Removed in favor of ZbSend with \"Read\" attribute. ZbReset 1 = perform a factory reset and reconfiguration of the CC2530 chip. You will need to re-pair all Zigbee devices ZbRestore Restores a device configuration previously dumped with ZbStatus2 . This command does not pair a device, but lets you get back device configuration like ModelId or IEEEAddress. <json> = json contains the fields dumped with ZbStatus2 . <json> can contain multiple devices (if they fit). ZbSave <hex> Forces saving the Zigbee device information to Flash. Auto-saving happens 10 seconds after a new Device parameter was changed, this command is normally not useful ZbZNPSend <hex> (CC2530 only) Send a raw ZCL message to a Zigbee device. This is a low-level command, and requires to manually build the ZCL parameters. Most common usage will be provided as high-level functions. ZbZNPReceive (CC2530 only) Simulates a received message <hex> = hex string of the simulated message, same format as ZbZNPReceived debug logs ZbEZSPSend<x> <hex> (EZSP only) Send a raw EZSP message. This is a low-level command, and requires to manually build the ZCL parameters. Most common usage will be provided as high-level functions. <x> : 1 =high-level EZSP command, 2 =low-level EZSP frame, 3 =low-level EZSP/ASH frame <hex> = hex string of the message ZbEZSPReceive<x> <hex> (EZSP only) Simulates a received message <x> : 1 =high-level EZSP command, 2 =low-level EZSP frame, 3 =low-level EZSP/ASH frame <hex> = hex string of the simulated message, same format as ZbZNPReceived debug logs Bluetooth ~ Command Parameters HM10Scan Start a new device discovery scan HM10Period Show interval in seconds between sensor read cycles. Set to TelePeriod value at boot. HM10Baud Show ESP8266 serial interface baudrate ( Not HM-10 baudrate ) <value> = set baudrate HM10AT <command> = send AT commands to HM-10. See list HM10Time <n> = set time time of a LYWSD02 only sensor to Tasmota UTC time and timezone. <n> is the sensor number in order of discovery starting with 0 (topmost sensor in the webUI list). HM10Auto <value> = start an automatic discovery scan with an interval of <value> seconds to receive data in BLE advertisements periodically. This is an active scan and it should be used only if necessary . At the moment that is the case just with MJ_HT_V1. This can change if a future HM-10 firmware starts supporting passive scan. NRFPage Show the maximum number of sensors shown per page in the webUI list. <value> = set number of sensors (default = 4) NRFIgnore 0 = all known sensor types active_(default)_ <value> = ignore certain sensor type ( 1 = Flora, 2 = MJ_HT_V1, 3 = LYWSD02, 4 = LYWSD03, 5 = CGG1, 6 = CGD1 NRFScan Scan for regular BLE-advertisements and show a list in the console 0 = start a new scan list 1 = append to the scan list 2 = stop running scan NRFBeacon Set a BLE device as a beacon using the (fixed) MAC-address <value> (1-3 digits) = use beacon from scan list <value> (12 characters) = use beacon given the MAC interpreted as an uppercase string AABBCCDDEEFF Stepper Motors ~ Command Parameters MotorMIS 1,2,4,8,16 Set micro stepping increment - 1/1 (full steps) to 1/16 (default = 1 ) MotorSPR integer Set the number of steps the given motor needs for one revolution (default = 200 ) This is dependent on the type of motor and micro stepping. Most common motors are 1.8\u00b0 per step. MotorRPM 1..300 Set revolutions per minute (default = 30 ) MotorMove integer Move the motor the given number of steps (positive values: clockwise, negative values: counterclockwise) MotorRotate integer Rotate the motor the given number of degrees (positive values: clockwise, negative values: counterclockwise) MotorTurn float Spin the motor the given number of turns (positive values: clockwise, negative values: counterclockwise) MP3 Player ~ The MP3 Player driver is based on the one from DFRobot. They named it DFPlayer mini . All MP3 Players with the identical Serial Control Command structure can be used. Command Parameters MP3DAC 0 = DAC on (default) 1 = DAC off MP3Device Specify playback device 1 = USB 2 = SD Card (default (also defaults on reset or power cycle)) MP3EQ Set equalizer mode: 0 = normal 1 = pop 2 = rock 3 = jazz 4 = classic 5 = bass) MP3Pause Pause MP3Play Play, works as a normal play on a real MP3 Player, starts at first MP3 file MP3Reset Reset the MP3 player to defaults MP3Stop Stop MP3Track x = play track <x> MP3Volume 0..100 = set Volume ESP32 ~ Command Parameters Ethernet Currently only for Olimex ESP32-PoE board 0 = disable Ethernet 1 = enable Ethernet (default) EthAddress Set ethernet address. Currently only for Olimex ESP32-PoE board 0..31 = PHYxx address EthClockMode Ethernet clock mode. Currently only for Olimex ESP32-PoE board 0 = ETH_CLOCK_GPIO0_IN (default) 1 = ETH_CLOCK_GPIO0_OUT 2 = ETH_CLOCK_GPIO16_OUT 3 = ETH_CLOCK_GPIO17_OUT EthType Ethernet type. Currently only for Olimex ESP32-PoE board 0 = ETH_PHY_LAN8720 *(default) 1 = ETH_PHY_TLK110 2 = ETH_PHY_IP101 Wi-Fi Currently only for Olimex ESP32-PoE board 0 = disable Wi-Fi 1 = enable Wi-Fi (default) Thermostat ~ Command Parameters ThermostatModeSet Sets the thermostat mode 0 = Thermostat Off (controller inactive, default) 1 = Thermostat in automatic mode (controller active) 2 = Thermostat in manual mode (output switch follows the input switch, used to follow an existing wall thermostat) ClimateModeSet Sets the climate mode 0 = Heating mode (default) 1 = Cooling mode ControllerModeSet Sets the controller mode (used for thermostat in automatic mode) 0 = Hybrid controller (Predictive ramp-up controller and PI, default) 1 = PI controller 2 = Predictive ramp-up controller TempFrostProtectSet Sets the frost protection temperature. The controller, if in automatic mode, will never allow the temperature to sink below this value <0..12> = Temperature value in degrees Celsius/Fahrenheit (default 4.0\u00b0 Celsius) InputSwitchSet Sets the number of the input used in case in manual control <1..4> = Number of the input (default 1) InputSwitchUse Switch to decide if the input shall be used to automatically switch to manual mode and assign it to the output (usefull if using a serially connected wall thermostat) 0 = Input not used (default) 1 = Input used SensorInputSet Sets the temperature sensor to be used 0 = MQTT (default) 1 = Local sensor (can be changed by define, default DS18B20) OutputRelaySet Sets the output switch to be used for the thermostat <1..8> = Number of the output (default 1) EnableOutputSet Enables or disables the physical output 0 = Output disabled 1 = Output enabled (default) TimeAllowRampupSet Sets the minimum time in minutes since the last control action to be able to switch to the predictive ramp-up controller phase (applicable just in case of Hybrid controller, used normally in case of big deltas between the setpoint and the room temperature) <value> = Minutes (default 300 minutes) TempFormatSet Sets the temperature format 0 = Degrees celsius (default) 1 = Degrees Fahrenheit TempMeasuredSet Sets the temperature measured by the sensor (for MQTT sensor mode) <TempFrostProtectSet..100> = Temperature (default 18.0\u00b0 Celsius) TempTargetSet Sets the target temperature for the controller (setpoint) <TempFrostProtectSet..100> = Temperature (default 18.0\u00b0 Celsius) TempMeasuredGrdRead Returns the calculated temperature gradient <value> = Temperature gradient in degrees Celsius/Fahrenheit StateEmergencySet Sets the thermostat emergency flag 0 = Emergency flag off (default) 1 = Emergency flag on (thermostat switches to off state) TimeManualToAutoSet Sets the time in manual mode after the last active input action (f.i. last action from serial connected wall thermostat) to switch to aumatic mode 0..1440 = time in minutes (default 60 minutes) PropBandSet Sets the value of the proportional band of the PI controller 0..20 = value in degrees Celsius (default 4 degrees Celsius) TimeResetSet Sets the value of the reset time of the PI controller 0..86400 = value in seconds (default 12000 seconds) TimePiProportRead Returns the proportional part of the PI controller calculation in seconds value = value in seconds TimePiIntegrRead Returns the integral part of the PI controller calculation in seconds value = value in seconds TimePiCycleSet Sets the value of the cycle for the PI controller 0..1440 = value in minutes (default 30 minutes) TempAntiWindupResetSet Sets the value of the delta between controlled temperature and setpoint above which the integral part of the PI controller will be set to 0, in degrees Celsius/Fahrenheit 0..10 = value in degrees (default 0.8\u00b0 Celsius) TempHystSet Sets the value of the temperature hysteresis for the PI controller, in degrees Celsius/Fahrenheit -10..10 = value in degrees (default 0.1\u00b0 Celsius) TimeMaxActionSet Sets the maximum duty cycle of the PI controller in minutes 0..1440 = value in minutes (default 20 minutes) TimeMinActionSet Sets the minimum duty cycle of the PI controller in minutes 0..1440 = value in minutes (default 4 minutes) TimeSensLostSet Sets the maximum time without a temperature sensor update to mark it as lost in minutes 0..1440 = value in minutes (default 30 minutes) TimeMinTurnoffActionSet Sets the minimum time in minutes within a cycle for the PI controller to switch off the output, below it, it will stay on 0..1440 = value in minutes (default 3 minutes) TempRupDeltInSet Sets the minimum delta between controlled temperature and setpoint for the controller to switch to ramp-up controller phase (applicable just in Hybrid controller mode) 0..10 = value in degrees Celsius/Fahrenheit (default 0.4\u00b0 Celsius) TempRupDeltOutSet Sets the maximum delta between controlled temperature and setpoint for the controller to switch to the PI controller phase (applicable just in Hybrid controller mode) 0..10 = value in degrees Celsius/Fahrenheit (default 0.2\u00b0 Celsius) TimeRampupMaxSet Sets the maximum time in minutes for the controller to stay in the ramp-up phase (applicable just in Hybrid controller mode 0..1440 = value in minutes (default 960 minutes) TimeRampupCycleSet Sets the value of the cycle for the ramp-up controller 0..1440 = value in minutes (default 30 minutes) TempRampupPiAccErrSet Sets the initial accumulated error when switching from ramp-up to the PI controller phase if the target temperature has not been reached (applicable just in Hybrid controller mode) 0..25 = value in degrees Celsius/Fahrenheit (default 2\u00b0 Celsius) CtrDutyCycleRead Returns the duty cycle of the controller 0..100 = value in % DiagnosticModeSet Enables/disables the diagnostics flag 0 = Diagnostics disabled 1 = Diagnostics enabled (default) Domoticz ~ Command Parameters DzIdx<x> Show Domoticz Relay idx <x> (x = 1..4 ) 0 = disable use of Relay idx <x> (default) <value> = Show Relay idx <x> DzKeyIdx<x> Show Domoticz Key idx <x> (x = 1..4 ) 0 = disable use of Key idx <x> (default) <value> = Show Key idx <x> (to use enable ButtonTopic ) DzSend<type> send values or state to Domoticz <index>,<value1(;value2)|state> DzSensorIdx<x> Show Domoticz Sensor idx <x> (x = 1..5 ) 0 = disable use of Sensor idx <x> (default) <value> = Show Sensor idx <x> DzSwitchIdx<x> Show Domoticz Switch idx <x> (x = 1..4 ) 0 = disable use of Switch idx <x> (default) <value> = Show Switch idx <x> (to use enable SwitchTopic ) DzUpdateTimer Show current update timer value in seconds 0 = disable sending interim Domoticz status (default) 1..3600 = send status to Domoticz in defined intervals KNX ~ Command Parameters KnxTx_Cmnd<x> 0 or 1 = send command using slot <x> set in KNX Menu at KNX_TX KnxTx_Val<x> <value> = send float value using slot <x> set in KNX Menu at KNX_TX KnxTx_Scene <value> = send scene number to the GA set in KNX Menu KNX_ENABLED Status of KNX Communications 0 = set to Disable 1 = set to Enable KNX_ENHANCED Status of Enhanced mode for KNX Communications 0 = set to Disable 1 = set to Enable KNX_PA KNX Physical Address 0.0.0 = address not set x.x.x = set the device address (example 1.1.0 ) KNX_GA Return the amount of Group Address to Send Data/Commands configured KNX_GA<x> Setup Group Address to Send Data/Commands (<x> = KNX Group Address number) 1 = return configuration of GA<x> <option>, <area>, <line>, <member> to set configuration of GA<x> <option> = see table below for OPTION list <area>, <line>, <member> = KNX Address to Send Data/Commands KNX_CB Return the amount of Group Address to Receive Data/Commands configured KNX_CB<x> Setup Group Address to Receive Data/Commands 1 = return configuration of CB<x> <option>, <area>, <line>, <member> to set configuration of CB<x> <option> = see table below for OPTION list <area>, <line>, <member> = KNX Address to Receive Data/Commands OPTION OPTION Value OPTION OPTION Value 1 Relay 1 17 TEMPERATURE 2 Relay 2 18 HUMIDITY 3 Relay 3 19 ENERGY_VOLTAGE 4 Relay 4 20 ENERGY_CURRENT 5 Relay 5 21 ENERGY_POWER 6 Relay 6 22 ENERGY_POWERFACTOR 7 Relay 7 23 ENERGY_DAILY 8 Relay 8 24 ENERGY_START 9 Button 1 25 ENERGY_TOTAL 10 Button 2 26 KNX_SLOT1 11 Button 3 27 KNX_SLOT2 12 Button 4 28 KNX_SLOT3 13 Button 5 29 KNX_SLOT4 14 Button 6 30 KNX_SLOT5 15 Button 7 255 EMPTY 16 Button 8","title":"Commands"},{"location":"Commands/#how-to-use","text":"Every command used without a parameter (payload) returns the current setting . Power returns the status of first defined power output (usually Relay1)\" Instead of 0 you can use off or false and instead of 1 you can use on or true . Power ON turns first defined power output (usually Relay1) on Power1 1 also turns first defined power output (usually Relay1) on Power1 True also turns first defined power output (usually Relay1) on Replace <x> in a command with the appropriate index number. Leave it empty to use the first available. Power1 and Power both control first defined power output (usually Relay1) In commands with x..y value parameters use a number from x to y range. When a command mentions resetting to \"firmware default\" it means the setting will revert to the one in the flashed binary file. If you used user_config_override.h at compile time it will revert to those. Note Beside results initiated by a command (synchronous) you can get asynchronous results initiated by rule trigger, telemetry event, commands from other source or changed device values. Simply put, other messages may precede messages published as a result of your commands. Example A tele/%topic%/STATUS message (sent every 300 seconds by default) may appear exactly after you issue Power off command and before you receive stat/%topic%/RESULT = {\"POWER\":\"OFF\"} message.","title":"How to use"},{"location":"Commands/#with-mqtt","text":"To send commands and view responses you'll need an MQTT client . Commands over MQTT are issued by using cmnd/%topic%/<command> <parameter> where %topic% is the topic of the device you're sending the command to. If there is no <parameter> (an empty MQTT message/payload), a query is sent for current status of the <command> . See MQTT article to find out more.","title":"with MQTT"},{"location":"Commands/#with-web-requests","text":"Commands can be executed via web (HTTP) requests, for example: http://<ip>/cm?cmnd=Power%20TOGGLE http://<ip>/cm?cmnd=Power%20On http://<ip>/cm?cmnd=Power%20off http://<ip>/cm?user=admin&password=joker&cmnd=Power%20Toggle Any spaces or special characters must be replaced with their ASCII hex codes . You must precede each hex code with % . Most used codes are: space = %20 and ; = %3B . Tip Use URLencoder.org to easily convert your commands. If you have set a password for web user interface access, this must be included (in plaintext) in the URL of the HTTP request, like so: http://<ip>/cm?user=<username>&password=<password>&cmnd=Power%20On","title":"with Web Requests"},{"location":"Commands/#in-console-in-the-web-ui","text":"Console menu in the web UI is a convenient place to send commands and it behaves similar to a terminal connection via serial bridge. Warning The GUI controls do not and can not have all the features and commands implemented. For precise and complete control use Console commands!","title":"in Console in the Web UI"},{"location":"Commands/#over-serial-bridge","text":"If you flashed the device via serial method you can connect to it with a terminal application (e.g. Termite or Arduino IDE Serial Monitor) to issue commands and follow responses. This is a practical way to do a Backlog setup of your new device. Serial interface is set to 115200 bps except for devices that require a different baudrate","title":"over Serial Bridge"},{"location":"Commands/#the-power-of-backlog","text":"Backlog command allows executing up to 30 consecutive commands with a single command line. Each command is separated by a semicolon (\";\"). Backlog is a useful feature to avoid numerous restarts when setting up a new device. You can use it to: Set up both Wi-Fi AP's Backlog SSID1 < myssid > ; Password1 < mypassword > ; SSID2 < myssid2 > ; Password2 < mypassword2 > Configure MQTT broker address, MQTT credentials, device topic and activate a few custom options Backlog MqttHost < yourhost > ; MqttUser < user > ; MqttPassword < password > ; Topic < customtopic > ; SetOption53 1 ; PowerRetain on For specific power control, using backlog like a script Backlog Status 1 ; Power2 on ; Delay 20 ; Power2 off ; Status 4 When using web requests (Don't forget to encode \"space\" as '%20' and \";\" as '%3B') http://<ip>/cm?user=admin&password=joker&cmnd=Backlog%20Power%20Toggle%3BPower1%20ff A Backlog command without an argument clears an possible existing Backlog queue. Example in case of command Backlog Power1 OFF; Delay 600; Power1 ON the usage of an additional Backlog command without any argument within the delay time of 1 minute will delete the whole queue Power1 OFF; Delay 600; Power1 ON . Therefore Power1 ON command will not be executed and the power would remain off.","title":"the Power of Backlog"},{"location":"Commands/#commands-list","text":"Warning If you're using Tasmota versions earlier current release some of the commands might not work. Availability of some features and their associated commands depend on the firmware build. Please consult the builds table for a reference of which features are available for each firmware variant. Note Almost all settings using string parameters (except Rule and MqttFingerprint ) share a common area with max 698 chars, i.e. the total length of all these parameters is limited to this size (you will be noted if this limit is exceeded).","title":"Commands List"},{"location":"Commands/#control","text":"Command Parameters Backlog List of commands to be executed in sequence separated by ; See Using Backlog for examples. BlinkCount Number of relay toggles ( blinks ) (does not control the status LED) 0 = blink many times before restoring power state 1..32000 = set number of blinks (default = 10 ) BlinkTime 2..3600 set duration, in 0.1 second increments, to blink aka toggle Power (does not control the status LED) ButtonDebounce User control over button debounce timing 40..1000 = set button debounce time in milliseconds (default = 50 ) Buzzer 0 = stop active buzzer cycle <count>,<beep>,<silence>,<tune> = read more... 2,3 = Beep twice with 300 milliseconds duration and 100 milliseconds pause 2,3,4 = Beep twice with 300 milliseconds duration and 400 milliseconds pause 1,2,3,0xF54 (0000 0000 0000 0000 0000 1111 0101 0100). Each 1 bit beeps for 200 milliseconds and each bounded 0 bit pauses for 300 milliseconds -1 = infinite mode -2 = follow LED mode DevGroupName<x> 0 = clear device group <x> name and restart <value> = set device group <x> name and restart. Prior to 8.2.0.3, GroupTopic was used to specify the device group name DevGroupSend<x> <item>=<value>[ ...] = send an update to device group <x>. The device group name must have been previously set with DevGroupName<x>. Multiple item/value pairs can be specified separated by a space. Spaces in <value> must be escaped with a backslash (\\). The message sent is also processed on the local device as if it had been received from the network. For items with numeric values, <value> can be specified as @<operator>[<operand>] to send a value after performing an operation on the current value. <operator> can be + (add), - (subtract) or ^ (invert). If <operand> is not specified, it defaults to 0xffffffff for the invert operator and 1 for other operators. 2 = Light fade (0 = Off, 1 = On) 3 = Light speed (1..40) 4 = Light brightness (0..255) 5 = Light Scheme 6 = Light fixed color (0 = white (using CT channels), other values according to Color Command ) 7 = PWM dimmer low preset (0..255) 8 = PWM dimmer high preset (0..255) 9 = PWM dimmer power-on brightness (0..255) 128 = Relay Power - bitmask with bits set for relays to be powered on. The number of relays can be specified in bits 24 - 31. If the number of relays is not specified, only relay 1 is set 192 = Event - event name and arguments 193 = Command - command and arguments 224 = Light channels - comma separated list of brightness levels (0..255) for channels 1 - 5 (e.g. 255,128,0,0,0 will turn the red channel on at 100% and the green channel on at 50% on an RBG light) Examples: DevGroupSend 4=90 128=1 - send an update to set the light brightness to 90 and turn relay 1 on. DevGroupSend 193=Buzzer\\ 2,3 - send the Buzzer 2,3 command. DevGroupSend 6=@+ 4=@-10 - set the next fixed color and decrease the brightness by 10. DevGroupSend 128=^ - toggle all the relays. DevGroupShare <in>,<out> = set incoming and outgoing shared items (default = 0xffffffff,0xffffffff ) . <in> and <out> are bit masks where each mask is the sum of the values for the categories (listed below) to be shared. For example, to receive only power (1), light brightness (2) and light color (16) and send only power (1), enter the command DevGroupShare 19,1. 1 = Power 2 = Light brightness 4 = Light fade/speed 8 = Light scheme 16 = Light color 32 = Dimmer settings (presets) 64 = Event DevGroupStatus<x> Show the status of device group <x> including a list of the currently known members. FanSpeed Fan speed control (iFan02/iFan03 only) 0 = turn fan OFF 1..3 = set fan speed + = increase fan speed - = decrease fan speed Interlock Relay interlock mode and group selection. 0 = disable relay interlock for all relays (i.e., each relay is self-locking) (default) 1 = set interlock mode for selected relays Add up to 8 relays in 1 to 4 interlock groups, each separated by a space. For example 1,2 3,4 = Group Relay1 and Relay2 in group 1 and Relay3 and Relay4 in group 2 ( note the space between the two groups ) 1,2,3 = group Relay1, Relay2 and Relay3 in a single interlock group 1 3 2,4 = Relay1 is in group 1, Relay3 in group 2, Relay2 and Relay4 in group 3 LedMask Set a bitmask specifiying which relays control the LED indicator. Read more... <bitmask> = bitwise value representing each relay. Values may be entered as either hexadecimal or decimal values (e.g., 0xFFFF = 65535). 0xFFFF (= 1111 1111 1111 1111) All relays control the power LED (default) LedState must be enabled (i.e., != 0 ) in order for LedMask to take effect. LedPower LED power state as on or off 0 = turn LED OFF and set LedState 0 1 = turn LED ON and set LedState 8 2 = toggle LED and set LedState 0 (Use Backlog LedPower 0; SetOption31 1 to disable LED even when Wi-Fi or MQTT is not connected) LedPower<x> LED<x> power state control. Enabled only when LedLink(i) is configured 0 = turn LED OFF and set LedState 0 1 = turn LED ON and set LedState 0 2 = toggle LED and set LedState 0 LedState Manage LED state 0 = disable use of LED as much as possible 1 = show power state on LED (LED on when power on) (default) (inverted for Sonoff Touch/T1) 2 = show MQTT subscriptions as a LED blink 3 = show power state and MQTT subscriptions as a LED blink 4 = show MQTT publications as a LED blink 5 = show power state and MQTT publications as a LED blink 6 = show all MQTT messages as a LED blink 7 = show power state and MQTT messages as a LED blink 8 = LED on when Wi-Fi and MQTT are connected. Cannot be issued directly and is only activated when LedPower is switched from 0 to 1 due to a software function NoDelay Delay defined by SetOption34 is omitted for any command in a backlog sequence following immediately after NoDelay This must be used with care, and only for simple commands. Example Power0 Control the power state simultaneously for all power outputs on the device 0 / off = turn OFF 1 / on = turn ON 2 / toggle = if relay is ON switch to OFF and vice versa Power<x> Control the corresponding power state ( 1..8 ) (also restarts PulseTime)<x> 0 / off / false = turn OFF 1 / on / true = turn ON 2 / toggle = if power state is ON switch to OFF and vice versa 3 / blink = toggle power for BlinkCount times each BlinkTime duration (at the end of blink , power state is returned to pre-blink state) 4 / blinkoff = stop blink sequence and return power state to pre-blink state PowerOnState Control power state when the device is powered up . More information 0 / OFF = keep power(s) OFF after power up 1 / ON = turn power(s) ON after power up 2 / TOGGLE = toggle power(s) from last saved state 3 = switch power(s) to their last saved state (default) 4 = turn power(s) ON and disable further power control 5 = after a PulseTime period turn power(s) ON (acts as inverted PulseTime mode) PulseTime<x> Display the amount of PulseTime remaining on the corresponding Relay<x> <value> Set the duration to keep Relay<x> ON when Power<x> ON command is issued. After this amount of time, the power will be turned OFF . 0 / OFF = disable use of PulseTime for Relay<x> 1..111 = set PulseTime for Relay<x> in 0.1 second increments 112..64900 = set PulseTime for Relay<x>, offset by 100, in 1 second increments. Add 100 to desired interval in seconds, e.g., PulseTime 113 = 13 seconds and PulseTime 460 = 6 minutes (i.e., 360 seconds) SwitchDebounce User control over switch debounce timing and method 40..1000 = set switch debounce time in milliseconds (default = 50 ) . The granularity is 10 milliseconds, so the normally unnecessary last digit is used by the debouncing code to flag special handling: 0 = no special handling 1 = force_high: only a debounce time long LOW pulse could turn the switch off 2 = force_low: only a debounce time long HIGH pulse could turn the switch on 3 = force_high + force_low 4..8 = unused 9 = AC detection for switches / relays similar to MOES MS-104B / BlitzWolf SS5 etc. If the AC frequency is 50 Hz, SwitchDebounce 69 will turn on the switch after three pulses and off after three missing one. SwitchMode<x> Switch mode 0 = toggle (default) 1 = follow (0 = off, 1 = on) 2 = inverted follow (0 = on, 1 = off) 3 = pushbutton (default 1, 0 = toggle) 4 = inverted pushbutton (default 0, 1 = toggle) 5 = pushbutton with hold (default 1, 0 = toggle, Hold = hold) 6 = inverted pushbutton with hold (default 0, 1 = toggle, hold = hold) 7 = pushbutton toggle (0 = toggle, 1 = toggle) 8 = multi change toggle (0 = toggle, 1 = toggle, 2x change = hold) 9 = multi change follow (0 = off, 1 = on, 2x change = hold) 10 = inverted multi change follow (0 = on, 1 = off, 2x change = hold) 11 = pushbutton with dimmer mode 12 = inverted pushbutton with dimmer mode 13 = pushon mode (1 = on, switch off using PulseTime ) 14 = inverted pushon mode (0 = on, switch off using PulseTime ) SwitchText<x> Show current JSON label of Switch<x> ( 1..8 ). Only SwitchText shows value for all 8 switches <text> - replace default Switch<x> label in JSON messages with a custom text Webbutton<x> Change the name of the toggle buttons of the WEB UI. This command accepts spaces in the name See also SetOption1 - Set button multipress mode SetOption11 - Swap pushbutton single and double press functionality SetOption13 - Allow immediate action on single button press SetOption26 - Use indexes even when only one relay is present SetOption31 - Disable Wi-Fi LED status blinking SetOption32 - Set hold interval before sending HOLD action SetOption40 - Stop detecting any input change on button GPIO SetOption67 - Enable/Disable Buzzer SetOption73 - Decouple buttons from controlling power outputs","title":"Control"},{"location":"Commands/#management","text":"Command Parameters Delay 2..3600 = set delay between two backlog commands with 0.1 second increment DeepSleepTime Time to enter deep sleep mode 0 = disable deep sleep mode (default) 11..86400 = set deep sleep mode time period in seconds DeviceName Device name displayed in the webUI and used for HA autodiscovery. <value> = set device name (default = FriendlyName1 value) Emulation 0 = disable emulation (default) 1 = enable Belkin WeMo emulation for Alexa 2 = enable Hue Bridge emulation for Alexa FriendlyName<x> 1 = Reset friendly name to firmware default <value> = set friendly name (32 char limit) Gpios Show list of available components by name and index 255 / All Show list of all components by name and index Gpio Show current component assignments of the Module's configurable GPIO 255 / All Show component assignments for all the devices available GPIO Gpio<x> <component> = assign a component to Gpio<x> I2Cscan Scan I 2 C bus and show addresses for found devices I2CDriver Enable / Disable I 2 C sensor drivers. Read more... LogHost 1 = reset syslog host to firmware default ( SYS_LOG_HOST ) <value> = set syslog host LogPort 1 = reset syslog port to firmware default ( SYS_LOG_PORT ) 2..32766 = set syslog port Modules Show available modules by name and index Module Displays active module by name and index <value> = switch to module <value> and restart 0 = switch to defined template and restart Module2 Displays active fast reboot fallback module by name and index <value> = set fast reboot fallback module to <value> 0 = set fast reboot fallback module to defined template MqttLog 0 = disable logging via MQTT (default) 1 = show only error messages 2 = show error and info messages 3 = show error, info and debug messages 4 = show error, info and more debug messsages NtpServer<x> NTP server setup (x= 1..3 ) 0 = clear NtpServer<x> settings 1 = reset NtpServer<x> settings to firmware defaults <value> = set NtpServer<x> host or IP address (32 char limit) OtaUrl Display current OTA URL 1 = Reset OtaUrl to firmware default url = set address for OTA (100 char limit) Pwm<x> 0..1023 = set PWM value for channel PwmFrequency 1 = reset PWM frequency to 223Hz 100..4000 = set PWM frequency (100Hz to 4kHz) As of v8.3.0 the default frequency changed to 977Hz PwmRange 1 = reset maximum PWM range to 1023 255..1023 = set maximum PWM range Reset 1 = reset device settings to firmware defaults and restart 2 = erase flash, reset device settings to firmware defaults and restart 3 = erase System Parameter Area in flash (Wi-Fi calibration and related data) and restart 4 = reset device settings to firmware defaults but retain Wi-Fi credentials and restart 5 = erase all flash and reset parameters to firmware defaults but keep Wi-Fi settings and restart 6 = erase all flash and reset parameters to firmware defaults but keep Wi-Fi and MQTT settings and restart (Erase of flash can take a few seconds to complete and there is no output during the erase process on the serial or web console) 99 = reset device bootcount to zero Restart 1 = restart device with configuration saved to flash 2 = halt system (needs hardware reset or power cycle to restart) 99 = force restart device without configuration save For debug and testing stack trace dumps only: -1 = force an Exception (28) crash -2 = force a Soft WDT reset (after a freeze of 2 seconds) -3 = force an OS watchdog reset (after a freeze of 120 seconds, caution! ) SaveData 0 = save parameter changes only manually, e.g. with Restart 1 1 = save parameter changes every second (default) 2..3600 = save parameter changes every x second SerialLog Disable hardware serial bridge and 0 = disable serial logging 1 = show only error messages 2 = show error and info messages (default) 3 = show error, info and debug messages 4 = show error, info and more debug messages SerialLog will be disabled automatically 10 minutes after the device reboots. Sleep 0 = turn sleep off 1..250 = set sleep duration in milliseconds to enable energy saving (default = 50 ) State Display current device state and publish to %prefix%/%topic%/RESULT topic\u2003 Status = show abbreviated status information 0 = show all status information (1 - 11) 1 = show device parameters information 2 = show firmware information 3 = show logging and telemetry information 4 = show memory information 5 = show network information 6 = show MQTT information 7 = show time information 8 = show connected sensor information 9 = show power thresholds (only on modules with power monitoring) 10 = same as Status 8 (retained for backwards compatibility) 11 = show information equal to TelePeriod state message 12 = in case of crash to dump the call stack saved in RT memory SysLog 0 = disable syslog logging (default) 1 = show only error messages 2 = show error and info messages 3 = show error, info and debug messages 4 = show error, info and more debug messages Template Show current Template 0 = create template from active module x = create template from a supported module 255 = merge current module and template settings into new template { ... } = store template in a JSON payload Does not activate the template. To activate use Module 0 . Time 0 = enable NTP (default) 1 = format JSON message timestamp in ISO format 2 = format JSON message timestamp in both ISO and Epoch format 3 = format JSON message timestamp in Epoch format 4 = format JSON message timestamp in milliseconds <value> = disable NTP and set UTC time as epoch value if greater than 1451602800 (January 1, 2016) TimeSTD TimeDST Set policies for the beginning of daylight saving time (DST) and return back to standard time (STD)\u2003 0 = reset parameters to firmware defaults H , W , M , D , h , T H = hemisphere ( 0 = northern hemisphere / 1 = southern hemisphere) W = week ( 0 = last week of month, 1..4 = first .. fourth) M = month ( 1..12 ) D = day of week ( 1..7 1 = sunday 7 = saturday) h = hour ( 0..23 ) T = timezone ( -780..780 ) (offset from UTC in MINUTES - 780min / 60min=13hrs) Example: TIMEDST 1,1,10,1,2,660 _If timezone is NOT 99, DST is not used (even if displayed) see Timezone -13..+13 = set timezone offset from UTC in hours -13:00..+13:00 = set timezone offset from UTC in hours and minutes 99 = use timezone configured with TimeDST and TimeSTD Upgrade 1 = download firmware from OtaUrl and restart <value> = download firmware from OtaUrl if <value> is higher than device version Upload 1 = download firmware from OtaUrl and restart <value> = download firmware from OtaUrl if <value> is higher than device version WebLog 0 = disable web logging 1 = show only error messages 2 = show error and info messages (default) 3 = show error, info and debug messages 4 = show error, info and more debug messages See also SetOption68 - PWM Channel control SetOption76 - DeepSleep disable bootcount incrementing","title":"Management"},{"location":"Commands/#wi-fi","text":"Command Parameters AP 0 = switch to other Wi-Fi Access Point 1 = select Wi-Fi Access Point 1 2 = select Wi-Fi Access Point 2 CORS \" = disable CORS (Cross Origin Resource Sharing) (default) * = enable CORS for all locations value = Enable CORS for location. This needs to be complete url ex: http://tasui.shantur.com Hostname 1 = reset hostname to MQTT_TOPIC-<4digits> and restart <value> = set hostname (32 char limit) and restart. If hostname contains % it will be reset to the default instead. If using MQTT to issue this command, if it is used with the device GroupTopic , the command will not be executed. IPAddress<x> Set networking IP ( XXX.XXX.XXX.XXX ) addresses IPAddress1 = set device IP address 0.0.0.0 = use dynamic IP address (DHCP) XXX.XXX.XXX.XXX = set static IP address IPAddress2 = set gateway IP address IPAddress3 = set subnet mask IPAddress4 = set DNS server IP address follow IPAddress commands with restart 1 to apply changes Password<x> <x> = 1..2 <value> = set AP<x> Wi-Fi password and restart 1 = reset AP<x> Wi-Fi password to firmware default ( STA_PASS1 or STA_PASS2 ) and restart Passwords are limited to 64 characters. Do not use special characters or white spaces in the password . Note that Password and Password1 are equivalent commands. Ping<x> <addr> <x> = 0..8 = the number of ICMP packets to send, 0 uses the default (4) <addr> = address to send Ping, either in numerical format 192.168.1.200 or domain name tasmota.com (requires #define USE_PING ) Example Ping4 192.168.1.203 : RSL: tele/tasmota_xxx/RESULT = {\"Ping\":{\"192.168.1.203\":{\"Reachable\":true,\"Success\":4,\"Timeout\":0,\"MinTime\":59,\"MaxTime\":167,\"AvgTime\":116}}} Ssid<x> <x> = 1..2 <value> = set AP<x> Wi-Fi SSID and restart 1 = reset AP<x> Wi-Fi SSID to firmware default ( STA_SSID1 or STA_SSID2 ) and restart SSID are limited to 32 characters. Do not use special characters or white spaces in the SSID WebColor<x> Configure Web GUI colors (x = 1..19 ) #RRGGBB = Set color for WebColor<x> 1 = Global text (Black) 2 = Global background (White) 3 = Form background (Greyish) 4 = Input text (Black) 5 = Input background (White) 6 = Console text (Black) 7 = Console background (White) 8 = Warning text (Red) 9 = Success text (Green) 10 = Button text (White) 11 = Button (Blueish) 12 = Button hovered over (Darker blueish) 13 = Restart/Reset/Delete button (Redish) 14 = Restart/Reset/Delete button hover (Darker reddish) 15 = Save button (Greenish) 16 = Save button hover (Darker greenish) 17 = Config timer tab text (White) 18 = Config timer tab background (Light grey) 19 = Module title and FriendlyName text (Whiteish) User themes WebPassword Show current web server password 0 = disable use of password for web UI 1 = reset password to firmware default ( WEB_PASSWORD ) <value> = set web UI password (32 char limit) for user WEB_USERNAME (Default WEB_USERNAME = admin ) WebRefresh Web page refresh 1000..10000 = set refresh time in milliseconds (default = 2345 ) WebSend Send a command to Tasmota host over http. If a command starts with a / it will be used as a link. [<host>:<port>,<user>:<password>] <command> <host> = hostname or IP address. <port> = port for the device if not the default 80 <user> = enter username of the device you're sending the command to <password> = enter password of the device you're sending the command to <command> = command and payload example 1: [<ip>] POWER1 ON sends http://<ip>/cm?cmnd=POWER1 ON example 2: WebSend [myserver.com] /fancy/data.php?log=1234 sends http://myserver.com/fancy/data.php?log=1234 WebSensor<x> Control display of sensor telemetry in the web UI 0 = Do not display sensor's telemetry 1 = Display sensor's telemetry ( default ) <x> = number corresponding to the sensor - listed in the sns section of the supported sensor spreadsheet <x> = 3 Energy telemetry Issue a Status 4 to obtain a list of sensor types enabled in the firmware loaded on the device. WebServer 0 = stop web server 1 = start web server in user mode 2 = start web server in admin mode WifiConfig 0 = disable Wi-Fi Manager and reboot (used with alternate AP) 2 = set Wi-Fi Manager as the current configuration tool and start Wi-Fi Manager (web server at 192.168.4.1) for 3 minutes, then reboot and try to connect Wi-Fi network 4 = retry other AP without rebooting (default) 5 = wait until selected AP is available again without rebooting 6 = Wi-Fi parameters can only be entered via commands in the serial console 7 = set Wi-Fi Manager (web server at 192.168.4.1) as the current configuration tool restricted to reset settings only. This setting is recommended for devices without an external control/reset button . \u2003 No longer supported 1 = set SmartConfig ( Android /iOS) for 3 minutes 3 = set WPS for 3 minutes WifiPower set Wi-Fi transmit power level in decibel-milliwatts (dBm) (default = 17 ) See also SetOption55 - mDNS service control SetOption56 - Wi-Fi network scan to select strongest signal on restart SetOption57 - Wi-Fi network re-scan, alternate AP","title":"Wi-Fi"},{"location":"Commands/#mqtt","text":"Command Parameters ButtonRetain 0 = disable use of MQTT retain flag (default) 1 = enable MQTT retain flag on button press ButtonTopic <value> = set MQTT button topic 0 = disable use of MQTT button topic 1 = set MQTT button topic to device %topic% 2 = reset MQTT button topic to firmware default ( MQTT_BUTTON_TOPIC ) (default = 0 ) If using MQTT to issue this command, if it is published to the device GroupTopic , the command will not be executed. FullTopic 1 = reset MQTT fulltopic to firmware default ( MQTT_FULLTOPIC ) and restart <value> = set MQTT fulltopic and restart. Use of optional %prefix%, %topic%, %hostname%, and %id% substitution tokens is allowed. If using MQTT to issue this command, if it is published to the device GroupTopic , you must ensure uniqueness of the resulting fulltopic on each destination device by using one or more of these substitution tokens. GroupTopic<x> 1 = reset MQTT group <x> topic to firmware default ( MQTT_GRPTOPIC ) and restart <value> = set MQTT group <x> topic and restart MqttClient 1 = reset MQTT client to firmware config ( MQTT_CLIENT_ID ) and restart <value> = set MQTT client and restart. You can use the %06X substitution token to replace with last six characters of MAC address. If using MQTT to issue this command, if it is used with the device GroupTopic , the command will not be executed. MqttFingerprint TLS needs to be enabled in firmware for this command \u2003 <value> = set current fingerprint as 20 space separated bytes (59 chars max) MqttHost 0 = clear MQTT host field and allow mDNS to find MQTT host 1 = reset MQTT host to firmware default ( MQTT_HOST ) and restart <value> = set MQTT host and restart (do NOT use .local ) MqttPassword 0 = clear MQTT password 1 = reset MQTT password to firmware default ( MQTT_PASS ) and restart <value> = set MQTT password and restart MqttPort 1 = reset MQTT port to firmware default ( MQTT_PORT ) and restart <value> = set MQTT port between 2 and 32766 and restart MqttRetry 10..32000 = set MQTT connection retry timer in seconds (default = 10 ) MqttUser 0 = clear MQTT user name 1 = reset MQTT user name to firmware default ( MQTT_USER ) and restart <value> = set MQTT user name and restart PowerRetain MQTT power retain state 0 / off = disable MQTT power retain on status update (default) 1 / on = enable MQTT power retain on status update Prefix1 1 = reset MQTT command subscription prefix to firmware default ( SUB_PREFIX ) and restart <value> = set MQTT command subscription prefix and restart Prefix2 1 = reset MQTT status prefix to firmware default ( PUB_PREFIX ) and restart <value> = set MQTT status prefix and restart Prefix3 1 = Reset MQTT telemetry prefix to firmware default ( PUB_PREFIX2 ) and restart <value> = set MQTT telemetry prefix and restart Publish <topic> <payload> = MQTT publish any topic and optional payload\u2003 Publish2 <topic> <payload> = MQTT publish any topic and optional payload with retain flag SensorRetain 0 = disable use of sensor MQTT retain flag (default) 1 = enable MQTT retain flag on message tele/%topic%/SENSOR StateText<x> <value> = set state text ( <x> = 1..4 ) 1 = OFF state text 2 = ON state text 3 = TOGGLE state text 4 = HOLD state text SwitchRetain 0 = disable use of MQTT retain flag (default) 1 = enable MQTT retain flag on switch press Subscribe Subscribes to an MQTT topic and assigns an Event name to it. <eventName>, <mqttTopic> [, <key>] = Read more... = list all topics currently subscribed SwitchTopic <value> = set MQTT switch topic 0 = disable use of MQTT switch topic 1 = set MQTT switch topic to device %topic% 2 = reset MQTT switch topic to firmware default ( MQTT_SWITCH_TOPIC ) (default = 0 ) Read more about this. If using MQTT to issue this command, if it is used with the device GroupTopic , the command will not be executed. TelePeriod See current value and force publish STATE message 0 = disable telemetry messages 1 = reset telemetry period to firmware default ( TELE_PERIOD ) 10..3600 = set telemetry period in seconds (default = 300 ) Topic 1 = reset MQTT topic to firmware default ( MQTT_TOPIC ) and restart <value> = set MQTT topic and ButtonTopic and restart. If using MQTT to issue this command, if it is used with the device GroupTopic , the command will not be executed. * Topic can not be identical to MqttClient ** Unsubscribe Unsubscribe from topics subscribed to with Subscribe = unsubscribe all topics <eventName> = unsubscribe from a specific MQTT topic See also SetOption3 - Disable//Enable MQTT SetOption4 - Return MQTT response as RESULT or %COMMAND% topic SetOption10 - Main topic change behavior","title":"MQTT"},{"location":"Commands/#rules","text":"Command Parameters Add<x> <value> = add value to Var<x> ( example ) CalcRes Current calculation resolution 0..7 = set number of decimal places to be used in Add , Sub , Mult and Scale Event Execute an event to trigger a rule as documented \u2003 Mem<x> Manage up to 16 variables stored on flash (x = 1..16 ) Mem returns all current values. Mem<x> returns the variable's current value. <value> = store a string value in a variable \" = clear stored value in Mem<x> Mult<x> <value> = multiply value to Var<x> ( example ) Rule<x> Rules. Read more... 0 = disable Rule<x> 1 = enable Rule<x> 2 = toggle Rule<x> 4 = disable one-shot detection (perform commands as long as trigger is met) 5 = enable one-shot (e.g., sometimes used for slow changing sensors like temperature) detection 6 = toggle one-shot detection 8 = disable stop-on-error after exception restart 9 = enable stop-on-error after exception restart 10 = toggle stop-on-error after exception restart <value> = define Rule<x> +<value> = append to Rule<x> \" = clear Rule<x> Rule set one-shot: Each rule within the rule set will trigger only once until the trigger condition returns to a false condition. For example, ON Energy#Power<3 : Without one-shot enabled, it will trigger anytime Energy#Power gets an update (i.e., the Power telemetry value changes) and the value is <3 . This can potentially trigger that rule multiple times. With one-shot enabled, the rule will trigger only the on the first transition to <3 and not again until the trigger value goes >=3 . In other words, the rule will trigger again, but it has to cross the conditional \"boundary\" before it will trigger again. Rule0 Same functionality as Rule<x> but affects all rulesets at once RuleTimer<x> Up to eight timers to be used as countdown event (x = 1..8 )\u2003 0..65535 = set countdown rule timer in seconds Scale<x> Scale value from a low and high limit to another low and high limits and save in Var<x> ( example ) v = value: the number to scale fl = fromLow: the lower bound of the value\u2019s current range fh = fromHigh: the upper bound of the value\u2019s current range tl = toLow: the lower bound of the value\u2019s target range th = toHigh: the upper bound of the value\u2019s target range Sub<x> <value> = subtract value to Var<x> ( example ) Var<x> Manage up to 16 variables stored in memory (x = 1..16 ) Var returns all current values. Var<x> returns the variable's current value. <string> = store a string value in a variable \" = clear stored value in Var<x>","title":"Rules"},{"location":"Commands/#timers","text":"Command Parameters Latitude <value> = set latitude in decimal degrees format, e.g. -33.893681 Longitude <value> = set longitude in decimal degrees format, e.g. 18.619954 Timers Timers control 0 = disable all timers 1 = enable all timers 2 = toggle all timers Timer<x> Parameters for Timer<x> where x = 1..16 0 = clear parameters for Timer<x> 1..16 = copy Timer<y> parameters to Timer<x> { \"name\":value ; .. } = set all or individual parameters using JSON payload with names and values of data pairs from the table Information on sensors documented below is transmitted in the Tasmota telemetry message","title":"Timers"},{"location":"Commands/#sensors","text":"Command Parameters AdcParam ADC analog input tuning parameters <sensor>, <param1>, <param2>, <param3>, <param4> <sensor> values: \u2003 2 = Temperature Steinhart-Hart thermistor equation parameters: <param1> = NTC Voltage bridge resistor in Ohms (default = 32000 ) <param2> = NTC Resistance in Ohms (default = 10000 ) <param3> = NTC Beta Coefficient (default = 3350 ) \u2003 3 = Light Lux equation parameters: <param1> = LDR Voltage bridge resistor in Ohms (default = 10000 ) <param2> = LDR Lux Scalar (default = 12518931 ) <param3> = LDR Lux Exponent (default = -1.4050 ) \u2003 6 = ADC linear range remapping parameters: <param1> = input range low value adcLow (default = 0 ) <param2> = input range high value adcHigh (default = 1023 ) <param3> = output range low value rangeLow (default = 0 ) <param4> = output range high value rangeHigh (default = 100 ) The range remapping perform the following calculation on the ADC value [0..1023] : Range = ((adcHigh - ADC) / (adcHigh - adcLow)) * (rangeLow - rangeHigh) + rangeHigh The calculation is performed in double resolution floating point but all 4 parameters as well as the range output are unsigned 16 bit integers. The calculation result must not exceed [0..65535]. Example to convert the ADC value on a D1-mini into millivolts (using the default resistor bridge of 220k/100k): AdcParam 6, 0, 1023, 0, 3200 \u2003 7 = CT POWER parameter adjustments: <param1> = ANALOG_CT_FLAGS (default 0 for a non-invasive current sensor). When value is >0 its sets the adcLow value as base for the measurement via OpAmp differential amplifier. <param2> = ANALOG_CT_MULTIPLIER ( 2146 = Default settings for a (AC) 20A/1V Current Transformer.) multiplier*100000 to convert raw ADC peak to peak range 0..1023 to RMS current in Amps. Value of 100000 corresponds to 1 <param3> = ANALOG_CT_VOLTAGE (default 2300) to convert current in Amps to apparent power in Watts using voltage in Volts*10. Value of 2200 corresponds to AC220V. For DC its Volt/1000. Eg. 12VDC = 0.012. AdcParam 7,406,3282,0.012 Altitude -30000..30000 = altitude in meters AmpRes Current sensor resolution 0..3 = maximum number of decimal places BH1750Resolution<x> BH1750 resolution mode. x = BH1750 sensor number ( 1..2 ) 0..2 = choose sensor resolution ( 0 = high (default) , 1 = high2, 2 = low) BH1750MTime<x> BH1750 Measurement Time value. x = BH1750 sensor number ( 1..2 ) 30..255 = set Measurement Time value. Not persistent after reboot. (default = 69 ) Counter<x> 0 = reset Counter<x> 1..64900 = preset Counter<x> -1..-64900 = decrease Counter<x> +1..+64900 = increase Counter<x> In order to define and use a Counter, * you must configure one of the free device GPIO as Counter<x> . Counter module configuration is using internal pull-up resistor while Counter n does not. * CounterDebounce 0 = turn off counter debounce 1..32000 = set counter debounce time in milliseconds. Counter is increased with every falling edge when CounterType =0 or time between successive falling edges is measured when CounterType =1. When CounterDebounceLow and CounterDebounceHigh are set to zero (default) only falling edges of the counter's GPIO are checked. Any CounterDebounceLow or CounterDebounceHigh unequal zero checks are carried out befor CounterDebounce check is done. As an example you can set CounterDebounce 500 to allow a minimum distance between to succesive valid falling edges equal to 500ms. CounterDebounceLow 0 = turn off counter debounce low 1..32000 = set counter debounce low time in milliseconds. Allow individual debounce times for low pulse widths to discard non valid falling edges. These are checked before legacy CounterDebounce checks distance between two valid falling edges. When unequal zero tasmota will check falling and rising edges on the counter's GPIO. For CounterDebounceLow any GPIO change from low to high hat happens after the GPIO was not low for at least CounterDebounceLow will be ignored. As an example you can set CounterDebounceLow 50 to allow a valid minimum distance between a falling and rising edge equal to 50ms while having a final CounterDebounce 500 check between to succesive valid falling edges equal to 500ms. CounterDebounceHigh 0 = turn off counter debounce high 1..32000 = set counter debounce high time in milliseconds. Allow individual debounce times for high pulse widths to discard non valid falling edges. These are checked before legacy CounterDebounce checks distance between two valid falling edges. When unequal zero tasmota will check falling and rising edges on the counter's GPIO. For CounterDebounceHigh any GPIO change from high to low hat happens after the GPIO was not high for at least CounterDebounceHigh will be ignored. As an example you can set CounterDebounceHigh 100 to allow a valid minimum distance between a rising and falling edge equal to 100ms while having a final CounterDebounce 500 check between to succesive valid falling edges equal to 500ms. CounterType<x> 0 = set Counter<x> as pulse Counter 1 = set Counter<x> as pulse Timer GlobalHum 0.0..100.0 = Set global Humidity for some Sensors that uses global Humidity. GlobalTemp -50.0..100.0 = Set global Temperature for some Sensors that uses global temperature. HumOffset -10.0..10.0 = Set calibraton offset value for reported humidity telemetry This setting affects all humidity sensors on the device. HumRes Humidity sensor resolution 0..3 = maximum number of decimal places PressRes Pressure sensor resolution 0..3 = maximum number of decimal places Sensor13 INA219 low voltage current sensor calibration mode Predefined modes to use with standard 0.1 ohm resistor: 0 = set INA219 calibration to max 32V and 2A 1 = set INA219 calibration to max 32V and 1A 2 = set INA219 calibration to max 16V and 0.4A 10 .. 255 : Define custom shunt resistor encoded as a decimal number RRM such that Rshunt = RR * 10^M milliohm Do not forget to choose a resistor adapted for the correct power dissipation and apply a 50% security margin ! Examples: 11 = 1 * 10^1 = 10 milliohm (Imax=32A => Pres=15W) 21 = 2 * 10^1 = 20 milliohm (Imax=16A => Pres=7W) 12 = 1 * 10^2 = 100 milliohm (default, Imax=3.2A => Pres=2W) 13 = 1 * 10^3 = 1000 milliohm = 1 ohm (Imax=0.320A => Pres=0,2W) Sensor15 Automatic Baseline Correction for MH-Z19B CO 2 sensor 0 = disabled 1 = enabled (default) 2 = start manual calibration from 400 ppm of CO 2 9 = reset sensor to factory defaults 1000 = sets measurement range to 1000ppm CO 2 2000 = sets measurement range to 2000ppm CO 2 3000 = sets measurement range to 3000ppm CO 2 5000 = sets measurement range to 5000ppm CO 2 Sensor18 PMSx003 particle dust sensor 0..32000 = control sensor polling interval to extend lifetime Sensor20 Nova Fitness SDS011 dust sensor. 1..255 = number of seconds before TelePeriod to poll the sensor Sensor27 APDS-9960 sensor commands 0 = enable light level and proximity sensor / disable gestures (default) 1 = enable gesture mode/ disable light level and proximity sensor 2 = enable gestures with half gain / disable light and proximity sensor 3..255 = Set ATIME register for different integration times Sensor29 MCP23008 / MCP23017 I 2 C GPIO Expander configuration. Read more... Reset<x> = reset all pins x = 1..6 1 = INPUT mode, no reporting, no pull-up 2 = INPUT mode, report on CHANGE, pull-up enabled 3 = INPUT mode, report on LOW, pull-up enabled 4 = INPUT mode, report on HIGH, pull-up enabled 5 = OUTPUT mode (if enabled by #define USE_MCP230xx_OUTPUT ) 6 = inverted OUTPUT mode (if enabled by #define USE_MCP230xx_OUTPUT ) pin,pinmode{,intpullup|outstate{,repmode}} Continue reading... Sensor34 HX711 load cell sensor calibration 1 = reset display to 0 2 = start calibration 2 <value> = set reference weight in grams and start calibration 3 = show reference weight in grams 3 <value> = set reference weight in grams 4 = show calibrated scale value 4 <value> = set calibrated scale value 5 = show max weight in gram 5 <value> = set max weight in grams 6 = show single item weight in grams 6 <value> = set single item weight in grams. Once the item weight is set, when items are added to the scale, the telemetry message will report Count as the number of items on the scale 7 = save current weight to be used as start weight on restart 8 0/1 \u2003 0 = disable JSON message on weight change over 4 grams \u2003 1 = enable JSON message on weight change (see below) 9 <value> = set minimum delta to trigger JSON message (see above). \u2003 0 = 4 grams (old default) \u2003 1..100 = set delta to 0-99 grams \u2003 101-255 = set delta to 110-1650 grams (10g increments) Sensor50 PAJ7620 gesture sensor 0 = sensor muted, no readings in Tasmota 1 = gesture mode 2 = proximity mode 3 = corner mode 4 = PIN mode 5 = cursor mode Sensor52 iBeacon driver with HM10 or HM17/HM16 1 and 2 = required only once to initialize the module u<x> = sets update interval in seconds (scan tags every <x> seconds) (default = 10) t<x> = set timeout interval in seconds (send RSSI=0 if tag is not detected after <x> seconds) (default = 30) d1 = enable debug mode (shows all serial traffic in console) d0 = disable debug mode_(default = 30)_ c = clears iBeacon list s AT+<command> = send native AT commands Sensor53 Smart Meter Interface r = reset the driver with a new descriptor specified with the Tasmota Scripting language. c<x> <value> = preset counter (x = 1..5 ) to value when the driver is set to counter mode d<x> = disable data decoding and dump meter (x = 1..5 ) data to the Console. This is used to decipher the meter's data format to define the variable encoding in the meter's descriptor. d0 = disable data dump mode and revert to decoding mode. Sensor54 INA226 Current Sensor 1 = rescan for devices and return the number found. 2 = save the configuration and restart 10 = return channel 1 shunt resistance and full scale current 11 <resistance> = set INA226 channel 1 shunt in ohms, floating point 12 <current> = set INA226 channel 1 full scale in amperes, floating point 20 = return channel 2 shunt resistance and full scale current 21 <resistance> = set INA226 channel 2 shunt in ohms, floating point 22 <current> = set INA226 channel 2 full scale in amperes, floating point 30 = return channel 1 shunt resistance and full scale current 31 <resistance> = set INA226 channel 1 shunt in ohms, floating point 32 <current> = set INA226 channel 1 full scale in amperes, floating point 40 = return channel 1 shunt resistance and full scale current 41 <resistance> = set INA226 channel 1 shunt in ohms, floating point 42 <current> = set INA226 channel 1 full scale in amperes, floating point Sensor60 GPS 0 = write to all available sectors, then restart and overwrite the older ones 1 = write to all available sectors, then restart and overwrite the older ones 2 = filter out horizontal drift noise 3 = turn off noise filter 4 = start recording, new data will be appended 5 = start new recording, old data will lost 6 = stop recording, download link will be visible in webUI 7 = send mqtt on new postion + TELE (consider to set TELE to a very high value) 8 = only TELE message 9 = start NTP server 10 = deactivate NTP server 11 = force update of Tasmota-system-UTC with every new GPS-time-message 12 = do not update of Tasmota-system-UTC with every new GPS-time-message 13 = set latitude and longitude in settings 14 = open virtual serial port over TCP, usable for u-center 15 = pause virtual serial port over TCP Sensor68 WindMeter sensor - Analog (pulse count) anemometer 1, <value> = set radius length in millimeters (measured from centre to the edge of one of the cups) 0..65535 (default = 61 mm) 2, <value> = set number of pulses for a complete turn 1..255 (default = 1 ) 3, <value> = set pulse counter debounce time in milliseconds 1..32000 (default = 10 ) 4, <value> = set speed compensation factor, a multiplication coefficient to adjust resulting speed -32.768..32.767 three decimal places (default = 1.180 ) 5, <value> = set minimum percentage change between current and last reported speed trigger a new tele message 0..100 , 255 = off (default = 255 ) Sensor78 EZO sensors - commands Ascii commands are sent directly to the sensor as-is. See your specific EZO device datasheet for the list of commands available. By default, the specific command is sent to all EZO devices that are found. If using multiple EZO sensors, and the command should be issued to a single device, the index can be specified as part of the command: Sensor78-# where # represent the index of the device (ex: Sensor78-1 i). For more details please see Tasmota's support for EZO devices . SpeedUnit TX20/TX23 and WindMeter anemometer speed unit 1 = m/s 2 = km/h 3 = kn 4 = mph 5 = ft/s 6 = yd/s TempRes Temperature sensor resolution 0..3 = maximum number of decimal places TempOffset -12.6..12.6 = Set calibraton offset value for reported temperature telemetry This setting affects all temperature sensors on the device. VoltRes Voltage sensor resolution 0..3 = maximum number of decimal places WattRes Power sensor resolution 0..3 = maximum number of decimal places WeightRes Load cell sensor resolution 0..3 = maximum number of decimal places See also SetOption8 - Show temperature in Celsius (default) or Fahrenheit SetOption18 - Set status of signal light paired with CO 2 sensor SetOption24 - Set pressure units","title":"Sensors"},{"location":"Commands/#bluetooth-low-energy-ble","text":"Command Parameters BLEMode Change the operational mode of the BLE driver. BLEMode0 = disable regular BLE scans. BLEMode1 = BLE scan on command only. BLEMode2 = regular BLE scanning (default). BLEPeriod Set the period for publish of BLE data <value> = set interval in seconds BLEScan Cause/Configure BLE a scan BLEScan0 0..1 = enable or disable Active scanning. (an active scan will gather extra data from devices, including name) BLEScan = Trigger a 20s scan now if in BLEMode1 BLEScan n = Trigger a scan now for n seconds if in BLEMode1 BLEDetails Display details about recevied adverts BLEDetails0 = disable showing of details. BLEDetails1 mac|alias = show the next advert from device mac BLEAlias Set Alias names for devices. A device may be referred to by it's alias in subsequent commands BLEAlias mac=alias mac=alias ... = set one or more aliases from devices. BLEAlias2 = clear all aliases. BLEName Read or write the name of a BLE device. BLEName mac|alias = read the name of a device using 1800/2A00. BLEName mac|alias = write the name of a device using 1800/2A00 - many devices are read only. BLEDevices Cause a list of known devices to be sent on MQTT, or Empty the list of known devices. BLEDevices0 = clear the known devices list. BLEDevices = Cause the known devices list to be published on stat/TASName/BLE. BLEMaxAge Set the timeout for device adverts. BLEMaxAge n = set the devices timeout to n seconds. BLEMaxAge = display the device timeout. BLEOp Perform a simple active BLE operation (read/write/notify). see separate description in source code BLEDebug Set BLE debug level. BLEDebug = show extra debug information BLEDebug0 = suppress extra debug BLEAddrFilter Set BLE Address type filter. BLEAddrFilter = show filter level BLEAddrFilter n = set BLE address type filter 0..3 - default 3. Ignores BLE address types > filter value. Set 0 to ONLY see public addresses.","title":"Bluetooth Low Energy - BLE"},{"location":"Commands/#ble-ibeacon-esp32","text":"Command Parameters iBeacon Show or set enable for the iBeacon driver iBeacon = Display 0 iBeaconOnlyAliased Show or set OnlyAliased for the iBeacon driver iBeaconOnlyAliased = Display 0 iBeaconClear Clear iBeacon list iBeaconPeriod Display or Set the period for publish of iBeacon data iBeaconPeriod = display interval iBeaconPeriod ss = set interval in seconds iBeaconTimeout Display or Set the timeout for iBeacon devices iBeaconTimeout = display timeout iBeaconTimeout ss = set timeout in seconds","title":"BLE iBeacon (ESP32)"},{"location":"Commands/#ble-mixiaomi-sensors-esp32","text":"Command Parameters MI32Period Display/Set the active scan and tele period for the MI32 driver. MI32Period = diisplay the period in seconds. MI32Period n = Set the MI driver active read and tele period to n seconds. MI32Time Set the time on a device. MI32Time n = set the time on the device in slot n. MI32Page Display/Set the sensors per page in the web view. MI32page = show sensors per page. MI32page n = Set sensors per page to n. MI32Battery Trigger an active read of battery values. MI32Battery = request the driver read the battery from all sensors which have active battery read requirements. MI32Unit Write the current Tasmota temperature unit to a sensor. MI32Unit s = set the Temp unit on sensor in slot s. MI32Key Add a decryption key. MI32Key hexkey = add a 44 character decryption key to the keys list. MI32Keys Add one or more decryption keys by mac or alias. MI32Keys = list keys. MI32Keys mac|alias=key mac|alias=key ... = add keys for mac MI32Block Block or unblock a sensor device. MI32Block = list blocked devices by mac. MI32Block mac|alias = Block one mac/alias. MI32Option Set a MI driver option. MI32Option0 0|1(default) = set 'alwaysagregate'. MI32Option1 0(default)|1 = set 'nosummary'. MI32Option2 0(default)|1 = set 'directBridgeMode'. MI32Option3 0|1(default) = set 'ignoreBogusBattery'.","title":"BLE MI/Xiaomi sensors (ESP32)"},{"location":"Commands/#power-monitoring","text":"Command Parameters AmpRes Current sensor resolution 0..3 = maximum number of decimal places CurrentCal 1000..32000 (default = 3500 ) Set calibration offset value for reported Current telemetry Allows finer calibration for HLW8012, HJL01, and BL0937 energy monitoring devices CurrentHigh 0 = disable current high threshold (default) <value> = set current high threshold value in milliamps CurrentLow 0 = disable current low threshold (default) <value> = set current low threshold value in milliamps CurrentSet <value> = calibrate current to target value in mA EnergyRes Energy sensor resolution 0..5 = maximum number of decimal places EnergyReset<x> 0..42500 (for 3 , Total, upper limit is 4250000 ) in watt-hours (Wh) x = 1..5 1 <value> = ((p)re)set values for Today 2 <value> = ((p)re)set values for Yesterday 3 <value> = ((p)re)set values for Total 4 <standard> {, <off-peak> } = ((p)re)set tariff period values for Totals 5 <standard> {, <off-peak> } = ((p)re)set tariff period values for Exported FreqRes Frequency sensor resolution 0..3 = maximum number of decimal places FrequencySet <value> = calibrate frequency to a target value in Hz MaxPower 0 = disable use maximum power monitoring <value> = set maximum allowed power in watts MaxPowerHold 1 = set default time to 10 seconds to stay over MaxPower before power off <value> = set time in seconds to stay over MaxPower before power off MaxPowerWindow 1 = set default time to 30 seconds to stay power off before re-applying power up to 5 times <value> = set time in seconds to stay power off before re-applying power up to 5 times ModuleAddress Set the address of a PZEM module 1..3 = the last octet of the PZEM-004T serial address <address> = the last octet of the address on MODBUS PZEM energy monitoring modules Prior to setting the module address, the PZEM must be connected to both RX and TX, and AC voltage. Connect one PZEM at a time and issue this command. Repeat for each PZEM to be connected for multi-phase monitoring. The command without an argument cannot be used to read the address of the connected PZEM. PowerCal 1000..32000 (default = 12530 ) Set calibration offset value for reported Power telemetry reading Allows finer calibration for HLW8012, HJL01, and BL0937 energy monitoring devices PowerDelta<x> Set maximum delta of phase a<x> in energy monitoring devices to report on active power load change while the power is ON. PowerDelta will not report when the power turns off.\u2003 0 = disable reporting on power change 1..100 = set reporting on percentage power change to send an MQTT telemetry message 101..32000 = set reporting on absolute power change to send an MQTT telemetry message (offset by 100, e.g., 101 =1W, 207 =107W) PowerHigh 0 = disable power high threshold (default) <value> = set power high threshold value in watts to send an MQTT telemetry message PowerLow 0 = disable power low threshold (default) <value> = set power low threshold value in watts to send an MQTT telemetry message PowerSet <value> = calibrate power to a target value in watts\u2003 Status 8 = show power usage 9 = show power thresholds Tariff<x> P1 Smart Meter tariff configuration x = 1, 2, 9 1 STD,DST Start times for off-peak tariff 2 STD,DST End times for off-peak tariff 9 0/1 \u2003 0 = use Start/End times also on weekends. \u2003 1 = use off-peak tariff all weekend. STD and DST may be specified as: \u2003 <hour> = 0..23 or \u2003 <time> = 00:00..23:59 or \u2003 <minutes> = 0..1439 (since midnight) If both Tariff1 STD and Tariff2 STD are equal, all tariffs are disabled. VoltageCal Set calibration offset value for reported Voltage telemetry reading 1000..32000 (default = 1950 ) Allows finer calibration for HLW8012, HJL01, and BL0937 energy monitoring devices VoltageHigh 0 = disable voltage high threshold (default) <value> = set voltage high threshold value in V VoltageLow 0 = disable voltage low threshold (default) <value> = set voltage low threshold value in V VoltageSet <value> = calibrate voltage to a target value in V\u2003 VoltRes Voltage sensor resolution 0..3 = maximum number of decimal places WattRes Power sensor resolution 0..3 = maximum number of decimal places See Also SetOption21 - Energy monitoring when power is off SetOption33 - Configure power monitoring Max_Power_Retry count number SetOption39 - Control handling of invalid power measurements SetOption72 - Set reference used for total energy","title":"Power Monitoring"},{"location":"Commands/#light","text":"Command Parameters Channel<x> 0..100 = set PWM channel dimmer value from 0 to 100%\u2003 + = increase by 10 - = decrease by 10 When SetOption68 is set to 1 Channel<x> will follow Power<x> numbering with Relays first then PWM. Example : 2 Relays and 3 PWM: Relay1 = Power1 ; Relay2 = Power2 ; PWM1 = Power3 and Channel3 ; PWM2 = Power4 and Channel4 ; PWM3 = Power5 and Channel5 Color<x> x = 1..6 \u2003 1 = Set color \u2003 2 = Set color adjusted to current Dimmer value \u2003 3 = Set clock seconds hand color ( Scheme 5 only) \u2003 4 = Set clock minutes hand color ( Scheme 5 only) \u2003 5 = Set clock hour hand color ( Scheme 5 only) \u2003 6 = Set clock hour marker color <value> r,g,b = set color by decimal value ( 0..255 ) #CWWW = set hex color value for CT lights #RRGGBB = set hex color value for RGB lights #RRGGBBWW = set hex color value for RGBW lights #RRGGBBCWWW = set hex color value for RGBCCT lights (5 PWM channels) Note : Just append an = instead of the remaining color codes, this way they wont get changed. For example a command like Color #00ff= would update the RGB part to disable red and enable geen, but would omit to update blue or any white channel. Set color to 1 = red 2 = green 3 = blue 4 = orange 5 = light green 6 = light blue 7 = amber 8 = cyan 9 = purple 10 = yellow 11 = pink 12 = white (using RGB channels) + = next color - = previous color CT 153..500 = set color temperature from 153 (cold) to 500 (warm) for CT lights + = increase CT value by 10 - = decrease CT value by 10 Dimmer 0..100 = set dimmer value from 0 to 100% + = increase by DimmerStep value (default = 10 ) - = decrease by DimmerStep value (default = 10 ) Dimmer<x> Commands available only when SetOption37 >= 128 ( #6819 ) <value> same as in Dimmer Dimmer0 <value> = set dimming for all channels Dimmer1 <value> = set dimming for RGB channels Dimmer2 <value> = set dimming for white channels DimmerRange Change dimming range. <dimmerMin>,<dimmerMax> = set the internal dimming range from minimum to maximum value (0..100, 0..100) Does not change Dimmer command behavior DimmerStep 1..50 - set Dimmer +/- step value. (default = 10 ) Fade 0 = do not use fade (default) 1 = use fade See also SetOption91 HsbColor <hue>,<sat>,<bri> = set color by hue, saturation and brightness HsbColor1 0..360 = set hue HsbColor2 0..100 = set saturation HsbColor3 0..100 = set brightness Led<x> #RRGGBB = set hex color value where <x> is the pixel number of the LED (applies only to addressable LEDs) LedPwmMode<x> Control status LED light mode (x = 0..4 ) 0 = digital on/off mode (default) 1 = PWM mode 2 = toggle between modes LedPwmOff 0..255 = set LED brightness when OFF LedPwmOn 0..255 = set LED brightness when ON LedTable 0 = do not use LED gamma correction (default \u00ab6.5.0.9) 1 = use gamma correction (default \u00bb6.5.0.9) Palette 0 = Clear color palette [...] = Set list of colors in RGB used by Color and Scheme commands with each color separated by a space. Example: Palette 255,0,0 0,255,0 255,255,153 to use only red, green, yellow colors Pixels 1..512 = set amount of pixels in strip or ring and reset Rotation (applies only to addressable LEDs) RGBWWTable Control lightintensity of unbalanced PWM channels PWM1,PWM2,PWM3,PWM4,PWM5 = channel range with values 0..255 (default = 255,255,255,255,255 ) Range adjustment is computed after Gamma correction. Rotation <value> = set amount of pixels to rotate (up to Pixels value) (applies only to addressable LEDs) Scheme Light effects + = next scheme - = previous scheme 0 = single color for LED light (default) 1 = start wake up sequence (same as Wakeup ) 2 = cycle up through colors using Speed option 3 = cycle down through colors using Speed option 4 = random cycle through colors using Speed and Fade Use <value>, <startcolor> if you want to set the starting color of selected scheme Following schemes are usable only with addressable LEDs, e.g. WS281X, Neopixel 5 = clock mode ( example ) 6 = candlelight pattern 7 = RGB pattern 8 = Christmas pattern 9 = Hanukkah pattern 10 = Kwanzaa pattern 11 = rainbow pattern 12 = fire pattern Speed 1..40 = set fade speed from fast 1 to very slow 40 + = increase speed - = decrease speed The Speed value represents the time in 0.5s to fade from 0 to 100% (or the reverse). Example: Speed 4 takes 2.0s to fade from full brightness to black, or 0.5s to move from 75% to 100%. Wakeup Start wake up sequence from OFF to stored Dimmer value 0..100 = Start wake up sequence from OFF to provided Dimmer value WakeupDuration 1..3000 = set wake up duration in seconds White 1..100 = set white channel brightness in single white channel lights (single W or RGBW lights) Width<x> x = 1..4 1 = 0..4 = LED group width ( Scheme 6..12 only) 2 = 0..32 = seconds hand width ( Scheme 5 only) 3 = 0..32 = minutes hand width ( Scheme 5 only) 4 = 0..32 = hour hand width ( Scheme 5 only) See also SetOption15 , SetOption16 , SetOption17 , SetOption20 , SetOption37 and SetOption68","title":"Light"},{"location":"Commands/#tuyamcu","text":"Command Parameters TuyaEnum<x> Send value inside configured range to enum<x> (x = 0..4 ) <value> = a numerical value from range configured with TuyaEnumList TuyaEnumList <enum>,<range> = declare the range for a configured enum fnId <enum> = 1..4 <range> = 0..31 (starts counting from 0 ) TuyaMCU Used to map functions for TuyaMCU (54) module <fnId>,<dpId> = read more... <fnId>,0 = remove setting for fnId TuyaRGB Set RGB string format reported from TuyaMCU 0 = Type 1, 12 characters uppercase, for example: 00DF00DC0244 (default) 1 = Type 2, 12 characters lowercase, for example: 008003e8037a Type 2, 14 characters uppercase, for example: 00FF00FFFF6464 Type 2, 14 characters lowercase, for example: 00e420ffff6464 TuyaSend<x> Send data to MCU with TuyaMCU TuyaSend0 = send a query command to the MCU which returns MCU ID and dpId states if supported TuyaSend1 <dpId>,<boolean> = send boolean ( 0 / 1 ) data type to dpId (1 byte max length) TuyaSend2 <dpId>,<int> = send integer data to dpId (4 bytes max length) TuyaSend2 <dpId>,<0xAABBCCDD> = send 4 byte data to dpId (4 bytes max length) TuyaSend3 <dpId>,<value> = send any data type to dpId (unknown max length) TuyaSend4 <dpId>,<enum> = send enumerated ( 0 / 1 / 2 / 3 / 4 / 5 ) data type to dpId (1 byte max length) TuyaSend8 = request all dpId states if supported TuyaSend9 = toggle reporting of individual dpId changes to their own topic stat/%topic%/DPTYPE<x>ID<x>","title":"TuyaMCU"},{"location":"Commands/#device-groups","text":"Command Parameters DevGroupName<x> 0 = clear device group <x> name and restart <value> = set device group <x> name and restart. Prior to 8.2.0.3, GroupTopic was used to specify the device group name. DevGroupSend<x> <item> = <value>[ ...] = send an update to device group <x>. The device group name must have been previously set with DevGroupName<x>. Multiple item/value pairs can be specified separated by a space. Spaces in <value> must be escaped with a backslash (\\). The message sent is also processed on the local device as if it had been received from the network. For items with numeric values, <value> can be specified as @<operator>[<operand>] to send a value after performing an operation on the current value. <operator> can be + (add), - (subtract) or ^ (invert). If <operand> is not specified, it defaults to 0xffffffff for the invert operator and 1 for other operators. Examples: DevGroupSend 4=90 128=1 - send an update to set the light brightness to 90 and turn relay 1 on. DevGroupSend 193=Buzzer\\\\ 2,3 - send the Buzzer 2,3 command. DevGroupSend 6=@+ 4=@-10 - set the next fixed color and decrease the brightness by 10. DevGroupSend 128=^ - toggle all the relays. 2 = Light fade (0 = Off, 1 = On) 3 = Light speed (1..40) 4 = Light brightness (0..255) 5 = Light Scheme 6 = Light fixed color (0 = white (using CT channels), other values according to Color ) 7 = PWM dimmer low preset (0..255) 8 = PWM dimmer high preset (0..255) 9 = PWM dimmer power-on brightness (0..255) 128 = Relay Power - bitmask with bits set for relays to be powered on. The number of relays can be specified in bits 24 - 31. If the number of relays is not specified, only relay 1 is set 192 = Event - event name and arguments 193 = Command - command and arguments 224 = Light channels - comma separated list of brightness levels (0..255) for channels 1 - 5 (e.g. 255,128,0,0,0 will turn the red channel on at 100% and the green channel on at 50% on an RBG light) DevGroupShare <in>,<out> = set incoming and outgoing shared items (default = 0xffffffff,0xffffffff ) <in> and <out> are bit masks where each mask is the sum of the values for the categories (listed below) to be shared. For example, to receive only power (1), light brightness (2) and light color (16) and send only power (1), enter the command DevGroupShare 19,1. 1 = Power 2 = Light brightness 4 = Light fade/speed 8 = Light scheme 16 = Light color 32 = Dimmer settings (presets) 64 = Event DevGroupStatus<x> Show the status of device group <x> including a list of the currently known members.","title":"Device Groups"},{"location":"Commands/#setoptions","text":"Tip Instead of typing SetOption you can use shorter form of SO . so instead of SetOption19 1 you can use SO19 1 Command Parameters SetOption0 Save power state and use after restart (=SaveState) 0 = disable 1 = enable (default) SetOption1 Set button multipress mode to 0 = allow all button actions (default) 1 = restrict to single to penta press and hold actions (i.e., disable inadvertent reset due to long press) SetOption3 MQTT 0 = disable MQTT 1 = enable MQTT (default) SetOption4 Return MQTT response as 0 = RESULT topic (default) 1 = %COMMAND% topic SetOption8 Show temperature in 0 = Celsius (default) 1 = Fahrenheit SetOption10 When the device MQTT topic changes 0 = remove retained message on old topic LWT (default) 1 = send \"Offline\" to old topic LWT SetOption11 Swap button single and double press functionality 0 = disabled (default) 1 = enabled SetOption12 Configuration saving to flash option 0 = allow dynamic flash save slot rotation (default) 1 = use fixed eeprom flash slot SetOption13 Allow immediate action on single button press 0 = single, multi-press and hold button actions (default) 1 = only single press action for immediate response (i.e., disable multipress detection). Disable by holding for 4 x button hold time (see SetOption32 ). SetOption15 Set PWM control for LED lights 0 = basic PWM control 1 = control with Color or Dimmer commands (default) SetOption16 Set addressable LED Clock scheme parameter 0 = clock-wise mode (default) 1 = counter-clock-wise mode SetOption17 Show Color string as 0 = hex string (default) 1 = comma-separated decimal string SetOption18 Set status of signal light paired with CO 2 sensor 0 = disable light (default) 1 = enable light The light will be green below CO2_LOW and red above CO2_HIGH (transition yellow/orange between). The default levels are: 800ppm for low and 1200ppm for high but these can be set in user_config_override.h . SetOption19 Home Assistant automatic discovery. WARNING On version 6.4.1.x enabling may cause a watchdog reset if used on a device with a configured sensor 0 = disabled (default) 1 = enabled and also sets SetOption59 1 If you enable and then disable SetOption19 , doing so does not set SetOption59 = 0 and does not revert to default %prefix%/%topic%/ FullTopic SetOption20 Update of Dimmer/Color/CT without turning power on 0 = disabled (default) 1 = enabled SetOption21 Energy monitoring when power is off 0 = disabled (default) 1 = enabled SetOption24 Set pressure units 0 = hPa (default) 1 = mmHg SetOption26 Use indexes even when only one relay is present 0 = messages use POWER (default) 1 = messages use POWER1 SetOption28 RF received data format 0 = hex (default) 1 = decimal SetOption29 IR received data format 0 = hex (default) 1 = decimal SetOption30 Enforce Home Assistant auto-discovery as light 0 = relays are announced as a switch and PWM as a light (default) 1 = both relays and PWM are announced as light SetOption31 Set status LED blinking during Wi-Fi and MQTT connection problems. LedPower must be set to 0 for this feature to work 0 = Enabled (default) 1 = Disabled SetOption32 Number of 0.1 seconds to hold button before sending HOLD action message. 1..100 to set button hold time (default = 40 ) . This option also affects the time required to perform a firmware defaults reset (10x HOLD action time) SetOption33 Number of seconds for which the maximum power limit can be exceeded before the power is turned off 1..250 = set number of seconds (default = 5 ) SetOption34 0..255 = set Backlog inter-command delay in milliseconds (default = 200 ) SetOption36 Boot loop defaults restoration control. 0 = disable boot loop control 1..200 = set number of boot loops (a restart caused by any exception or watchdog timer within less than BOOT_LOOP_TIME (default 10 seconds) before beginning to restore settings (default = 1 ) . Once this number is reached, subsequent restarts will: 1 st restart: disable ESP8285 generic GPIOs interfering with flash SPI 2 nd restart: disable rules causing boot loop 3 rd restart: disable all rules 4 th restart: reset user defined GPIOs to disable any attached peripherals 5 th restart: reset module to Sonoff Basic (1) SetOption37 Color remapping for led channels, also provides an option for allowing independent handling of RGB and white channels. Setting changes require a device reboot. 0 = disabled 1..119 = according to this table 120..127 = invalid (results in same as 0 ) 128..255 = same as 0..127 but with independent channel handling enabled SetOption38 6..255 = set IRReceive protocol detection sensitivity minimizing UNKNOWN protocols SetOption39 Control handling of invalid power measurements. Read more... 0 = reset to default on next restart 1..255 = number of invalid power readings before reporting no load (default = 128 ) . SetOption40 Stop detecting input change on the button GPIO. Solves #5449 Active only when SetOption1 1 and SetOption13 0 . This disables all long press functionality. 0..250 = button hold time in 0.1 seconds after which button functionality is disabled. (default = 1 ) Example: Backlog SetOption1 1; SetOption13 0; SetOption40 10 = discard any button press over 1 second SetOption41 0 = Disable ARP (default) <x> = Force sending gratuitous ARP (Wi-Fi keep alive) every <x> seconds (default = 0 ) If <x> is below 100 it is the number of seconds, if <x> is above 100 , it is the number of minutes after substracting 100. Ex: 105 is every 5 minutes, while 90 is every 90 seconds. SetOption42 0..255 = set over-temperature (Celsius only) threshold resulting in power off on all energy monitoring devices (default = 90 ) SetOption43 Deprecated in favor of DimmerRange 0..255 = set maximum dimming value ( details ) (default = 100 ) Available for Tuya and PS_16_DZ dimmers SetOption51 Enable GPIO9 and GPIO10 component selections in Module Configuration WARNING Do not use on ESP8266 devices! 0 = disable (default) 1 = enable SetOption52 Control display of optional time offset from UTC in JSON payloads 0 = disable (default) 1 = enable SetOption53 Display hostname and IP address in GUI 0 = disable (default) 1 = enable SetOption54 Apply SetOption20 settings to commands from Tuya device 0 = disable (default) 1 = enable SetOption55 mDNS service 0 = disable (default) 1 = enable SetOption56 Wi-Fi network scan to select strongest signal on restart (network has to be visible) 0 = disable (default) 1 = enable SetOption57 Wi-Fi network re-scan every 44 minutes with alternate to +10dB stronger signal if detected (only visible networks) 0 = disable (default) 1 = enable SetOption58 IR Raw data in JSON payload 0 = disable (default) 1 = enable SetOption59 Send tele/%topic%/STATE in addition to stat/%topic%/RESULT for commands: State , Power and any command causing a light to be turned on. 0 = disable (default) 1 = enable SetOption60 Set sleep mode 0 = dynamic sleep (default) 1 = normal sleep SetOption61 Force local operation when ButtonTopic or SwitchTopic is set. 0 = disable (default) 1 = enable SetOption62 Set retain on Button or Switch hold messages 0 = disable (default) 1 = don't use retain flag on HOLD messages SetOption63 Set relay state feedback scan at restart ( #5594 , #5663 ) 0 = Scan power state at restart (default) 1 = Disable power state scanning at restart SetOption64 Switch between - or _ as sensor name separator 0 = sensor name index separator is - (hyphen) (default) 1 = sensor name index separator is _ (underscore) Affects DS18X20, DHT, BMP and SHT3X sensor names in tele messages SetOption65 Device recovery using fast power cycle detection 0 = enabled (default) 1 = disabled SetOption66 Set publishing TuyaReceived to MQTT 0 = disable publishing TuyaReceived over MQTT (default) 1 = enable publishing TuyaReceived over MQTT SetOption67 iFan03 Buzzer control 0 = disable Sonoff iFan03 buzzer (default) 1 = enable Sonoff iFan03 buzzer SetOption68 Multi-channel PWM instead of a single light 0 = Treat PWM as a single light (default) 1 = Treat PWM as separate channels. In this mode, use Power<x> to turn lights on and off, and Channel<x> to change the value of each channel. Color still works to set all channels at once. Requires restart after change SetOption69 Deprecated in favor of DimmerRange By default Tuya dimmers won't dim below 10% because some don't function very well that way. 0 = disable Tuya dimmer 10% lower limit 1 = enable Tuya dimmer 10% lower limit (default) SetOption71 Set DDS238 Modbus register for active energy 0 = set primary register (default) 1 = set alternate register SetOption72 Set reference used for total energy 0 = use firmware counter (default) 1 = use energy monitor (e.g., PZEM-0xx, SDM120, SDM630, DDS238, DDSU666) hardware counter SetOption73 Detach buttons from relays and send multi-press and hold MQTT messages instead 0 = disabled (default) 1 = enabled Example message: {\"Button1\":{\"Action\":\"SINGLE\"}} SetOption74 Enable internal pullup for single DS18x20 sensor 0 = disabled (default) 1 = internal pullup enabled SetOption75 Set grouptopic behaviour ( #6779 ) 0 = GroupTopic using FullTopic replacing %topic% (default) 1 = GroupTopic is cmnd/%grouptopic%/ SetOption76 Bootcount incrementing when DeepSleep is enabled ( #6930 ) 0 = disable bootcount incrementing (default) 1 = enable bootcount incrementing SetOption77 Do not power off if a slider is moved to far left 0 = disabled (default) 1 = enabled SetOption78 Version check on Tasmota upgrade 0 = enabled (default) 1 = disabled SetOption79 Reset counters at TelePeriod time 0 = disabled (default) 1 = enabled SetOption80 Blinds and shutters support 0 = disable blinds and shutters support (default) 1 = enable blinds and shutters support SetOption81 Set PCF8574 component behavior for all ports 0 = set as regular state (default) 1 = set as inverted state SetOption82 Reduce the CT range from 153..500 to 200.380 to accomodate with Alexa range 0 = CT ranges from 153 to 500 (default) 1 = CT ranges from 200 to 380 (although you can still set in from 153 to 500) SetOption83 Uses Zigbee device friendly name instead of 16 bits short addresses as JSON key when reporting values and commands 0 = JSON key as short address 1 = JSON key as friendly name See ZbName <device>,<name> SetOption84 (Experimental) When using AWS IoT, sends a device shadow update (alternative to retained) 0 = don't update device shadow (default) 1 = update device shadow Note: if the Topic contains '/' they are replaced with '_' SetOption85 Device group support 0 = disabled (default) 1 = enabled SetOption86 PWM Dimmer only! Turn brightness LED's off 5 seconds after last change 0 = disabled (default) 1 = enabled SetOption87 PWM Dimmer only! Turn red LED on when powered off 0 = disabled (default) 1 = enabled SetOption88 Make each relay part of a separate device group. Relay 1 updates are sent to/received from device group 1, relay 2 updates are sent to/received from device group 2, etc. For the PWM Dimmer module, make each button be associated with a different device group. 0 = disabled (default) 1 = enabled SetOption89 Configure MQTT topic for Zigbee devices (also see SensorRetain ) 0 = single tele/%topic%/SENSOR topic (default) 1 = unique device topic based on Zigbee device ShortAddr Example: tele/Zigbee/5ADF/SENSOR = {\"ZbReceived\":{\"0x5ADF\":{\"Dimmer\":254,\"Endpoint\":1,\"LinkQuality\":70}}} SetOption90 Disable sending MQTT with non-JSON messages 0 = send all MQTT (default) 1 = send only MQTT messages with JSON payloads SetOption91 Enable Fade at boot and power on. By default fading is not enabled at boot because of stuttering caused by wi-fi connection 0 = don't Fade at startup (default) 1 = Fade at startup SetOption92 Alternative to Module 38 : for Cold/Warm white bulbs, enable the second PWM as CT (Color Temp) instead of Warm White, as required for Philips-Xiaomi bulbs. 0 = normal Cold/Warm PWM (default) 1 = Brightness/CT PWM See PWM CT in Lights SetOption93 Control caching of compressed rules 0 = Disable memory caching of uncompressed rules 1 = Keep uncompressed rules in memory to avoid CPU load of uncompressing at each tick (default) SetOption94 Select MAX31855 or MAX6675 thermocouple support 0 = Use MAX31855 protocol (default) 1 = Use simpler MAX6675 protocol instead of MAX31855 SetOption97 Set TuyaMCU serial baudrate 0 = 9600 bps (default) 1 = 115200 bps SetOption98 Provide rotary dimmer rule triggers 0 = disabled (default) 1 = enabled (see Rules ) SetOption99 Enable zero-cross capable AC dimmer 0 = no zero-cross AC dimmer connected (default) 1 = zero-cross AC dimmer attached. Focus on raising edge and sync frequency SetOption100 remove Zigbee ZbReceived value from {\"ZbReceived\":{xxx:yyy}} JSON message 0 = disabled (default) 1 = enabled SetOption101 Add Zigbee source endpoint as suffix to attributes 0 = disabled (default) 1 = enabled e.g. Power3 instead of Power if sent from endpoint 3 . SetOption102 Set baudrate for Teleinfo communication 0 = 1200 (default) 1 = 9600 SetOption103 Set TLS mode 0 = disable TLS 1 = enable TLS SetOption104 Disable MQTT retained messages (some brokers don't support them) 0 = retained messages enabled (default) 1 = retained messages disabled SetOption105 White Blend Mode 0 = disabled (default) 1 = enabled SetOption106 Virtual CT channel (experimental feature) 0 = disabled (default) 1 = create a virtual second white channel using RGB channels _only if light is RGBW (4 channels), SetOption68 0 and SetOption37 < 128 SetOption107 Set virtual CT channel light type (experimental feature) 0 = Warm White 1 = Cold White SetOption108 0 = Teleinfo telemetry into Energy MQTT JSON (default) 1 = Teleinfo raw data only SetOption109 0 = (default) 1 = force gen1 Alexa mode, for Echo Dot 2nd gen devices only SetOption110 0 = (default) 1 = disable Zigbee auto-binding and auto-attribute reporting when pairing a new device. Use only if you want to manually configure devices SetOption111 0 = (default) 1 = use frequency output for buzzer pin instead of on/off signal, for piezo buzzers SetOption112 0 = (default) 1 = use friendly name in Zigbee topic (use with `SetOption89) SetOption113 works only with rotary dial button 0 = (default) 1 = set dimmer low on rotary dial after power off SetOption114 Detach switches from relays and send MQTT messages instead 0 = disabled (default) 1 = enabled Example result: {\"Switch1\":{\"Action\":\"ON\"}} SetOption115 Enable ESP32 MI32 BLE 0 = disabled (default) 1 = enabled SetOption116 Disable auto-query of zigbee light devices (avoids network storms with large groups) 0 = enabled (default) 1 = disabled SetOption117 Light fading at fixed duration instead of fixed slew rate 0 = disabled (default) 1 = enabled","title":"SetOptions"},{"location":"Commands/#serial-bridge","text":"Both hardware and software Serial Bridge are supported. Hardware Serial Bridge uses GPIO1 (Tx) and GPIO3 (Rx) or GPIO13 (Tx) and GPIO15 (Rx) pins of your device. Software Serial Bridge can use any other GPIO to be configured as components Serial Tx and Serial Rx (or SerBr Tx and SerBr Rx ). If Tx and Rx components are not assigned in the Template or Module, GPIO1 and GPIO3 will be used. Note that changing serial logging ( SerialLog 0) will disable the hardware Serial Bridge. Information received by Tasmota over the serial bridge is captured automatically. Before data will be received, a properly formatted SerialSend<x> or SSerialSend<x> command must be executed. This must be done any time the device restarts (e.g., via a System#Boot triggered rule). This command is required in order to set how the expected serial data will be formatted and interpreted (i.e., which <x> option). A {\"SSerialReceived\":{\"Data\":\"<string>\"}} message will be posted. You can use a rule to process the string which will be contained in SSerialReceived#Data . Expect possible communication errors when additional sensors are configured. Command Parameters Baudrate 1 = set hardware serial bridge to default baud rate of 115200 bps <value> = set baud rate. The set rate will be a multiple of 300. The maximum baud rate possible is 19,660,500. SBaudrate 1 = set software serial bridge to default baud rate of 9600 bps <value> = set baud rate. The set rate will be a multiple of 300. The maximum baud rate possible is 19,660,500. SerialConfig value = set serial protocol using data/parity/stop conventional notation (example: 8N1 or 702 ) 0..23 = set serial protocol ( 3 equals 8N1 ) SerialDelimiter <value> = set serial delimiter to escape character code or ASCII character 1..127 = set serial delimiter to decimal ASCII 128 = only allow ASCII characters 32 to 127 in response text 129..255 = disable serial delimiter SerialSend<x> <string> Disable serial logging and send using hardware serial x = 1..5 1 = send appending \\n (newline) () 2 = send 3 = replace escape characters and send 4 = send as binary. Data in serial response messages is encoded as hex strings 5 = send as hex. Data in serial response messages is encoded as hex strings 6 = send as comma-delimited string of decimal numbers SSerialSend<x> <string> Send using software serial protocol x = 1..5 1 = send appending \\n (newline) () 2 = send 3 = replace escape characters and send 4 = send as binary data. Data in serial response messages is encoded as hex strings 5 = send as hex. Data in serial response messages is encoded as hex strings 6 = send as comma-delimited string of decimal numbers","title":"Serial Bridge"},{"location":"Commands/#rf-bridge","text":"Command Parameters RfCode Show last sent 24-bit user code 1..8388607 = send 24-bit user code #1..#7FFFFF = send 24-bit hexadecimal user code using RfSync, RfLow and RfHigh timing RfHigh 1 = reset high pulse time to 840 microseconds 2..32767 = set high pulse time in microseconds #2..#7FFF = set high pulse time in hexadecimal microseconds RfHost Show 16-bit host part of user code 1 = reset 16-bit host part of user code to 11802 (#2E1A) 2..32767 = set 16-bit host part of user code #2..7FFF = set 16-bit host part of user code in hexadecimal RfKey<x> Send learned or default RF data for RfKey<x> (x = 1 \u2013 16 ) 1 = send default RF data for RfKey<x> using RfSync, RfLow, RfHigh and RfHost parameters 2 = learn RF data for RfKey<x> 3 = unlearn RF data for RfKey<x> 4 = save RF data using RfSync, RfLow, RfHigh and last RfCode parameters 5 = show default or learned RF data 6 = send learned RF data RfLow 1 = reset low pulse time to 270 microseconds 2..32767 = set low pulse time in microseconds #2..#7FFF = set low pulse time in hexadecimal microseconds RfRaw This command only works when the firmware has been updated with Portisch firmware . Refer to the Portisch wiki for details. Learning and Decoding RF Codes with Portisch Firmware 0 = Set iTead default firmware support and messages (default on restart) 1 = set Portisch firmware support and messages 166 or AAA655 = start sniffing/reading RF signals disabling iTead default RF handling 167 or AAA755 = stop sniffing/reading RF signals enabling iTead default RF handling 168 or AAA855 = transmitting iTead default RF protocols 169 or AAA955 = start sniffing and learning predefined protocols 176 or AAB055 = bucket Transmitting using command 0xB0 177 or AAB155 = start Bucket sniffing using command 0xB1 192 or AAC000C055 = beep ( 00C0 is the length of the sound) 255 or AAFF55 = show Rf firmware version (result AA02FF means Version 02) <value> = hexadecimal data to be sent to RF chip. This must be immediately followed by the RfRaw 0 command (e.g., Backlog RfRaw <value>; RfRaw 0 RfSync 1 = reset start sync pulse time to 8470 microseconds 2..32767 = set start sync pulse time in microseconds #2..#7FFF = set start sync pulse time in hexadecimal microseconds See also SetOption28 - Set RF received data format","title":"RF Bridge"},{"location":"Commands/#rf-transciever","text":"Command Parameters RfProtocol = returns an array of enabled protocols JSON 1...35 = sets enable protocols mask value a = set mask to all (case sensitive) 0 = turn all off RfProtocol<x> 1 = set specific protocol on RfProtocol<x> 0 = set specific protocol off RfSend <value> = code decimal or JSON. Data value is required and can be decimal or hexadecimal (using the 0x prefix), other values are optional. JSON {\"Data\":\"<value>\",\"Bits\":<value>,\"Protocol\":<value>,\"Pulse\":<value>} \"Data\":\"<value>\" = hexadecimal code \"Bits\":<value> = required number of data bits (default = 24 ) \"Protocol\":<value> = protocol number (default = 1 ) \"Repeat\":<value> = repeat value (default = 10 ) \"Pulse\":<value> = pulse value ( 350 = default for protocol 1) \u2003e.g., RFsend {\"Data\":\"0x7028DC\",\"Bits\":24,\"Protocol\":1,\"Pulse\":238} Decimal data, bits, protocol, repeat, pulse \u2003e.g., RFsend 7350492, 24, 1, 10, 238 or RFsend 0x7028DC, 24, 1, 10, 238","title":"RF Transciever"},{"location":"Commands/#ir-remote","text":"The standard Tasmota builds have reduced support for IR protocols: RC5 , RC6 and NEC . Use Tasmota-IR to have access to full protocols. Command Parameters IRsend <x> Send an IR remote control code as a decimal or hexadecimal string in a JSON payload. In order to send IR data, you must configure one of the free device GPIO as IRsend (8) . GPIO01 nor GPIO03 can be used. <x> [ optional ] = number of times the IR message is sent. If not specified or 0..1 , the message is sent only once (i.e., not repeated) (default) >1 = emulate a long-press on the remote control, sending the message <x> times, or sending a repeat message for specific protocols (like NEC) {\"Protocol\":\"<value>\",\"Bits\":<value>,\"Data\":<value>} \"Protocol\" (select one of the following): \"NEC\" \"RC5\" \"RC6\" \"Bits\":1..32 = required number of data bits for PANASONIC protocol this parameter is the the address, not the number of bits \"Data\":1..(2^32)-1 = data frame as 32 bit decimal. e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":2170978686} or \"Data\":0x1..0xFFFFFFFF = data frame as 32 bit hexadecimal. e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x8166817E} Alternatively, you can send IR remote control codes using RAW command encoding . Read more... Tasmota-IR enabled with all protocols Command Parameters IRsend <x> <x> [ optional ] = number of times the IR message is sent. If not specified or 0..1 , the message is sent only once (i.e., not repeated) (default) >1 = emulate a long-press on the remote control, sending the message <x> times, or sending a repeat message for specific protocols (like NEC) {\"Protocol\":\"<value>\",\"Bits\":<value>,\"Data\":<value>,\"DataLSB\":<value>,\"Repeat\":<value>} \"Protocol\" or \"Vendor\" (select one of the following): RC5, RC6, NEC, SONY, PANASONIC, JVC, SAMSUNG, WHYNTER, AIWA_RC_T501, LG, MITSUBISHI, DISH, SHARP, DENON, SHERWOOD, RCMM, SANYO_LC7461, RC5X, NEC (non-strict), NIKAI, MAGIQUEST, LASERTAG, CARRIER_AC, MITSUBISHI2, HITACHI_AC1, HITACHI_AC2, GICABLE, LUTRON, PIONEER, LG2, SAMSUNG36, LEGOPF, INAX, DAIKIN152 \"Bits\":1..64 = required number of data bits for PANASONIC protocol this parameter is the the address, not the number of bits \"Data\":0x1..0xFFFFFFFFFFFFFFFF = data frame as 64 bit hexadecimal. e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x8166817E} Or \"DataLSB\":0x1..0xFFFFFFFFFFFFFFFF = data frame as 64 bit hexadecimal with LSB (each byte with bits reversed). e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x8166817E} DataLSB comes handy with LSB-first (Least Significant Bit First) protocols like NEC, and makes decoding/encoding easier. \"Repeat\":0..<x> if 0 send the frame once, if >0 simulates a long press; Note: \"Repeat\":1 sends the message twice. Alternatively, you can send IR remote control codes using RAW command encoding . See also SetOption29 - Set IR received data format SetOption38 - Set IR received protocol sensitivity SetOption58 - IR Raw data in JSON payload IRhvac Send HVAC IR remote control code as JSON payload IRhvac {\"Vendor\":\"Mitsubishi_Heavy_152\", \"Power\":\"On\",\"Mode\":\"Hot\",\"FanSpeed\":3,\"Temp\":22.5} \"Protocol\" or \"Vendor\" (select one of the following): COOLIX, DAIKIN, KELVINATOR, MITSUBISHI_AC, GREE, ARGO, TROTEC, TOSHIBA_AC, FUJITSU_AC, MIDEA, HAIER_AC, HITACHI_AC, HAIER_AC_YRW02, WHIRLPOOL_AC, SAMSUNG_AC, ELECTRA_AC, PANASONIC_AC, DAIKIN2, VESTEL_AC, TECO, TCL112AC, MITSUBISHI_HEAVY_88, MITSUBISHI_HEAVY_152, DAIKIN216, SHARP_AC, GOODWEATHER, DAIKIN160, NEOCLIMA, DAIKIN176, DAIKIN128 \"Model\": Some HVAC have variants in protocols, this field allows to specify the variant, see detailed list . Fujitsu_AC : ARRAH2E|ARDB1 Panasonic_AC : LKE|NKE|DKE|JKE|CKP|RKR Whirlpool_AC : DG11J13A|DG11J104|DG11J1-04|DG11J191 \"Power\" : On, Yes, True, 1 Off, No, False, 0 \"Mode\" : Off, Stop Auto, Automatic Cool, Cooling Heat, Heating Dry, Drying, Dehumidify Fan, Fanonly, Fan_Only \"FanSpeed\" : Auto, Automatic Min, Minimum, Lowest, 1 Low, 2 Med, Medium, Mid, 3 High, Hi, 4 Max, Maximum, Highest, 5 \"SwingV\" : vertical swing of Fan Auto, Automatic, On, Swing Off, Stop Min, Minimum, Lowest, Bottom, Down Low Mid, Middle, Med, Medium, Centre, Center High, Hi Highest, Max, Maximum, Top, Up \"SwingH\" : horizontal swing of Fan Auto, Automatic, On, Swing Off, Stop LeftMax, Left Max, MaxLeft, Max Left, FarLeft, Far Left Left Mid, Middle, Med, Medium, Centre, Center Right RightMax, Right Max, MaxRight, Max Right, FarRight, Far Right Wide \"Celsius\" : temperature is in Celsius ( \"On\" ) of Farenheit ( \"Off\" ) \"Temp\" : Temperature, can be float if supported by protocol \"Quiet\" : Quiet mode ( \"On\" / \"Off\" ) \"Turbo\" : Turbo mode ( \"On\" / \"Off\" ) \"Econo\" : Econo mode ( \"On\" / \"Off\" ) \"Light\" : Light ( \"On\" / \"Off\" ) \"Filter\" : Filter active ( \"On\" / \"Off\" ) \"Clean\" : Clean mode ( \"On\" / \"Off\" ) \"Beep\" : Beep active ( \"On\" / \"Off\" ) \"Sleep\" : Timer in seconds \"StateMode\" : SendOnly (default) StoreOnly SendStore See also SetOption29 - Set IR received data format SetOption38 - Set IR received protocol sensitivity SetOption58 - IR Raw data in JSON payload","title":"IR Remote"},{"location":"Commands/#displays","text":"Command Parameters Display Show current display setting as a JSON payload DisplayAddress 0..255 Set display module address DisplayDimmer 0 Turn the display off 1..100 Turn the display on 0..100 Set display luminosity (only on 8x8 Dot-Matrix displays) DisplayMode 0..5 Set to display predefined content according to display type DisplayModel Set display model: 1 = I 2 C LCD Display (default addresses 0x27 , 0x3F ) 2 = SSD1306 OLED 128x32/128x64/68x48 (default I 2 C addresses 0x3C , 0x3D ) 3 = HT16K33 8x8 Dot-Matrix 4 = ILI9341 TFT LCD 5 = 2.9 inch E-Paper Display 296x128 (software 3-wire SPI) 6 = 4.2 inch E-Paper Display 400x300 (software 3-wire SPI) 7 = SH1106 OLED 128x64 (default I 2 C address 0x3c ) 8 = ILI9488 TFT 480x320 (capacitive touch, hardware 3-wire SPI) 9 = SSD1351 color OLED 128x128 (hardware 3-wire SPI) 10 = RA8867 TFT LCD 1024x600 (capacitive touch, hardware 4-wire SPI) 11 = Common anode 7 segment display 12 = ST7789 240x240 TFT LCD (capacitive touch, SPI) DisplayRefresh 1..7 Set time in seconds to update predefined content when using DisplayMode \u2260 0 DisplaySize 1..4 Set display scale-up size (SSD1306 and ILI9341 only) DisplayRotate Set rotation angle 0 = 0\u00b0 1 = 90\u00b0 2 = 180\u00b0 3 = 270\u00b0 DisplayText <value> = See DisplayText use DisplayCols 1..44 Set number of display columns (for display modes>0) DisplayRows 1..32 Set number of display rows (for display modes>0) DisplayFont Specify the current font 0 use classic GFX font 1 = 12 2 = 24 3 = 8 (opt) 7 use RA8876 internal font DisplayWidth Specify the display width in pixels (SSD1306 only) DisplayHeight Specify the display height in pixels (SSD1306 only)","title":"Displays"},{"location":"Commands/#shutters","text":"Command (x = 1..4 ) Parameters ShutterMode<x> 1..5 (default = 0 ) Defines the mode the shutter will operates the relays, steppers and/or servos. 0=autodetect based on INTERLOCK and GPIO defined. STATUS 13 shows the mode. 1 = normal two relay up/off down/off 2 = two relay on/off up/down 3 = one relay garage mode 4 = one relay plus stepper motor 5 = one relay and position servo ShutterButton<x> <button> <func> <mqtt> Assign a button to control the shutter. For more details please refer to Blinds and Shutters support <button> \u2003 0 : disable buttons for this shutter \u2003 1..4 : Button number <func> up / down / updown / toggle : function to assign to the button <mqtt> 1 / 0 : enable/disable MQTT publish for button hold action For example: To control shutter #1 by two buttons: Backlog ShutterButton1 1 up 1; ShutterButton1 2 down 1 assigns button #1 to act as an \"up\" button (1x press open, 2x press 50% position, 3x press 74% position) and button #2 to act as an \"down\" button (1x press close, 2x press 50% position, 3x press 24% position) for shutter #1 including MQTT publish. To control shutter #1 by a single button: ShutterButton1 1 updown 0 assigns button #1 to act as an \"up and down\" button (1x press up, 2x press down). To control shutter #1 by a single button: ShutterButton1 1 toggle 0 assigns button #1 to act as a \"toggle\" button (1x press toggle, 2x press 50% position). ShutterCalibration<x> Granular shutter position calibration. The measured opening position of the shutter at the 30, 50, 70, 90, and 100 percent opened locations. For example: ShutterCalibration<x> 23 38 56 74 82 ShutterChange -100..100 - change shutter position from current in % ShutterCloseDuration<x> 1..255 (default = 10 ) time, in seconds, it takes to fully close the shutter. A fraction of a second can be specified (e.g. 45.7 ). ShutterClose<x> Engage the relay to close the shutter. This action can be requested at any time. Number of shutter can be the index or the arguement ShutterFrequency<x> 0..10,000 Hz (default = 1000 ) the maximum frequency at which the stepper motor can operate reliably. Typically this is up to 2,000Hz with a 12V power supply and up to 5,000Hz with a 24V power supply. ShutterEnableEndStopTime<x> 0 = no additional shutter end stop time (default) 1 = 1 s additional shutter end stop time ShutterInvert<x> 0 = use default shutter positioning ( 0 = Closed, 100 = Open) 1 = invert shutter positioning ( 100 = Closed, 0 = Open) (e.g., if used with KNX) ShutterInvertWebButtons<x> 0 = use default button icons (\u25b2 for open, \u25bc for close) 1 = invert button icons (\u25bc for open, \u25b2 for close) (e.g., if used with horizontal awning: where open means rolling-down fabric material and close rolling-up in a protect position) ShutterLock<x> 0 = unlock shutter positioning (default) 1 = lock shutter positioning ShutterMotorDelay<x> 0.00 .. 12.75 (default = 0 ) time, in seconds, it takes the motor to start moving once power is turned on; i.e., motor lag time. When used with stepper motors, this setting defines the ramp up/down speed (i.e., acceleration/deceleration) before the motor reaches its target speed for gradual starting and stopping. ShutterOpenDuration<x> 1..255 (default = 10 ) time, in seconds, it takes to fully open the shutter. A fraction of a second can be specified (e.g. 45.7 ). ShutterOpen<x> Engage the relay to open the shutter. This action can be requested at any time. Number of shutter can be index or the arguement ShutterPosition<x> 0..100 , UP , DOWN , STOP A shutter position change can be requested at any time. The shutter will stop and revert or update to the requested position. The shutter's actual position will be saved after the movement is completed. In this case, the position will be restored during reboot. An interruption during shutter movement (e.g., a device restart) will lose the current position. ShutterMove<x> -100..100 Moves the shutter from the current position relativly in %. If the resulting position is below 0 or above 100 it will be capped. Command can also be executed during movement and will change the target position. ShutterPWMRange<x> 0..1023,0..1023 For servo motors the min and max position is defined by the length of the duty cycle signal. Because every servo is different the min and max PWM value must be set for each servo type. The value is also dependend on the PWMfrequency . Servos normally use 50..200 as PWMfrequency . ShutterRelay<x> <value> 0 = disable this and all higher numbered shutters Relay<value> component used to open the shutter. This relay's mate, the next higher numbered relay, closes the shutter. Depending on the shutter mode, the relays may need to be interlocked using the Interlock command. The ShutterRelay command must be executed first before any other shutter commands for Shutter<x> can be executed. ShutterSetClose<x> shutter closed position. ShutterPosition will be reset to fully closed value (e.g., 0 when ShutterInvert = 0 , 100 otherwise). ShutterSetOpen<x> shutter opened position. ShutterPosition will be reset to fully opened value (e.g., 100 when ShutterInvert = 0 , 0 otherwise). ShutterSetHalfway<x> 0..100 (default = 50 ) Define shutter half open position (in percent) ShutterStop<x> Disengage the relays to stop the shutter. Number of shutter can be the index or the argument ShutterStopClose<x> Stop the shutter when currently moving, close it otherwise ShutterStopOpen<x> Stop the shutter when currently moving, open it otherwise ShutterStopPosition<x> Stop the shutter when currently moving, set it to position 0..100 , UP , DOWN , STOP , TOGGLE otherwise ShutterStopToggle<x> Stop the shutter when currently moving, do ShutterToggle otherwise ShutterStopToggleDir<x> Stop the shutter when currently moving, do ShutterToggleDir otherwise ShutterToggle<x> Toggle the shutter - close the shutter when its position is >50, open it otherwise ShutterToggleDir<x> Toggle the shutter - close the shutter when it previously moved to open, open it otherwise See also SetOption80 - Enable shutter support","title":"Shutters"},{"location":"Commands/#zigbee","text":"See Zigbee article for more information Command Parameters <device> As <device> in following commands you can use interchangeably: <shortaddr> = short address of the Zigbee device on the network, example: 0x1234 <longaddr> = permanent IEEE address of the Zigbee device (64 bits), example: 0x00158D00041160C5 <index> = number of the device in the internal list (starts at 1), ideal for enumerating devices, example: 3 for third device in the list <name> = friendly name. Only when previously set with ZbName ZbBind Binds one Zigbee device to another device or to a group. This allows one device to directly send commands (f.e. a remote to a bulb) without any action on the coordinator. Command structure: {\"Device\":\"<device>\", \"Endpoint\":<endpoint>, \"Cluster\":<cluster>, \"ToDevice\":\"<to_device>\", \"ToEndpoint\":<to_endpoint>, \"ToGroup\":<to_group> } <device> = device sending messages (mandatory) <endpoint> = source endpoint (mandatory) <cluster> = source cluster id (mandatory) <to_device> = target device (optional) <to_endpoint> = target endpoint \u2003(optional if it can be inferred from ZbStatus3 ) <to_group> = target group id (optional) You must specify either \"ToDevice\" or \"ToGroup\" but not both Zigbee2Tasmota must know the IEEE address of target device, see ZbStatus2 to verify and ZbProbe to have Zigbee2Tasmota query the address ZbBindState<n> Asks the device for its internal binding states <device> the device to query <n> the start index for the request, 1 is the default. This is used to scan through all bindings. ZbConfig display the current Zigbee configuration Example or result: {\"ZbConfig\":{\"Channel\":11,\"PanID\":\"0x1A63\",\"ExtPanID\":\"0xCCCCCCCCCCCCCCCC\",\"KeyL\":\"0x0F0D0B0907050301\",\"KeyH\":\"0x0D0C0A0806040200\"}} ZbConfig <json> change the configuration and restart if any change was applied. Warning: change in configuration causes a reset of the CC2530/ZBBridge and requires devices to be re-paired. \"Channel\":<channel> : Zigbee radio channel (11-26) \"PanID\":<panid> : identifier of the Zigbee Network \"ExtPanID\":<extpanid> : unique identifier of the Zigbee Network (ExtPanID features are not supported in Z2T but this parameter needs to be set) \"KeyL\":<key_l>,\"KeyH\":<key_h> : 128 bits encryption key, split into 2 64 bits values (Low and High) \"TXRadio\":<txradio> : radion power in dBm (1-20) only for ZBBridge All parameters are optional and only the ones specified are changed. The command always displays the complete configuration after the change Example of command: ZbConfig {\"Channel\":22,\"PanID\":\"0x1A69\",\"ExtPanID\":\"0xDDCCCCCCCCCCCCCC\",\"KeyL\":\"0xFF0D0B0907050301\",\"KeyH\":\"0xED0C0A0806040200\"} The following command creates a highly secure Network key based on a hardware random generator: ZbConfig {\"KeyL\":\"\",\"KeyH\":\"\"} ZbData feature in development ZbForget Used for devices that are unused but still visible in ZbStatus <device> = Remove a device from the Tasmota flash memory. It does not un-pair the device nor deleting the device information in the CC2530/ZBBridge. ZbLeave <device> = request a device to leave the network ZbInfo <device> = display all information known about a device, equivalent to ZbStatus3 with a simpler JSON output ZbLight Sets or reads the light type to be emulated in Zigbee Hue Emulation with Alexa. <device>,<light_type> sets the light type using an integer 0..5 corresponding to the number of channels (from one channel (on/off) to 5 channel (RGBCCT) lights) <device>,-1 removes the device from Philips Hue emulation <device> displays the current status of the Light (Zigbee2Tasmota tracks all changes to the light) ZbListen<x> <group> (EZSP ZBBridge only)Listens to a multicast group address. By default EZSP will not report group messages unless you subscribe to the group. <x> : slot in the array of group addresses, 1..15 <group> : group address to listen to, 0..0xFFFF At start-up, Z2T automatically listns to groupe 0 in slot 0. CC2530 does not need this command and always report all group messages. ZbMap<n> Asks the device for its view of the Zigbee topology <device> the device to query <n> the start index for the request, 1 is the default. This is used to scan through all values since devices usually return only 3 values per request. ZbName Sets or reads the Zigbee device friendly name (up to 32 characters). <device>,<name> sets the new friendly name <device>, (empty name) clears the friendly name <device> displays the current friendly name Also see SetOption83 1 to enable friendly names as JSON keys instead of ShortAddr. ZbOccupancy Configure the time-out after \"Occupancy\":1 to send a synthetic \"Occupancy\":0 for Zigbee motion sensors <device>,<x> - set occupancy timeout for <device> Possible values for <x> 0 : no time-out, the device actually generates \"Occupancy\":0 n : the number of seconds. The possible values are 15, 30, 45, 60, 75, 90, 105, 120. If the number is different, it is rounded up -1 : apply the default of 90 seconds ZbPermitJoin Sets pairing mode for new device discovery 0 = disable pairing mode 1 = enable pairing mode for 60 seconds 99 = enable pairing until device reboots (CC2530 only) Leaving Zigbee network open to join will allow any Zigbee device to connect and retrieve your network encryption key. This can lead to a compromise of your Zigbee network. ZbPing <device> = test availability of Zigbee device. If the device is connected and not sleeping, you should receive a ZbPing message within the next second. Example: ZbPing 0x5ADF responds with: {\"ZbPing\":{\"Device\":\"0x5ADF\",\"IEEEAddr\":\"0x90FD9FFFFE03B051\"}} ZbSend Command structure: {\"Device\":\"<shortaddr>\", \"Endpoint\":\"<endpoint>\", \"Manuf\":<manuf>, \"Send\":{\"<sendcmd>\":<sendparam>}} <shortaddr> = short address of the Zigbee device on the network <endpoint> = target endpoint on the device ( understanding endpoints ) <manuf> = (optional) forces a specific ManufacturerId in the ZCL frame (required by some Xiaomi devices) \"<sendcmd>\":<sendparam> = command and parameters to send ( Zigbee Device Commands ) _Use ZbZNPSend to send a raw form low-level message on CC253x gateways _ Example: ZbSend { \"Device\":\"0x1234\", \"Endpoint\":\"0x03\", \"Send\":{\"Power\":\"on\"} } ZbStatus<x> Display Zigbee devices seen on the network since boot <device> (optional) = all devices This command provides three levels of increasing detail according to <x> ZbStatus1 Display Short Address, and Friendly Name ZbStatus2 Also include Manufacturer ID and Model ID ZbStatus3 Also include a list of endpoints and the clusterIds supported by each endpoint Example: ZbStatus3 1 requests all details for device number 1 Requested information may exceed maximum result size allowed by Tasmota. In this case, the output will be truncated. To get all of the desired information, request results for a specific device individually. ZbUnbind Unbinds one Zigbee device from another or from a group. {\"Device\":\"<device>\", \"Endpoint\":<endpoint>, \"Cluster\":<cluster>, \"ToDevice\":\"<to_device>\", \"ToEndpoint\":<to_endpoint>, \"ToGroup\":<to_group> } <device> = the device sending the messages (mandatory) <endpoint> = the source endpoint (mandatory) <cluster> = the source cluster id (mandatory) <to_device> = the target device (optional) <to_endpoint> = the target endpoint (optional if it can be inferred from ZbStatus3 ) <to_group> = the target group id (optional) You must specify either \"ToDevice\" or \"ToGroup\" but not both Zigbee2Tasmota must know the IEEE address of the target device, use ZbStatus2 to verify and ZbProbe to query the address. See also SetOption83 , SetOption89 , SetOption100 , SetOption101","title":"Zigbee"},{"location":"Commands/#bluetooth","text":"Command Parameters HM10Scan Start a new device discovery scan HM10Period Show interval in seconds between sensor read cycles. Set to TelePeriod value at boot. HM10Baud Show ESP8266 serial interface baudrate ( Not HM-10 baudrate ) <value> = set baudrate HM10AT <command> = send AT commands to HM-10. See list HM10Time <n> = set time time of a LYWSD02 only sensor to Tasmota UTC time and timezone. <n> is the sensor number in order of discovery starting with 0 (topmost sensor in the webUI list). HM10Auto <value> = start an automatic discovery scan with an interval of <value> seconds to receive data in BLE advertisements periodically. This is an active scan and it should be used only if necessary . At the moment that is the case just with MJ_HT_V1. This can change if a future HM-10 firmware starts supporting passive scan. NRFPage Show the maximum number of sensors shown per page in the webUI list. <value> = set number of sensors (default = 4) NRFIgnore 0 = all known sensor types active_(default)_ <value> = ignore certain sensor type ( 1 = Flora, 2 = MJ_HT_V1, 3 = LYWSD02, 4 = LYWSD03, 5 = CGG1, 6 = CGD1 NRFScan Scan for regular BLE-advertisements and show a list in the console 0 = start a new scan list 1 = append to the scan list 2 = stop running scan NRFBeacon Set a BLE device as a beacon using the (fixed) MAC-address <value> (1-3 digits) = use beacon from scan list <value> (12 characters) = use beacon given the MAC interpreted as an uppercase string AABBCCDDEEFF","title":"Bluetooth"},{"location":"Commands/#stepper-motors","text":"Command Parameters MotorMIS 1,2,4,8,16 Set micro stepping increment - 1/1 (full steps) to 1/16 (default = 1 ) MotorSPR integer Set the number of steps the given motor needs for one revolution (default = 200 ) This is dependent on the type of motor and micro stepping. Most common motors are 1.8\u00b0 per step. MotorRPM 1..300 Set revolutions per minute (default = 30 ) MotorMove integer Move the motor the given number of steps (positive values: clockwise, negative values: counterclockwise) MotorRotate integer Rotate the motor the given number of degrees (positive values: clockwise, negative values: counterclockwise) MotorTurn float Spin the motor the given number of turns (positive values: clockwise, negative values: counterclockwise)","title":"Stepper Motors"},{"location":"Commands/#mp3-player","text":"The MP3 Player driver is based on the one from DFRobot. They named it DFPlayer mini . All MP3 Players with the identical Serial Control Command structure can be used. Command Parameters MP3DAC 0 = DAC on (default) 1 = DAC off MP3Device Specify playback device 1 = USB 2 = SD Card (default (also defaults on reset or power cycle)) MP3EQ Set equalizer mode: 0 = normal 1 = pop 2 = rock 3 = jazz 4 = classic 5 = bass) MP3Pause Pause MP3Play Play, works as a normal play on a real MP3 Player, starts at first MP3 file MP3Reset Reset the MP3 player to defaults MP3Stop Stop MP3Track x = play track <x> MP3Volume 0..100 = set Volume","title":"MP3 Player"},{"location":"Commands/#esp32","text":"Command Parameters Ethernet Currently only for Olimex ESP32-PoE board 0 = disable Ethernet 1 = enable Ethernet (default) EthAddress Set ethernet address. Currently only for Olimex ESP32-PoE board 0..31 = PHYxx address EthClockMode Ethernet clock mode. Currently only for Olimex ESP32-PoE board 0 = ETH_CLOCK_GPIO0_IN (default) 1 = ETH_CLOCK_GPIO0_OUT 2 = ETH_CLOCK_GPIO16_OUT 3 = ETH_CLOCK_GPIO17_OUT EthType Ethernet type. Currently only for Olimex ESP32-PoE board 0 = ETH_PHY_LAN8720 *(default) 1 = ETH_PHY_TLK110 2 = ETH_PHY_IP101 Wi-Fi Currently only for Olimex ESP32-PoE board 0 = disable Wi-Fi 1 = enable Wi-Fi (default)","title":"ESP32"},{"location":"Commands/#thermostat","text":"Command Parameters ThermostatModeSet Sets the thermostat mode 0 = Thermostat Off (controller inactive, default) 1 = Thermostat in automatic mode (controller active) 2 = Thermostat in manual mode (output switch follows the input switch, used to follow an existing wall thermostat) ClimateModeSet Sets the climate mode 0 = Heating mode (default) 1 = Cooling mode ControllerModeSet Sets the controller mode (used for thermostat in automatic mode) 0 = Hybrid controller (Predictive ramp-up controller and PI, default) 1 = PI controller 2 = Predictive ramp-up controller TempFrostProtectSet Sets the frost protection temperature. The controller, if in automatic mode, will never allow the temperature to sink below this value <0..12> = Temperature value in degrees Celsius/Fahrenheit (default 4.0\u00b0 Celsius) InputSwitchSet Sets the number of the input used in case in manual control <1..4> = Number of the input (default 1) InputSwitchUse Switch to decide if the input shall be used to automatically switch to manual mode and assign it to the output (usefull if using a serially connected wall thermostat) 0 = Input not used (default) 1 = Input used SensorInputSet Sets the temperature sensor to be used 0 = MQTT (default) 1 = Local sensor (can be changed by define, default DS18B20) OutputRelaySet Sets the output switch to be used for the thermostat <1..8> = Number of the output (default 1) EnableOutputSet Enables or disables the physical output 0 = Output disabled 1 = Output enabled (default) TimeAllowRampupSet Sets the minimum time in minutes since the last control action to be able to switch to the predictive ramp-up controller phase (applicable just in case of Hybrid controller, used normally in case of big deltas between the setpoint and the room temperature) <value> = Minutes (default 300 minutes) TempFormatSet Sets the temperature format 0 = Degrees celsius (default) 1 = Degrees Fahrenheit TempMeasuredSet Sets the temperature measured by the sensor (for MQTT sensor mode) <TempFrostProtectSet..100> = Temperature (default 18.0\u00b0 Celsius) TempTargetSet Sets the target temperature for the controller (setpoint) <TempFrostProtectSet..100> = Temperature (default 18.0\u00b0 Celsius) TempMeasuredGrdRead Returns the calculated temperature gradient <value> = Temperature gradient in degrees Celsius/Fahrenheit StateEmergencySet Sets the thermostat emergency flag 0 = Emergency flag off (default) 1 = Emergency flag on (thermostat switches to off state) TimeManualToAutoSet Sets the time in manual mode after the last active input action (f.i. last action from serial connected wall thermostat) to switch to aumatic mode 0..1440 = time in minutes (default 60 minutes) PropBandSet Sets the value of the proportional band of the PI controller 0..20 = value in degrees Celsius (default 4 degrees Celsius) TimeResetSet Sets the value of the reset time of the PI controller 0..86400 = value in seconds (default 12000 seconds) TimePiProportRead Returns the proportional part of the PI controller calculation in seconds value = value in seconds TimePiIntegrRead Returns the integral part of the PI controller calculation in seconds value = value in seconds TimePiCycleSet Sets the value of the cycle for the PI controller 0..1440 = value in minutes (default 30 minutes) TempAntiWindupResetSet Sets the value of the delta between controlled temperature and setpoint above which the integral part of the PI controller will be set to 0, in degrees Celsius/Fahrenheit 0..10 = value in degrees (default 0.8\u00b0 Celsius) TempHystSet Sets the value of the temperature hysteresis for the PI controller, in degrees Celsius/Fahrenheit -10..10 = value in degrees (default 0.1\u00b0 Celsius) TimeMaxActionSet Sets the maximum duty cycle of the PI controller in minutes 0..1440 = value in minutes (default 20 minutes) TimeMinActionSet Sets the minimum duty cycle of the PI controller in minutes 0..1440 = value in minutes (default 4 minutes) TimeSensLostSet Sets the maximum time without a temperature sensor update to mark it as lost in minutes 0..1440 = value in minutes (default 30 minutes) TimeMinTurnoffActionSet Sets the minimum time in minutes within a cycle for the PI controller to switch off the output, below it, it will stay on 0..1440 = value in minutes (default 3 minutes) TempRupDeltInSet Sets the minimum delta between controlled temperature and setpoint for the controller to switch to ramp-up controller phase (applicable just in Hybrid controller mode) 0..10 = value in degrees Celsius/Fahrenheit (default 0.4\u00b0 Celsius) TempRupDeltOutSet Sets the maximum delta between controlled temperature and setpoint for the controller to switch to the PI controller phase (applicable just in Hybrid controller mode) 0..10 = value in degrees Celsius/Fahrenheit (default 0.2\u00b0 Celsius) TimeRampupMaxSet Sets the maximum time in minutes for the controller to stay in the ramp-up phase (applicable just in Hybrid controller mode 0..1440 = value in minutes (default 960 minutes) TimeRampupCycleSet Sets the value of the cycle for the ramp-up controller 0..1440 = value in minutes (default 30 minutes) TempRampupPiAccErrSet Sets the initial accumulated error when switching from ramp-up to the PI controller phase if the target temperature has not been reached (applicable just in Hybrid controller mode) 0..25 = value in degrees Celsius/Fahrenheit (default 2\u00b0 Celsius) CtrDutyCycleRead Returns the duty cycle of the controller 0..100 = value in % DiagnosticModeSet Enables/disables the diagnostics flag 0 = Diagnostics disabled 1 = Diagnostics enabled (default)","title":"Thermostat"},{"location":"Commands/#domoticz","text":"Command Parameters DzIdx<x> Show Domoticz Relay idx <x> (x = 1..4 ) 0 = disable use of Relay idx <x> (default) <value> = Show Relay idx <x> DzKeyIdx<x> Show Domoticz Key idx <x> (x = 1..4 ) 0 = disable use of Key idx <x> (default) <value> = Show Key idx <x> (to use enable ButtonTopic ) DzSend<type> send values or state to Domoticz <index>,<value1(;value2)|state> DzSensorIdx<x> Show Domoticz Sensor idx <x> (x = 1..5 ) 0 = disable use of Sensor idx <x> (default) <value> = Show Sensor idx <x> DzSwitchIdx<x> Show Domoticz Switch idx <x> (x = 1..4 ) 0 = disable use of Switch idx <x> (default) <value> = Show Switch idx <x> (to use enable SwitchTopic ) DzUpdateTimer Show current update timer value in seconds 0 = disable sending interim Domoticz status (default) 1..3600 = send status to Domoticz in defined intervals","title":"Domoticz"},{"location":"Commands/#knx","text":"Command Parameters KnxTx_Cmnd<x> 0 or 1 = send command using slot <x> set in KNX Menu at KNX_TX KnxTx_Val<x> <value> = send float value using slot <x> set in KNX Menu at KNX_TX KnxTx_Scene <value> = send scene number to the GA set in KNX Menu KNX_ENABLED Status of KNX Communications 0 = set to Disable 1 = set to Enable KNX_ENHANCED Status of Enhanced mode for KNX Communications 0 = set to Disable 1 = set to Enable KNX_PA KNX Physical Address 0.0.0 = address not set x.x.x = set the device address (example 1.1.0 ) KNX_GA Return the amount of Group Address to Send Data/Commands configured KNX_GA<x> Setup Group Address to Send Data/Commands (<x> = KNX Group Address number) 1 = return configuration of GA<x> <option>, <area>, <line>, <member> to set configuration of GA<x> <option> = see table below for OPTION list <area>, <line>, <member> = KNX Address to Send Data/Commands KNX_CB Return the amount of Group Address to Receive Data/Commands configured KNX_CB<x> Setup Group Address to Receive Data/Commands 1 = return configuration of CB<x> <option>, <area>, <line>, <member> to set configuration of CB<x> <option> = see table below for OPTION list <area>, <line>, <member> = KNX Address to Receive Data/Commands OPTION OPTION Value OPTION OPTION Value 1 Relay 1 17 TEMPERATURE 2 Relay 2 18 HUMIDITY 3 Relay 3 19 ENERGY_VOLTAGE 4 Relay 4 20 ENERGY_CURRENT 5 Relay 5 21 ENERGY_POWER 6 Relay 6 22 ENERGY_POWERFACTOR 7 Relay 7 23 ENERGY_DAILY 8 Relay 8 24 ENERGY_START 9 Button 1 25 ENERGY_TOTAL 10 Button 2 26 KNX_SLOT1 11 Button 3 27 KNX_SLOT2 12 Button 4 28 KNX_SLOT3 13 Button 5 29 KNX_SLOT4 14 Button 6 30 KNX_SLOT5 15 Button 7 255 EMPTY 16 Button 8","title":"KNX"},{"location":"Compile-your-build/","text":"Flash and memory space on an ESP82XX chip is limited and very valuable. Because of that our precompiled binaries include the most popular features of Tasmota but no build can include all of them. To include a feature you need (or build completely customized Tasmota) you will have to configure and compile your own version. First you will need Tasmota's source code (either development or master branch) and a compiling tool. Compiling Tools ~ If you want to modify the code or default settings you can use: PlatformIO - setup and configure PlatformIO for Tasmota compilation and upload PlatformIO CLI - how to flash Tasmota using the PlatformIO command line interface on Linux PlatformIO-Core - automate firmware builds using PlatformIO-Core and flash with esptool Visual Studio Code - setup and configure Visual Studio Code with PlatformIO for Tasmota Atom - beginner guide building Tasmota firmware using Atom with PlatformIO plugin Docker Tasmota - compile from a Docker container using PlatformIO Online Compilers Can only create a firmware binary. Use one of the tools to flash it to your device. Gitpod - compile your own binary in the cloud using Gitpod . TasmoCompiler - simple web GUI to compile Tasmota with your own settings Simplest way to compile is with GitPod , requires only a web browser. Once you have set up the development environment, unzip the source code into a folder. Customize your build ~ The base for your self compiled version has to be Tasmota . Do NOT use a other Tasmota build variant for. Create a new file in /tasmota folder called user_config_override.h . Open the file in chosen development environment for editing. Enter lines required to enable or disable desired feature. All features and their identifier can be found in my_user_config.h . Best practice to enable a feature is to use #ifndef %identifier% #define %identifier% #endif Directives Description #define %identifier% enables the feature #undef %identifier% disables the feature #ifdef %identifier% checks if the feature is defined in code #ifndef %identifier% checks if the feature is not defined #endif closes #if statement Example: enable blinds and shutters support #ifndef USE_SHUTTER #define USE_SHUTTER // Add Shutter support for up to 4 shutter with different motortypes (+6k code) #endif identifier = USE_SHUTTER check whether USE_SHUTTER is already defined and proceed if it is not this line copied from my_user_config.h then uncommented, tells the compiler to include (#define) shutter support close the IF statement from line 1 Example: disable Domoticz support #ifdef USE_DOMOTICZ #undef USE_DOMOTICZ #endif identifier = USE_DOMOTICZ check whether USE_DOMOTICZ is already defined and proceed if it is tell the compiler to remove (#undef) Domoticz support close the IF statement from line 1 It is not recommended to change my_user_config.h , use it only for reference Save file, compile the custom binary and flash it Note There are limits to how many features can be included! If you go overboard code might not compile due to features conflicting or might not be able to be flashed if it exceeds ESP8266 limits .","title":"Compiling"},{"location":"Compile-your-build/#compiling-tools","text":"If you want to modify the code or default settings you can use: PlatformIO - setup and configure PlatformIO for Tasmota compilation and upload PlatformIO CLI - how to flash Tasmota using the PlatformIO command line interface on Linux PlatformIO-Core - automate firmware builds using PlatformIO-Core and flash with esptool Visual Studio Code - setup and configure Visual Studio Code with PlatformIO for Tasmota Atom - beginner guide building Tasmota firmware using Atom with PlatformIO plugin Docker Tasmota - compile from a Docker container using PlatformIO","title":"Compiling Tools"},{"location":"Compile-your-build/#customize-your-build","text":"The base for your self compiled version has to be Tasmota . Do NOT use a other Tasmota build variant for. Create a new file in /tasmota folder called user_config_override.h . Open the file in chosen development environment for editing. Enter lines required to enable or disable desired feature. All features and their identifier can be found in my_user_config.h . Best practice to enable a feature is to use #ifndef %identifier% #define %identifier% #endif Directives Description #define %identifier% enables the feature #undef %identifier% disables the feature #ifdef %identifier% checks if the feature is defined in code #ifndef %identifier% checks if the feature is not defined #endif closes #if statement Example: enable blinds and shutters support #ifndef USE_SHUTTER #define USE_SHUTTER // Add Shutter support for up to 4 shutter with different motortypes (+6k code) #endif identifier = USE_SHUTTER check whether USE_SHUTTER is already defined and proceed if it is not this line copied from my_user_config.h then uncommented, tells the compiler to include (#define) shutter support close the IF statement from line 1 Example: disable Domoticz support #ifdef USE_DOMOTICZ #undef USE_DOMOTICZ #endif identifier = USE_DOMOTICZ check whether USE_DOMOTICZ is already defined and proceed if it is tell the compiler to remove (#undef) Domoticz support close the IF statement from line 1 It is not recommended to change my_user_config.h , use it only for reference Save file, compile the custom binary and flash it Note There are limits to how many features can be included! If you go overboard code might not compile due to features conflicting or might not be able to be flashed if it exceeds ESP8266 limits .","title":"Customize your build"},{"location":"Components/","text":"Component is anything wired to the ESP8266/ESP8255 chip to be controlled by or send data to it. Components can be: buttons, switches, relays, LEDs, sensors, displays, MCU units, etc. Every component is assigned in the device template to the GPIO it is wired (connected) to. Every Tasmota device has some components configured by default. Most often there is a relay, a button and a LED configured as is the case for a Sonoff Basic in the following image. Bug Tasmota 9.1 completely redesigned GPIO mapping to allow for future expansion. Read more about the GPIO Conversion Assigning Components ~ If you wish to expand a device with a peripheral component, after properly wiring everything, you need to assign it to a free GPIO in Configure Module page or use command GPIO<x> . Read more about peripherals . Tip GPIOs configured as User (1) are the GPIOs that can be assigned to components in the Configure Module page. GPIO Conversion ~ Old GPIO New GPIO Name Description 255 1 User User 0 0 None Not used 1 1184 DHT11 DHT11 sensor 2 1216 AM2301 AM230X, DHT21 and DHT22 sensor 3 1248 SI7021 Only for Sonoff Si7021, not the i2c version 4 1312 DS18x20 Dallas Semiconductor DS18b20 1-Wire temperature sensor 5 608 I2C SCL I2C serial clock pin, used with any I2C component (sensors, displays, ...) 6 640 I2C SDA I2C serial data pin, used with any I2C component (sensors, displays, ...) 7 1376 WS2812 Addressable LEDs such as WS281X or Neopixel 8 1056 IRsend IR Transmitter LED 9 160 Switch1 Switch 10 161 Switch2 Switch 11 162 Switch3 Switch 12 163 Switch4 Switch 13 164 Switch5 Switch 14 165 Switch6 Switch 15 166 Switch7 Switch 16 167 Switch8 Switch 17 32 Button1 Button 18 33 Button2 Button 19 34 Button3 Button 20 35 Button4 Button 21 224 Relay1 Relay 22 225 Relay2 Relay 23 226 Relay3 Relay 24 227 Relay4 Relay 25 228 Relay5 Relay 26 229 Relay6 Relay 27 230 Relay7 Relay 28 231 Relay8 Relay 29 256 Relay1i Relay inverted 30 257 Relay2i Relay inverted 31 258 Relay3i Relay inverted 32 259 Relay4i Relay inverted 33 260 Relay5i Relay inverted 34 261 Relay6i Relay inverted 35 262 Relay7i Relay inverted 36 263 Relay8i Relay inverted 37 416 PWM1 Pulse Width Modulated Output 38 417 PWM2 Pulse Width Modulated Output 39 418 PWM3 Pulse Width Modulated Output 40 419 PWM4 Pulse Width Modulated Output 41 420 PWM5 Pulse Width Modulated Output 42 352 Counter1 Counter Input 43 353 Counter2 Counter Input 44 354 Counter3 Counter Input 45 355 Counter4 Counter Input 46 448 PWM1i Pulse Width Modulated inverted Output 47 449 PWM2i Pulse Width Modulated inverted Output 48 450 PWM3i Pulse Width Modulated inverted Output 49 451 PWM4i Pulse Width Modulated inverted Output 50 452 PWM5i Pulse Width Modulated inverted Output 51 1088 IRrecv IR Receiver Input (for example TSOP1838) 52 288 Led1 LED 53 289 Led2 LED 54 290 Led3 LED 55 291 Led4 LED 56 320 Led1i Inverted LED - default state ON 57 321 Led2i Inverted LED - default state ON 58 322 Led3i Inverted LED - default state ON 59 323 Led4i Inverted LED - default state ON 60 1408 MHZ Rx MHZ 19 CO2 Sensor 61 1440 MHZ Tx MHZ 19 CO2 Sensor 62 1472 PZEM0XX Tx Peacefair Pzem-0XX Power Meter Tx pin 63 1504 PZEM004 Rx Peacefair Pzem-004 Power Meter Rx pin 64 1600 SAir Rx Sensor Senseair 65 1632 SAir Tx Sensor Senseair 66 768 SPI CS SPI Interface (ePaper Display) 67 800 SPI DC SPI Interface (ePaper Display) 68 992 BkLight Backlight (Display) 69 1696 PMS5003 PMS5003 Air Quality Sensor 70 1760 SDS0X1 Rx Nova Fitness SDS011 Laser Dust Sensor Rx pin 71 1792 SerBr Rx Serial Bridge Receive 72 1824 SerBr Tx Serial Bridge Transmit 73 1856 SR04 Tri Ultrasonic Sensor HC-SR04 Trigger pin 74 1888 SR04 Ech Ultrasonic Sensor HC-SR04 Echo pin 75 1920 SDMx20 Tx SDMx20-Modbus Multifunction Power Analyser Tx pin 76 1952 SDMx20 Rx SDMx20-Modbus Multifunction Power Analyser Rx pin 77 1984 SDM630 Tx SDM630-Modbus Multifunction Power Analyser Tx pin 78 2016 SDM630 Rx SDM630-Modbus Multifunction Power Analyser Rx pin 79 2048 TM16 CLK TM1638 Switch Module 80 2080 TM16 DIO TM1638 Switch Module 81 2112 TM16 STB TM1638 Switch Module 82 192 Switch1n Switch, no pullup resistor 83 193 Switch2n Switch, no pullup resistor 84 194 Switch3n Switch, no pullup resistor 85 195 Switch4n Switch, no pullup resistor 86 196 Switch5n Switch, no pullup resistor 87 197 Switch6n Switch, no pullup resistor 88 198 Switch7n Switch, no pullup resistor 89 199 Switch8n Switch, no pullup resistor 90 64 Button1n Button, no pullup resistor 91 65 Button2n Button, no pullup resistor 92 66 Button3n Button, no pullup resistor 93 67 Button4n Button, no pullup resistor 94 384 Counter1n Counter sensor, no pullup resistor 95 385 Counter2n Counter sensor, no pullup resistor 96 386 Counter3n Counter sensor, no pullup resistor 97 387 Counter4n Counter sensor, no pullup resistor 98 1536 PZEM016 Rx Peacefair Pzem-016 Power Meter Rx pin 99 1568 PZEM017 Rx Peacefair Pzem-017 Power Meter Rx pin 100 2144 MP3 Player DF MP3 Player mini (Input) 101 1728 SDS0X1 Tx Nova Fitness SDS011 Laser Dust Sensor Tx pin 102 2176 HX711 SCK HX711 weight sensor serial clock input 103 2208 HX711 DAT HX711 weight sensor data output 104 2240 TX20 TX20 Wind Sensor Input (Tx from sensor) 105 1120 RFSend RF Emitter (433Mhz module needed; Requires self-compile with RF_SENSOR and USE_RC_SWITCH) 106 1152 RFrecv RF Receiver (433Mhz module needed; Requires self-compile with RF_SENSOR and USE_RC_SWITCH) 107 2272 Tuya Tx Tuya Transfer pin 108 2304 Tuya Rx Tuya Receive pin 109 2336 MGC3130 Xfr MGC3130 E-field Xfr pin 110 2368 MGC3130 Rst MGC3130 E-field Reset pin 111 832 SSPI MISO Software SPI MISO (Display) 112 864 SSPI MOSI Software SPI MOSI (Display) 113 896 SSPI SCLK Software SPI SCLK (Display) 114 928 SSPI CS Software SPI CS (Display) 115 960 SSPI DC Software SPI DC (Display) 116 2400 RF Sensor Theo Arendst RF433 Sensor 117 2432 AZ Rx AZ 7798 CO2 datalogger 118 2464 AZ Tx AZ 7798 CO2 datalogger 119 2496 MX31855 CS MAX31855 Thermocouple Sensor Chip Select pin 120 2528 MX31855 CLK MAX31855 Thermocouple Sensor Serial Clock pin 121 2560 MX31855 DO MAX31855 Thermocouple Sensor Digital Output pin 122 96 Button1i Button inverted 123 97 Button2i Button inverted 124 98 Button3i Button inverted 125 99 Button4i Button inverted 126 128 Button1in Button inverted, no pullup resistor 127 129 Button2in Button inverted, no pullup resistor 128 130 Button3in Button inverted, no pullup resistor 129 131 Button4in Button inverted, no pullup resistor 130 2592 HLWBL SEL Energy Monitoring (for example Pow) 131 2624 HLWBL SELi Energy Monitoring (for example Pow) 132 2656 HLWBL CF1 Energy Monitoring (for example Pow) 133 2688 HLW8012 CF HLW8012 Single Phase Energy Monitor Chip CF pin 134 2720 BL0937 CF BL0937 Single Phase Energy Monitor Chip CF pin 135 2752 MCP39F5 Tx Energy Monitoring (for example Shelly2) 136 2784 MCP39F5 Rx Energy Monitoring (for example Shelly2) 137 2816 MCP39F5 Rst Energy Monitoring (for example Shelly2) 138 2848 PN532 Tx PN532 RFID/NFC Reader Tx pin 139 2880 PN532 Rx PN532 RFID/NFC Reader Rx pin 140 2912 SM16716 CLK SM16716 Pixel LED Serial Clock pin 141 2944 SM16716 DAT SM16716 Pixel LED Data pin 142 2976 SM16716 PWR SM16716 Pixel LED Power pin 143 3008 MY92x1 DI Light Bulb with MY92x controller 144 3040 MY92x1 DCKI Light Bulb with MY92x controller 145 3072 CSE7766 Tx CSE7766 Single Phase Energy Monitor Chip Tx pin 146 3104 CSE7766 Rx CSE7766 Single Phase Energy Monitor Chip Rx pin 147 3136 ALux IrRcv AriLux RGB Controller IR receive (Input) 148 3200 Serial Tx Serial Transfer pin 149 3232 Serial Rx Serial Receive pin 150 3264 Rotary1a Rotary Encoder (Mi Desk Lamp) 151 3296 Rotary1b Rotary Encoder (Mi Desk Lamp) 152 3265 Rotary2a Rotary Encoder (Mi Desk Lamp) 153 3297 Rotary2b Rotary Encoder (Mi Desk Lamp) 154 3392 HRE CLOCK Clock/Power line for HR-E Water Meter 155 3424 HRE DATA Data line for HR-E Water Meter 156 3456 ADE7953_IRQ ADE7953 IRQ 157 544 LedLink Device Status LED 158 576 LedLinki Device Status LED, inverted 159 3168 ALux IrSel For AriLux devices - switches between IR/RF mode 160 480 Buzzer Sonoff iFan03 Buzzer 161 512 Buzzeri Sonoff iFan03 Buzzer inverted 162 1024 OLED Reset OLED Display Reset 163 3488 SolaxX1 Tx Solax Inverter Tx pin 164 3520 SolaxX1 Rx Solax Inverter Rx pin 165 3552 Zigbee Tx Zigbee Serial interface Tx 166 3584 Zigbee Rx Zigbee Serial interface Rx 167 3616 RDM6300 Rx RDM6300 RX 168 3648 iBeacon Tx HM17 iBeacon Tx 169 3680 iBeacon Rx HM17 iBeacon Rx 170 3712 A4988 DIR A4988 Motor Direction 171 3744 A4988 STP A4988 Step motor 172 3776 A4988 ENA A4988 Enable motor 173 3808 A4988 MS1 A4988 Microstep increment select pin1 174 3809 A4988 MS2 A4988 Microstep increment select pin2 175 3810 A4988 MS3 A4988 Microstep increment select pin3 176 3904 DDS238-2 Tx DDS2382 Serial interface Tx 177 3936 DDS238-2 Rx DDS2382 Serial interface Rx 178 3968 DDSU666 Tx DDSU666 Serial interface Tx 179 4000 DDSU666 Rx DDSU666 Serial interface Rx 180 4032 SM2135 CLK SM2135 Clk 181 4064 SM2135 DAT SM2135 Dat 182 4096 DeepSleep DeepSleep wake switch 183 4128 EXS Enable EXS Dimmer MCU Enable 184 4160 Client TX TasmotaClient TX 185 4192 Client RX TasmotaClient RX 186 4224 Client RST TasmotaClient Reset Pin 187 4256 Client RSTi TasmotaClient Reset Inverted 188 4288 HPMA RX Honeywell HPMA115S0 Serial Rx 189 4320 HPMA TX Honeywell HPMA115S0 Serial Tx 190 4352 GPS RX GPS Serial Tx 191 4384 GPS TX GPS Serial Tx 192 1344 DSB OUT Pseudo Single wire DS18B20 or DS18S20 193 1280 DHT11 OUT Pseudo Single wire DHT11, DHT21, DHT22, AM2301, AM2302, AM2321 194 4416 HM10 RX HM10-BLE-Mijia-bridge Serial 195 4448 HM10 TX HM10-BLE-Mijia-bridge Serial 196 4480 LE01MR RX F&F LE-01MR Energy Meter Serial 197 4512 LE01MR TX F&F LE-01MR Energy Meter Serial 198 4544 CC1101 GDO0 CC1101 RX Pin 199 4576 CC1101 GDO2 CC1101 TX Pin 200 4608 HRXL RX Data from MaxBotix HRXL sonar range sensor 201 4640 MOODL TX ElectriQ iQ-wifiMOODL Serial TX 202 4672 AS3935 Lightning Detector Interrupt Pin 203 1664 PMS5003 TX Plantower PMS5003 Serial interface 204 4928 Boiler OT Rx OpenTherm Boiler RX pin 205 4960 Boiler OT Tx OpenTherm Boiler TX pin 206 4992 Windmeter Speed WindMeter speed counter pin 207 5056 BL0940 RX BL0940 serial interface 208 5088 TCP TX TCP Serial bridge 209 5120 TCP RX TCP Serial bridge 210 5152 TELEINFO RX TELEINFO serial interface 211 5184 TELEINFO Enable TELEINFO Enable PIN 212 5216 LMT01 LMT01 input counting pin 213 5248 IEM3000 TX IEM3000 Serial interface 214 5280 IEM3000 RX IEM3000 Serial interface 215 5312 Zigbee RST Zigbee reset 216 5344 DYP Rx DYP-ME007 Rx pin ADC Conversion ~ Old ADC New ADC Option WebUI display MQTT mesage 0 0 None none none 1 4704 Analog Analog0 %value% {\"A0\":%value%} 2 4736 Temperature Temperature %value% \u00b0C (\u00b0F) {\"Temperature\":%value%},\"TempUnit\":\"C\"} 3 4768 Light Illuminance %value% lux {\"Illuminance\":%value%} 4 4800 Button none none 5 4832 Buttoni none none 6 4864 Range Range %value% {\"Range\":%value%} 7 4896 CT Power Voltage 230 V Current %value A Power %value W Energy Total %value kWh {\"Energy\": %value ,\"Power\": %value ,\"Voltage\":230,\"Current\": %value } 8 3328 Joystick none {\"ANALOG\":{\"Joy1\":%value%}","title":"Components"},{"location":"Components/#assigning-components","text":"If you wish to expand a device with a peripheral component, after properly wiring everything, you need to assign it to a free GPIO in Configure Module page or use command GPIO<x> . Read more about peripherals . Tip GPIOs configured as User (1) are the GPIOs that can be assigned to components in the Configure Module page.","title":"Assigning Components"},{"location":"Components/#gpio-conversion","text":"Old GPIO New GPIO Name Description 255 1 User User 0 0 None Not used 1 1184 DHT11 DHT11 sensor 2 1216 AM2301 AM230X, DHT21 and DHT22 sensor 3 1248 SI7021 Only for Sonoff Si7021, not the i2c version 4 1312 DS18x20 Dallas Semiconductor DS18b20 1-Wire temperature sensor 5 608 I2C SCL I2C serial clock pin, used with any I2C component (sensors, displays, ...) 6 640 I2C SDA I2C serial data pin, used with any I2C component (sensors, displays, ...) 7 1376 WS2812 Addressable LEDs such as WS281X or Neopixel 8 1056 IRsend IR Transmitter LED 9 160 Switch1 Switch 10 161 Switch2 Switch 11 162 Switch3 Switch 12 163 Switch4 Switch 13 164 Switch5 Switch 14 165 Switch6 Switch 15 166 Switch7 Switch 16 167 Switch8 Switch 17 32 Button1 Button 18 33 Button2 Button 19 34 Button3 Button 20 35 Button4 Button 21 224 Relay1 Relay 22 225 Relay2 Relay 23 226 Relay3 Relay 24 227 Relay4 Relay 25 228 Relay5 Relay 26 229 Relay6 Relay 27 230 Relay7 Relay 28 231 Relay8 Relay 29 256 Relay1i Relay inverted 30 257 Relay2i Relay inverted 31 258 Relay3i Relay inverted 32 259 Relay4i Relay inverted 33 260 Relay5i Relay inverted 34 261 Relay6i Relay inverted 35 262 Relay7i Relay inverted 36 263 Relay8i Relay inverted 37 416 PWM1 Pulse Width Modulated Output 38 417 PWM2 Pulse Width Modulated Output 39 418 PWM3 Pulse Width Modulated Output 40 419 PWM4 Pulse Width Modulated Output 41 420 PWM5 Pulse Width Modulated Output 42 352 Counter1 Counter Input 43 353 Counter2 Counter Input 44 354 Counter3 Counter Input 45 355 Counter4 Counter Input 46 448 PWM1i Pulse Width Modulated inverted Output 47 449 PWM2i Pulse Width Modulated inverted Output 48 450 PWM3i Pulse Width Modulated inverted Output 49 451 PWM4i Pulse Width Modulated inverted Output 50 452 PWM5i Pulse Width Modulated inverted Output 51 1088 IRrecv IR Receiver Input (for example TSOP1838) 52 288 Led1 LED 53 289 Led2 LED 54 290 Led3 LED 55 291 Led4 LED 56 320 Led1i Inverted LED - default state ON 57 321 Led2i Inverted LED - default state ON 58 322 Led3i Inverted LED - default state ON 59 323 Led4i Inverted LED - default state ON 60 1408 MHZ Rx MHZ 19 CO2 Sensor 61 1440 MHZ Tx MHZ 19 CO2 Sensor 62 1472 PZEM0XX Tx Peacefair Pzem-0XX Power Meter Tx pin 63 1504 PZEM004 Rx Peacefair Pzem-004 Power Meter Rx pin 64 1600 SAir Rx Sensor Senseair 65 1632 SAir Tx Sensor Senseair 66 768 SPI CS SPI Interface (ePaper Display) 67 800 SPI DC SPI Interface (ePaper Display) 68 992 BkLight Backlight (Display) 69 1696 PMS5003 PMS5003 Air Quality Sensor 70 1760 SDS0X1 Rx Nova Fitness SDS011 Laser Dust Sensor Rx pin 71 1792 SerBr Rx Serial Bridge Receive 72 1824 SerBr Tx Serial Bridge Transmit 73 1856 SR04 Tri Ultrasonic Sensor HC-SR04 Trigger pin 74 1888 SR04 Ech Ultrasonic Sensor HC-SR04 Echo pin 75 1920 SDMx20 Tx SDMx20-Modbus Multifunction Power Analyser Tx pin 76 1952 SDMx20 Rx SDMx20-Modbus Multifunction Power Analyser Rx pin 77 1984 SDM630 Tx SDM630-Modbus Multifunction Power Analyser Tx pin 78 2016 SDM630 Rx SDM630-Modbus Multifunction Power Analyser Rx pin 79 2048 TM16 CLK TM1638 Switch Module 80 2080 TM16 DIO TM1638 Switch Module 81 2112 TM16 STB TM1638 Switch Module 82 192 Switch1n Switch, no pullup resistor 83 193 Switch2n Switch, no pullup resistor 84 194 Switch3n Switch, no pullup resistor 85 195 Switch4n Switch, no pullup resistor 86 196 Switch5n Switch, no pullup resistor 87 197 Switch6n Switch, no pullup resistor 88 198 Switch7n Switch, no pullup resistor 89 199 Switch8n Switch, no pullup resistor 90 64 Button1n Button, no pullup resistor 91 65 Button2n Button, no pullup resistor 92 66 Button3n Button, no pullup resistor 93 67 Button4n Button, no pullup resistor 94 384 Counter1n Counter sensor, no pullup resistor 95 385 Counter2n Counter sensor, no pullup resistor 96 386 Counter3n Counter sensor, no pullup resistor 97 387 Counter4n Counter sensor, no pullup resistor 98 1536 PZEM016 Rx Peacefair Pzem-016 Power Meter Rx pin 99 1568 PZEM017 Rx Peacefair Pzem-017 Power Meter Rx pin 100 2144 MP3 Player DF MP3 Player mini (Input) 101 1728 SDS0X1 Tx Nova Fitness SDS011 Laser Dust Sensor Tx pin 102 2176 HX711 SCK HX711 weight sensor serial clock input 103 2208 HX711 DAT HX711 weight sensor data output 104 2240 TX20 TX20 Wind Sensor Input (Tx from sensor) 105 1120 RFSend RF Emitter (433Mhz module needed; Requires self-compile with RF_SENSOR and USE_RC_SWITCH) 106 1152 RFrecv RF Receiver (433Mhz module needed; Requires self-compile with RF_SENSOR and USE_RC_SWITCH) 107 2272 Tuya Tx Tuya Transfer pin 108 2304 Tuya Rx Tuya Receive pin 109 2336 MGC3130 Xfr MGC3130 E-field Xfr pin 110 2368 MGC3130 Rst MGC3130 E-field Reset pin 111 832 SSPI MISO Software SPI MISO (Display) 112 864 SSPI MOSI Software SPI MOSI (Display) 113 896 SSPI SCLK Software SPI SCLK (Display) 114 928 SSPI CS Software SPI CS (Display) 115 960 SSPI DC Software SPI DC (Display) 116 2400 RF Sensor Theo Arendst RF433 Sensor 117 2432 AZ Rx AZ 7798 CO2 datalogger 118 2464 AZ Tx AZ 7798 CO2 datalogger 119 2496 MX31855 CS MAX31855 Thermocouple Sensor Chip Select pin 120 2528 MX31855 CLK MAX31855 Thermocouple Sensor Serial Clock pin 121 2560 MX31855 DO MAX31855 Thermocouple Sensor Digital Output pin 122 96 Button1i Button inverted 123 97 Button2i Button inverted 124 98 Button3i Button inverted 125 99 Button4i Button inverted 126 128 Button1in Button inverted, no pullup resistor 127 129 Button2in Button inverted, no pullup resistor 128 130 Button3in Button inverted, no pullup resistor 129 131 Button4in Button inverted, no pullup resistor 130 2592 HLWBL SEL Energy Monitoring (for example Pow) 131 2624 HLWBL SELi Energy Monitoring (for example Pow) 132 2656 HLWBL CF1 Energy Monitoring (for example Pow) 133 2688 HLW8012 CF HLW8012 Single Phase Energy Monitor Chip CF pin 134 2720 BL0937 CF BL0937 Single Phase Energy Monitor Chip CF pin 135 2752 MCP39F5 Tx Energy Monitoring (for example Shelly2) 136 2784 MCP39F5 Rx Energy Monitoring (for example Shelly2) 137 2816 MCP39F5 Rst Energy Monitoring (for example Shelly2) 138 2848 PN532 Tx PN532 RFID/NFC Reader Tx pin 139 2880 PN532 Rx PN532 RFID/NFC Reader Rx pin 140 2912 SM16716 CLK SM16716 Pixel LED Serial Clock pin 141 2944 SM16716 DAT SM16716 Pixel LED Data pin 142 2976 SM16716 PWR SM16716 Pixel LED Power pin 143 3008 MY92x1 DI Light Bulb with MY92x controller 144 3040 MY92x1 DCKI Light Bulb with MY92x controller 145 3072 CSE7766 Tx CSE7766 Single Phase Energy Monitor Chip Tx pin 146 3104 CSE7766 Rx CSE7766 Single Phase Energy Monitor Chip Rx pin 147 3136 ALux IrRcv AriLux RGB Controller IR receive (Input) 148 3200 Serial Tx Serial Transfer pin 149 3232 Serial Rx Serial Receive pin 150 3264 Rotary1a Rotary Encoder (Mi Desk Lamp) 151 3296 Rotary1b Rotary Encoder (Mi Desk Lamp) 152 3265 Rotary2a Rotary Encoder (Mi Desk Lamp) 153 3297 Rotary2b Rotary Encoder (Mi Desk Lamp) 154 3392 HRE CLOCK Clock/Power line for HR-E Water Meter 155 3424 HRE DATA Data line for HR-E Water Meter 156 3456 ADE7953_IRQ ADE7953 IRQ 157 544 LedLink Device Status LED 158 576 LedLinki Device Status LED, inverted 159 3168 ALux IrSel For AriLux devices - switches between IR/RF mode 160 480 Buzzer Sonoff iFan03 Buzzer 161 512 Buzzeri Sonoff iFan03 Buzzer inverted 162 1024 OLED Reset OLED Display Reset 163 3488 SolaxX1 Tx Solax Inverter Tx pin 164 3520 SolaxX1 Rx Solax Inverter Rx pin 165 3552 Zigbee Tx Zigbee Serial interface Tx 166 3584 Zigbee Rx Zigbee Serial interface Rx 167 3616 RDM6300 Rx RDM6300 RX 168 3648 iBeacon Tx HM17 iBeacon Tx 169 3680 iBeacon Rx HM17 iBeacon Rx 170 3712 A4988 DIR A4988 Motor Direction 171 3744 A4988 STP A4988 Step motor 172 3776 A4988 ENA A4988 Enable motor 173 3808 A4988 MS1 A4988 Microstep increment select pin1 174 3809 A4988 MS2 A4988 Microstep increment select pin2 175 3810 A4988 MS3 A4988 Microstep increment select pin3 176 3904 DDS238-2 Tx DDS2382 Serial interface Tx 177 3936 DDS238-2 Rx DDS2382 Serial interface Rx 178 3968 DDSU666 Tx DDSU666 Serial interface Tx 179 4000 DDSU666 Rx DDSU666 Serial interface Rx 180 4032 SM2135 CLK SM2135 Clk 181 4064 SM2135 DAT SM2135 Dat 182 4096 DeepSleep DeepSleep wake switch 183 4128 EXS Enable EXS Dimmer MCU Enable 184 4160 Client TX TasmotaClient TX 185 4192 Client RX TasmotaClient RX 186 4224 Client RST TasmotaClient Reset Pin 187 4256 Client RSTi TasmotaClient Reset Inverted 188 4288 HPMA RX Honeywell HPMA115S0 Serial Rx 189 4320 HPMA TX Honeywell HPMA115S0 Serial Tx 190 4352 GPS RX GPS Serial Tx 191 4384 GPS TX GPS Serial Tx 192 1344 DSB OUT Pseudo Single wire DS18B20 or DS18S20 193 1280 DHT11 OUT Pseudo Single wire DHT11, DHT21, DHT22, AM2301, AM2302, AM2321 194 4416 HM10 RX HM10-BLE-Mijia-bridge Serial 195 4448 HM10 TX HM10-BLE-Mijia-bridge Serial 196 4480 LE01MR RX F&F LE-01MR Energy Meter Serial 197 4512 LE01MR TX F&F LE-01MR Energy Meter Serial 198 4544 CC1101 GDO0 CC1101 RX Pin 199 4576 CC1101 GDO2 CC1101 TX Pin 200 4608 HRXL RX Data from MaxBotix HRXL sonar range sensor 201 4640 MOODL TX ElectriQ iQ-wifiMOODL Serial TX 202 4672 AS3935 Lightning Detector Interrupt Pin 203 1664 PMS5003 TX Plantower PMS5003 Serial interface 204 4928 Boiler OT Rx OpenTherm Boiler RX pin 205 4960 Boiler OT Tx OpenTherm Boiler TX pin 206 4992 Windmeter Speed WindMeter speed counter pin 207 5056 BL0940 RX BL0940 serial interface 208 5088 TCP TX TCP Serial bridge 209 5120 TCP RX TCP Serial bridge 210 5152 TELEINFO RX TELEINFO serial interface 211 5184 TELEINFO Enable TELEINFO Enable PIN 212 5216 LMT01 LMT01 input counting pin 213 5248 IEM3000 TX IEM3000 Serial interface 214 5280 IEM3000 RX IEM3000 Serial interface 215 5312 Zigbee RST Zigbee reset 216 5344 DYP Rx DYP-ME007 Rx pin","title":"GPIO Conversion"},{"location":"Components/#adc-conversion","text":"Old ADC New ADC Option WebUI display MQTT mesage 0 0 None none none 1 4704 Analog Analog0 %value% {\"A0\":%value%} 2 4736 Temperature Temperature %value% \u00b0C (\u00b0F) {\"Temperature\":%value%},\"TempUnit\":\"C\"} 3 4768 Light Illuminance %value% lux {\"Illuminance\":%value%} 4 4800 Button none none 5 4832 Buttoni none none 6 4864 Range Range %value% {\"Range\":%value%} 7 4896 CT Power Voltage 230 V Current %value A Power %value W Energy Total %value kWh {\"Energy\": %value ,\"Power\": %value ,\"Voltage\":230,\"Current\": %value } 8 3328 Joystick none {\"ANALOG\":{\"Joy1\":%value%}","title":"ADC Conversion"},{"location":"Configuration-Procedure-for-New-Devices/","text":"If your device is not a built-in module listed in the module configuration menu, a user contributed device template ( explanation ) may be available. Otherwise, follow this procedure for configuring the ESP chip pins used by your device. Some smart devices have additional functionality which may be handled by codes sent to a separate MCU in the device. Devices with functions offloaded to a separate MCU require additional coding in the software or via rules. Certain supported Tasmota BASE devices have built-in code to handle MCU controlled devices. Using a template with an appropriate BASE device may have the programming logic required to manage the MCU commands for your device. If an existing BASE device with the logic for your device is not available, a modified device driver will be required. This case is outside of the scope of this article. If your device is similar to the existing built-in module (e.g., a particular MCU or power monitoring algorithm) it is best to use that as a starting point. When you are not sure which module is suitable for your device, use Generic module (18) . Step 1. ~ Begin this procedure by disabling power state saves. Some improper GPIO assignments can cause device reboots. Disabling this setting avoids repeated flash writes. Also, it is best to allow Tasmota to return to a fail safe state in case of a bad configuration. Ensure that boot loop control is not disabled. Backlog SetOption0 0 ; SetOption36 1 Step 2. ~ Assign every available GPIO to successive Relay<x> components. For the initial GPIO probe, exclude \"dedicated\" GPIO such as GPIO0/GPIO2 and Tx/Rx, etc. You can use a Template to easily perform these assignments: { \"NAME\" : \"ID Relays\" , \"GPIO\" :[ 0 , 0 , 0 , 0 , 224 , 225 , 0 , 0 , 226 , 227 , 228 , 229 , 230 , 0 ], \"FLAG\" : 0 , \"BASE\" : 18 } Step 2a. Save the configuration. Once the device reboots, use the virtual buttons on the web UI to find which of the assigned GPIO actually control the physical relays and LEDs on the device. Make note of which GPIO act on which device peripheral. If you are unable to control some of the relays or LEDs on the device, they may be attached to the \"dedicated\" GPIO skipped in the initial probe. Now assign those GPIOs and repeat step 2a : { \"NAME\" : \"ID Relays 2\" , \"GPIO\" :[ 224 , 225 , 226 , 227 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \"FLAG\" : 0 , \"BASE\" : 18 } If your device is based on the ESP8285 and you are still unable to control some of the relays or LEDs on the device, they may be attached to GPIO9 or GPIO10. Now assign those remaining GPIO and repeat step 2a : { \"NAME\" : \"ID Relays 3\" , \"GPIO\" :[ 0 , 0 , 0 , 0 , 0 , 0 , 224 , 225 , 0 , 0 , 0 , 0 , 0 , 0 ], \"FLAG\" : 0 , \"BASE\" : 18 } Step 2b. Once you have found which GPIOs control the relays and LEDs, set these \"active\" GPIO to associate them with the corresponding Relay<x> , LED<x> , or LEDLink or PWM<x> (Some may require the use of inverted (i.e., Relay<x>i / LED<x>i / LEDLinki ) component). Bulbs have mainly PWM . For proper operation, in the final device configuration, assignment of like components must begin from 1 and be assigned sequentially! Regular and inverted components can be intermixed. (e.g., Relay1 , then Relay2 ; Led1 , then Led2i and so on) Step 3. ~ Now assign every remaining GPIO (excluding, once again, remaining \"dedicated\" GPIO like GPIO0/GPIO2 and Tx/Rx, etc.) to successive Switch1 .. Switch8 components ( 9 .. 16 ). You can once again use a Template using 0 for the GPIO identified in step 2. Step 3a. Save the configuration. Once the device reboots, use the web UI Console to run the Status 8 (sensors) command. This will display the current state of each GPIO. Step 3b. Then, while either holding down the physical button or having flipped the position of the physical switch, display Status 8 again. Whichever GPIO changes state from what was shown in step 3a is the GPIO connected to the input. If you have a bulb, GPIO which are in state on will probably be SM16716 CLK or SM16716 DAT component. If none of the GPIO change state, then assign the remaining GPIO and retry step 3a . Step 3c. Once you have found which GPIO are connected to each input, change the GPIO setting in the configuration to a Button<x> or Switch<x> according to your input component or use case. Proper operation may dictate the use regular or inverted (i.e., Switch<x>i / Button<x>i ) settings. For buttons, you may need to determine whether the internal pull-up is used or not. If so, select Button<x> n , where n indicates no pull-up. Step 4. ~ Once you have determined which GPIO your device uses, set any remaining GPIOs to None (0) including the Analog A0 pin. Save the configuration. Step 5. ~ In case your device is a Tuya device with an MCU which controls everything see TuyaMCU for instructions on how to configure it. Step 6. ~ Once the device reboots, set the device to save power state changes ( SetOption0 1 ). Step 7. ~ Your device is configured for use with Tasmota. Submit new template ~ Since you have now configured a device not previously known to the Tasmota user base, you can export the template and submit it to the Tasmota Device Templates Repository . View this Digiblur DIY video for a tutorial on this procedure.","title":"Configure Unknown Device"},{"location":"Configuration-Procedure-for-New-Devices/#step-1","text":"Begin this procedure by disabling power state saves. Some improper GPIO assignments can cause device reboots. Disabling this setting avoids repeated flash writes. Also, it is best to allow Tasmota to return to a fail safe state in case of a bad configuration. Ensure that boot loop control is not disabled. Backlog SetOption0 0 ; SetOption36 1","title":"Step 1."},{"location":"Configuration-Procedure-for-New-Devices/#step-2","text":"Assign every available GPIO to successive Relay<x> components. For the initial GPIO probe, exclude \"dedicated\" GPIO such as GPIO0/GPIO2 and Tx/Rx, etc. You can use a Template to easily perform these assignments: { \"NAME\" : \"ID Relays\" , \"GPIO\" :[ 0 , 0 , 0 , 0 , 224 , 225 , 0 , 0 , 226 , 227 , 228 , 229 , 230 , 0 ], \"FLAG\" : 0 , \"BASE\" : 18 }","title":"Step 2."},{"location":"Configuration-Procedure-for-New-Devices/#step-3","text":"Now assign every remaining GPIO (excluding, once again, remaining \"dedicated\" GPIO like GPIO0/GPIO2 and Tx/Rx, etc.) to successive Switch1 .. Switch8 components ( 9 .. 16 ). You can once again use a Template using 0 for the GPIO identified in step 2.","title":"Step 3."},{"location":"Configuration-Procedure-for-New-Devices/#step-4","text":"Once you have determined which GPIO your device uses, set any remaining GPIOs to None (0) including the Analog A0 pin. Save the configuration.","title":"Step 4."},{"location":"Configuration-Procedure-for-New-Devices/#step-5","text":"In case your device is a Tuya device with an MCU which controls everything see TuyaMCU for instructions on how to configure it.","title":"Step 5."},{"location":"Configuration-Procedure-for-New-Devices/#step-6","text":"Once the device reboots, set the device to save power state changes ( SetOption0 1 ).","title":"Step 6."},{"location":"Configuration-Procedure-for-New-Devices/#step-7","text":"Your device is configured for use with Tasmota.","title":"Step 7."},{"location":"Configuration-Procedure-for-New-Devices/#submit-new-template","text":"Since you have now configured a device not previously known to the Tasmota user base, you can export the template and submit it to the Tasmota Device Templates Repository . View this Digiblur DIY video for a tutorial on this procedure.","title":"Submit new template"},{"location":"Contributing/","text":"Any contribution helps our team and makes Tasmota better for the entire community! You can contribute by: providing Pull Requests (Features, Proof of Concepts, Language files or Fixes) testing new released features and report issues donating to acquire hardware for testing and implementing or out of gratitude contributing documentation for features and devices submitting new device templates fixing spelling mistakes, broken links and other errors in the documentation writing guides on wiring and using sensors or your DIY projects featuring Tasmota Editing Articles ~ You need a GitHub user account to be able to edit If you spot an error in an article use the pencil icon link at the top of the page, near the title, to correct it. This version of documentation uses strict markdown syntax with some enhancements. See Markdown Cheatsheet for all features You'll be taken to the GitHub repository page of that file, after a \"fork\" (copy) of the docs are made into your own GitHub account. Click on the edit button (pencil icon). Edit/Add the text you wanted. When finished find the Propose changes button at the bottom and click it. Next you need to click Create pull request which is GitHub speak for propose changes. In the PR window add a small description of what you did and click Create pull request Now you wait for one of the Tasmota admins to approve your PR (or deny , no guarantees!) Congratulations ! You've made a contribution to the Tasmota project making it a better experience for all future users. Thank you! Adding devices to the documentation ~ If you're adding a new page, go to documentation GitHub and click Create new file , name the file with .md extension.","title":"Contributing"},{"location":"Contributing/#editing-articles","text":"You need a GitHub user account to be able to edit If you spot an error in an article use the pencil icon link at the top of the page, near the title, to correct it. This version of documentation uses strict markdown syntax with some enhancements. See Markdown Cheatsheet for all features You'll be taken to the GitHub repository page of that file, after a \"fork\" (copy) of the docs are made into your own GitHub account. Click on the edit button (pencil icon). Edit/Add the text you wanted. When finished find the Propose changes button at the bottom and click it. Next you need to click Create pull request which is GitHub speak for propose changes. In the PR window add a small description of what you did and click Create pull request Now you wait for one of the Tasmota admins to approve your PR (or deny , no guarantees!) Congratulations ! You've made a contribution to the Tasmota project making it a better experience for all future users. Thank you!","title":"Editing Articles"},{"location":"Contributing/#adding-devices-to-the-documentation","text":"If you're adding a new page, go to documentation GitHub and click Create new file , name the file with .md extension.","title":"Adding devices to the documentation"},{"location":"Control-a-Sonoff-using-a-remote-button/","text":"REMOTE BUTTON ~ IMPORTANT: The ESP8266 needs GPIO0 and GPIO2 to be high (not connected to anything, or connected to 3.3V) during boot. GPIO0 and GPIO2 are the pins D3 and D4 on the Wemos D1 mini. D3 and D4 should only be used to connect push buttons (which are only low when pressed), not toggle switches. I have a cabin that is remote from my house, and I'm using a Sonoff to turn on/off the heaters remotely, so the place can be warm when I get there. The Sonoff(heater control) is located near the fuse box, and it controls a relay which switches the 120V/30A to the heaters. It's awkward to get at the Sonoff(heater control) to physically press the toggle button, so when I'm using it, I use MQTT commands to control the heaters. But I have some family members that are not comfortable with MQTT usage and certainly don't want to open the fuse box. So I built a small ESP-01 and a DHT22 and a push button, and used this project code to drive it (>rev 1.0.30). I use the cmnd/my_DHT/buttontopic to set the mqtt command to control the heaters. Yes, you can program a sonoff so that the button sends out any arbitrary command. In this case, I'm using the button to control the other sonoff. This ESP+DHT device is in the common area of the cabin, so my family members can simply push the button to toggle the heater. In other words, I'm using one trivial (DHT+button) wifi device to control the other (sonoff+heater relay). This technique uses Theo's flexible design, since buttontopic can be made different from topic . Schematic ~ NOTE: with this schematic, the DHT sensor is on GPIO2. You'll have to change the #define DHT_PIN in this project's source code from 14 to 2. Also, make sure you use the black ESP01 with 1MB of flash; most 2016 purchases should be ok. Of course you can use an ESP12 if you wish. The optional block shown attaches an LED to the DHT data line, so you can watch when the data is being fetched from the DHT device. Power regulator, 5V to 3.3V: search eBay for 5v/3.3v power 1117 ESP: search eBay for esp-01 and pick a black one DHT22: search eBay for dht22 ; any AM2302, DHT11 or DHT12 will do in its place; or you can omit the DHT and just use the button Cost (2016-09-05) USB-5V-adapter: CAD$1 + DC5V->3.3V: CAD$1 + ESP01: CAD$2.62 + DHT12: CAD$1.50 = CAD$6.12 = EUR 4.25 This little device has two inputs (DHT & button), and no output . You can use either the Sonoff or the ElectroDragon version of this project, but because this has no output, the following commands don't make any sense: power, light, ledstate . You may also want to change the #define APP_NAME and #define PROJECT to reflect that this isn't a real Sonoff. Pat B Update ~ 2017-11-12 This design still works with version 5.5.2 of the firmware. There's no need anymore to create a special build; the new design allows you to customize the code at runtime. For the above schematic, go into the Config Module menu and set - Module: 18 WeMos D1 mini - GPIO0: 09 Switch1 - GPIO2: 03 DHT22 and set switchtopic1 to the topic for the device you want to control, and switchmode1 to 3 (toggle). That's all you need to do :) I also discovered that the button must be a momentary pushbutton; don't use a switch, because both GPIO0 and GPIO2 must be floating at boot time. Another Update ~ 2017-09-22 I have installed the above device at my cabin in the woods, and I'm using a cellular modem to connect to the internet for data. If I set the Tasmota-Sonoff software with a teleperiod=3600 (once per hour), the MQTT traffic is about 6kB/hour, which is about 4.2MB/month. That includes the TCP keep-alives and the telemetry messages. So two devices (the main sonoff power switch and the esp-01 button device) takes 8.4MB/month, just below my economy 10MB/month sim card. Just FYI, I also have tried using a Raspberry PI at the cabin, and instructing it to SSH to my public-facing server, and creating a reverse tunnel back so that I can access my cabin from my public-facing server. The keep-alives on that connection is about 7.6MB/month. [The cellular phone company is probably using NAT, so I have to connect from cabin->server and not the other way around]","title":"Control a Sonoff using a remote button"},{"location":"Control-a-Sonoff-using-a-remote-button/#remote-button","text":"IMPORTANT: The ESP8266 needs GPIO0 and GPIO2 to be high (not connected to anything, or connected to 3.3V) during boot. GPIO0 and GPIO2 are the pins D3 and D4 on the Wemos D1 mini. D3 and D4 should only be used to connect push buttons (which are only low when pressed), not toggle switches. I have a cabin that is remote from my house, and I'm using a Sonoff to turn on/off the heaters remotely, so the place can be warm when I get there. The Sonoff(heater control) is located near the fuse box, and it controls a relay which switches the 120V/30A to the heaters. It's awkward to get at the Sonoff(heater control) to physically press the toggle button, so when I'm using it, I use MQTT commands to control the heaters. But I have some family members that are not comfortable with MQTT usage and certainly don't want to open the fuse box. So I built a small ESP-01 and a DHT22 and a push button, and used this project code to drive it (>rev 1.0.30). I use the cmnd/my_DHT/buttontopic to set the mqtt command to control the heaters. Yes, you can program a sonoff so that the button sends out any arbitrary command. In this case, I'm using the button to control the other sonoff. This ESP+DHT device is in the common area of the cabin, so my family members can simply push the button to toggle the heater. In other words, I'm using one trivial (DHT+button) wifi device to control the other (sonoff+heater relay). This technique uses Theo's flexible design, since buttontopic can be made different from topic .","title":"REMOTE BUTTON"},{"location":"Control-a-Sonoff-using-a-remote-button/#schematic","text":"NOTE: with this schematic, the DHT sensor is on GPIO2. You'll have to change the #define DHT_PIN in this project's source code from 14 to 2. Also, make sure you use the black ESP01 with 1MB of flash; most 2016 purchases should be ok. Of course you can use an ESP12 if you wish. The optional block shown attaches an LED to the DHT data line, so you can watch when the data is being fetched from the DHT device. Power regulator, 5V to 3.3V: search eBay for 5v/3.3v power 1117 ESP: search eBay for esp-01 and pick a black one DHT22: search eBay for dht22 ; any AM2302, DHT11 or DHT12 will do in its place; or you can omit the DHT and just use the button Cost (2016-09-05) USB-5V-adapter: CAD$1 + DC5V->3.3V: CAD$1 + ESP01: CAD$2.62 + DHT12: CAD$1.50 = CAD$6.12 = EUR 4.25 This little device has two inputs (DHT & button), and no output . You can use either the Sonoff or the ElectroDragon version of this project, but because this has no output, the following commands don't make any sense: power, light, ledstate . You may also want to change the #define APP_NAME and #define PROJECT to reflect that this isn't a real Sonoff. Pat B","title":"Schematic"},{"location":"Control-a-Sonoff-using-a-remote-button/#update","text":"","title":"Update"},{"location":"Control-a-Sonoff-using-a-remote-button/#another-update","text":"","title":"Another Update"},{"location":"Create-your-own-Firmware-Build-without-IDE/","text":"PlatformIO is not just an IDE. In fact, all its features are accessible from the command line, and the IDE is a convenience wrapper layer around it. Thus, we can build Tasmota using only this PlatformIO-Core, which may come handy for automated builds, or for those who feel more comfortable with the command line than with the IDE. The steps are surprisingly simple and straightforward: Provision a Linux VM ~ At least if you want to work in a cloud environment, but you may also choose to work on your physical machine as well. PlatformIO is based on python, so if we use python-virtualenv , then all the dependent packages will be confined to a separate folder, so it won't even taint the OS installation. As all of python , python-virtualenv and python-pip are available in most of the recent distros, you may pick your favourite one. Install python and tools ~ Install python and python-virtualenv , and python-pip , because we don't want to mess up the python ecosystem of the distro. Update pip by pip install --upgrade pip , and this was the last step done as root, the rest goes as a plain user. I used CentOS here, so if you prefer Debian-based distros, just substitute apt-get install -y ... for yum install -y ... . [tasmota_builder@jtest ~]$ sudo yum install -y python python-virtualenv python-pip Loaded plugins: fastestmirror Loading mirror speeds from cached hostfile ... Complete! You may update pip in the host environment, but we'll do it in the virtualenv as well, so it's optional: [tasmota_builder@jtest ~]$ sudo pip install --upgrade pip Collecting pip ... Successfully installed pip-18.1 Prepare a PlatformIO-Core environment contained in a folder ~ virtualenv creates a folder and prepares a whole self-contained python subsystem there. To activate it, so that all python-related things refer to this environment and not to the system global, you need to source the file bin/activate within it. NOTE : Not just execute in a subshell, but include it into the current one, so please note the . before bin/activate below: [ tasmota_builder @ jtest ~ ] $ virtualenv platformio - core New python executable in / home / tasmota_builder / platformio - core / bin / python Installing setuptools , pip , wheel ... done . [ tasmota_builder @ jtest ~ ] $ cd platformio - core [ tasmota_builder @ jtest platformio - core ] $ . bin / activate ( platformio - core ) [ tasmota_builder @ jtest platformio - core ] $ Now we are ready to install PlatformIO-Core into this small virtual environment: ( platformio - core ) [ tasmota_builder @ jtest platformio - core ] $ pip install - U platformio Collecting platformio Downloading https : // files . pythonhosted . org / packages / 95 / 4 a / 3 ccce45ba750dd9a8d48dcbe9b9080011ac2a5a248312b19552bbaec6b7d / platformio - 3.6 . 3 - py27 - none - any . whl ( 160 kB ) 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 163 kB 4.5 MB / s Collecting semantic - version < 3 , >= 2.5 . 0 ( from platformio ) Downloading https : // files . pythonhosted . org / packages / 72 / 83 / f76958017f3094b072d8e3a72d25c3ed65f754cc607fdb6a7b33d84ab1d5 / semantic_version - 2.6 . 0. tar . gz Collecting click < 6 , >= 5 ( from platformio ) Downloading https : // files . pythonhosted . org / packages / 8 f / 98 / 14966 b6d772fd5fba1eb3bb34a62a7f736d609572493397cdc5715c14514 / click - 5.1 - py2 . py3 - none - any . whl ( 65 kB ) 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 71 kB 8.1 MB / s Collecting colorama ( from platformio ) Downloading https : // files . pythonhosted . org / packages / 4 f / a6 / 728666 f39bfff1719fc94c481890b2106837da9318031f71a8424b662e12 / colorama - 0.4 . 1 - py2 . py3 - none - any . whl Collecting requests < 3 , >= 2.4 . 0 ( from platformio ) Downloading https : // files . pythonhosted . org / packages / 7 d / e3 / 20 f3d364d6c8e5d2353c72a67778eb189176f08e873c9900e10c0287b84b / requests - 2.21 . 0 - py2 . py3 - none - any . whl ( 57 kB ) 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 61 kB 7.9 MB / s Collecting pyserial != 3.3 , < 4 , >= 3 ( from platformio ) Downloading https : // files . pythonhosted . org / packages / 0 d / e4 / 2 a744dd9e3be04a0c0907414e2a01a7c88bb3915cbe3c8cc06e209f59c30 / pyserial - 3.4 - py2 . py3 - none - any . whl ( 193 kB ) 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 194 kB 4.7 MB / s Collecting bottle < 0.13 ( from platformio ) Downloading https : // files . pythonhosted . org / packages / 32 / 4 e / ed046324d5ec980c252987c1dca191e001b9f06ceffaebf037eef469937c / bottle - 0.12 . 16. tar . gz ( 72 kB ) 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 81 kB 8.8 MB / s Collecting urllib3 < 1.25 , >= 1.21 . 1 ( from requests < 3 , >= 2.4 . 0 -> platformio ) Downloading https : // files . pythonhosted . org / packages / 62 / 00 / ee1d7de624db8ba7090d1226aebefab96a2c71cd5cfa7629d6ad3f61b79e / urllib3 - 1.24 . 1 - py2 . py3 - none - any . whl ( 118 kB ) 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 122 kB 7.5 MB / s Collecting chardet < 3.1 . 0 , >= 3.0 . 2 ( from requests < 3 , >= 2.4 . 0 -> platformio ) Downloading https : // files . pythonhosted . org / packages / bc / a9 / 01 ffebfb562e4274b6487b4bb1ddec7ca55ec7510b22e4c51f14098443b8 / chardet - 3.0 . 4 - py2 . py3 - none - any . whl ( 133 kB ) 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 143 kB 6.8 MB / s Collecting idna < 2.9 , >= 2.5 ( from requests < 3 , >= 2.4 . 0 -> platformio ) Downloading https : // files . pythonhosted . org / packages / 14 / 2 c / cd551d81dbe15200be1cf41cd03869a46fe7226e7450af7a6545bfc474c9 / idna - 2.8 - py2 . py3 - none - any . whl ( 58 kB ) 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 61 kB 7.8 MB / s Collecting certifi >= 2017.4 . 17 ( from requests < 3 , >= 2.4 . 0 -> platformio ) Downloading https : // files . pythonhosted . org / packages / 9 f / e0 / accfc1b56b57e9750eba272e24c4dddeac86852c2bebd1236674d7887e8a / certifi - 2018.11 . 29 - py2 . py3 - none - any . whl ( 154 kB ) 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 163 kB 5.9 MB / s Building wheels for collected packages : semantic - version , bottle Running setup . py bdist_wheel for semantic - version ... done Stored in directory : / home / tasmota_builder /. cache / pip / wheels / 60 / bb / 50 / 215 d669d31f992767f5dd8d3c974e79261707ee7f898f0dc10 Running setup . py bdist_wheel for bottle ... done Stored in directory : / home / tasmota_builder /. cache / pip / wheels / 0 c / 68 / ac / 1546 dcb27101ca6c4e50c5b5da92dbd3307f07cda5d88e81c7 Successfully built semantic - version bottle Installing collected packages : semantic - version , click , colorama , urllib3 , chardet , idna , certifi , requests , pyserial , bottle , platformio Successfully installed bottle - 0.12 . 16 certifi - 2018.11 . 29 chardet - 3.0 . 4 click - 5.1 colorama - 0.4 . 1 idna - 2.8 platformio - 3.6 . 3 pyserial - 3.4 requests - 2.21 . 0 semantic - version > You are using pip version 9.0 . 1 , however version 18.1 is available . As it would prefer a recent pip instead of the one set up by virtualenv , so let's upgrade it: ( platformio - core ) [ tasmota_builder @ jtest platformio - core ] $ pip install -- upgrade pip Collecting pip Downloading https : // files . pythonhosted . org / packages / c2 / d7 / 90 f34cb0d83a6c5631cf71dfe64cc1054598c843a92b400e55675cc2ac37 / pip - 18.1 - py2 . py3 - none - any . whl ( 1.3 MB ) 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 1.3 MB 793 kB / s Installing collected packages : pip Found existing installation : pip 9.0 . 1 Uninstalling pip - 9.0 . 1 : Successfully uninstalled pip - 9.0 . 1 Successfully installed pip - 18.1 Fetch the Tasmota sources ~ If you want only to build, then the original repo will do, but if you want to contribute as well, then fork an own copy of the repo and clone out that one. (platformio-core) [tasmota_builder@jtest platformio-core]$ git clone https://github.com/arendst/Tasmota.git Cloning into 'Tasmota'... remote: Enumerating objects: 6, done. remote: Counting objects: 100% (6/6), done. remote: Compressing objects: 100% (5/5), done. remote: Total 16930 (delta 1), reused 3 (delta 1), pack-reused 16924 Receiving objects: 100% (16930/16930), 23.75 MiB | 12.94 MiB/s, done. Resolving deltas: 100% (11426/11426), done. After changing to the working copy, we are ready to go: (platformio-core) [tasmota_builder@jtest platformio-core]$ cd Tasmota/ (platformio-core) [tasmota_builder@jtest Tasmota]$ Configure the sources ~ Now you may want to configure the sources for your needs. Actually, the sources do build fine right out-of-the box, only it'll be a full build, including all the language localisation and all the build flavours as well, while you are usually interested only in one language and one build flavour only. In platformio.ini choose the environment (or flavour, if you like) you want to build. In tasmota/user_config_override.h fine tune the default values for the module, the wifi, the MQTT server, and so on. Refer to the Tasmota Wiki for details. Build the firmware ~ The build command itself is pio run , but as it emits quite a lot of messages (including errors if you're developing), so you may want to redirect a copy of the standard output and error to a file, so it'll be pio run 2>&1 | tee build.log . ( platformio - core ) [ tasmota_builder @ jtest Tasmota ] $ time pio run 2 >& 1 | tee build . log ************************************************************************************************************************************************************************ If you like PlatformIO , please : - follow us on Twitter to stay up - to - date on the latest project news > https : //twitter.com/PlatformIO_Org - star it on GitHub > https : //github.com/platformio/platformio - try PlatformIO IDE for IoT development > https : //platformio.org/platformio-ide - support us with PlatformIO Plus > https : //pioplus.com ************************************************************************************************************************************************************************ Processing tasmota ( framework : arduino ; platform : espressif8266 @1.8.0 ; board : esp01_1m ) ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ PlatformManager : Installing espressif8266 @ 1.8.0 Downloading ... Environment tasmota - TW [ SUCCESS ] Environment tasmota - UK [ SUCCESS ] ==================================================================== [ SUCCESS ] Took 797.56 seconds ==================================================================== That's all, really :D ! PlatformIO seems to handle the rebuilds and dependencies well, but if you want a clean build, the say pio run -t clean first, and then the pio run . Collect the results ~ The result will be here: ./.pioenvs/<build-flavour>/firmware.bin ( platformio-core ) [ tasmota_builder@jtest Tasmota ] $ find .pioenvs - name ' *. bin ' .pioenvs / tasmota-FR / firmware.bin .pioenvs / tasmota-GR / firmware.bin .pioenvs / tasmota-HE / firmware.bin .pioenvs / tasmota-HU / firmware.bin .pioenvs / tasmota-IT / firmware.bin .pioenvs / tasmota-NL / firmware.bin .pioenvs / tasmota-PL / firmware.bin .pioenvs / tasmota-PT / firmware.bin .pioenvs / tasmota-RU / firmware.bin .pioenvs / tasmota-SE / firmware.bin .pioenvs / tasmota-SK / firmware.bin .pioenvs / tasmota-TR / firmware.bin .pioenvs / tasmota-TW / firmware.bin .pioenvs / tasmota-UK / firmware.bin .pioenvs / tasmota / firmware.bin .pioenvs / tasmota-minimal / firmware.bin .pioenvs / tasmota-basic / firmware.bin .pioenvs / tasmota-knx / firmware.bin .pioenvs / tasmota-sensors / firmware.bin .pioenvs / tasmota-display / firmware.bin .pioenvs / tasmota-BG / firmware.bin .pioenvs / tasmota-BR / firmware.bin .pioenvs / tasmota-CN / firmware.bin .pioenvs / tasmota-CZ / firmware.bin .pioenvs / tasmota-DE / firmware.bin .pioenvs / tasmota-ES / firmware.bin About build times ~ The recent versions of PlatformIO-Core seem to parallelise quite well. When you've changed only a few files, not everything needs to be recompiled (though the image must still be re-packed), so that minute-like build time is the maximum, usually it'll be less. Prepare the local installer tool ~ You may rebuild the firmware on a remote machine, but you must have the installer tool on the local machine where the module is connected to. Fortunately, it's also python-based, so we can again employ virtualenv here. If you built the firmware also on your localhost, then there is no need for a separate environment, you may quite well install esptool into that one. Otherwise, create a virtual environment the usual way: [ tasmota_installer @ lantash ~ ] $ virtualenv esptool New python executable in / home / tasmota_installer / esptool / bin / python2 . 7 Also creating executable in / home / tasmota_installer / esptool / bin / python Installing setuptools , pip , wheel ... done . [ tasmota_installer @ lantash ~ ] $ cd esptool / [ tasmota_installer @ lantash ~/ esptool ] $ . bin / activate ( esptool ) [ tasmota_installer @ lantash ~/ esptool ] $ pip install -- upgrade pip Requirement already up - to - date : pip in ./ lib / python2 . 7 / site - packages ( 18.1 ) Now let's install esptool : ( esptool ) [ tasmota_installer @ lantash ~/ esptool ] $ pip install esptool Collecting esptool Downloading https : // files . pythonhosted . org / packages / 5 c / 85 / 5654e7 b9019739d3d89af0adf528c9ae57a9a26682e3aa012e1e30f20674 / esptool - 2.6 . tar . gz ( 80 kB ) 100 % | ################################| 81kB 222kB/s Collecting pyserial >= 3.0 ( from esptool ) Downloading https : // files . pythonhosted . org / packages / 0 d / e4 / 2 a744dd9e3be04a0c0907414e2a01a7c88bb3915cbe3c8cc06e209f59c30 / pyserial - 3.4 - py2 . py3 - none - any . whl ( 193 kB ) 100 % | ################################| 194kB 491kB/s Collecting pyaes ( from esptool ) Downloading https : // files . pythonhosted . org / packages / 44 / 66 / 2 c17bae31c906613795711fc78045c285048168919ace2220daa372c7d72 / pyaes - 1.6 . 1. tar . gz Collecting ecdsa ( from esptool ) Downloading https : // files . pythonhosted . org / packages / 63 / f4 / 73669 d51825516ce8c43b816c0a6b64cd6eb71d08b99820c00792cb42222 / ecdsa - 0.13 - py2 . py3 - none - any . whl ( 86 kB ) 100 % | ################################| 92kB 382kB/s Building wheels for collected packages : esptool , pyaes Running setup . py bdist_wheel for esptool ... done Stored in directory : / home / tasmota_installer /. cache / pip / wheels / cf / 1 f / 62 / 7 ad4e47843affd4f5b7032a39f1ef8a153c6d27533614d21aa Running setup . py bdist_wheel for pyaes ... done Stored in directory : / home / tasmota_installer /. cache / pip / wheels / bd / cf / 7 b / ced9e8f28c50ed666728e8ab178ffedeb9d06f6a10f85d6432 Successfully built esptool pyaes Installing collected packages : pyserial , pyaes , ecdsa , esptool Successfully installed ecdsa - 0.13 esptool - 2.6 pyaes - 1.6 . 1 pyserial - 3.4 If you've built the firmware on a remote machine, now it's time to download it into this installer environment (e.g. via scp or sftp ). IMPORTANT : For the subsequent steps your user must have the permission to write the serial port. Back up the current firmware (optional) ~ First of all, disconnect the bulb from the mains and wire up the serial connection and a button on GPIO0. If this GPIO0 is connected to GND when the module gets power, it starts in a firmware-update mode, and you can then read/write its flash storage. Switch off the power of the board, this will be the reference 'steady state' of the system. ( esptool ) [ tasmota_installer @ lantash ~/ esptool ] $ esptool . py read_flash 0x00000 0x100000 fcmila_bulb_orig . bin esptool . py v2 . 6 Found 1 serial ports Serial port / dev / cuaU0 Connecting ...... Now, it'll wait for the module to appear connected, so press the button (GPIO0 to GND), keep it pressed switch on the power of the board now you may release the button ... Detecting chip type ... ESP8266 Chip is ESP8266EX Features : WiFi MAC : bc : dd : c2 : e0 : 2 a : f2 Uploading stub ... Running stub ... Stub running ... 1048576 ( 100 % ) Read 1048576 bytes at 0x0 in 95.0 seconds ( 88.3 kbit / s ) ... Hard resetting via RTS pin ... If all is well, the flash is being dumped, it may take a minute or so. If done, then power the module off , as this management mode is not restartable! If it's not well, then you may try some queries: ( esptool ) [ tasmota_installer @ lantash ~/ esptool ] $ esptool . py - p / dev / ttyU0 chip_id ... Chip ID : 0x00e02af2 ... ( esptool ) [ tasmota_installer @ lantash ~/ esptool ] $ esptool . py - p / dev / ttyU0 flash_id ... Manufacturer : c8 Device : 4014 Detected flash size : 1 MB ... If they don't work, then check your cabling and your serial adapter. Until you can't get this step working, don't proceed to the next one, it won't work either. Erase the flash ~ (With the usual button-pressed-power-on rain dance, and don't forget to power the module off afterwards.) ( esptool ) [ tasmota_installer @ lantash ~/ esptool ] $ esptool . py erase_flash ... Erasing flash ( this may take a while ) ... Chip erase completed successfully in 1.6 s Install the firmware to your module ~ ( esptool ) [ tasmota_installer @ lantash ~/ esptool ] $ esptool . py write_flash -- flash_size 1 MB -- flash_mode dout 0x00000 firmware . bin Configuring flash size ... Compressed 535424 bytes to 367679. .. Wrote 535424 bytes ( 367679 compressed ) at 0x00000000 in 33.8 seconds ( effective 126.6 kbit / s ) ... Hash of data verified . Leaving ... Power on for normal operation ~ No button-pressing, power on, and see what you achieved :). The module sends its logs on the serial line at 115200 baud 8N1, so to check the logs: ( esptool ) [ tasmota_installer @ lantash ~/ esptool ] $ cu - s 115200 - l / dev / ttyU0 | tee - a my_sonoff . log Connected < some initial binary data > 00 : 00 : 00 CFG : Use defaults 00 : 00 : 00 SM16716 : ModuleSelected ; clk_pin = 4 , dat_pin = 14 ) 00 : 00 : 00 SRC : Restart 00 : 00 : 00 SM16716 : Entry ; function = FUNC_SET_DEVICE_POWER , index = 00 , payload = 02 00 : 00 : 00 SM16716 : Update ; pwr = 00 , rgb = 000000 00 : 00 : 00 Project sonoff Sonoff Version 6.4 . 1.9 ( sonoff ) - 2 _4_2 00 : 00 : 00 SM16716 : Entry ; function = FUNC_INIT 00 : 00 : 00 SM16716 : ModuleSelected ; clk_pin = 4 , dat_pin = 14 ) 00 : 00 : 00 WIF : Attempting connection ... ... (Assuming that you're using FreeBSD. On Linux you set the speed via setserial or stty , and then do the dump with dd . Or just minicom , if you prefer.) Now you have a complete build path from source to device, and a log feedback as well, so you've got everything needed for being able to implement your ideas :D !","title":"Create your own Firmware Build without IDE"},{"location":"Create-your-own-Firmware-Build-without-IDE/#provision-a-linux-vm","text":"At least if you want to work in a cloud environment, but you may also choose to work on your physical machine as well. PlatformIO is based on python, so if we use python-virtualenv , then all the dependent packages will be confined to a separate folder, so it won't even taint the OS installation. As all of python , python-virtualenv and python-pip are available in most of the recent distros, you may pick your favourite one.","title":"Provision a Linux VM"},{"location":"Create-your-own-Firmware-Build-without-IDE/#install-python-and-tools","text":"Install python and python-virtualenv , and python-pip , because we don't want to mess up the python ecosystem of the distro. Update pip by pip install --upgrade pip , and this was the last step done as root, the rest goes as a plain user. I used CentOS here, so if you prefer Debian-based distros, just substitute apt-get install -y ... for yum install -y ... . [tasmota_builder@jtest ~]$ sudo yum install -y python python-virtualenv python-pip Loaded plugins: fastestmirror Loading mirror speeds from cached hostfile ... Complete! You may update pip in the host environment, but we'll do it in the virtualenv as well, so it's optional: [tasmota_builder@jtest ~]$ sudo pip install --upgrade pip Collecting pip ... Successfully installed pip-18.1","title":"Install python and tools"},{"location":"Create-your-own-Firmware-Build-without-IDE/#prepare-a-platformio-core-environment-contained-in-a-folder","text":"virtualenv creates a folder and prepares a whole self-contained python subsystem there. To activate it, so that all python-related things refer to this environment and not to the system global, you need to source the file bin/activate within it. NOTE : Not just execute in a subshell, but include it into the current one, so please note the . before bin/activate below: [ tasmota_builder @ jtest ~ ] $ virtualenv platformio - core New python executable in / home / tasmota_builder / platformio - core / bin / python Installing setuptools , pip , wheel ... done . [ tasmota_builder @ jtest ~ ] $ cd platformio - core [ tasmota_builder @ jtest platformio - core ] $ . bin / activate ( platformio - core ) [ tasmota_builder @ jtest platformio - core ] $ Now we are ready to install PlatformIO-Core into this small virtual environment: ( platformio - core ) [ tasmota_builder @ jtest platformio - core ] $ pip install - U platformio Collecting platformio Downloading https : // files . pythonhosted . org / packages / 95 / 4 a / 3 ccce45ba750dd9a8d48dcbe9b9080011ac2a5a248312b19552bbaec6b7d / platformio - 3.6 . 3 - py27 - none - any . whl ( 160 kB ) 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 163 kB 4.5 MB / s Collecting semantic - version < 3 , >= 2.5 . 0 ( from platformio ) Downloading https : // files . pythonhosted . org / packages / 72 / 83 / f76958017f3094b072d8e3a72d25c3ed65f754cc607fdb6a7b33d84ab1d5 / semantic_version - 2.6 . 0. tar . gz Collecting click < 6 , >= 5 ( from platformio ) Downloading https : // files . pythonhosted . org / packages / 8 f / 98 / 14966 b6d772fd5fba1eb3bb34a62a7f736d609572493397cdc5715c14514 / click - 5.1 - py2 . py3 - none - any . whl ( 65 kB ) 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 71 kB 8.1 MB / s Collecting colorama ( from platformio ) Downloading https : // files . pythonhosted . org / packages / 4 f / a6 / 728666 f39bfff1719fc94c481890b2106837da9318031f71a8424b662e12 / colorama - 0.4 . 1 - py2 . py3 - none - any . whl Collecting requests < 3 , >= 2.4 . 0 ( from platformio ) Downloading https : // files . pythonhosted . org / packages / 7 d / e3 / 20 f3d364d6c8e5d2353c72a67778eb189176f08e873c9900e10c0287b84b / requests - 2.21 . 0 - py2 . py3 - none - any . whl ( 57 kB ) 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 61 kB 7.9 MB / s Collecting pyserial != 3.3 , < 4 , >= 3 ( from platformio ) Downloading https : // files . pythonhosted . org / packages / 0 d / e4 / 2 a744dd9e3be04a0c0907414e2a01a7c88bb3915cbe3c8cc06e209f59c30 / pyserial - 3.4 - py2 . py3 - none - any . whl ( 193 kB ) 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 194 kB 4.7 MB / s Collecting bottle < 0.13 ( from platformio ) Downloading https : // files . pythonhosted . org / packages / 32 / 4 e / ed046324d5ec980c252987c1dca191e001b9f06ceffaebf037eef469937c / bottle - 0.12 . 16. tar . gz ( 72 kB ) 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 81 kB 8.8 MB / s Collecting urllib3 < 1.25 , >= 1.21 . 1 ( from requests < 3 , >= 2.4 . 0 -> platformio ) Downloading https : // files . pythonhosted . org / packages / 62 / 00 / ee1d7de624db8ba7090d1226aebefab96a2c71cd5cfa7629d6ad3f61b79e / urllib3 - 1.24 . 1 - py2 . py3 - none - any . whl ( 118 kB ) 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 122 kB 7.5 MB / s Collecting chardet < 3.1 . 0 , >= 3.0 . 2 ( from requests < 3 , >= 2.4 . 0 -> platformio ) Downloading https : // files . pythonhosted . org / packages / bc / a9 / 01 ffebfb562e4274b6487b4bb1ddec7ca55ec7510b22e4c51f14098443b8 / chardet - 3.0 . 4 - py2 . py3 - none - any . whl ( 133 kB ) 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 143 kB 6.8 MB / s Collecting idna < 2.9 , >= 2.5 ( from requests < 3 , >= 2.4 . 0 -> platformio ) Downloading https : // files . pythonhosted . org / packages / 14 / 2 c / cd551d81dbe15200be1cf41cd03869a46fe7226e7450af7a6545bfc474c9 / idna - 2.8 - py2 . py3 - none - any . whl ( 58 kB ) 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 61 kB 7.8 MB / s Collecting certifi >= 2017.4 . 17 ( from requests < 3 , >= 2.4 . 0 -> platformio ) Downloading https : // files . pythonhosted . org / packages / 9 f / e0 / accfc1b56b57e9750eba272e24c4dddeac86852c2bebd1236674d7887e8a / certifi - 2018.11 . 29 - py2 . py3 - none - any . whl ( 154 kB ) 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 163 kB 5.9 MB / s Building wheels for collected packages : semantic - version , bottle Running setup . py bdist_wheel for semantic - version ... done Stored in directory : / home / tasmota_builder /. cache / pip / wheels / 60 / bb / 50 / 215 d669d31f992767f5dd8d3c974e79261707ee7f898f0dc10 Running setup . py bdist_wheel for bottle ... done Stored in directory : / home / tasmota_builder /. cache / pip / wheels / 0 c / 68 / ac / 1546 dcb27101ca6c4e50c5b5da92dbd3307f07cda5d88e81c7 Successfully built semantic - version bottle Installing collected packages : semantic - version , click , colorama , urllib3 , chardet , idna , certifi , requests , pyserial , bottle , platformio Successfully installed bottle - 0.12 . 16 certifi - 2018.11 . 29 chardet - 3.0 . 4 click - 5.1 colorama - 0.4 . 1 idna - 2.8 platformio - 3.6 . 3 pyserial - 3.4 requests - 2.21 . 0 semantic - version > You are using pip version 9.0 . 1 , however version 18.1 is available . As it would prefer a recent pip instead of the one set up by virtualenv , so let's upgrade it: ( platformio - core ) [ tasmota_builder @ jtest platformio - core ] $ pip install -- upgrade pip Collecting pip Downloading https : // files . pythonhosted . org / packages / c2 / d7 / 90 f34cb0d83a6c5631cf71dfe64cc1054598c843a92b400e55675cc2ac37 / pip - 18.1 - py2 . py3 - none - any . whl ( 1.3 MB ) 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 1.3 MB 793 kB / s Installing collected packages : pip Found existing installation : pip 9.0 . 1 Uninstalling pip - 9.0 . 1 : Successfully uninstalled pip - 9.0 . 1 Successfully installed pip - 18.1","title":"Prepare a PlatformIO-Core environment contained in a folder"},{"location":"Create-your-own-Firmware-Build-without-IDE/#fetch-the-tasmota-sources","text":"If you want only to build, then the original repo will do, but if you want to contribute as well, then fork an own copy of the repo and clone out that one. (platformio-core) [tasmota_builder@jtest platformio-core]$ git clone https://github.com/arendst/Tasmota.git Cloning into 'Tasmota'... remote: Enumerating objects: 6, done. remote: Counting objects: 100% (6/6), done. remote: Compressing objects: 100% (5/5), done. remote: Total 16930 (delta 1), reused 3 (delta 1), pack-reused 16924 Receiving objects: 100% (16930/16930), 23.75 MiB | 12.94 MiB/s, done. Resolving deltas: 100% (11426/11426), done. After changing to the working copy, we are ready to go: (platformio-core) [tasmota_builder@jtest platformio-core]$ cd Tasmota/ (platformio-core) [tasmota_builder@jtest Tasmota]$","title":"Fetch the Tasmota sources"},{"location":"Create-your-own-Firmware-Build-without-IDE/#configure-the-sources","text":"Now you may want to configure the sources for your needs. Actually, the sources do build fine right out-of-the box, only it'll be a full build, including all the language localisation and all the build flavours as well, while you are usually interested only in one language and one build flavour only. In platformio.ini choose the environment (or flavour, if you like) you want to build. In tasmota/user_config_override.h fine tune the default values for the module, the wifi, the MQTT server, and so on. Refer to the Tasmota Wiki for details.","title":"Configure the sources"},{"location":"Create-your-own-Firmware-Build-without-IDE/#build-the-firmware","text":"The build command itself is pio run , but as it emits quite a lot of messages (including errors if you're developing), so you may want to redirect a copy of the standard output and error to a file, so it'll be pio run 2>&1 | tee build.log . ( platformio - core ) [ tasmota_builder @ jtest Tasmota ] $ time pio run 2 >& 1 | tee build . log ************************************************************************************************************************************************************************ If you like PlatformIO , please : - follow us on Twitter to stay up - to - date on the latest project news > https : //twitter.com/PlatformIO_Org - star it on GitHub > https : //github.com/platformio/platformio - try PlatformIO IDE for IoT development > https : //platformio.org/platformio-ide - support us with PlatformIO Plus > https : //pioplus.com ************************************************************************************************************************************************************************ Processing tasmota ( framework : arduino ; platform : espressif8266 @1.8.0 ; board : esp01_1m ) ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ PlatformManager : Installing espressif8266 @ 1.8.0 Downloading ... Environment tasmota - TW [ SUCCESS ] Environment tasmota - UK [ SUCCESS ] ==================================================================== [ SUCCESS ] Took 797.56 seconds ==================================================================== That's all, really :D ! PlatformIO seems to handle the rebuilds and dependencies well, but if you want a clean build, the say pio run -t clean first, and then the pio run .","title":"Build the firmware"},{"location":"Create-your-own-Firmware-Build-without-IDE/#collect-the-results","text":"The result will be here: ./.pioenvs/<build-flavour>/firmware.bin ( platformio-core ) [ tasmota_builder@jtest Tasmota ] $ find .pioenvs - name ' *. bin ' .pioenvs / tasmota-FR / firmware.bin .pioenvs / tasmota-GR / firmware.bin .pioenvs / tasmota-HE / firmware.bin .pioenvs / tasmota-HU / firmware.bin .pioenvs / tasmota-IT / firmware.bin .pioenvs / tasmota-NL / firmware.bin .pioenvs / tasmota-PL / firmware.bin .pioenvs / tasmota-PT / firmware.bin .pioenvs / tasmota-RU / firmware.bin .pioenvs / tasmota-SE / firmware.bin .pioenvs / tasmota-SK / firmware.bin .pioenvs / tasmota-TR / firmware.bin .pioenvs / tasmota-TW / firmware.bin .pioenvs / tasmota-UK / firmware.bin .pioenvs / tasmota / firmware.bin .pioenvs / tasmota-minimal / firmware.bin .pioenvs / tasmota-basic / firmware.bin .pioenvs / tasmota-knx / firmware.bin .pioenvs / tasmota-sensors / firmware.bin .pioenvs / tasmota-display / firmware.bin .pioenvs / tasmota-BG / firmware.bin .pioenvs / tasmota-BR / firmware.bin .pioenvs / tasmota-CN / firmware.bin .pioenvs / tasmota-CZ / firmware.bin .pioenvs / tasmota-DE / firmware.bin .pioenvs / tasmota-ES / firmware.bin","title":"Collect the results"},{"location":"Create-your-own-Firmware-Build-without-IDE/#about-build-times","text":"The recent versions of PlatformIO-Core seem to parallelise quite well. When you've changed only a few files, not everything needs to be recompiled (though the image must still be re-packed), so that minute-like build time is the maximum, usually it'll be less.","title":"About build times"},{"location":"Create-your-own-Firmware-Build-without-IDE/#prepare-the-local-installer-tool","text":"You may rebuild the firmware on a remote machine, but you must have the installer tool on the local machine where the module is connected to. Fortunately, it's also python-based, so we can again employ virtualenv here. If you built the firmware also on your localhost, then there is no need for a separate environment, you may quite well install esptool into that one. Otherwise, create a virtual environment the usual way: [ tasmota_installer @ lantash ~ ] $ virtualenv esptool New python executable in / home / tasmota_installer / esptool / bin / python2 . 7 Also creating executable in / home / tasmota_installer / esptool / bin / python Installing setuptools , pip , wheel ... done . [ tasmota_installer @ lantash ~ ] $ cd esptool / [ tasmota_installer @ lantash ~/ esptool ] $ . bin / activate ( esptool ) [ tasmota_installer @ lantash ~/ esptool ] $ pip install -- upgrade pip Requirement already up - to - date : pip in ./ lib / python2 . 7 / site - packages ( 18.1 ) Now let's install esptool : ( esptool ) [ tasmota_installer @ lantash ~/ esptool ] $ pip install esptool Collecting esptool Downloading https : // files . pythonhosted . org / packages / 5 c / 85 / 5654e7 b9019739d3d89af0adf528c9ae57a9a26682e3aa012e1e30f20674 / esptool - 2.6 . tar . gz ( 80 kB ) 100 % | ################################| 81kB 222kB/s Collecting pyserial >= 3.0 ( from esptool ) Downloading https : // files . pythonhosted . org / packages / 0 d / e4 / 2 a744dd9e3be04a0c0907414e2a01a7c88bb3915cbe3c8cc06e209f59c30 / pyserial - 3.4 - py2 . py3 - none - any . whl ( 193 kB ) 100 % | ################################| 194kB 491kB/s Collecting pyaes ( from esptool ) Downloading https : // files . pythonhosted . org / packages / 44 / 66 / 2 c17bae31c906613795711fc78045c285048168919ace2220daa372c7d72 / pyaes - 1.6 . 1. tar . gz Collecting ecdsa ( from esptool ) Downloading https : // files . pythonhosted . org / packages / 63 / f4 / 73669 d51825516ce8c43b816c0a6b64cd6eb71d08b99820c00792cb42222 / ecdsa - 0.13 - py2 . py3 - none - any . whl ( 86 kB ) 100 % | ################################| 92kB 382kB/s Building wheels for collected packages : esptool , pyaes Running setup . py bdist_wheel for esptool ... done Stored in directory : / home / tasmota_installer /. cache / pip / wheels / cf / 1 f / 62 / 7 ad4e47843affd4f5b7032a39f1ef8a153c6d27533614d21aa Running setup . py bdist_wheel for pyaes ... done Stored in directory : / home / tasmota_installer /. cache / pip / wheels / bd / cf / 7 b / ced9e8f28c50ed666728e8ab178ffedeb9d06f6a10f85d6432 Successfully built esptool pyaes Installing collected packages : pyserial , pyaes , ecdsa , esptool Successfully installed ecdsa - 0.13 esptool - 2.6 pyaes - 1.6 . 1 pyserial - 3.4 If you've built the firmware on a remote machine, now it's time to download it into this installer environment (e.g. via scp or sftp ). IMPORTANT : For the subsequent steps your user must have the permission to write the serial port.","title":"Prepare the local installer tool"},{"location":"Create-your-own-Firmware-Build-without-IDE/#back-up-the-current-firmware-optional","text":"First of all, disconnect the bulb from the mains and wire up the serial connection and a button on GPIO0. If this GPIO0 is connected to GND when the module gets power, it starts in a firmware-update mode, and you can then read/write its flash storage. Switch off the power of the board, this will be the reference 'steady state' of the system. ( esptool ) [ tasmota_installer @ lantash ~/ esptool ] $ esptool . py read_flash 0x00000 0x100000 fcmila_bulb_orig . bin esptool . py v2 . 6 Found 1 serial ports Serial port / dev / cuaU0 Connecting ...... Now, it'll wait for the module to appear connected, so press the button (GPIO0 to GND), keep it pressed switch on the power of the board now you may release the button ... Detecting chip type ... ESP8266 Chip is ESP8266EX Features : WiFi MAC : bc : dd : c2 : e0 : 2 a : f2 Uploading stub ... Running stub ... Stub running ... 1048576 ( 100 % ) Read 1048576 bytes at 0x0 in 95.0 seconds ( 88.3 kbit / s ) ... Hard resetting via RTS pin ... If all is well, the flash is being dumped, it may take a minute or so. If done, then power the module off , as this management mode is not restartable! If it's not well, then you may try some queries: ( esptool ) [ tasmota_installer @ lantash ~/ esptool ] $ esptool . py - p / dev / ttyU0 chip_id ... Chip ID : 0x00e02af2 ... ( esptool ) [ tasmota_installer @ lantash ~/ esptool ] $ esptool . py - p / dev / ttyU0 flash_id ... Manufacturer : c8 Device : 4014 Detected flash size : 1 MB ... If they don't work, then check your cabling and your serial adapter. Until you can't get this step working, don't proceed to the next one, it won't work either.","title":"Back up the current firmware (optional)"},{"location":"Create-your-own-Firmware-Build-without-IDE/#erase-the-flash","text":"(With the usual button-pressed-power-on rain dance, and don't forget to power the module off afterwards.) ( esptool ) [ tasmota_installer @ lantash ~/ esptool ] $ esptool . py erase_flash ... Erasing flash ( this may take a while ) ... Chip erase completed successfully in 1.6 s","title":"Erase the flash"},{"location":"Create-your-own-Firmware-Build-without-IDE/#install-the-firmware-to-your-module","text":"( esptool ) [ tasmota_installer @ lantash ~/ esptool ] $ esptool . py write_flash -- flash_size 1 MB -- flash_mode dout 0x00000 firmware . bin Configuring flash size ... Compressed 535424 bytes to 367679. .. Wrote 535424 bytes ( 367679 compressed ) at 0x00000000 in 33.8 seconds ( effective 126.6 kbit / s ) ... Hash of data verified . Leaving ...","title":"Install the firmware to your module"},{"location":"Create-your-own-Firmware-Build-without-IDE/#power-on-for-normal-operation","text":"No button-pressing, power on, and see what you achieved :). The module sends its logs on the serial line at 115200 baud 8N1, so to check the logs: ( esptool ) [ tasmota_installer @ lantash ~/ esptool ] $ cu - s 115200 - l / dev / ttyU0 | tee - a my_sonoff . log Connected < some initial binary data > 00 : 00 : 00 CFG : Use defaults 00 : 00 : 00 SM16716 : ModuleSelected ; clk_pin = 4 , dat_pin = 14 ) 00 : 00 : 00 SRC : Restart 00 : 00 : 00 SM16716 : Entry ; function = FUNC_SET_DEVICE_POWER , index = 00 , payload = 02 00 : 00 : 00 SM16716 : Update ; pwr = 00 , rgb = 000000 00 : 00 : 00 Project sonoff Sonoff Version 6.4 . 1.9 ( sonoff ) - 2 _4_2 00 : 00 : 00 SM16716 : Entry ; function = FUNC_INIT 00 : 00 : 00 SM16716 : ModuleSelected ; clk_pin = 4 , dat_pin = 14 ) 00 : 00 : 00 WIF : Attempting connection ... ... (Assuming that you're using FreeBSD. On Linux you set the speed via setserial or stty , and then do the dump with dd . Or just minicom , if you prefer.) Now you have a complete build path from source to device, and a log feedback as well, so you've got everything needed for being able to implement your ideas :D !","title":"Power on for normal operation"},{"location":"DHT11-Wiring---Sonoff-Basic/","text":"To wire a DHT11 up to a Sonoff Basic, I first soldered a pin header to the main pin header row. For the location see [[Pinouts]]. I decided to use regular 2.54mm connectors (often referred to as Dupont connectors), so that I can switch sensors if I have to. In order to fit the dupont cables within the enclosure, I had to bend the 2.54mm pin headers by about 45\u00b0. As the DHT11 requires a pullup (depending on the cable length), and I didn't want to design a PCB just to connect 3 wires and a resistor, I came up with the solution described below. First, I slipped ferrules over the DHT11 pins and inserted the wires. This makes it a lot easier to hold the cables and the DHT11 pins in place. I left a bit more wire exposed so that I have a place to apply solder without burning the wire insulation. I applied heat to the ferrule, not the wire, and applied solder directly at the end of the ferrule. Solder will then flow into the ferrule. I also added a small solder blob (visible on the top ferrule) so that I can solder an 0805 resistor in place. Thanks to the ferrule, the wires won't become detached when heated again. Keep in mind that the ferrule has quite some heat capacity, so wait for the solder to cool down prior moving the wires or the sensor. I then did shrink the 2:1 green heatshrink tubes so that the contacts don't touch each other. Also, it is so very handy to have 4:1 shrinking tube. An 8mm 4:1 tube fits perfectly over the pins, and fully encloses the 3 wires. Get 4:1 heatshrink tube. It's so worth it. Here's how the finished project looks like:","title":"DHT11 Wiring   Sonoff Basic"},{"location":"DHT11/","text":"DHT11 temperature and humidity sensor ~ DHT11 is a basic, ultra low-cost digital temperature and humidity sensor. It is very inaccurate and surpassed by others (AM2301, BME280, ...) thus not recommended by us. Configuration ~ Wiring ~ DHT11 ESP266 - GND OUT GPIOx + 3.3V Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to DHT11 (1) After reboot of the device the temperature and humidity are displayed. Commands ~ TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device. Wemos DHT11 Shield ~ Note: this is ONLY for v1.0.0 of the DHT11 shield, since v2.0.0 uses I 2 C and pinned differently. From the Wemos DHT11 shield specs the DATA OUT pin is connected to D4 of the Wemos. Note: Having the shield compact on top of the processor increases the temperature. In normal Mode this can be up to 6\u00b0C. So you should add sleep mode. Adding normal \"Sleep 100\" and putting the sensor vertically reduces the temperature difference to 2\u00b0C Sonoff Basic specific ~ To wire a DHT11 up to a Sonoff Basic, I first soldered a pin header to the main pin header row. For the location see GPIO Locations . I decided to use regular 2.54mm connectors (often referred to as Dupont connectors), so that I can switch sensors if I have to. In order to fit the dupont cables within the enclosure, I had to bend the 2.54mm pin headers by about 45\u00b0. As the DHT11 requires a pullup (depending on the cable length), and I didn't want to design a PCB just to connect 3 wires and a resistor, I came up with the solution described below. First, I slipped ferrules over the DHT11 pins and inserted the wires. This makes it a lot easier to hold the cables and the DHT11 pins in place. I left a bit more wire exposed so that I have a place to apply solder without burning the wire insulation. I applied heat to the ferrule, not the wire, and applied solder directly at the end of the ferrule. Solder will then flow into the ferrule. I also added a small solder blob (visible on the top ferrule) so that I can solder an 0805 resistor in place. Thanks to the ferrule, the wires won't become detached when heated again. Keep in mind that the ferrule has quite some heat capacity, so wait for the solder to cool down prior moving the wires or the sensor. I then did shrink the 2:1 green heatshrink tubes so that the contacts don't touch each other. Also, it is so very handy to have 4:1 shrinking tube. An 8mm 4:1 tube fits perfectly over the pins, and fully encloses the 3 wires. Get 4:1 heatshrink tube. It's so worth it. Here's how the finished project looks like: OpenHab ~ sonoff.items: // DHT-6 Number DHT6_Temp \"Bathroom DHT-6 [%.1f \u00b0C]\" <temperature> (gTemperature,gTemperatureRoom) { mqtt=\"<[broker:tele/sonoff-dht-6/SENSOR:state:JSONPATH($.DHT11.Temperature)]\" } Number DHT6_Humidity \"Bathroom DHT-6 [%.1f %%]\" <humidity> (gHumidity) { mqtt=\"<[broker:tele/sonoff-dht-6/SENSOR:state:JSONPATH($.DHT11.Humidity)]\" } Switch DHT6_Reachable \"DHT-6 reachable\" <contact> (gReachable) { mqtt=\"<[broker:tele/sonoff-dht-6/LWT:state:MAP(reachable.map)]\" } Number DHT6_RSSI \"DHT-6 RSSI [%d %%]\" <qualityofservice> (gRSSI) { mqtt=\"<[broker:tele/sonoff-dht-6/STATE:state:JSONPATH($.Wifi.RSSI)]\" } sonoff.sitemap Frame { Text item=DHT6_Temp labelcolor=[DHT6_Reachable == \"ON\" = \"green\",DHT6_Reachable == \"OFF\" = \"red\"] { Text item=DHT6_Temp Text item=DHT6_Humidity Text item=DHT6_Reachable Text item=DHT6_RSSI } } Printable Housing ~ https://www.thingiverse.com/thing:2814909","title":"DHT11 temperature and humidity sensor"},{"location":"DHT11/#dht11-temperature-and-humidity-sensor","text":"DHT11 is a basic, ultra low-cost digital temperature and humidity sensor. It is very inaccurate and surpassed by others (AM2301, BME280, ...) thus not recommended by us.","title":"DHT11 temperature and humidity sensor"},{"location":"DHT11/#configuration","text":"","title":"Configuration"},{"location":"DHT11/#wiring","text":"DHT11 ESP266 - GND OUT GPIOx + 3.3V","title":"Wiring"},{"location":"DHT11/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to DHT11 (1) After reboot of the device the temperature and humidity are displayed.","title":"Tasmota Settings"},{"location":"DHT11/#commands","text":"TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device.","title":"Commands"},{"location":"DHT11/#wemos-dht11-shield","text":"Note: this is ONLY for v1.0.0 of the DHT11 shield, since v2.0.0 uses I 2 C and pinned differently. From the Wemos DHT11 shield specs the DATA OUT pin is connected to D4 of the Wemos. Note: Having the shield compact on top of the processor increases the temperature. In normal Mode this can be up to 6\u00b0C. So you should add sleep mode. Adding normal \"Sleep 100\" and putting the sensor vertically reduces the temperature difference to 2\u00b0C","title":"Wemos DHT11 Shield"},{"location":"DHT11/#sonoff-basic-specific","text":"To wire a DHT11 up to a Sonoff Basic, I first soldered a pin header to the main pin header row. For the location see GPIO Locations . I decided to use regular 2.54mm connectors (often referred to as Dupont connectors), so that I can switch sensors if I have to. In order to fit the dupont cables within the enclosure, I had to bend the 2.54mm pin headers by about 45\u00b0. As the DHT11 requires a pullup (depending on the cable length), and I didn't want to design a PCB just to connect 3 wires and a resistor, I came up with the solution described below. First, I slipped ferrules over the DHT11 pins and inserted the wires. This makes it a lot easier to hold the cables and the DHT11 pins in place. I left a bit more wire exposed so that I have a place to apply solder without burning the wire insulation. I applied heat to the ferrule, not the wire, and applied solder directly at the end of the ferrule. Solder will then flow into the ferrule. I also added a small solder blob (visible on the top ferrule) so that I can solder an 0805 resistor in place. Thanks to the ferrule, the wires won't become detached when heated again. Keep in mind that the ferrule has quite some heat capacity, so wait for the solder to cool down prior moving the wires or the sensor. I then did shrink the 2:1 green heatshrink tubes so that the contacts don't touch each other. Also, it is so very handy to have 4:1 shrinking tube. An 8mm 4:1 tube fits perfectly over the pins, and fully encloses the 3 wires. Get 4:1 heatshrink tube. It's so worth it. Here's how the finished project looks like:","title":"Sonoff Basic specific"},{"location":"DHT11/#openhab","text":"sonoff.items: // DHT-6 Number DHT6_Temp \"Bathroom DHT-6 [%.1f \u00b0C]\" <temperature> (gTemperature,gTemperatureRoom) { mqtt=\"<[broker:tele/sonoff-dht-6/SENSOR:state:JSONPATH($.DHT11.Temperature)]\" } Number DHT6_Humidity \"Bathroom DHT-6 [%.1f %%]\" <humidity> (gHumidity) { mqtt=\"<[broker:tele/sonoff-dht-6/SENSOR:state:JSONPATH($.DHT11.Humidity)]\" } Switch DHT6_Reachable \"DHT-6 reachable\" <contact> (gReachable) { mqtt=\"<[broker:tele/sonoff-dht-6/LWT:state:MAP(reachable.map)]\" } Number DHT6_RSSI \"DHT-6 RSSI [%d %%]\" <qualityofservice> (gRSSI) { mqtt=\"<[broker:tele/sonoff-dht-6/STATE:state:JSONPATH($.Wifi.RSSI)]\" } sonoff.sitemap Frame { Text item=DHT6_Temp labelcolor=[DHT6_Reachable == \"ON\" = \"green\",DHT6_Reachable == \"OFF\" = \"red\"] { Text item=DHT6_Temp Text item=DHT6_Humidity Text item=DHT6_Reachable Text item=DHT6_RSSI } }","title":"OpenHab"},{"location":"DHT11/#printable-housing","text":"https://www.thingiverse.com/thing:2814909","title":"Printable Housing"},{"location":"DS18x20/","text":"DS18x20 temperature sensor ~ DS18x20 driver supports DS18B20 , DS18S20 and DS1822 1-Wire digital temperature sensors. Configuration ~ Wiring ~ DS18b20 ESP266 1 GND GND 2 Data GPIOx 3 VCC 3.3v You need to connect a 4.7K pullup resistor from data to 3.3V. Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to DS18x20 (4) After a reboot webUI will display temperature measured. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-01-01T00:00:00\" , \"DS18B20\" :{ \"Temperature\" : 49.7 }, \"TempUnit\" : \"C\" } Commands ~ SetOption74 is used to enable/disable internal pullup for single DS18x20 sensor. TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device. Multiple Sensors ~ Tasmota supports multiple DS18b20 sensors connected to a single ESP8266 chip. At this time, the maximum is set to 8 (see #define DS18X20_MAX_SENSORS 8 in https://github.com/arendst/Tasmota/blob/development/tasmota/xsns_05_ds18x20.ino#L40 ) Every sensors will get a unique ID used in webUI and MQTT telemetry. Sensor Versions ~ ESP01 Module ~ Danger BEWARE OF MANY VISUALLY SIMILAR BOARDS TO THIS RELAY BOARD but different schematics Some modules have culprits: * \"CH_PD\" is not set to HI (3.3V) as actually required. Usually this is done with a 10K resistor or directly to 3.3V, I have connected directly to the 3.3V * A resistor (R2 10k) which is connected between the terminal GPIO0 to ground. This ensures that the GPIO0 is always pulled to ground, which actually places the ESP-01 in program mode (flashing). To make the module working it is necessary to remove (solder out). Connect DS18B20 to the GPIO2 (see diagram below - soldering not necessary , it is possible to put the wires and the resistor directly in to the female part of the connector together with ESP 01S module pins) After flashing, set up Tasmota (see images below): * \"Generic module\" * GPIO0 as Relay1 (21) * GPIO2 as DS18x20(4) Retrieving the temperature via HTTP http://tasmota-ip/cm?user=<USER>&password=<PASS>&cmnd=status%2010 The temperature information will put published by MQTT to the tele/%topic%/SENSOR in the format of: \"Time\":\"2018-06-14T07:56:34\",\"DS18B20\":{\"Temperature\":21.9},\"TempUnit\":\"C\"}","title":"DS18x20 temperature sensor"},{"location":"DS18x20/#ds18x20-temperature-sensor","text":"DS18x20 driver supports DS18B20 , DS18S20 and DS1822 1-Wire digital temperature sensors.","title":"DS18x20 temperature sensor"},{"location":"DS18x20/#configuration","text":"","title":"Configuration"},{"location":"DS18x20/#wiring","text":"DS18b20 ESP266 1 GND GND 2 Data GPIOx 3 VCC 3.3v You need to connect a 4.7K pullup resistor from data to 3.3V.","title":"Wiring"},{"location":"DS18x20/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to DS18x20 (4) After a reboot webUI will display temperature measured. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-01-01T00:00:00\" , \"DS18B20\" :{ \"Temperature\" : 49.7 }, \"TempUnit\" : \"C\" }","title":"Tasmota Settings"},{"location":"DS18x20/#commands","text":"SetOption74 is used to enable/disable internal pullup for single DS18x20 sensor. TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device.","title":"Commands"},{"location":"DS18x20/#multiple-sensors","text":"Tasmota supports multiple DS18b20 sensors connected to a single ESP8266 chip. At this time, the maximum is set to 8 (see #define DS18X20_MAX_SENSORS 8 in https://github.com/arendst/Tasmota/blob/development/tasmota/xsns_05_ds18x20.ino#L40 ) Every sensors will get a unique ID used in webUI and MQTT telemetry.","title":"Multiple Sensors"},{"location":"DS18x20/#sensor-versions","text":"","title":"Sensor Versions"},{"location":"DS18x20/#esp01-module","text":"Danger BEWARE OF MANY VISUALLY SIMILAR BOARDS TO THIS RELAY BOARD but different schematics Some modules have culprits: * \"CH_PD\" is not set to HI (3.3V) as actually required. Usually this is done with a 10K resistor or directly to 3.3V, I have connected directly to the 3.3V * A resistor (R2 10k) which is connected between the terminal GPIO0 to ground. This ensures that the GPIO0 is always pulled to ground, which actually places the ESP-01 in program mode (flashing). To make the module working it is necessary to remove (solder out). Connect DS18B20 to the GPIO2 (see diagram below - soldering not necessary , it is possible to put the wires and the resistor directly in to the female part of the connector together with ESP 01S module pins) After flashing, set up Tasmota (see images below): * \"Generic module\" * GPIO0 as Relay1 (21) * GPIO2 as DS18x20(4) Retrieving the temperature via HTTP http://tasmota-ip/cm?user=<USER>&password=<PASS>&cmnd=status%2010 The temperature information will put published by MQTT to the tele/%topic%/SENSOR in the format of: \"Time\":\"2018-06-14T07:56:34\",\"DS18B20\":{\"Temperature\":21.9},\"TempUnit\":\"C\"}","title":"ESP01 Module"},{"location":"DS3231/","text":"DS3231 Real Time Clock ~ This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_DS3231 #define USE_DS3231 // DS3231 external RTC (+1k2 code) // #define USE_RTC_ADDR 0x68 // Default I2C address 0x68 #endif If you use a DS3231 with a different I 2 C address, uncomment and change to your address: #define USE_RTC_ADDR 0x68 Tasmota requires that its time be set in order to use timers. Usually, when the device boots, it gets the time and date from an an NTP (Network Time Protocol) server located somewhere on the Internet. When there is no Internet connection, Tasmota is not able to request the current date and time. The DS3231 is an external Real Time Clock (RTC) component used for keeping the time and date set in the device when it cannot establish an Internet connection. Configuration ~ Wiring ~ DS3231 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) Wiring on Wemos D1 mini Tasmota Settings ~ Any time your device has an NTP connection, the DS3231 internal clock will be set automatically. The first time RTC is used, you must have an Internet connection . From that point forward, the time is stored in the RTC and the device time will be restored from the RTC when there is no Internet connection. (You can use your mobile phone hotspot for your device in a location where it can't get a Wi-Fi connection Check that the time is set correctly by inspecting the log in the Console. You should see messages that Tasmota read or wrote the time from and to the DS3231. Make sure that the time is set correctly even when you do not have Internet connection .","title":"DS3231 Real Time Clock"},{"location":"DS3231/#ds3231-real-time-clock","text":"This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_DS3231 #define USE_DS3231 // DS3231 external RTC (+1k2 code) // #define USE_RTC_ADDR 0x68 // Default I2C address 0x68 #endif If you use a DS3231 with a different I 2 C address, uncomment and change to your address: #define USE_RTC_ADDR 0x68 Tasmota requires that its time be set in order to use timers. Usually, when the device boots, it gets the time and date from an an NTP (Network Time Protocol) server located somewhere on the Internet. When there is no Internet connection, Tasmota is not able to request the current date and time. The DS3231 is an external Real Time Clock (RTC) component used for keeping the time and date set in the device when it cannot establish an Internet connection.","title":"DS3231 Real Time Clock"},{"location":"DS3231/#configuration","text":"","title":"Configuration"},{"location":"DS3231/#wiring","text":"DS3231 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"DS3231/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) Wiring on Wemos D1 mini","title":"Tasmota Settings"},{"location":"DS3231/#tasmota-settings_1","text":"Any time your device has an NTP connection, the DS3231 internal clock will be set automatically. The first time RTC is used, you must have an Internet connection . From that point forward, the time is stored in the RTC and the device time will be restored from the RTC when there is no Internet connection. (You can use your mobile phone hotspot for your device in a location where it can't get a Wi-Fi connection Check that the time is set correctly by inspecting the log in the Console. You should see messages that Tasmota read or wrote the time from and to the DS3231. Make sure that the time is set correctly even when you do not have Internet connection .","title":"Tasmota Settings"},{"location":"DeepSleep/","text":"Deep sleep support for up to 1 day (i.e., 86,400 seconds) (e.g., if used with KNX) ( DeepSleepTime ). The ESP8266 has a limitation of a maximum of ~71 minutes deep sleep. To overcome the limitation, a short wake-up is performed - the device will wake up every hour for <0.3 seconds until the deep sleep time is reached. The remaining deep sleep time is decremented, and the device is then put back in deep sleep again. The remaining time is stored in RTC memory. As long as the device is powered (e.g., via the battery), this should work fine. Flash memory is not used because of how often this has to occur (every hour) and the time it takes for the flash to be ready takes much longer than the total time to write to the RTC. DeepSleepTime sets the time the device remains in deep sleep before it returns to full operating mode. Once the command is issued, the deep sleep cycle commences. During deep sleep, the device is effectively off and, as such, it is not possible to modify DeepSleepTime without exiting deep sleep. Example With DeepSleepTime 3600 , the device will wake up exactly every hour (e.g., 8:00am, 9:00am, ...). If you define DeepSleepTime 86400 (i.e., 60*60*24), it will wake-up exactly at 0:00 UTC time - not your local time. If you define DeepSleepTime 600 , it will wake-up every 10 minutes (e.g., 8:00, 8:10, 8:20, ...). Please be aware that the minimum deep sleep time is 10 seconds. In order for the device to wake itself to perform its function during the deep sleep cycle, the RST pin must be connected to the D0/GPIO16 pin. This is the only pin which can perform this function as the wake-up signal is sent from the RTC through D0/GPIO16 to RST. When connected to RST for our purposes, GPIO16 may not be used for other functions. As such, it is recommended to leave it configured as None (0) . Disable deep sleep mode ~ using a switch ~ Select another GPIO (let's call it \"GPIOn\") and connect it GND. This can be performed through a switch per the schematic below. Flipping the switch to \"ON\" will prevent Tasmota to enter DeepSleep again after next wake-up until the switch is flipped back OFF. GPIOn should be defined as DeepSleep (182) in the configuration as shown below: The following GPIOs CANNOT be used for the purpose of temporarily disabling deep sleep as described above: - GPIO16 (because it is connected to RST), - GPIO15 (because of an existing on-board pull-down resistor), - GPIO0 (because pulling it down at wake up will enter serial bootload mode). All others GPIO should be acceptable. An interresting use-case is to disable DeepSleep when external power (USB, PSU, solar panel...) is applied to the device using a transistor. If the device is not (easily) accessible, methods can be used to disable the DeepSleep loop without physical access. using MQTT ~ Send a retained DeepSleepTime 0 command to your device. As the message is retained in the MQTT broker, the device will receive it as soon as it connectes to the MQTT broker. You can use console to send from another Tasmota device: Publish2 cmnd/%topic%/DeepSleepTime 0 Don't forget to remove the retained message from the broker with Publish2 cmnd/%topic%/DeepSleepTime !!! If using mosquitto broker\" mosquitto_pub -t \"cmnd/myDeviceTopic/DeepsleepTime\" -r -m \"0\" Remove retained message mosquitto_pub -t \"cmnd/myDeviceTopic/DeepsleepTime\" -r -n Once you have made your configuration change, you will need to re-enable DeepSleep mode using DeepSleepTime command. using smart home automation ~ Configure a settable flag in your home automation hub (e.g., Node-Red, openHAB, Home Assistant). The flag should subscribe to the tele/%topic%/LWT topic for the payload Online . Alternatively, if testing the payload value is not easy, subscribe to the topic tele/%topic%/STATE which is the 2nd topic on which hte device publish right after waking-up. The moment a message is received on this topic, the automation can publish a message to topic cmnd/%topic%/DeepSleepTime with payload 0 . This will cause the device to disable deep sleep and allow maintenance such as firmware updates to be performed without having an unexpected deep sleep event. Send the DeepSleepTime 0 command only once . Once device maintenance is completed, place it back into deep sleep mode using original configuration. If you're having issues after wakeup from sleep Make sure bootloop detection is off SetOption36 0 . See issue #6890 Executing commands before entering DeepSleep ~ If you want to execute some commands or a special script BEFORE device goes into deep sleep, use FUNC_SAVE_BEFORE_RESTART as a predefined hook to implement your own procedure. This requires you to code your own function and self-compile custom firmware. To use rules, use the System#Save trigger. This will be executed just before the device goes into deep sleep. Overcome network issues ~ If all requirements (Wifi, NTP time synchronization, MQTT broker connection and TelePeriod) are not met, the device will stay awake while trying to attain the remaining requirements. On battery powered devices this behavior is undesirable because it will quickly deplete the battery. To avoid this when these requirements cannot be met, put the device back into deep sleep for an hour. Do this through a rule that will be triggered 30 seconds after reboot and sends the device into deepsleep for an hour. Rule1 ON Dimmer#Boot DO RuleTimer1 30 ENDON ON Rules#Timer=1 DO DeepSleepTime 3600 ENDON Rule1 ON Deep Sleep Algorithm General Timing ~ Let's assume you have set DeepSleepTime 3600 (one hour) and TelePeriod 300 (five minutes). The device will first wake at 8:00 am. The device will boot and connect Wi-Fi. Next, the correct time must be sync'ed from one of the NTP servers. Now the device has all prerequisites for going into deep sleep. Deep sleep is then triggered at the TelePeriod event. In this example, it will occur after five minutes. Telemetry will be collected and sent (e.g., via MQTT). Now, deep sleep can happen. First, Offline is published to the LWT topic on MQTT. It then calculates the new sleeping time to wake-up at 9:00 am (3600 seconds after the last wake-up). At 9:00 am this same sequence of events happens again. If you want to minimize the time that the device is in operation, decrease TelePeriod down to 10 seconds. This period of time is counted after MQTT is connected. Also, in this case, the device will wake up at 9:00 am even if the uptime was much smaller. If the device missed a wake-up it will try a start at the next event - in this case 10:00 am. ESP8266 Deep Sleep Side-effects ~ Not all GPIO behave the same during deep sleep. Some GPIO go HIGH, some LOW, some FOLLOW the relay but work only on FET transistors. As soon as current flows they go LOW. I use one GPIO to trigger a BC337 transistor to switch OFF all connected devices during deep sleep. Findings: Pin GPIO Behavior D0 16 Excluded due to use as wake-up pin D1 5 KEEP STATE, go LOW if resistance to ground < infinite D2 4 KEEP STATE, go LOW if resistance to ground < infinite D3 0 HIGH D4 2 HIGH D5 14 HIGH, go LOW if resistance to ground < infinite D6 12 HIGH, go LOW if resistance to ground < infinite D7 13 HIGH, go LOW if resistance to ground < infinite D8 15 LOW Log Output Explanation ~ (logging level 4 ) When MQTT connects at 13:08:38 , this sets the system to READY. 13 : 08 : 43 MQT : tele /tasmota/ INFO3 = { \"RestartReason\" : \"Deep-Sleep Wake\" } 13 : 08 : 44 APP : Boot Count 3 13 : 08 : 44 CFG : Saved to flash at F4 , Count 96 , Bytes 3824 In the context of DeepSleep, maintaining a device boot count is not relevant. When deep sleep is enabled, boot count will not be incremented. This avoids excessive flash writes which will deteriorate the flash memory chip and eventually cause the device to fail. Boot count incrementing can be enabled using SetOption76 . In this example, TelePeriod is 10. Therefore when it is reached, telemetry reporting occurs. 13 : 08 : 48 MQT : tele /tasmota/ STATE = { \"Time\" : \"2019-09-04T13:08:48\" , \"Epoch\" : 1567595328 , \"Uptime\" : \"0T00:00:14\" , \"UptimeSec\" : 14 , \"Heap\" : 24 , \"SleepMode\" : \"Dynamic\" , \"Sleep\" : 50 , \"LoadAvg\" : 20 , \"MqttCount\" : 1 , \"Wifi\" :{ \"AP\" : 1 , \"SSId\" : \"MyWLAN\" , \"BSSId\" : \"AA:FF:AA:AA:AA:AA\" , \"Channel\" : 11 , \"RSSI\" : 100 , \"LinkCount\" : 1 , \"Downtime\" : \"0T00:00:08\" , \"DeepSleep\" : 300 , \"Heap\" : 25160 }} 13 : 08 : 48 MQT : tele /tasmota/ SENSOR = { \"Time\" : \"2019-09-04T13:08:48\" , \"Epoch\" : 1567595328 , \"ANALOG\" :{ \"A0\" : 8 }} Date and time is set, status and telemetry sent. Now start shutdown procedure. First, send MQTT offline. 13:08:48 MQT: state/sonoff/LWT = Offline Deep sleep is 300 seconds. Therefore +-30 sec is allowed as deviation between proposed wake-up time and real wake-up time. Reporting in 0.1sec. In this case wake-up was one second late. 13:08:48 Timeslip 0.1 sec:? -300 < -10 < 300 If the error is in the range, this is tagged as a normal wake up where drift can be recalculated 13:08:48 Normal deepsleep? 1 Recalculate a new drift that is a multiplier for the next wake-up in 1/10000. In this case, the multiplier is 1.0257 13:08:48 % RTC new drift 10257 And for information: New target wake-up time 13:08:48 Next wakeup 2019-09-04T13:10:00 Based on run time and the error in the last loop, a new sleeping time will be calculated. This will be multiplied by the deepsleep_slip and, ideally, the device will wake up at the time above. 13:08:48 Sleeptime 285 sec, deepsleep_slip 10257 The effectiveness of the compensation can be seen here. Instead of typically 160-200 seconds, most times it is better than 10 seconds in a one hour deep sleep cycle.","title":"DeepSleep"},{"location":"DeepSleep/#disable-deep-sleep-mode","text":"","title":"Disable deep sleep mode"},{"location":"DeepSleep/#using-a-switch","text":"Select another GPIO (let's call it \"GPIOn\") and connect it GND. This can be performed through a switch per the schematic below. Flipping the switch to \"ON\" will prevent Tasmota to enter DeepSleep again after next wake-up until the switch is flipped back OFF. GPIOn should be defined as DeepSleep (182) in the configuration as shown below: The following GPIOs CANNOT be used for the purpose of temporarily disabling deep sleep as described above: - GPIO16 (because it is connected to RST), - GPIO15 (because of an existing on-board pull-down resistor), - GPIO0 (because pulling it down at wake up will enter serial bootload mode). All others GPIO should be acceptable. An interresting use-case is to disable DeepSleep when external power (USB, PSU, solar panel...) is applied to the device using a transistor. If the device is not (easily) accessible, methods can be used to disable the DeepSleep loop without physical access.","title":"using a switch"},{"location":"DeepSleep/#using-mqtt","text":"Send a retained DeepSleepTime 0 command to your device. As the message is retained in the MQTT broker, the device will receive it as soon as it connectes to the MQTT broker. You can use console to send from another Tasmota device: Publish2 cmnd/%topic%/DeepSleepTime 0 Don't forget to remove the retained message from the broker with Publish2 cmnd/%topic%/DeepSleepTime !!! If using mosquitto broker\" mosquitto_pub -t \"cmnd/myDeviceTopic/DeepsleepTime\" -r -m \"0\" Remove retained message mosquitto_pub -t \"cmnd/myDeviceTopic/DeepsleepTime\" -r -n Once you have made your configuration change, you will need to re-enable DeepSleep mode using DeepSleepTime command.","title":"using MQTT"},{"location":"DeepSleep/#using-smart-home-automation","text":"Configure a settable flag in your home automation hub (e.g., Node-Red, openHAB, Home Assistant). The flag should subscribe to the tele/%topic%/LWT topic for the payload Online . Alternatively, if testing the payload value is not easy, subscribe to the topic tele/%topic%/STATE which is the 2nd topic on which hte device publish right after waking-up. The moment a message is received on this topic, the automation can publish a message to topic cmnd/%topic%/DeepSleepTime with payload 0 . This will cause the device to disable deep sleep and allow maintenance such as firmware updates to be performed without having an unexpected deep sleep event. Send the DeepSleepTime 0 command only once . Once device maintenance is completed, place it back into deep sleep mode using original configuration. If you're having issues after wakeup from sleep Make sure bootloop detection is off SetOption36 0 . See issue #6890","title":"using smart home automation"},{"location":"DeepSleep/#executing-commands-before-entering-deepsleep","text":"If you want to execute some commands or a special script BEFORE device goes into deep sleep, use FUNC_SAVE_BEFORE_RESTART as a predefined hook to implement your own procedure. This requires you to code your own function and self-compile custom firmware. To use rules, use the System#Save trigger. This will be executed just before the device goes into deep sleep.","title":"Executing commands before entering DeepSleep"},{"location":"DeepSleep/#overcome-network-issues","text":"If all requirements (Wifi, NTP time synchronization, MQTT broker connection and TelePeriod) are not met, the device will stay awake while trying to attain the remaining requirements. On battery powered devices this behavior is undesirable because it will quickly deplete the battery. To avoid this when these requirements cannot be met, put the device back into deep sleep for an hour. Do this through a rule that will be triggered 30 seconds after reboot and sends the device into deepsleep for an hour. Rule1 ON Dimmer#Boot DO RuleTimer1 30 ENDON ON Rules#Timer=1 DO DeepSleepTime 3600 ENDON Rule1 ON","title":"Overcome network issues"},{"location":"DeepSleep/#deep-sleep-algorithm-general-timing","text":"Let's assume you have set DeepSleepTime 3600 (one hour) and TelePeriod 300 (five minutes). The device will first wake at 8:00 am. The device will boot and connect Wi-Fi. Next, the correct time must be sync'ed from one of the NTP servers. Now the device has all prerequisites for going into deep sleep. Deep sleep is then triggered at the TelePeriod event. In this example, it will occur after five minutes. Telemetry will be collected and sent (e.g., via MQTT). Now, deep sleep can happen. First, Offline is published to the LWT topic on MQTT. It then calculates the new sleeping time to wake-up at 9:00 am (3600 seconds after the last wake-up). At 9:00 am this same sequence of events happens again. If you want to minimize the time that the device is in operation, decrease TelePeriod down to 10 seconds. This period of time is counted after MQTT is connected. Also, in this case, the device will wake up at 9:00 am even if the uptime was much smaller. If the device missed a wake-up it will try a start at the next event - in this case 10:00 am.","title":"Deep Sleep Algorithm General Timing"},{"location":"DeepSleep/#esp8266-deep-sleep-side-effects","text":"Not all GPIO behave the same during deep sleep. Some GPIO go HIGH, some LOW, some FOLLOW the relay but work only on FET transistors. As soon as current flows they go LOW. I use one GPIO to trigger a BC337 transistor to switch OFF all connected devices during deep sleep. Findings: Pin GPIO Behavior D0 16 Excluded due to use as wake-up pin D1 5 KEEP STATE, go LOW if resistance to ground < infinite D2 4 KEEP STATE, go LOW if resistance to ground < infinite D3 0 HIGH D4 2 HIGH D5 14 HIGH, go LOW if resistance to ground < infinite D6 12 HIGH, go LOW if resistance to ground < infinite D7 13 HIGH, go LOW if resistance to ground < infinite D8 15 LOW","title":"ESP8266 Deep Sleep Side-effects"},{"location":"DeepSleep/#log-output-explanation","text":"(logging level 4 ) When MQTT connects at 13:08:38 , this sets the system to READY. 13 : 08 : 43 MQT : tele /tasmota/ INFO3 = { \"RestartReason\" : \"Deep-Sleep Wake\" } 13 : 08 : 44 APP : Boot Count 3 13 : 08 : 44 CFG : Saved to flash at F4 , Count 96 , Bytes 3824 In the context of DeepSleep, maintaining a device boot count is not relevant. When deep sleep is enabled, boot count will not be incremented. This avoids excessive flash writes which will deteriorate the flash memory chip and eventually cause the device to fail. Boot count incrementing can be enabled using SetOption76 . In this example, TelePeriod is 10. Therefore when it is reached, telemetry reporting occurs. 13 : 08 : 48 MQT : tele /tasmota/ STATE = { \"Time\" : \"2019-09-04T13:08:48\" , \"Epoch\" : 1567595328 , \"Uptime\" : \"0T00:00:14\" , \"UptimeSec\" : 14 , \"Heap\" : 24 , \"SleepMode\" : \"Dynamic\" , \"Sleep\" : 50 , \"LoadAvg\" : 20 , \"MqttCount\" : 1 , \"Wifi\" :{ \"AP\" : 1 , \"SSId\" : \"MyWLAN\" , \"BSSId\" : \"AA:FF:AA:AA:AA:AA\" , \"Channel\" : 11 , \"RSSI\" : 100 , \"LinkCount\" : 1 , \"Downtime\" : \"0T00:00:08\" , \"DeepSleep\" : 300 , \"Heap\" : 25160 }} 13 : 08 : 48 MQT : tele /tasmota/ SENSOR = { \"Time\" : \"2019-09-04T13:08:48\" , \"Epoch\" : 1567595328 , \"ANALOG\" :{ \"A0\" : 8 }} Date and time is set, status and telemetry sent. Now start shutdown procedure. First, send MQTT offline. 13:08:48 MQT: state/sonoff/LWT = Offline Deep sleep is 300 seconds. Therefore +-30 sec is allowed as deviation between proposed wake-up time and real wake-up time. Reporting in 0.1sec. In this case wake-up was one second late. 13:08:48 Timeslip 0.1 sec:? -300 < -10 < 300 If the error is in the range, this is tagged as a normal wake up where drift can be recalculated 13:08:48 Normal deepsleep? 1 Recalculate a new drift that is a multiplier for the next wake-up in 1/10000. In this case, the multiplier is 1.0257 13:08:48 % RTC new drift 10257 And for information: New target wake-up time 13:08:48 Next wakeup 2019-09-04T13:10:00 Based on run time and the error in the last loop, a new sleeping time will be calculated. This will be multiplied by the deepsleep_slip and, ideally, the device will wake up at the time above. 13:08:48 Sleeptime 285 sec, deepsleep_slip 10257 The effectiveness of the compensation can be seen here. Instead of typically 160-200 seconds, most times it is better than 10 seconds in a one hour deep sleep cycle.","title":"Log Output Explanation"},{"location":"Device-Groups/","text":"Device Groups ~ Allow devices to share values and control entire groups of devices A framework to allow multiple devices to be in a group with values such as power, light color, color temperature, brightness, PWM values, sensor values and more, all shared with other devices in the group. For example, with multiple lights in a device group, light settings can be changed on one light and the settings will automatically be changed on other lights. Dimmer switches could be in a device group with lights and that dimmer switch could control the power, brightness and colors of all the lights in the group. Multiple dimmer switches could be in a device group to form a 3-way/4-way dimmer switch. UDP multicasts, followed by UDP unicasts if necessary, are used to send updates to all devices so updates are fast. There is no need for an MQTT server but all the devices in a group must be on the same multicast network. The multicast address and port are specified at compile time with the DEVICE_GROUPS_ADDRESS (default = 239.255.250.250) and DEVICE_GROUPS_PORT (default = 4447) macros respectively. To enable device groups, execute command: SetOption85 1 . All devices in a group must be running firmware with device group support and have device groups enabled. Operation ~ The device group name is set with the DevGroupName command ( GroupTopic prior to v8.2.0.3). If a device group name is not set for a group, the MQTT group topic is used (with the device group number appended for device group numbers > 1). All devices in the same multicast network with the same device group name are in the same group. Some modules may define additional device groups. For example, if Remote Device Mode is enabled, the PWM Dimmer module defines three devices groups. The items sent and received from the group are selected with the DevGroupShare command. By default all items are sent and received. An example of when the DevGroupShare command would be used is when you have a group of lights that you control with a dimmer switch and home automation software. You want the dimmer switch to be able to control all items. The home automation software controls each light individually. When it controls the whole group, it actually sends command to each light in the group. If you use the home automation software to turn an individual light on or off or change it's brightness, color or scheme, you do not want the change to be replicated to the other lights. In this case, you would set the incoming and outgoing item masks to 0xffffffff (all items) on the dimmer switch ( DevGroupShare 0xffffffff,0xffffffff ) and set the incoming item mask to 0xffffffff and outgoing item mask to 0 on all the lights ( DevGroupShare 0xffffffff,0 ). By default, the state of all relays is sent to and received from device group 1. To enable each relay to be in a separate device group, enable option 88 ( SetOption88 1 ). Relay 1 updates will be sent to/received from device group 1, relay 2 updates will be sent to/received from device group 2, etc. Troubleshooting ~ If no values seem to be shared between devices, perform the following checks: Enter the command SetOption85 on all devices in the group and make sure the result is ON on all devices. Enter the command DevGroupName on all devices in the group and make sure the result for device group 1 is the exact same (case-sensitive) name on all devices. Enter the command DevGroupShare -1,-1 on all devices in the group to enable sharing of all items. Enter the command DevGroupSend 128=1 on one device in the group. If the power turns on on the other devices, the device groups feature is working. Enter the command DevGroupStatus on all devices in the group. If you do not see all the other devices in the group listed as members, multicast packets are not being received by the devices. Check the network infrastructure that connects the devices together to make sure multicasts are enabled are not being filtered. Commands ~ Command Parameters DevGroupName<x> 0 = clear device group <x> name and restart <value> = set device group <x> name and restart. Prior to 8.2.0.3, GroupTopic was used to specify the device group name. DevGroupSend<x> <item> = <value>[ ...] = send an update to device group <x>. The device group name must have been previously set with DevGroupName<x>. Multiple item/value pairs can be specified separated by a space. Spaces in <value> must be escaped with a backslash (\\). The message sent is also processed on the local device as if it had been received from the network. For items with numeric values, <value> can be specified as @<operator>[<operand>] to send a value after performing an operation on the current value. <operator> can be + (add), - (subtract) or ^ (invert). If <operand> is not specified, it defaults to 0xffffffff for the invert operator and 1 for other operators. Examples: DevGroupSend 4=90 128=1 - send an update to set the light brightness to 90 and turn relay 1 on. DevGroupSend 193=Buzzer\\ 2,3 - send the Buzzer 2,3 command. DevGroupSend 6=@+ 4=@-10 - set the next fixed color and decrease the brightness by 10. DevGroupSend 128=^ - toggle all the relays. 2 = Light fade (0 = Off, 1 = On) 3 = Light speed (1..40) 4 = Light brightness (0..255) 5 = Light Scheme 6 = Light fixed color (0 = white (using CT channels), other values according to Color ) 7 = PWM dimmer low preset (0..255) 8 = PWM dimmer high preset (0..255) 9 = PWM dimmer power-on brightness (0..255) 128 = Relay Power - bitmask with bits set for relays to be powered on. The number of relays can be specified in bits 24 - 31. If the number of relays is not specified, only relay 1 is set 192 = Event - event name and arguments 193 = Command - command and arguments 224 = Light channels - comma separated list of brightness levels (0..255) for channels 1 - 5 (e.g. 255,128,0,0,0 will turn the red channel on at 100% and the green channel on at 50% on an RBG light) DevGroupShare <in>,<out> = set incoming and outgoing shared items (default = 0xffffffff,0xffffffff ) <in> and <out> are bit masks where each mask is the sum of the values for the categories (listed below) to be shared. For example, to receive only power (1), light brightness (2) and light color (16) and send only power (1), enter the command DevGroupShare 19,1. 1 = Power 2 = Light brightness 4 = Light fade/speed 8 = Light scheme 16 = Light color 32 = Dimmer settings (presets) 64 = Event DevGroupStatus<x> Show the status of device group <x> including a list of the currently known members.","title":"Device Groups"},{"location":"Device-Groups/#device-groups","text":"Allow devices to share values and control entire groups of devices A framework to allow multiple devices to be in a group with values such as power, light color, color temperature, brightness, PWM values, sensor values and more, all shared with other devices in the group. For example, with multiple lights in a device group, light settings can be changed on one light and the settings will automatically be changed on other lights. Dimmer switches could be in a device group with lights and that dimmer switch could control the power, brightness and colors of all the lights in the group. Multiple dimmer switches could be in a device group to form a 3-way/4-way dimmer switch. UDP multicasts, followed by UDP unicasts if necessary, are used to send updates to all devices so updates are fast. There is no need for an MQTT server but all the devices in a group must be on the same multicast network. The multicast address and port are specified at compile time with the DEVICE_GROUPS_ADDRESS (default = 239.255.250.250) and DEVICE_GROUPS_PORT (default = 4447) macros respectively. To enable device groups, execute command: SetOption85 1 . All devices in a group must be running firmware with device group support and have device groups enabled.","title":"Device Groups"},{"location":"Device-Groups/#operation","text":"The device group name is set with the DevGroupName command ( GroupTopic prior to v8.2.0.3). If a device group name is not set for a group, the MQTT group topic is used (with the device group number appended for device group numbers > 1). All devices in the same multicast network with the same device group name are in the same group. Some modules may define additional device groups. For example, if Remote Device Mode is enabled, the PWM Dimmer module defines three devices groups. The items sent and received from the group are selected with the DevGroupShare command. By default all items are sent and received. An example of when the DevGroupShare command would be used is when you have a group of lights that you control with a dimmer switch and home automation software. You want the dimmer switch to be able to control all items. The home automation software controls each light individually. When it controls the whole group, it actually sends command to each light in the group. If you use the home automation software to turn an individual light on or off or change it's brightness, color or scheme, you do not want the change to be replicated to the other lights. In this case, you would set the incoming and outgoing item masks to 0xffffffff (all items) on the dimmer switch ( DevGroupShare 0xffffffff,0xffffffff ) and set the incoming item mask to 0xffffffff and outgoing item mask to 0 on all the lights ( DevGroupShare 0xffffffff,0 ). By default, the state of all relays is sent to and received from device group 1. To enable each relay to be in a separate device group, enable option 88 ( SetOption88 1 ). Relay 1 updates will be sent to/received from device group 1, relay 2 updates will be sent to/received from device group 2, etc.","title":"Operation"},{"location":"Device-Groups/#troubleshooting","text":"If no values seem to be shared between devices, perform the following checks: Enter the command SetOption85 on all devices in the group and make sure the result is ON on all devices. Enter the command DevGroupName on all devices in the group and make sure the result for device group 1 is the exact same (case-sensitive) name on all devices. Enter the command DevGroupShare -1,-1 on all devices in the group to enable sharing of all items. Enter the command DevGroupSend 128=1 on one device in the group. If the power turns on on the other devices, the device groups feature is working. Enter the command DevGroupStatus on all devices in the group. If you do not see all the other devices in the group listed as members, multicast packets are not being received by the devices. Check the network infrastructure that connects the devices together to make sure multicasts are enabled are not being filtered.","title":"Troubleshooting"},{"location":"Device-Groups/#commands","text":"Command Parameters DevGroupName<x> 0 = clear device group <x> name and restart <value> = set device group <x> name and restart. Prior to 8.2.0.3, GroupTopic was used to specify the device group name. DevGroupSend<x> <item> = <value>[ ...] = send an update to device group <x>. The device group name must have been previously set with DevGroupName<x>. Multiple item/value pairs can be specified separated by a space. Spaces in <value> must be escaped with a backslash (\\). The message sent is also processed on the local device as if it had been received from the network. For items with numeric values, <value> can be specified as @<operator>[<operand>] to send a value after performing an operation on the current value. <operator> can be + (add), - (subtract) or ^ (invert). If <operand> is not specified, it defaults to 0xffffffff for the invert operator and 1 for other operators. Examples: DevGroupSend 4=90 128=1 - send an update to set the light brightness to 90 and turn relay 1 on. DevGroupSend 193=Buzzer\\ 2,3 - send the Buzzer 2,3 command. DevGroupSend 6=@+ 4=@-10 - set the next fixed color and decrease the brightness by 10. DevGroupSend 128=^ - toggle all the relays. 2 = Light fade (0 = Off, 1 = On) 3 = Light speed (1..40) 4 = Light brightness (0..255) 5 = Light Scheme 6 = Light fixed color (0 = white (using CT channels), other values according to Color ) 7 = PWM dimmer low preset (0..255) 8 = PWM dimmer high preset (0..255) 9 = PWM dimmer power-on brightness (0..255) 128 = Relay Power - bitmask with bits set for relays to be powered on. The number of relays can be specified in bits 24 - 31. If the number of relays is not specified, only relay 1 is set 192 = Event - event name and arguments 193 = Command - command and arguments 224 = Light channels - comma separated list of brightness levels (0..255) for channels 1 - 5 (e.g. 255,128,0,0,0 will turn the red channel on at 100% and the green channel on at 50% on an RBG light) DevGroupShare <in>,<out> = set incoming and outgoing shared items (default = 0xffffffff,0xffffffff ) <in> and <out> are bit masks where each mask is the sum of the values for the categories (listed below) to be shared. For example, to receive only power (1), light brightness (2) and light color (16) and send only power (1), enter the command DevGroupShare 19,1. 1 = Power 2 = Light brightness 4 = Light fade/speed 8 = Light scheme 16 = Light color 32 = Dimmer settings (presets) 64 = Event DevGroupStatus<x> Show the status of device group <x> including a list of the currently known members.","title":"Commands"},{"location":"Device-Recovery/","text":"Device Recovery ~ Configuration problems can cause boot loops, erratic behavior, devices which will not appear (i.e., no tasmota-xxxx AP) or connect to Wi-Fi, etc. In cases such as these when there is no proper operation a recovery process is required. By default, the firmware tries to preserve the existing configuration (to support automated updates via OTA upgrades). However, various things can happen that cause the existing configuration to become problematic, e.g., when upgrading from old releases without following the migration path . When code updates change the values or the way settings are used, those code changes don't directly write the settings on the running device when you load the new firmware. What happens is that when it boots up, the firmware looks to see if it has a valid configuration (if its an upgrade from an older Tasmota version) and if the CFG_HOLDER value is in the right place it assumes that the existing configuration is valid. If it doesn't find the right value it assumes that this is not a \"simple\" upgrade and takes the compiled-in configuration settings and writes them out to the configuration area. Recovery Techniques ~ Listed below are a few ways to reset the device to what is set in the firmware binary ( my_user_config.h and user_config_override.h ) aka firmware defaults, in order to recover a device: Hold the button ( Button1 ) down, if available, for 40 seconds. After that the device should reset and reboot. Fully cycle power after that is done to make sure everything is starting from scratch. Issue Reset 1 command via the console, MQTT or HTTP. After the device reboots fully cycle power. use Fast Power Cycle Device Recovery procedure Fast Power Cycle Device Recovery ~ Implemented for situations where a device cannot be reset to firmware defaults by other means (no serial access, no button). It resets ALL Tasmota settings (equal to Reset 1 ) after 7 power cycles. SetOption65 must be set to 0 (default) in order for this feature to be enabled. Warning If you have a weak power grid or frequent power brownouts its best to disable this feature with SetOption65 1 immediately or you'll end up with firmware default devices after a brownout event. Procedure Cut power from the device completely for 30 seconds Power the device on and off six times with intervals lower than 10 seconds and leave it on after seventh time Fast power cycle device recovery should activate and the device should be reset to firmware defaults If you flashed a precompiled binary you can reconfigure the device using the web UI after the reset. After Recovery ~ Once recovered, the device should be observed that it operates without instabilities before attempting to configure the device in any way. If the device still does not, follow these steps if you are able to configure its Wi-Fi and connect: Configure the device as Generic (18) Perform an OTA upgrade specifically to tasmota-minimal.bin . Taking this intermediate step ensures that the firmware will be reloaded. Since Tasmota performs a version comparison before performing the OTA update, explicitly changing the firmware that is on the device will ensure that the firmware is indeed replaced in the next step. Perform an OTA upgrade to the desired firmware variant. Once the device operates reliably, begin the configuration to set the GPIO configuration (via a Template or Module). Take any further configuration steps one at a time to ensure that after each setting is applied, the device continues to operate reliably. If the device exhibits defective behavior immediately after a particular individual setting is changed, then be aware that there may be a problem in the firmware. Please report this behavior via the Tasmota Discord Chat . That Didn't Work, What Now? ~ If none of these methods result in a working and reliable device, the only remaining option is to connect the device to the serial programming interface, erase the flash memory and flash a different precompiled firmware binary.","title":"Device Recovery"},{"location":"Device-Recovery/#device-recovery","text":"Configuration problems can cause boot loops, erratic behavior, devices which will not appear (i.e., no tasmota-xxxx AP) or connect to Wi-Fi, etc. In cases such as these when there is no proper operation a recovery process is required. By default, the firmware tries to preserve the existing configuration (to support automated updates via OTA upgrades). However, various things can happen that cause the existing configuration to become problematic, e.g., when upgrading from old releases without following the migration path . When code updates change the values or the way settings are used, those code changes don't directly write the settings on the running device when you load the new firmware. What happens is that when it boots up, the firmware looks to see if it has a valid configuration (if its an upgrade from an older Tasmota version) and if the CFG_HOLDER value is in the right place it assumes that the existing configuration is valid. If it doesn't find the right value it assumes that this is not a \"simple\" upgrade and takes the compiled-in configuration settings and writes them out to the configuration area.","title":"Device Recovery"},{"location":"Device-Recovery/#recovery-techniques","text":"Listed below are a few ways to reset the device to what is set in the firmware binary ( my_user_config.h and user_config_override.h ) aka firmware defaults, in order to recover a device: Hold the button ( Button1 ) down, if available, for 40 seconds. After that the device should reset and reboot. Fully cycle power after that is done to make sure everything is starting from scratch. Issue Reset 1 command via the console, MQTT or HTTP. After the device reboots fully cycle power. use Fast Power Cycle Device Recovery procedure","title":"Recovery Techniques"},{"location":"Device-Recovery/#fast-power-cycle-device-recovery","text":"Implemented for situations where a device cannot be reset to firmware defaults by other means (no serial access, no button). It resets ALL Tasmota settings (equal to Reset 1 ) after 7 power cycles. SetOption65 must be set to 0 (default) in order for this feature to be enabled. Warning If you have a weak power grid or frequent power brownouts its best to disable this feature with SetOption65 1 immediately or you'll end up with firmware default devices after a brownout event.","title":"Fast Power Cycle Device Recovery"},{"location":"Device-Recovery/#after-recovery","text":"Once recovered, the device should be observed that it operates without instabilities before attempting to configure the device in any way. If the device still does not, follow these steps if you are able to configure its Wi-Fi and connect: Configure the device as Generic (18) Perform an OTA upgrade specifically to tasmota-minimal.bin . Taking this intermediate step ensures that the firmware will be reloaded. Since Tasmota performs a version comparison before performing the OTA update, explicitly changing the firmware that is on the device will ensure that the firmware is indeed replaced in the next step. Perform an OTA upgrade to the desired firmware variant. Once the device operates reliably, begin the configuration to set the GPIO configuration (via a Template or Module). Take any further configuration steps one at a time to ensure that after each setting is applied, the device continues to operate reliably. If the device exhibits defective behavior immediately after a particular individual setting is changed, then be aware that there may be a problem in the firmware. Please report this behavior via the Tasmota Discord Chat .","title":"After Recovery"},{"location":"Device-Recovery/#that-didnt-work-what-now","text":"If none of these methods result in a working and reliable device, the only remaining option is to connect the device to the serial programming interface, erase the flash memory and flash a different precompiled firmware binary.","title":"That Didn't Work, What Now?"},{"location":"Displays/","text":"This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #define directive Description USE_DISPLAY Enable display support. Also requires at least one of the following compilation directives USE_DISPLAY_LCD Enable LCD display. Also requires USE_I2C USE_DISPLAY_SSD1306 Enable OLED SSD1306 display. Also requires USE_I2C USE_DISPLAY_MATRIX Enable MATRIX display USE_DISPLAY_ILI9341 Enable TFT display. Also requires USE_SPI USE_DISPLAY_EPAPER_29 Enable EPAPER_29 display. Also requires USE_SPI USE_DISPLAY_EPAPER_42 Enable EPAPER_42 display. Also requires USE_SPI USE_DISPLAY_SH1106 Enable OLED SH1106 display. Also requires USE_I2C USE_DISPLAY_ILI9488 Enable TFT ILI9488 display. Also requires USE_SPI USE_DISPLAY_SSD1351 Enable color OLED SSD1351 display. Also requires USE_SPI USE_DISPLAY_RA8876 Enable TFT RA8876 display. Also requires USE_SPI USE_DISPLAY_SEVENSEG Enable 7 segment display. Also requires USE_I2C USE_DISPLAY_ST7789 Enable TFT ST7789 display. Also requires USE_SPI USE_DISPLAY_SEVENSEG_COMMON_ANODE Common anode 7 segment displays. Also requires USE_I2C USE_TOUCH_BUTTONS Enable virtual touch button support with touch displays SHOW_SPLASH Enable initialization splash message on the display USE_AWATCH Enables analog watch support USE_GRAPH Enable line charts. Also requires NUM_GRAPHS ---- Display Commands ~ See commands page for full list of available Display Commands DisplayMode Parameters ~ The display driver is able to display predefined setups of text or user defined text. To display text using DisplayText set DisplayMode to 0 , or set DisplayMode to 1 for the HT16K33 dot-matrix display. Parameter LCD Display OLED Display TFT Display 0 DisplayText DisplayText DisplayText 1 Time/Date Time/Date Time/Date 2 Local sensors Local sensors Local sensors 3 MQTT and Time/Date Local sensors and Time/Date Local sensors and Time/Date 4 Local sensors MQTT and local sensors MQTT and local sensors 5 MQTT and Time/Date MQTT, local sensors and Time/Date MQTT, local sensors and Time/Date DisplayText Use ~ The DisplayText command is used to display text as well as graphics and graphs on LCD, OLED and e-Paper displays (EPD). The command argument is a string that is printed on the display at the current position. The string can be prefixed by embedded control commands enclosed in brackets [] . In order to use the DisplayText command the DisplayMode must be set to 0 (or optional 1 on LCD displays) or other modes must be disabled before compilation with #undef USE_DISPLAY_MODES1TO5 . DisplayText parameters ~ In the list below p stands for parameter and may be a number from 1 to n digits. On monochrome graphic displays things are drawn into a local frame buffer and sent to the display either via the d command or automatically at the end of the command. Positioning ~ lp = sets a character line to print at (on LCD display p = {0\u2026}, on TFT display p = {1\u2026}) cp = sets a character column to print at (on LCD display p = {0\u2026}, on TFT display p = {1\u2026}) xp = sets the x position for consecutive prints yp = sets the y position for consecutive prints Text is printed at the last provided position, either l or y for the vertical position, and either x or x for the horizontal position. Neither x nor y are advanced/updated after printing text. Line primitives ~ hp = draws a horizontal line with length p (x is advanced) vp = draws a vertical line with length p (y is advanced) Lp:p = draws a line top: p (x,y are advanced) kp = draws a circle with radius p Kp = draws a filled circle with radius p rp:p = draws a rectangle with p with and p height Rp:p = draws a filled rectangle with p with and p height up:p:p = draws a rounded rectangle with p with, p height and p radius ( not for ILI9341 ) Up:p:p = draws a filled rounded rectangle with p with, p height and p radius ( not for ILI9341 ) Miscellaneous ~ z = clear the display i = (re)init the display (in e-Paper mode with partial update) I = (re)init the display (in e-Paper mode with full update) d = update the display Dp = switch display auto updates on( p =1)/off( p =0), when off display must be updated with d o = switch display off O = switch display on ap = p (0..3) set rotation angle t = display Tasmota time in HH:MM tS = display Tasmota time in HH:MM:SS T = display Tasmota date in DD.MM.YY pp = pad text with spaces, positive values align left, negative values align right sp = set text scaling for classic GFX font (scaling factor 1...N) fp = set font (1=12, 2=24,(opt 3=8)) if font==0 the classic GFX font is used, if font==7 RA8876 internal font is used Cp = set foreground color (0,1) for black or white and RGB decimal code for color (see color codes ) Bp = set background color (0,1) for black or white and RGB decimal code for color (see color codes ) Cip = set foreground index color (0..18) for color displays (see index color table below) Bip = set background index color (0..18) for color displays (see index color table below) wp = draws an analog watch with radius p (#define USE_AWATCH) Pfilename: = display an rgb 16-bit color image when SD card file system is present Touch Buttons ~ ( #define USE_TOUCH_BUTTONS ) Draw up to 16 GFX buttons to switch real Tasmota devices such as relays. Button number + 256 - a virtual touch toggle button is created (MQTT => TBT) Button number + 512 - a virtual touch push button is created (MQTT => PBT) b#:xp:yp:xa:ys:oc:fc:tc:ts:text: Parameters are separated by colons. b# where # = button number 0-15 xp = x position yp = y position xa = x size ys = y size oc = outline index color fc = fill index color tc = text index color ts = text size text: = button text (must end with a colon :) (max 9 chars) b0:260:260:100:50:2:11:4:2:Rel 1: Line chart ~ ( #define USE_GRAPH and #define NUM_GRAPHS 4 - maximum of 16) Up to 4 line charts may be defined. Ticks may be defined by adding tick numbers to the n parameter. Example n = graph number (0..3) + x ticks (16*number of x ticks) + y ticks (1024*number of y ticks). Gn:xp:yp:xs:ys:t:fmax:fmin defines a line chart: Parameters are separated by colons. n = number up to 4 charts (0..3) + optional ticks xp = x position yp = y position xs = x size (if xs<0) graph is not reinitialized on second call (e.g., restart of scripter) ys = y size t = time in minutes for total chart ymin = float chart minimum y ymax = float chart maximum y icol = line color index (only for color graphs) gn:v adds a value to the chart buffer: n = number up to 4 charts (0..3) v = float value to add Gdn:m sets graph n draw mode 0 = off, 1 = on. When on, redraw graph Gsn:path: = save graph n to path (if optional SD card is present) Grn:path: = restore graph n from path (if optional SD card is present) Color Codes ~ While computers and web design are generally using a 24-bit RGB888 color code built from a byte-triplet such as (255, 136, 56) or #FF8038, small color panels often use a more compact code 16-bit RGB565 color code. This means that the R, G and B coefficient are coded on less number of bits: Red on 5 bits = 0..31 Green on 6 bits = 0..63 Blue on 5 bits = 0..31 For Cp and Bp , p is calculated as p = 2048 * Red + 64 * Green + Blue Example Red 50% + Green 20% + Blue 100% = 2048 * 16 + 64 * 12 + 31 = 33576 equivalent to web #8033FF Common colors table: Color Code Color Code Color Code Black 0 Navy 15 Dark green 3 Dark cyan 1007 Maroon 30720 Purple 30735 Olive 31712 Light grey 50712 Dark grey 31727 Blue 31 Green 7 Cyan 2047 Red 63488 Magenta 63519 Yellow 65504 White 65535 Orange 64800 Green yellow 45029 Pink 64536 Color Indices ~ Selected with Ci and Bi in the ILI9488, SSD1351, RA8876 and ST7789 color panels Index Color Index Color Index Color 0 BLACK 1 WHITE 2 RED 3 GREEN 4 BLUE 5 CYAN 6 MAGENTA 7 YELLOW 8 NAVY 9 DARKGREEN 10 DARKCYAN 11 MAROON 12 PURPLE 13 OLIVE 14 LIGHTGREY 15 DARKGREY 16 ORANGE 17 GREENYELLOW 18 PINK Notes on e-Paper Displays E-Paper displays have 2 operating modes: full update and partial update. While full update delivers a clean and sharp picture, it has the disadvantage of taking several seconds for the screen update and shows severe flickering during update. Partial update is quite fast (300 ms) with no flickering but there is the possibility that erased content is still slightly visible. It is therefore useful to perform a full update in regular intervals (e.g., each hour) to fully refresh the display. Compilation directives: #define USE_SPI , #define USE_DISPLAY , #define USE_DISPLAY_EPAPER29 , or #define USE_DISPLAY_EPAPER42 Remark : the 4.2 e-Paper display requires about 15k of RAM. Therefore it only works with Core 2.42 and above. OLED Lifetime The typical specifications for the lifetime of an OLED when permanently on is about 10000 hours (416 days). Dimming to 50% expands the lifetime to about 25000 hours. Burn-in The data sheets of the TFT and OLED displays mention burn-in effects when a static display is shown for extended periods of time. You may want to consider turning on the display on demand only. Fonts ~ The EPD font contains 95 characters starting from code 32, while the classic GFX font contains 256 characters ranging from 0 to 255. Custom characters above 127 can be displayed. To display these characters, you must specify an escape sequence (standard octal escapes do not work). The ~ character followed by a hex byte can define any character code. GFXFont: EPDFont: Hardware Connections ~ I 2 C displays are connected in the usual manner and defined via the GPIO component selection. The I 2 C address must be specified using DisplayAddress XX , e.g., 60 . The model must be spedified with DisplayModel , e.g., 2 for SSD1306. To permanently turn the display on set DisplayDimmer 100 . Display rotation can be permanently set using DisplayRotate X (x = 0..3 ). E-Paper displays are connected via software 3-wire SPI (CS, SCLK, MOSI) . DC should be connected to GND , Reset to 3.3 V and busy may be left unconnected. The jumper on the circuit board of the display must be set to 3-wire SPI. The ILI9488, ILI9341 and SSD1351 are connected via hardware 3-wire SPI (MOSI=GPIO13, SCLK=GPIO14, CS=GPIO15) . The ILI9488 must also be connected to the backlight pin (dimmer supported on SSD1351). Wiring The RA8876 is connected via standard hardware 4-wire SPI (MOSI=GPIO13, SCLK=GPIO14, CS=GPIO15, MISO=GPIO12) . No backlight pin is needed (dimmer supported). The ST7789 is connected via 4 Wire software SPI ((CS), SCLK, MOSI, DC, (RES), BL ) Examples ~ Print Text at size 1 on line 1, column 1: DisplayText [s1l1c1]Hello how are you? Draw a rectangle and draw text inside with size 2 and 7 chars padded with spaces: DisplayText [x85y95h130v30h-130v-30s2p7x90y100]37.25 C Refresh screen: DisplayText [z] Draw rectangle from x,y with width and height: DisplayText [x50y50r200:100] Display Local Sensors ~ (line breaks and indentation added to the rules for readability) Use Tasmota rules to display sensor values, time, and a separation line. Refresh the display every 60 minutes: rule1 on tele - SHT3X - 0x44 # Temperature do DisplayText [ f1p7x0y5 ] % value % C endon on tele - SHT3X - 0x44 # Humidity do DisplayText [ f1p10x70y5 ] % value % % [ x0y20h296x250y5t ] endon on tele - BMP280 # Pressure do DisplayText [ f1p10x140y5 ] % value % hPa endon on Time # Minute | 60 do DisplayText [ Tt ] endon Show 4 analog channels: rule1 on tele - ADS1115 # A0 do DisplayText [ s1p21c1l01 ] Analog1: % value % adc endon on tele - ADS1115 # A1 do DisplayText [ s1p21c1l3 ] Analog2: % value % adc endon on tele - ADS1115 # A2 do DisplayText [ s1p21c1l5 ] Analog3: % value % adc endon on tele - ADS1115 # A3 do DisplayText [ s1p21c1l7 ] Analog4: % value % adc endon Show BME280 + SGP30: rule1 on tele - BME280 # Temperature do DisplayText [ s1p21x0y0 ] Temp: % value % C endon on tele - BME280 # Humidity do DisplayText [ s1p21x0y10 ] Hum : % value % %% endon on tele - BME280 # Pressure do DisplayText [ s1p21x0y20 ] Prss: % value % hPa endon on tele - SGP30 # TVOC do DisplayText [ s1p21x0y30 ] TVOC: % value % ppb endon on tele - SGP30 # eCO2 do DisplayText [ s1p21x0y40 ] eCO2 : % value % ppm [ s1p0x0y50 ] Time: [ x35y50t ] endon Display Drivers ~ Waveshare has two kinds of display controllers: with partial update and without partial update. The 2.9 inch driver is for partial update and should also support other Waveshare partial update models with modified WIDTH and HEIGHT parameters. The 4.2 inch driver is a hack which makes the full update display behave like a partial update and should probably work with other full update displays. The drivers are subclasses of the Adafruit GFX library. The class hierarchy is LOWLEVEL :: Paint :: Renderer :: GFX , where: GFX : unmodified Adafruit library Renderer : the interface for Tasmota Paint : the modified pixel driver for e-paper - there are several virtual functions that can be subclassed down to LOWLEVEL . The display dispatcher only does the class initialization call. All other calls go to the Renderer class. In black and white displays, a local RAM buffer must be allocated before calling the driver. This must be set to zero on character or TFT color displays. The EPD fonts use about 9k space, which can be selected at compile time using #ifdef directives. SSD1306 - 1.15k EPD42 - 2.57k EPD29 - 2.1k Display and Render class - ~12k","title":"Displays"},{"location":"Displays/#display-commands","text":"See commands page for full list of available Display Commands","title":"Display Commands"},{"location":"Displays/#displaymode-parameters","text":"The display driver is able to display predefined setups of text or user defined text. To display text using DisplayText set DisplayMode to 0 , or set DisplayMode to 1 for the HT16K33 dot-matrix display. Parameter LCD Display OLED Display TFT Display 0 DisplayText DisplayText DisplayText 1 Time/Date Time/Date Time/Date 2 Local sensors Local sensors Local sensors 3 MQTT and Time/Date Local sensors and Time/Date Local sensors and Time/Date 4 Local sensors MQTT and local sensors MQTT and local sensors 5 MQTT and Time/Date MQTT, local sensors and Time/Date MQTT, local sensors and Time/Date","title":"DisplayMode Parameters"},{"location":"Displays/#displaytext-use","text":"The DisplayText command is used to display text as well as graphics and graphs on LCD, OLED and e-Paper displays (EPD). The command argument is a string that is printed on the display at the current position. The string can be prefixed by embedded control commands enclosed in brackets [] . In order to use the DisplayText command the DisplayMode must be set to 0 (or optional 1 on LCD displays) or other modes must be disabled before compilation with #undef USE_DISPLAY_MODES1TO5 .","title":"DisplayText Use"},{"location":"Displays/#displaytext-parameters","text":"In the list below p stands for parameter and may be a number from 1 to n digits. On monochrome graphic displays things are drawn into a local frame buffer and sent to the display either via the d command or automatically at the end of the command.","title":"DisplayText parameters"},{"location":"Displays/#positioning","text":"lp = sets a character line to print at (on LCD display p = {0\u2026}, on TFT display p = {1\u2026}) cp = sets a character column to print at (on LCD display p = {0\u2026}, on TFT display p = {1\u2026}) xp = sets the x position for consecutive prints yp = sets the y position for consecutive prints Text is printed at the last provided position, either l or y for the vertical position, and either x or x for the horizontal position. Neither x nor y are advanced/updated after printing text.","title":"Positioning"},{"location":"Displays/#line-primitives","text":"hp = draws a horizontal line with length p (x is advanced) vp = draws a vertical line with length p (y is advanced) Lp:p = draws a line top: p (x,y are advanced) kp = draws a circle with radius p Kp = draws a filled circle with radius p rp:p = draws a rectangle with p with and p height Rp:p = draws a filled rectangle with p with and p height up:p:p = draws a rounded rectangle with p with, p height and p radius ( not for ILI9341 ) Up:p:p = draws a filled rounded rectangle with p with, p height and p radius ( not for ILI9341 )","title":"Line primitives"},{"location":"Displays/#miscellaneous","text":"z = clear the display i = (re)init the display (in e-Paper mode with partial update) I = (re)init the display (in e-Paper mode with full update) d = update the display Dp = switch display auto updates on( p =1)/off( p =0), when off display must be updated with d o = switch display off O = switch display on ap = p (0..3) set rotation angle t = display Tasmota time in HH:MM tS = display Tasmota time in HH:MM:SS T = display Tasmota date in DD.MM.YY pp = pad text with spaces, positive values align left, negative values align right sp = set text scaling for classic GFX font (scaling factor 1...N) fp = set font (1=12, 2=24,(opt 3=8)) if font==0 the classic GFX font is used, if font==7 RA8876 internal font is used Cp = set foreground color (0,1) for black or white and RGB decimal code for color (see color codes ) Bp = set background color (0,1) for black or white and RGB decimal code for color (see color codes ) Cip = set foreground index color (0..18) for color displays (see index color table below) Bip = set background index color (0..18) for color displays (see index color table below) wp = draws an analog watch with radius p (#define USE_AWATCH) Pfilename: = display an rgb 16-bit color image when SD card file system is present","title":"Miscellaneous"},{"location":"Displays/#touch-buttons","text":"( #define USE_TOUCH_BUTTONS ) Draw up to 16 GFX buttons to switch real Tasmota devices such as relays. Button number + 256 - a virtual touch toggle button is created (MQTT => TBT) Button number + 512 - a virtual touch push button is created (MQTT => PBT) b#:xp:yp:xa:ys:oc:fc:tc:ts:text: Parameters are separated by colons. b# where # = button number 0-15 xp = x position yp = y position xa = x size ys = y size oc = outline index color fc = fill index color tc = text index color ts = text size text: = button text (must end with a colon :) (max 9 chars) b0:260:260:100:50:2:11:4:2:Rel 1:","title":"Touch Buttons"},{"location":"Displays/#line-chart","text":"( #define USE_GRAPH and #define NUM_GRAPHS 4 - maximum of 16) Up to 4 line charts may be defined. Ticks may be defined by adding tick numbers to the n parameter. Example n = graph number (0..3) + x ticks (16*number of x ticks) + y ticks (1024*number of y ticks). Gn:xp:yp:xs:ys:t:fmax:fmin defines a line chart: Parameters are separated by colons. n = number up to 4 charts (0..3) + optional ticks xp = x position yp = y position xs = x size (if xs<0) graph is not reinitialized on second call (e.g., restart of scripter) ys = y size t = time in minutes for total chart ymin = float chart minimum y ymax = float chart maximum y icol = line color index (only for color graphs) gn:v adds a value to the chart buffer: n = number up to 4 charts (0..3) v = float value to add Gdn:m sets graph n draw mode 0 = off, 1 = on. When on, redraw graph Gsn:path: = save graph n to path (if optional SD card is present) Grn:path: = restore graph n from path (if optional SD card is present)","title":"Line chart"},{"location":"Displays/#color-codes","text":"While computers and web design are generally using a 24-bit RGB888 color code built from a byte-triplet such as (255, 136, 56) or #FF8038, small color panels often use a more compact code 16-bit RGB565 color code. This means that the R, G and B coefficient are coded on less number of bits: Red on 5 bits = 0..31 Green on 6 bits = 0..63 Blue on 5 bits = 0..31 For Cp and Bp , p is calculated as p = 2048 * Red + 64 * Green + Blue Example Red 50% + Green 20% + Blue 100% = 2048 * 16 + 64 * 12 + 31 = 33576 equivalent to web #8033FF Common colors table: Color Code Color Code Color Code Black 0 Navy 15 Dark green 3 Dark cyan 1007 Maroon 30720 Purple 30735 Olive 31712 Light grey 50712 Dark grey 31727 Blue 31 Green 7 Cyan 2047 Red 63488 Magenta 63519 Yellow 65504 White 65535 Orange 64800 Green yellow 45029 Pink 64536","title":"Color Codes"},{"location":"Displays/#color-indices","text":"Selected with Ci and Bi in the ILI9488, SSD1351, RA8876 and ST7789 color panels Index Color Index Color Index Color 0 BLACK 1 WHITE 2 RED 3 GREEN 4 BLUE 5 CYAN 6 MAGENTA 7 YELLOW 8 NAVY 9 DARKGREEN 10 DARKCYAN 11 MAROON 12 PURPLE 13 OLIVE 14 LIGHTGREY 15 DARKGREY 16 ORANGE 17 GREENYELLOW 18 PINK","title":"Color Indices"},{"location":"Displays/#fonts","text":"The EPD font contains 95 characters starting from code 32, while the classic GFX font contains 256 characters ranging from 0 to 255. Custom characters above 127 can be displayed. To display these characters, you must specify an escape sequence (standard octal escapes do not work). The ~ character followed by a hex byte can define any character code. GFXFont: EPDFont:","title":"Fonts"},{"location":"Displays/#hardware-connections","text":"I 2 C displays are connected in the usual manner and defined via the GPIO component selection. The I 2 C address must be specified using DisplayAddress XX , e.g., 60 . The model must be spedified with DisplayModel , e.g., 2 for SSD1306. To permanently turn the display on set DisplayDimmer 100 . Display rotation can be permanently set using DisplayRotate X (x = 0..3 ). E-Paper displays are connected via software 3-wire SPI (CS, SCLK, MOSI) . DC should be connected to GND , Reset to 3.3 V and busy may be left unconnected. The jumper on the circuit board of the display must be set to 3-wire SPI. The ILI9488, ILI9341 and SSD1351 are connected via hardware 3-wire SPI (MOSI=GPIO13, SCLK=GPIO14, CS=GPIO15) . The ILI9488 must also be connected to the backlight pin (dimmer supported on SSD1351). Wiring The RA8876 is connected via standard hardware 4-wire SPI (MOSI=GPIO13, SCLK=GPIO14, CS=GPIO15, MISO=GPIO12) . No backlight pin is needed (dimmer supported). The ST7789 is connected via 4 Wire software SPI ((CS), SCLK, MOSI, DC, (RES), BL )","title":"Hardware Connections"},{"location":"Displays/#examples","text":"Print Text at size 1 on line 1, column 1: DisplayText [s1l1c1]Hello how are you? Draw a rectangle and draw text inside with size 2 and 7 chars padded with spaces: DisplayText [x85y95h130v30h-130v-30s2p7x90y100]37.25 C Refresh screen: DisplayText [z] Draw rectangle from x,y with width and height: DisplayText [x50y50r200:100]","title":"Examples"},{"location":"Displays/#display-local-sensors","text":"(line breaks and indentation added to the rules for readability) Use Tasmota rules to display sensor values, time, and a separation line. Refresh the display every 60 minutes: rule1 on tele - SHT3X - 0x44 # Temperature do DisplayText [ f1p7x0y5 ] % value % C endon on tele - SHT3X - 0x44 # Humidity do DisplayText [ f1p10x70y5 ] % value % % [ x0y20h296x250y5t ] endon on tele - BMP280 # Pressure do DisplayText [ f1p10x140y5 ] % value % hPa endon on Time # Minute | 60 do DisplayText [ Tt ] endon Show 4 analog channels: rule1 on tele - ADS1115 # A0 do DisplayText [ s1p21c1l01 ] Analog1: % value % adc endon on tele - ADS1115 # A1 do DisplayText [ s1p21c1l3 ] Analog2: % value % adc endon on tele - ADS1115 # A2 do DisplayText [ s1p21c1l5 ] Analog3: % value % adc endon on tele - ADS1115 # A3 do DisplayText [ s1p21c1l7 ] Analog4: % value % adc endon Show BME280 + SGP30: rule1 on tele - BME280 # Temperature do DisplayText [ s1p21x0y0 ] Temp: % value % C endon on tele - BME280 # Humidity do DisplayText [ s1p21x0y10 ] Hum : % value % %% endon on tele - BME280 # Pressure do DisplayText [ s1p21x0y20 ] Prss: % value % hPa endon on tele - SGP30 # TVOC do DisplayText [ s1p21x0y30 ] TVOC: % value % ppb endon on tele - SGP30 # eCO2 do DisplayText [ s1p21x0y40 ] eCO2 : % value % ppm [ s1p0x0y50 ] Time: [ x35y50t ] endon","title":"Display Local Sensors"},{"location":"Displays/#display-drivers","text":"Waveshare has two kinds of display controllers: with partial update and without partial update. The 2.9 inch driver is for partial update and should also support other Waveshare partial update models with modified WIDTH and HEIGHT parameters. The 4.2 inch driver is a hack which makes the full update display behave like a partial update and should probably work with other full update displays. The drivers are subclasses of the Adafruit GFX library. The class hierarchy is LOWLEVEL :: Paint :: Renderer :: GFX , where: GFX : unmodified Adafruit library Renderer : the interface for Tasmota Paint : the modified pixel driver for e-paper - there are several virtual functions that can be subclassed down to LOWLEVEL . The display dispatcher only does the class initialization call. All other calls go to the Renderer class. In black and white displays, a local RAM buffer must be allocated before calling the driver. This must be set to zero on character or TFT color displays. The EPD fonts use about 9k space, which can be selected at compile time using #ifdef directives. SSD1306 - 1.15k EPD42 - 2.57k EPD29 - 2.1k Display and Render class - ~12k","title":"Display Drivers"},{"location":"Domoticz/","text":"Tasmota supports Domoticz MQTT 'out of the box' for both relays and sensors. Find below the procedure to configure Domoticz and Tasmota. Prerequisites The following servers should be made available: You have installed/access to a MQTT broker server and made contact with your Tasmota device You have installed Domoticz MQTT and Virtual Sensor ~ If not already done configure Domoticz MQTT and Virtual Sensor hardware. On the hardware page add Type MQTT Client Gateway with LAN interface Give it a name Configure the interface with access to your MQTT server ( Remote Address , Port , Username and Password ) Set the Public Topic to flat (which seems to relate to out in the select field) On the hardware page add Type Dummy (used for virtual switches) Give it a name Virtual Switch ~ Make a new virtual switch and remeber its Idx number. Make a new virtual switch to be used with Sonoff by clicking Create Virtual Sensors Give it a name Select Sensor Type Switch On the Devices page find the new switch by it's name Remember it's Idx number Tasmota Configuration ~ Tasmota provides different ways to configure Domoticz parameters. Choose the method you prefer: [The sections below don't look like they are needed any longer. The in topic and out topic entry areas don't appear to be in the Domoticz configure section - at least they are not there in mine and mine is working 17/03/2018] Use the webinterface and select Configuration - Configure Domoticz : Set In topic to domoticz/in as hardcoded in Domoticz Set Out topic to domoticz/out as hardcoded in Domoticz Configure Idx 1 to the value read in step 2.i Use MQTT and execute commands (if necessary, replace tasmota with unique topic you configured in Initital Configuration, see point 5 there ): cmnd/tasmota/DzInTopic with payload domoticz/in as hardcoded in Domoticz cmnd/tasmota/DzOutTopic with payload domoticz/out as hardcoded in Domoticz cmnd/tasmota/DzIdx1 with payload value read in step 2.i Use the serial interface and execute commands: DzInTopic with domoticz/in as hardcoded in Domoticz DzOutTopic with domoticz/out as hardcoded in Domoticz DzIdx1 with the value read in step 2.i Usage That's it! You can now control your device from the Domoticz user interface. On the Switches page scroll down and find your Switch as configured in step 1 Toggle the light bulb; Tasmota should respond Automatic Disovery ~ Tasmota supports automatic discovery by Domoticz through the Domoticz MQTT Discovery plugin . Prerequisites The following services should be made available: You have installed/access to a MQTT broker server and made contact with your sonoff You have installed Domoticz You have installed the Domoticz MQTT Discovery plugin MQTT Discovery Plugin ~ Configure Domoticz MQTT Discovery plugin. On the hardware page add Type MQTT Discovery Give it a name, e.g. Tasmota Configure the interface with access to your MQTT server ( MQTT Server Address , Port , Username and Password ) Set the Discovery topic to homeassistant unless it has been changed in a custom Tasmota build Set the Ignored device topic to /tasmota/ to avoid unconfigured Tasmota devices from being discoved Tasmota Configuration ~ Precompiled Binary Each Tasmota device must have it's own topic, the easiest way is to set topic to tasmota_%06X (%06X will be replaced by MAC address). See here for how to set the topic. Use MQTT or Serial or Web console and execute commands (replace %topic% with the device's unique topic) cmnd/%topic%/SetOption19 with payload 1 to enable MQTT discovery Custom Binary The above settings can be defined in user_config_override.h (TBD) Usage That's it! You will now find your Sonoff in the Domoticz user interface. On the Switches page scroll down and find your Switch as configured in step 1 Toggle the light bulb; Sonoff should respond ...including sensors ~","title":"Domoticz"},{"location":"Domoticz/#mqtt-and-virtual-sensor","text":"If not already done configure Domoticz MQTT and Virtual Sensor hardware. On the hardware page add Type MQTT Client Gateway with LAN interface Give it a name Configure the interface with access to your MQTT server ( Remote Address , Port , Username and Password ) Set the Public Topic to flat (which seems to relate to out in the select field) On the hardware page add Type Dummy (used for virtual switches) Give it a name","title":"MQTT and Virtual Sensor"},{"location":"Domoticz/#virtual-switch","text":"Make a new virtual switch and remeber its Idx number. Make a new virtual switch to be used with Sonoff by clicking Create Virtual Sensors Give it a name Select Sensor Type Switch On the Devices page find the new switch by it's name Remember it's Idx number","title":"Virtual Switch"},{"location":"Domoticz/#tasmota-configuration","text":"Tasmota provides different ways to configure Domoticz parameters. Choose the method you prefer: [The sections below don't look like they are needed any longer. The in topic and out topic entry areas don't appear to be in the Domoticz configure section - at least they are not there in mine and mine is working 17/03/2018] Use the webinterface and select Configuration - Configure Domoticz : Set In topic to domoticz/in as hardcoded in Domoticz Set Out topic to domoticz/out as hardcoded in Domoticz Configure Idx 1 to the value read in step 2.i Use MQTT and execute commands (if necessary, replace tasmota with unique topic you configured in Initital Configuration, see point 5 there ): cmnd/tasmota/DzInTopic with payload domoticz/in as hardcoded in Domoticz cmnd/tasmota/DzOutTopic with payload domoticz/out as hardcoded in Domoticz cmnd/tasmota/DzIdx1 with payload value read in step 2.i Use the serial interface and execute commands: DzInTopic with domoticz/in as hardcoded in Domoticz DzOutTopic with domoticz/out as hardcoded in Domoticz DzIdx1 with the value read in step 2.i","title":"Tasmota Configuration"},{"location":"Domoticz/#automatic-disovery","text":"Tasmota supports automatic discovery by Domoticz through the Domoticz MQTT Discovery plugin .","title":"Automatic Disovery"},{"location":"Domoticz/#mqtt-discovery-plugin","text":"Configure Domoticz MQTT Discovery plugin. On the hardware page add Type MQTT Discovery Give it a name, e.g. Tasmota Configure the interface with access to your MQTT server ( MQTT Server Address , Port , Username and Password ) Set the Discovery topic to homeassistant unless it has been changed in a custom Tasmota build Set the Ignored device topic to /tasmota/ to avoid unconfigured Tasmota devices from being discoved","title":"MQTT Discovery Plugin"},{"location":"Domoticz/#tasmota-configuration_1","text":"","title":"Tasmota Configuration"},{"location":"Domoticz/#including-sensors","text":"","title":"...including sensors"},{"location":"Dynamic-Sleep/","text":"Dynamic Sleep (CPU Main loop target / CPU Power Management) ~ SetOption60 may be used to configure your device to use Normal Sleep or Dynamic Sleep. Dynamic Sleep is enabled by default from Tasmota version 6.3.0.15 but may be reconfigured by setting the value of SetOption60 accordingly. Command Description SetOption60 0 Dynamic Sleep is ENABLED (Default since 6.3.0.15) SetOption60 1 Normal Sleep is ENABLED The term CPU is used loosely here for the sake of making it easier to understand - When the term CPU is used it is actually referring to the ESP8266 SoC Micro Controller. With the introduction of many new drivers, sensors and other functions as part of the Tasmota firmware, it has become more important to pay specific attention to the amount of microcontroller clock cycles shared with the underlying SDK/Arduino ESP8266 Core. The main application loop of the Tasmota firmware needs to visit each of the driver callbacks within the main loop to make sure all the required drivers and sensors receive the necessary processing time whilst ensuring that the main loop does not overwhelm the need for processing time by the SDK / Arduino ESP8266 core. The highest priority drivers/sensors need to be called once per 50ms to operate as designed but most of the normal run of the mill drivers and sensors do not necessarily require this amount of intense polling. The 50-millisecond mark would normally be considered to be an absolute minimum duty cycle for the main processing loop on ESP8266 boards whilst most Sonoff device derivatives will function perfectly well way above this default setting. To make this manageable from device to device a new setting has been introduced enabling the setting of the main loop target to a specific value in milliseconds. For default operation, this will be set to 50 milliseconds as there are generally no drivers or sensors that need to be polled at a rate higher than this. To allow for power usage flexibility this value may also be increased to a value of up to 250 milliseconds which is very useful to reduce power and processing demand on non-time critical devices such as switches (which is what most of Tasmota is used for.) The purpose of this setting is to allow you as a user to set the speed at which driver and sensors will be serviced and as a result also the amount of time given to the SDK / Arduino ESP8266 core to handle its background tasks (which are not under direct control of the Tasmota firmware.) Example Use Case ~ Let's assume the default value of 50 for sleep and that a simple device such as a Sonoff Basic R1 or R2 is being used. In this case, the main firmware loop will iterate through all the drivers and sensors once per 50 milliseconds. Current tests suggest that a simple device such as a Sonoff Basic requires only about 9.5 milliseconds to complete one iteration of servicing all the drivers and sensors enabled in the standard tasmota.bin firmware. The time management functionality offered by dynamic sleep will compute this time requirement automatically and allow the SDK / Arduino ESP8266 Core to service background tasks such as maintaining WiFi connectivity for the remainder of the time not spent in the main firmware loop - i.e. in the case of sleep 50 this would mean 50 milliseconds - ~9.5 milliseconds = ~40.5 milliseconds spent outside of the main firmware loop servicing SDK / ESP8266 Core functions which automatically consume fewer clock cycles when there is nothing intense for the SDK / ESP8266 Core to maintain or perform. Normal Sleep was previously the only option for Tasmota powered devices wishing to take advantage of power saving but it does have the disadvantage that the sleep would be a constant setting insofar that the entire firmware codebase would run at a pre-determined speed causing some drivers to run slower than expected and decreasing the speed at which services such as the WebUI is rendered (This varies between the various underlying cores depending on which version is used.) Using Dynamic Sleep (SetOption60 = 0) instead of Normal Sleep (SetOption60 = 1) has the advantage that CPU time will be given to any particular driver or process (let's say the WebUI) on demand as and when needed whilst spending most of its time waiting for the next main loop iteration to occur. During this time of waiting the ESP8266's power demand can go from 80mA all the way down to 20mA which yields great benefits for power saving vs. firmware responsiveness compared to the traditional sleep setting. Normally the target main loop setting would be 50 milliseconds. The firmware will service all the driver and sensor callbacks up to a maximum of 20 times per second. In most cases, this is unnecessary as most normal sensors like temperature sensors only need polling once per second. So, whether you poll the temperature sensor 20 times per second (sleep 50) or 5 times per second (sleep 200) it has no impact on the functionality. Allowing the main loop to iterate 20 times per second vs. 5 times per second is obviously more time consuming and processor consuming leaving less time to idle (i.e., save power). For example, if you were using an MCP230xx with interrupts, and you need a high interrupt response then sleep 50 or lower would make sense since that specific driver can poll once per 50 milliseconds to check for interrupts. Most other sensor polling can be done in intervals longer than 50 milliseconds so you achieve more idle time, and therefore also more sleep time so it saves power. Monitoring Performance ~ Given all the above it is an obvious conclusion that in order to manage something you would need to be able to measure it. For this reason two new variables have been added to the telemetry data namely LoopSet and LoadAvg and are represented in the telemetry JSON as follows: MQT : tele /sound1/ STATE = { \"Time\" : \"2018-11-26T17:41:27\" , \"Uptime\" : \"0T05:05:17\" , \"Vcc\" : 3.504 , \"SleepMode\" : \"Dynamic\" , \"Sleep\" : 50 , \"LoadAvg\" : 19 , \"POWER\" : \"OFF\" , \"Wifi\" :{ \"AP\" : 1 , \"SSId\" : \"Wireless\" , \"BSSId\" : \"DE:AD:00:00:BE:EF\" , \"Channel\" : 3 , \"RSSI\" : 100 }} The two values indicated for LoopSet and LoadAvg have the following relation: Variable Value Description SleepMode Normal Normal Sleep mode is enabled (SetOption60 = 1) SleepMode Dynamic Dynamic Sleep mode is enabled (SetOption60 = 0) Sleep 50 Current setting for sleep LoadAvg 19 Reported % time of Sleep spent doing Tasmota main loop processing In this example, 19% of 50 milliseconds would be 9.5 milliseconds (19/100*50), so we can see that there is sufficient headroom for the SDK / ESP8266 Arduino Core to do its background work. On some devices which have many sensors connected you may observe the LoadAvg value exceeding 100 - This means that you have not set the value of sleep high enough to accommodate all the sensors and drivers which need to be serviced. In the latter case, you have two options - either increase the value of sleep to a higher one to maintain a load average well below 100 or use multiple devices to spread the load across separate Tasmota powered devices/boards. For the most part, all Sonoff based products should perform well balanced with the default setting of 50 for sleep. How to use Dynamic Sleep ~ From serial console, or webui console enter command SetOption60 0 and Sleep xx Where xx is the number of milliseconds you wish to target your main processing loop at ranging from 0 through to 250. Should you set a sleep value that is too low you will observe output on telemetry for the value of LoadAvg to be in excess of 100 - This is not ideal and should be avoided as it starves the Arduino Core / SDK of the needed processing time to take care of background tasks such as WiFi management. For optimal operation of the Tasmota firmware, it is recommended to keep your device running at a LoadAvg value of 75 or lower. If your device does not have any time critical drivers/sensors connected you are encouraged to increase the sleep value to a higher value to gain from the power saving benefits thereof.","title":"Dynamic Sleep"},{"location":"Dynamic-Sleep/#dynamic-sleep-cpu-main-loop-target-cpu-power-management","text":"SetOption60 may be used to configure your device to use Normal Sleep or Dynamic Sleep. Dynamic Sleep is enabled by default from Tasmota version 6.3.0.15 but may be reconfigured by setting the value of SetOption60 accordingly. Command Description SetOption60 0 Dynamic Sleep is ENABLED (Default since 6.3.0.15) SetOption60 1 Normal Sleep is ENABLED The term CPU is used loosely here for the sake of making it easier to understand - When the term CPU is used it is actually referring to the ESP8266 SoC Micro Controller. With the introduction of many new drivers, sensors and other functions as part of the Tasmota firmware, it has become more important to pay specific attention to the amount of microcontroller clock cycles shared with the underlying SDK/Arduino ESP8266 Core. The main application loop of the Tasmota firmware needs to visit each of the driver callbacks within the main loop to make sure all the required drivers and sensors receive the necessary processing time whilst ensuring that the main loop does not overwhelm the need for processing time by the SDK / Arduino ESP8266 core. The highest priority drivers/sensors need to be called once per 50ms to operate as designed but most of the normal run of the mill drivers and sensors do not necessarily require this amount of intense polling. The 50-millisecond mark would normally be considered to be an absolute minimum duty cycle for the main processing loop on ESP8266 boards whilst most Sonoff device derivatives will function perfectly well way above this default setting. To make this manageable from device to device a new setting has been introduced enabling the setting of the main loop target to a specific value in milliseconds. For default operation, this will be set to 50 milliseconds as there are generally no drivers or sensors that need to be polled at a rate higher than this. To allow for power usage flexibility this value may also be increased to a value of up to 250 milliseconds which is very useful to reduce power and processing demand on non-time critical devices such as switches (which is what most of Tasmota is used for.) The purpose of this setting is to allow you as a user to set the speed at which driver and sensors will be serviced and as a result also the amount of time given to the SDK / Arduino ESP8266 core to handle its background tasks (which are not under direct control of the Tasmota firmware.)","title":"Dynamic Sleep (CPU Main loop target / CPU Power Management)"},{"location":"Dynamic-Sleep/#example-use-case","text":"Let's assume the default value of 50 for sleep and that a simple device such as a Sonoff Basic R1 or R2 is being used. In this case, the main firmware loop will iterate through all the drivers and sensors once per 50 milliseconds. Current tests suggest that a simple device such as a Sonoff Basic requires only about 9.5 milliseconds to complete one iteration of servicing all the drivers and sensors enabled in the standard tasmota.bin firmware. The time management functionality offered by dynamic sleep will compute this time requirement automatically and allow the SDK / Arduino ESP8266 Core to service background tasks such as maintaining WiFi connectivity for the remainder of the time not spent in the main firmware loop - i.e. in the case of sleep 50 this would mean 50 milliseconds - ~9.5 milliseconds = ~40.5 milliseconds spent outside of the main firmware loop servicing SDK / ESP8266 Core functions which automatically consume fewer clock cycles when there is nothing intense for the SDK / ESP8266 Core to maintain or perform. Normal Sleep was previously the only option for Tasmota powered devices wishing to take advantage of power saving but it does have the disadvantage that the sleep would be a constant setting insofar that the entire firmware codebase would run at a pre-determined speed causing some drivers to run slower than expected and decreasing the speed at which services such as the WebUI is rendered (This varies between the various underlying cores depending on which version is used.) Using Dynamic Sleep (SetOption60 = 0) instead of Normal Sleep (SetOption60 = 1) has the advantage that CPU time will be given to any particular driver or process (let's say the WebUI) on demand as and when needed whilst spending most of its time waiting for the next main loop iteration to occur. During this time of waiting the ESP8266's power demand can go from 80mA all the way down to 20mA which yields great benefits for power saving vs. firmware responsiveness compared to the traditional sleep setting. Normally the target main loop setting would be 50 milliseconds. The firmware will service all the driver and sensor callbacks up to a maximum of 20 times per second. In most cases, this is unnecessary as most normal sensors like temperature sensors only need polling once per second. So, whether you poll the temperature sensor 20 times per second (sleep 50) or 5 times per second (sleep 200) it has no impact on the functionality. Allowing the main loop to iterate 20 times per second vs. 5 times per second is obviously more time consuming and processor consuming leaving less time to idle (i.e., save power). For example, if you were using an MCP230xx with interrupts, and you need a high interrupt response then sleep 50 or lower would make sense since that specific driver can poll once per 50 milliseconds to check for interrupts. Most other sensor polling can be done in intervals longer than 50 milliseconds so you achieve more idle time, and therefore also more sleep time so it saves power.","title":"Example Use Case"},{"location":"Dynamic-Sleep/#monitoring-performance","text":"Given all the above it is an obvious conclusion that in order to manage something you would need to be able to measure it. For this reason two new variables have been added to the telemetry data namely LoopSet and LoadAvg and are represented in the telemetry JSON as follows: MQT : tele /sound1/ STATE = { \"Time\" : \"2018-11-26T17:41:27\" , \"Uptime\" : \"0T05:05:17\" , \"Vcc\" : 3.504 , \"SleepMode\" : \"Dynamic\" , \"Sleep\" : 50 , \"LoadAvg\" : 19 , \"POWER\" : \"OFF\" , \"Wifi\" :{ \"AP\" : 1 , \"SSId\" : \"Wireless\" , \"BSSId\" : \"DE:AD:00:00:BE:EF\" , \"Channel\" : 3 , \"RSSI\" : 100 }} The two values indicated for LoopSet and LoadAvg have the following relation: Variable Value Description SleepMode Normal Normal Sleep mode is enabled (SetOption60 = 1) SleepMode Dynamic Dynamic Sleep mode is enabled (SetOption60 = 0) Sleep 50 Current setting for sleep LoadAvg 19 Reported % time of Sleep spent doing Tasmota main loop processing In this example, 19% of 50 milliseconds would be 9.5 milliseconds (19/100*50), so we can see that there is sufficient headroom for the SDK / ESP8266 Arduino Core to do its background work. On some devices which have many sensors connected you may observe the LoadAvg value exceeding 100 - This means that you have not set the value of sleep high enough to accommodate all the sensors and drivers which need to be serviced. In the latter case, you have two options - either increase the value of sleep to a higher one to maintain a load average well below 100 or use multiple devices to spread the load across separate Tasmota powered devices/boards. For the most part, all Sonoff based products should perform well balanced with the default setting of 50 for sleep.","title":"Monitoring Performance"},{"location":"Dynamic-Sleep/#how-to-use-dynamic-sleep","text":"From serial console, or webui console enter command SetOption60 0 and Sleep xx Where xx is the number of milliseconds you wish to target your main processing loop at ranging from 0 through to 250. Should you set a sleep value that is too low you will observe output on telemetry for the value of LoadAvg to be in excess of 100 - This is not ideal and should be avoided as it starves the Arduino Core / SDK of the needed processing time to take care of background tasks such as WiFi management. For optimal operation of the Tasmota firmware, it is recommended to keep your device running at a LoadAvg value of 75 or lower. If your device does not have any time critical drivers/sensors connected you are encouraged to increase the sleep value to a higher value to gain from the power saving benefits thereof.","title":"How to use Dynamic Sleep"},{"location":"ESP32/","text":"ESP32 Support (Beta development) ~ ESP32 support is in beta and not all functions will work You can download precompiled development binaries from http://ota.tasmota.com/tasmota32/release/ or https://github.com/arendst/Tasmota/tree/firmware/firmware/tasmota32 and the needed ESP32 flash files https://github.com/arendst/Tasmota/tree/firmware/firmware/tasmota32/ESP32_needed_files . Command syntax for flashing Tasmota32 firmware on ESP32 via Esptool ( replace COM port number! ): esptool . py -- chip esp32 -- port COM5 -- baud 921600 -- before default_reset -- after hard_reset write_flash - z -- flash_mode dout -- flash_freq 40 m -- flash_size detect 0x1000 bootloader_dout_40m . bin 0x8000 partitions . bin 0xe000 boot_app0 . bin 0x10000 tasmota32 . bin Compiling for ESP32 ~ Uncomment in platformio_tasmota32.ini tasmota32 in line #9. Next build will create a tasmota32.bin . All binaries use user_config_override.h if it exists. Templates and Known Devices ~ Some known device templates and configurations LilyGO TTGO T-Camera OV2640_V05 ~ In platformio_override.ini uncomment the line with tasmota32 and set the correct COM port. In user_config_override.h add: #define USE_BMP #define USE_I2C #define USE_SPI #define USE_DISPLAY #define USE_DISPLAY_SSD1306 #define SHOW_SPLASH #define USE_WEBCAM Upload via USB, then apply the following Template: { \"NAME\" : \"TTGO_V05\" , \"GPIO\" :[ 1 , 1 , 1 , 1 , 5090 , 5088 , 1 , 1 , 5056 , 5024 , 5089 , 5091 , 1 , 1 , 5092 , 5184 , 0 , 640 , 608 , 5093 , 0 , 5152 , 4928 , 5120 , 0 , 0 , 0 , 0 , 4992 , 160 , 32 , 1 , 5094 , 0 , 0 , 5095 ], \"FLAG\" : 0 , \"BASE\" : 2 } The PIR will turn ON/OFF the display and send over MQTT the POWER status. The display shows the sensor data. To make the device work nicely, change the following settings in the Console: Camera settings to correct orientation (USB on the bottom): WCFlip ON WCMirror ON WCResolution 6 WCSaturation 0 WCBrightness -1 WCContrast 1 Display Settings (USB on the bottom): DisplayRotate 2 DisplayCols 21 DisplayRows 7 DisplayMode 2 BME280 Settings (it is not very trustable): HumOffset 10 TempOffset -15 PIR/Button Settings: SwitchMode1 1 SetOption73 1 ODROID-GO ~ In user_config_override.h add: #define USE_DISPLAY #define USE_SPI #define USE_DISPLAY_ILI9341 Upload via USB, then apply the following Template: { \"NAME\" : \"Odroid\" , \"GPIO\" :[ 0 , 1 , 0 , 1 , 1 , 768 , 1 , 1 , 1 , 0 , 416 , 1 , 1 , 1 , 736 , 672 , 0 , 800 , 1 , 704 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4704 , 3329 , 4866 , 0 , 0 , 0 ], \"FLAG\" : 0 , \"BASE\" : 1 } To make the device work nicely, change the following settings in the Console: adcparam3 6,0,4095,0,6160 Display Settings: DisplayRotate 3 DisplayCols 53 DisplayRows 30 DisplayMode 5 Rule for Joystick to dim the display: on analog#joy2=1 do dimmer - endon on analog#joy2=2 do dimmer + endon AITHINKER CAM ~ { \"NAME\" : \"AITHINKER CAM\" , \"GPIO\" :[ 4992 , 1 , 1 , 1 , 1 , 5088 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 5089 , 5090 , 0 , 5091 , 5184 , 5152 , 0 , 5120 , 5024 , 5056 , 0 , 0 , 0 , 0 , 4928 , 1 , 5094 , 5095 , 5092 , 0 , 0 , 5093 ], \"FLAG\" : 0 , \"BASE\" : 1 } wESP32 ~ { \"NAME\" : \"wESP32\" , \"GPIO\" :[ 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 5568 , 5600 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 ], \"FLAG\" : 0 , \"BASE\" : 1 } WT32-ETH01 ~ { \"NAME\" : \"WT32-ETH01\" , \"GPIO\" :[ 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 3840 , 576 , 5600 , 0 , 0 , 0 , 0 , 5568 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 ], \"FLAG\" : 0 , \"BASE\" : 1 } Denky (Teleinfo) ~ { \"NAME\" : \"Denky (Teleinfo)\" , \"GPIO\" :[ 1 , 1 , 1 , 1 , 5664 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 1376 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 5632 , 1 , 1 , 1 , 0 , 0 , 1 ], \"FLAG\" : 0 , \"BASE\" : 1 } Olimex ESP32-PoE ~ { \"NAME\" : \"Olimex ESP32-PoE\" , \"GPIO\" :[ 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 5536 , 1 , 1 , 1 , 1 , 0 , 5600 , 0 , 0 , 0 , 0 , 5568 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 ], \"FLAG\" : 0 , \"BASE\" : 1 } LilyGO ttgo-t-eth-poe ~ { \"NAME\" : \"LilyGO ttgo-t-eth-poe\" , \"GPIO\" :[ 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 5600 , 1 , 0 , 1 , 1 , 5568 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 ], \"FLAG\" : 0 , \"BASE\" : 1 } For working Ethernet, change the following setting in the Console: EthClockMode 1 these 3 devices are also fully supported, more detailed info will be added later TTGO ESP32 watch ~ fully supported with all sensors TTGO T4 ~ fully supported m5stack CORE2 ~ #define USE_M5STACK_CORE2 #define USE_SCRIPT_FATFS 4 #define FAT_SCRIPT_SIZE 8192 #define USE_SCRIPT #define USE_I2C #define USE_BMA423 #define SAY_TIME #define USE_WEBRADIO #define USE_DISPLAY #define USE_SPI #define USE_DISPLAY_ILI9342 #define USE_TOUCH_BUTTONS #define JPEG_PICTS #define USE_FT5206 #define USE_MPU6886 add this define to build_flags - DBOARD_HAS_PSRAM fully supported with all sensors and SD card all pin definitions hardcoded except GPIO 33,34 for extern SCL,SDA on grove bus console cmd: core2shutdown seconds - shut down hardware and wake up after N seconds (>=30) core2shutdown HH:MM - shut down hardware and wake up on HH:MM time Heltec WiFi Kit 32 ~ OLED display needs the following template { \"NAME\" : \"WiFi Kit 32\" , \"GPIO\" :[ 1 , 1 , 1 , 1 , 640 , 1 , 1 , 1 , 1 , 1 , 1 , 608 , 3840 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 224 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 ], \"FLAG\" : 0 , \"BASE\" : 1 } Displays, sensors and other options ~ displays: (most probably all I2C displays will work) USE_DISPLAY_SH1106 USE_DISPLAY_EPAPER_29 USE_DISPLAY_EPAPER_42 USE_DISPLAY_ILI9341 USE_DISPLAY_ILI9488 USE_DISPLAY_SSD1351 USE_DISPLAY_RA8876 USE_DISPLAY_ST7789 USE_DISPLAY_ILI9341_2 USE_DISPLAY_ILI9342 sensors: (most probably all I2C sensors will work) USE_SHT3X USE_BMP USE_VL53L0X USE_MLX90614 USE_IBEACON USE_SML_M misc: USE_MP3_PLAYER USE_SCRIPT ( scripting and all its options ) USE_24C256 USE_SENDMAIL","title":"ESP32 Support (Beta development)"},{"location":"ESP32/#esp32-support-beta-development","text":"ESP32 support is in beta and not all functions will work You can download precompiled development binaries from http://ota.tasmota.com/tasmota32/release/ or https://github.com/arendst/Tasmota/tree/firmware/firmware/tasmota32 and the needed ESP32 flash files https://github.com/arendst/Tasmota/tree/firmware/firmware/tasmota32/ESP32_needed_files . Command syntax for flashing Tasmota32 firmware on ESP32 via Esptool ( replace COM port number! ): esptool . py -- chip esp32 -- port COM5 -- baud 921600 -- before default_reset -- after hard_reset write_flash - z -- flash_mode dout -- flash_freq 40 m -- flash_size detect 0x1000 bootloader_dout_40m . bin 0x8000 partitions . bin 0xe000 boot_app0 . bin 0x10000 tasmota32 . bin","title":"ESP32 Support (Beta development)"},{"location":"ESP32/#compiling-for-esp32","text":"Uncomment in platformio_tasmota32.ini tasmota32 in line #9. Next build will create a tasmota32.bin . All binaries use user_config_override.h if it exists.","title":"Compiling for ESP32"},{"location":"ESP32/#templates-and-known-devices","text":"Some known device templates and configurations","title":"Templates and Known Devices"},{"location":"ESP32/#lilygo-ttgo-t-camera-ov2640_v05","text":"In platformio_override.ini uncomment the line with tasmota32 and set the correct COM port. In user_config_override.h add: #define USE_BMP #define USE_I2C #define USE_SPI #define USE_DISPLAY #define USE_DISPLAY_SSD1306 #define SHOW_SPLASH #define USE_WEBCAM Upload via USB, then apply the following Template: { \"NAME\" : \"TTGO_V05\" , \"GPIO\" :[ 1 , 1 , 1 , 1 , 5090 , 5088 , 1 , 1 , 5056 , 5024 , 5089 , 5091 , 1 , 1 , 5092 , 5184 , 0 , 640 , 608 , 5093 , 0 , 5152 , 4928 , 5120 , 0 , 0 , 0 , 0 , 4992 , 160 , 32 , 1 , 5094 , 0 , 0 , 5095 ], \"FLAG\" : 0 , \"BASE\" : 2 } The PIR will turn ON/OFF the display and send over MQTT the POWER status. The display shows the sensor data. To make the device work nicely, change the following settings in the Console: Camera settings to correct orientation (USB on the bottom): WCFlip ON WCMirror ON WCResolution 6 WCSaturation 0 WCBrightness -1 WCContrast 1 Display Settings (USB on the bottom): DisplayRotate 2 DisplayCols 21 DisplayRows 7 DisplayMode 2 BME280 Settings (it is not very trustable): HumOffset 10 TempOffset -15 PIR/Button Settings: SwitchMode1 1 SetOption73 1","title":"LilyGO TTGO T-Camera OV2640_V05"},{"location":"ESP32/#odroid-go","text":"In user_config_override.h add: #define USE_DISPLAY #define USE_SPI #define USE_DISPLAY_ILI9341 Upload via USB, then apply the following Template: { \"NAME\" : \"Odroid\" , \"GPIO\" :[ 0 , 1 , 0 , 1 , 1 , 768 , 1 , 1 , 1 , 0 , 416 , 1 , 1 , 1 , 736 , 672 , 0 , 800 , 1 , 704 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4704 , 3329 , 4866 , 0 , 0 , 0 ], \"FLAG\" : 0 , \"BASE\" : 1 } To make the device work nicely, change the following settings in the Console: adcparam3 6,0,4095,0,6160 Display Settings: DisplayRotate 3 DisplayCols 53 DisplayRows 30 DisplayMode 5 Rule for Joystick to dim the display: on analog#joy2=1 do dimmer - endon on analog#joy2=2 do dimmer + endon","title":"ODROID-GO"},{"location":"ESP32/#aithinker-cam","text":"{ \"NAME\" : \"AITHINKER CAM\" , \"GPIO\" :[ 4992 , 1 , 1 , 1 , 1 , 5088 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 5089 , 5090 , 0 , 5091 , 5184 , 5152 , 0 , 5120 , 5024 , 5056 , 0 , 0 , 0 , 0 , 4928 , 1 , 5094 , 5095 , 5092 , 0 , 0 , 5093 ], \"FLAG\" : 0 , \"BASE\" : 1 }","title":"AITHINKER CAM"},{"location":"ESP32/#wesp32","text":"{ \"NAME\" : \"wESP32\" , \"GPIO\" :[ 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 5568 , 5600 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 ], \"FLAG\" : 0 , \"BASE\" : 1 }","title":"wESP32"},{"location":"ESP32/#wt32-eth01","text":"{ \"NAME\" : \"WT32-ETH01\" , \"GPIO\" :[ 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 3840 , 576 , 5600 , 0 , 0 , 0 , 0 , 5568 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 ], \"FLAG\" : 0 , \"BASE\" : 1 }","title":"WT32-ETH01"},{"location":"ESP32/#denky-teleinfo","text":"{ \"NAME\" : \"Denky (Teleinfo)\" , \"GPIO\" :[ 1 , 1 , 1 , 1 , 5664 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 1376 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 5632 , 1 , 1 , 1 , 0 , 0 , 1 ], \"FLAG\" : 0 , \"BASE\" : 1 }","title":"Denky (Teleinfo)"},{"location":"ESP32/#olimex-esp32-poe","text":"{ \"NAME\" : \"Olimex ESP32-PoE\" , \"GPIO\" :[ 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 5536 , 1 , 1 , 1 , 1 , 0 , 5600 , 0 , 0 , 0 , 0 , 5568 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 ], \"FLAG\" : 0 , \"BASE\" : 1 }","title":"Olimex ESP32-PoE"},{"location":"ESP32/#lilygo-ttgo-t-eth-poe","text":"{ \"NAME\" : \"LilyGO ttgo-t-eth-poe\" , \"GPIO\" :[ 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 5600 , 1 , 0 , 1 , 1 , 5568 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 ], \"FLAG\" : 0 , \"BASE\" : 1 } For working Ethernet, change the following setting in the Console: EthClockMode 1 these 3 devices are also fully supported, more detailed info will be added later","title":"LilyGO ttgo-t-eth-poe"},{"location":"ESP32/#ttgo-esp32-watch","text":"fully supported with all sensors","title":"TTGO ESP32 watch"},{"location":"ESP32/#ttgo-t4","text":"fully supported","title":"TTGO T4"},{"location":"ESP32/#m5stack-core2","text":"#define USE_M5STACK_CORE2 #define USE_SCRIPT_FATFS 4 #define FAT_SCRIPT_SIZE 8192 #define USE_SCRIPT #define USE_I2C #define USE_BMA423 #define SAY_TIME #define USE_WEBRADIO #define USE_DISPLAY #define USE_SPI #define USE_DISPLAY_ILI9342 #define USE_TOUCH_BUTTONS #define JPEG_PICTS #define USE_FT5206 #define USE_MPU6886 add this define to build_flags - DBOARD_HAS_PSRAM fully supported with all sensors and SD card all pin definitions hardcoded except GPIO 33,34 for extern SCL,SDA on grove bus console cmd: core2shutdown seconds - shut down hardware and wake up after N seconds (>=30) core2shutdown HH:MM - shut down hardware and wake up on HH:MM time","title":"m5stack CORE2"},{"location":"ESP32/#heltec-wifi-kit-32","text":"OLED display needs the following template { \"NAME\" : \"WiFi Kit 32\" , \"GPIO\" :[ 1 , 1 , 1 , 1 , 640 , 1 , 1 , 1 , 1 , 1 , 1 , 608 , 3840 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 224 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 ], \"FLAG\" : 0 , \"BASE\" : 1 }","title":"Heltec WiFi Kit 32"},{"location":"ESP32/#displays-sensors-and-other-options","text":"displays: (most probably all I2C displays will work) USE_DISPLAY_SH1106 USE_DISPLAY_EPAPER_29 USE_DISPLAY_EPAPER_42 USE_DISPLAY_ILI9341 USE_DISPLAY_ILI9488 USE_DISPLAY_SSD1351 USE_DISPLAY_RA8876 USE_DISPLAY_ST7789 USE_DISPLAY_ILI9341_2 USE_DISPLAY_ILI9342 sensors: (most probably all I2C sensors will work) USE_SHT3X USE_BMP USE_VL53L0X USE_MLX90614 USE_IBEACON USE_SML_M misc: USE_MP3_PLAYER USE_SCRIPT ( scripting and all its options ) USE_24C256 USE_SENDMAIL","title":"Displays, sensors and other options"},{"location":"EZO/","text":"EZO sensors ~ EZO is a series of chemical sensors provided by Atlas Scientific Configuration ~ All EZO devices must operate under the I2C mode to be compatible with Tasmota. One of the easiest way to achieve this is to short SDA/Tx to PGND while powering the device through VCC & GND . For more details, see Instructables . Tasmota will automatically detect any new device that has an I2C bus address between 0x61-0x70 (which covers the default address range of all EZO devices). Tasmota supports any multiple of EZO devices (up to 16 of any kind). When more than one device is detected, the devices will be indexed starting at index 1 (ex: EZO-1) and ordered by their I2C address. If only one EZO device is connected, there will be no indexing of them. You may change the address of your device by sending an I2C command to the device. For example, to change the address of a single EZOpH sensor, the following command can be issued in the console: Sensor78 I2C,100 Specific details about the list of commands available for your EZO device can be found in the device-specific datasheet on the Atlas Scientific's website. In order to individually address a single EZO sensor when more than one is detected, the index must be specified on the command by appending \"-#\" to the command: Sensor78-2 I2C,101 Calibration ~ Many EZO devices require calibration in order to accurately report values. Calibration can be easily achieved by issuing the appropriate commands and following the instructions in the EZO datasheets. One easy way to achieve this is to put the sensor in the baseline environement and use the web interface to see when the value stabilizes. Once it does, visit the console and issue the device-specific calibration command. Readings ~ Currently, Tasmota samples the sensor information at the rate of 1Hz (1 sample/second) irrespective of the EZO device. Some EZO devices support reporting different units. For example EZO-RTD supports reading the temperature in \u00b0C, \u00b0K, or \u00b0F. In order to save memory, Tasmota will only be able reading the default format (ie: \u00b0C). If you wish to see the value in another format, you can use Tasmota's ability to display Farenheit to do the conversion for you. For conversions that are not supported by Tasmota, you may use OpenHab, Home Assistant or any other system in conjunction with MQTT to do the cnoversion. In every case, there exists a simple formula that will allow you to convert from one format to another and the EZO device are merely utilizing that formula to return the value. It's important to make sure that the default units are used. If that's not the case, Tasmota will simply assume that the default units are used and the number will seem drastically wrong. Some device supports the output of multiple diffrent sensors in one single EZO devices. One example of this is the EZO-HUM which supports outputing the humidity as well as the temperature. By default, only the humidity is enabled, but a command can be sent to enable the temperature as well. In that case, Tasmota does support reading the additional sensor provided that the command enables its output. Some readings can be made more precise by specifying additional parameters. The most common one is temperature. For example, the EZO-pH sensor can return more accurate values if it compensates for the temperature. At this point in time, Tasmota does not support reading sensor data which compensates with any other sensor's data. That said, these are typically well-established equations that will allow you to convert the existing reading and adjust it based on the reading from the other sensor. A simple Google search can be done to understand how to compensate in each case. Sleep mode for EZO devices is currently NOT supported by Tasmota. Build Configuration ~ By default, the EZO sensor is NOT built in the Tasmota binary. The Tasmota web build interface can be used to produce the proper binary. The following #define must be enabled in order to compile the following supported sensors: At this point in time, the following EZO sensors are supported: | Required build #define | Sensor ID | Sensor Name | |---|---|---| | USE_EZO_DO | EZO-D.O. | Disolved Oxygen | | USE_EZO_ORP | EZO-ORP | Oxygen Reduction Potential | | USE_EZO_PH | EZO-pH | pH | | USE_EZO_EC | EZO-EC | Electric Conductivity | | USE_EZO_RTD | EZO-RTD | Temperature | | USE_EZO_FLO | EZO-FLO | Flow Meter | | USE_EZO_CO2 | EZO-CO2 | Carbon Dioxyde (gas) | | USE_EZO_PRS | EZO-PRS | Pressure | | USE_EZO_O2 | EZO-O2 | Oxygen (gas) | | USE_EZO_HUM | EZO-HUM | Humidity | | USE_EZO_RGB | EZO-RGB | Color |","title":"EZO sensors"},{"location":"EZO/#ezo-sensors","text":"EZO is a series of chemical sensors provided by Atlas Scientific","title":"EZO sensors"},{"location":"EZO/#configuration","text":"All EZO devices must operate under the I2C mode to be compatible with Tasmota. One of the easiest way to achieve this is to short SDA/Tx to PGND while powering the device through VCC & GND . For more details, see Instructables . Tasmota will automatically detect any new device that has an I2C bus address between 0x61-0x70 (which covers the default address range of all EZO devices). Tasmota supports any multiple of EZO devices (up to 16 of any kind). When more than one device is detected, the devices will be indexed starting at index 1 (ex: EZO-1) and ordered by their I2C address. If only one EZO device is connected, there will be no indexing of them. You may change the address of your device by sending an I2C command to the device. For example, to change the address of a single EZOpH sensor, the following command can be issued in the console: Sensor78 I2C,100 Specific details about the list of commands available for your EZO device can be found in the device-specific datasheet on the Atlas Scientific's website. In order to individually address a single EZO sensor when more than one is detected, the index must be specified on the command by appending \"-#\" to the command: Sensor78-2 I2C,101","title":"Configuration"},{"location":"EZO/#calibration","text":"Many EZO devices require calibration in order to accurately report values. Calibration can be easily achieved by issuing the appropriate commands and following the instructions in the EZO datasheets. One easy way to achieve this is to put the sensor in the baseline environement and use the web interface to see when the value stabilizes. Once it does, visit the console and issue the device-specific calibration command.","title":"Calibration"},{"location":"EZO/#readings","text":"Currently, Tasmota samples the sensor information at the rate of 1Hz (1 sample/second) irrespective of the EZO device. Some EZO devices support reporting different units. For example EZO-RTD supports reading the temperature in \u00b0C, \u00b0K, or \u00b0F. In order to save memory, Tasmota will only be able reading the default format (ie: \u00b0C). If you wish to see the value in another format, you can use Tasmota's ability to display Farenheit to do the conversion for you. For conversions that are not supported by Tasmota, you may use OpenHab, Home Assistant or any other system in conjunction with MQTT to do the cnoversion. In every case, there exists a simple formula that will allow you to convert from one format to another and the EZO device are merely utilizing that formula to return the value. It's important to make sure that the default units are used. If that's not the case, Tasmota will simply assume that the default units are used and the number will seem drastically wrong. Some device supports the output of multiple diffrent sensors in one single EZO devices. One example of this is the EZO-HUM which supports outputing the humidity as well as the temperature. By default, only the humidity is enabled, but a command can be sent to enable the temperature as well. In that case, Tasmota does support reading the additional sensor provided that the command enables its output. Some readings can be made more precise by specifying additional parameters. The most common one is temperature. For example, the EZO-pH sensor can return more accurate values if it compensates for the temperature. At this point in time, Tasmota does not support reading sensor data which compensates with any other sensor's data. That said, these are typically well-established equations that will allow you to convert the existing reading and adjust it based on the reading from the other sensor. A simple Google search can be done to understand how to compensate in each case. Sleep mode for EZO devices is currently NOT supported by Tasmota.","title":"Readings"},{"location":"EZO/#build-configuration","text":"By default, the EZO sensor is NOT built in the Tasmota binary. The Tasmota web build interface can be used to produce the proper binary. The following #define must be enabled in order to compile the following supported sensors: At this point in time, the following EZO sensors are supported: | Required build #define | Sensor ID | Sensor Name | |---|---|---| | USE_EZO_DO | EZO-D.O. | Disolved Oxygen | | USE_EZO_ORP | EZO-ORP | Oxygen Reduction Potential | | USE_EZO_PH | EZO-pH | pH | | USE_EZO_EC | EZO-EC | Electric Conductivity | | USE_EZO_RTD | EZO-RTD | Temperature | | USE_EZO_FLO | EZO-FLO | Flow Meter | | USE_EZO_CO2 | EZO-CO2 | Carbon Dioxyde (gas) | | USE_EZO_PRS | EZO-PRS | Pressure | | USE_EZO_O2 | EZO-O2 | Oxygen (gas) | | USE_EZO_HUM | EZO-HUM | Humidity | | USE_EZO_RGB | EZO-RGB | Color |","title":"Build Configuration"},{"location":"Energy-Saving/","text":"Using the Sleep command you can instruct Tasmota to sleep for the set milliseconds in its main cycle. While sleeping your device will consume less power. Dynamic Sleep is enabled by default with a value of 50. To continue using Normal Sleep you may disable it by using the command: SetOption60 1 Setting Sleep to lowest value 1 reduces power consumption already about ~30% in idle mode (relay off) and button presses are still noticed without any delay. Setting this around 50 ms reduces power consumption from ~1.1 W to ~0.6 W on an idling (relay off) device and button presses are still noticed correctly. With this setting you have to concentrate very hard to click the button so fast that it is not recognized by the device. If your device needs to do something continuously, this will be affected. E.g., device LED will flicker and Sonoff POW will not be able to correctly total the energy consumption. Spot readings of power, voltage, etc. will however remain correct. From the release notes: Expect overall button/key/switch misses and wrong values on Sonoff Pow Notes: - Starting with Tasmota 6.1.1.12 Sleep \u2260 0 has no impact on real time related commands like Delay , PulseTime , TelePeriod and Blinktime . - As the WiFi Modem on an ESP8266 is the major consumer - using Sleep with WiFi AP mode enabled is more or less without effect. Device power consumption and measurement ~ Most low-price plug-in home energy meters like Sonoff devices are very imprecise for power consumption < 10 W and become more and more imprecise for power consumption (< 1.5 W). Furthermore, the results of such meters are very strongly dependant on the load type (capacitive/inductive) and are absolutely imprecise for non-ohmic load types having switch-mode power supplies. In addition, using Sleep - which periodically cycles the power of the device between 20% and 100% - on such meters makes their readings more or less useless. Example of power consumption ~ Absolute AC line measurement using calibrated meter ~ The following measurement was done directly on 230 V/AC line using a Sonoff Dual R2 and two different Sonoff S20 connected on different MID calibrated meter (Eastron SMD630 MID/saia-burgess ALE3). Device power consumption using Sleep Device Sleep 0 Sleep 1 Sleep 50 Sleep 200 Sonoff Dual R2 1.24 W 0.84 W 0.76 W 0.68 W Sonoff S20 1.11 W 0.77 W 0.59 W 0.51 W All measurements were done with - WiFi STA mode, enabled and connected (70%) - MQTT enabled and connected - Syslog enabled and connected - TelePeriod 60 for debugging - Relays off - Measurement period of 24-56 hours to reduce measurement discrepancies The first impression is that a higher sleep value reduces the consumption, but only slightly. The second result is that using Sleep <value> ( value \u2260 0, e. g., 1) is good enough to reduce the power consumption anywhere between 1/3 and up to 45% (value=200). Quantity measurement of ESP-12 module/ESP8266 3.3V line ~ To find out why Sleep reduces the power consumption and how its value should be set, the current of the 3.3V DC ESP8266 of an ESP-12 module was measured using an oscilloscope and (for easy reading the oscilloscope diagram) a 1 \u03a9 shunt which results in a 1:1 interpretation between voltage and current. This measurement simplified the measure of a time based power consumption; no integration must be done. On the other side note that the quantity measurement does not respect the effectiveness of the complete device circuit. Sleep 0 Using Sleep 0 there are no delay() calls in Tasmota main loop and therefore the power consumption is continuous at current ~80 mA: Sleep 1 Due to the fact that the Tasmota main loop now calls delay() (even with 1ms) it seems it results in periodically (100ms) enabling the WiFi Modem Sleep mode within the WiFi Manager library. It results in periodically lowering the current to 15-20 mA for ~90ms of each loop: Sleep 100 By increasing the sleep value, there are more and more ~90ms periods with additional lowering of the current to 8-10 mA - I really don't know where this comes from: Sleep 250 As already noticed with Sleep 100 the number periods having 8-10 mA instead of 15-20 mA increase again: The quantity measurement confirms the suspicion that a Sleep value \u2260 0 results in reducing the power consumption about 1/3.","title":"Energy Saving"},{"location":"Energy-Saving/#device-power-consumption-and-measurement","text":"Most low-price plug-in home energy meters like Sonoff devices are very imprecise for power consumption < 10 W and become more and more imprecise for power consumption (< 1.5 W). Furthermore, the results of such meters are very strongly dependant on the load type (capacitive/inductive) and are absolutely imprecise for non-ohmic load types having switch-mode power supplies. In addition, using Sleep - which periodically cycles the power of the device between 20% and 100% - on such meters makes their readings more or less useless.","title":"Device power consumption and measurement"},{"location":"Energy-Saving/#example-of-power-consumption","text":"","title":"Example of power consumption"},{"location":"Energy-Saving/#absolute-ac-line-measurement-using-calibrated-meter","text":"The following measurement was done directly on 230 V/AC line using a Sonoff Dual R2 and two different Sonoff S20 connected on different MID calibrated meter (Eastron SMD630 MID/saia-burgess ALE3).","title":"Absolute AC line measurement using calibrated meter"},{"location":"Energy-Saving/#quantity-measurement-of-esp-12-moduleesp8266-33v-line","text":"To find out why Sleep reduces the power consumption and how its value should be set, the current of the 3.3V DC ESP8266 of an ESP-12 module was measured using an oscilloscope and (for easy reading the oscilloscope diagram) a 1 \u03a9 shunt which results in a 1:1 interpretation between voltage and current. This measurement simplified the measure of a time based power consumption; no integration must be done. On the other side note that the quantity measurement does not respect the effectiveness of the complete device circuit.","title":"Quantity measurement of ESP-12 module/ESP8266 3.3V line"},{"location":"Esptool/","text":"How to setup and configure Esptool for Tasmota upload. The information below is for the Python version of esptool - If you want to use the Windows/Linux/OSX(MAC) executable version of esptool (as would be included in Arduino ESP8266 cores) then please go to the esptool executable (Windows & Linux) section at the bottom. Download Esptool ~ If you do not have an installed copy of Python 2.x or 3.x download and install it from https://www.python.org/. Download Esptool Source code from https://github.com/espressif/esptool/releases to a known folder. Install Esptool ~ Go to the known folder and install Esptool with command python setup.py install . Packages for Esptool are maintained for Debian and Ubuntu and can be installed with sudo apt install esptool . Download Tasmota ~ Download the latest Tasmota release firmware file tasmota.bin to a known folder. A second source is thehackbox This source can be used for OTA too. Upload Tasmota ~ Put device in firmware upload mode ~ When performing a firmware upload do not connect the device to AC but use the power supply provided by your (FTDI type) serial interface. Put the device in firmware upload mode by grounding pin GPIO00 while applying power. Grounding pin GPIO00 can often be achieved by pressing button 1 on the Sonoff device or using a wire between GPIO00 and Gnd if the button is not available. Deviations may apply. Connect the serial interface of your PC to the device while GPIO00 to Gnd. Esptool uses the serial interface to communicate with your device. On Windows these interfaces are named COM1, COM2 etc. On Linux these interfaces are called /dev/ttyUSB0, /dev/ttyUSB1 etc. Before using Esptool make sure you know to which serial interface name your device is connected to. In the following commands I use COM5 as an example. Optional: Backup firmware ~ Ensure the device is in firmware upload mode. Backup the current firmware with the following command: esptool . py -- port COM5 read_flash 0x00000 0x100000 image1M . bin NOTE: When the command completes the device is out of firmware upload mode! Erase firmware ~ Ensure the device is in firmware upload mode. Erase the complete flash memory holding the firmware with the following command: esptool . py -- port COM5 erase_flash NOTE1: When the command completes the device is out of firmware upload mode! NOTE2: It only takes a few seconds to erase 1M of flash. Upload firmware ~ Ensure the device is in firmware upload mode. Load the downloaded Tasmota firmware file tasmota.bin with the following command: esptool . py -- port COM5 write_flash - fs 1 MB - fm dout 0x0 tasmota . bin NOTE1: When the command completes the device is out of firmware upload mode! NOTE2: For a proper device initialization after first firmware upload power down and power up the device. ESPTOOL Executable (Windows & Linux) ~ The executable version of esptool is maintained by Ivan Grokhotkov and releases are kept at https://github.com/igrr/esptool-ck/releases Download and Install ~ For the purpose of simplicity only the Windows version will be explained here, but the command and parameters are the same for Windows, Linux and MAC/OSX. Download the latest release from https://github.com/igrr/esptool-ck/releases and extract the compressed file to a known location. Download Tasmota ~ Download the latest Tasmota release firmware file tasmota.bin to a known folder (The same folder as where you have the esptool executable will work well for this process to be simpler) If you want features from the current development codebase which has not been included in the last release please download this tasmota.bin to a known folder (The same folder as where you have the esptool executable will work well for this process to be simpler) The information posted further up in this Wiki for placing the device into bootload / firmware upgrade mode may be followed as this process does not change irrespective whether you use the Python or executable version of esptool. Once the device is in firmware upload mode the following commands are recommended for completion of the firmware flashing. Erase the flash completely with the following command (substituting the COM port for the one which was used on your computer) esptool -cp COM3 -cb 115200 -ce -v Once the erase is complete, reset your device back into programming mode and then upload the firmware using the following command esptool -cp COM3 -cb 115200 -bm dout -cf tasmota.bin -v","title":"Esptool"},{"location":"Esptool/#download-esptool","text":"If you do not have an installed copy of Python 2.x or 3.x download and install it from https://www.python.org/. Download Esptool Source code from https://github.com/espressif/esptool/releases to a known folder.","title":"Download Esptool"},{"location":"Esptool/#install-esptool","text":"Go to the known folder and install Esptool with command python setup.py install . Packages for Esptool are maintained for Debian and Ubuntu and can be installed with sudo apt install esptool .","title":"Install Esptool"},{"location":"Esptool/#download-tasmota","text":"Download the latest Tasmota release firmware file tasmota.bin to a known folder. A second source is thehackbox This source can be used for OTA too.","title":"Download Tasmota"},{"location":"Esptool/#upload-tasmota","text":"","title":"Upload Tasmota"},{"location":"Esptool/#put-device-in-firmware-upload-mode","text":"When performing a firmware upload do not connect the device to AC but use the power supply provided by your (FTDI type) serial interface. Put the device in firmware upload mode by grounding pin GPIO00 while applying power. Grounding pin GPIO00 can often be achieved by pressing button 1 on the Sonoff device or using a wire between GPIO00 and Gnd if the button is not available. Deviations may apply. Connect the serial interface of your PC to the device while GPIO00 to Gnd. Esptool uses the serial interface to communicate with your device. On Windows these interfaces are named COM1, COM2 etc. On Linux these interfaces are called /dev/ttyUSB0, /dev/ttyUSB1 etc. Before using Esptool make sure you know to which serial interface name your device is connected to. In the following commands I use COM5 as an example.","title":"Put device in firmware upload mode"},{"location":"Esptool/#optional-backup-firmware","text":"Ensure the device is in firmware upload mode. Backup the current firmware with the following command: esptool . py -- port COM5 read_flash 0x00000 0x100000 image1M . bin NOTE: When the command completes the device is out of firmware upload mode!","title":"Optional: Backup firmware"},{"location":"Esptool/#erase-firmware","text":"Ensure the device is in firmware upload mode. Erase the complete flash memory holding the firmware with the following command: esptool . py -- port COM5 erase_flash NOTE1: When the command completes the device is out of firmware upload mode! NOTE2: It only takes a few seconds to erase 1M of flash.","title":"Erase firmware"},{"location":"Esptool/#upload-firmware","text":"Ensure the device is in firmware upload mode. Load the downloaded Tasmota firmware file tasmota.bin with the following command: esptool . py -- port COM5 write_flash - fs 1 MB - fm dout 0x0 tasmota . bin NOTE1: When the command completes the device is out of firmware upload mode! NOTE2: For a proper device initialization after first firmware upload power down and power up the device.","title":"Upload firmware"},{"location":"Esptool/#esptool-executable-windows-linux","text":"The executable version of esptool is maintained by Ivan Grokhotkov and releases are kept at https://github.com/igrr/esptool-ck/releases","title":"ESPTOOL Executable (Windows &amp; Linux)"},{"location":"Esptool/#download-and-install","text":"For the purpose of simplicity only the Windows version will be explained here, but the command and parameters are the same for Windows, Linux and MAC/OSX. Download the latest release from https://github.com/igrr/esptool-ck/releases and extract the compressed file to a known location.","title":"Download and Install"},{"location":"Esptool/#download-tasmota_1","text":"Download the latest Tasmota release firmware file tasmota.bin to a known folder (The same folder as where you have the esptool executable will work well for this process to be simpler) If you want features from the current development codebase which has not been included in the last release please download this tasmota.bin to a known folder (The same folder as where you have the esptool executable will work well for this process to be simpler) The information posted further up in this Wiki for placing the device into bootload / firmware upgrade mode may be followed as this process does not change irrespective whether you use the Python or executable version of esptool. Once the device is in firmware upload mode the following commands are recommended for completion of the firmware flashing. Erase the flash completely with the following command (substituting the COM port for the one which was used on your computer) esptool -cp COM3 -cb 115200 -ce -v Once the erase is complete, reset your device back into programming mode and then upload the firmware using the following command esptool -cp COM3 -cb 115200 -bm dout -cf tasmota.bin -v","title":"Download Tasmota"},{"location":"Expanding-4CH/","text":"Opening my Sonoff 4CH (https://www.itead.cc/sonoff-4ch.html) I realized that on PCB there is a predisposition for 2.5 mm jack (also confirmed by schematic on Itead wiki: https://www.itead.cc/wiki/File:Sonoff_4CH.SCHMATIC.pdf). I ordered on Aliexpress some 2.5 mm jacks and when I received it after some work... The schematic reports that 2.5 mm jack is configured as following (jack on right side, ESP8285 on the left side: 3.3V and GND are very welcome for sensors expansions but GPIO7 and GPIO8 are not usable because they are used internally by ESP8285 for flash memory connection (sigh!) R35 and R36 resistors are not soldered on Sonoff 4CH PCB and it is possible to use their pads to \"manually route\" the jack contact on another ESP8285 pin (!). I selected R35 pad because my \"waterproof\" DS18B20 sensors provide signal line on TEM1 jack contact. For ESP8285 pin I prefer IO2 that is already available on header programming pins... Then the route to do is: TEM1 -> R35 pad -> GPIO2: DS18B20 sensors need a 4.7Kohm pullup resistor between DATA pin and 3.3V and this is also useful to pullup GPIO2 in order to avoid ESP8285 reset. Final result in these photos: Tasmota is also configured with DS18x20 on GPIO2 and it works ! * Note * : source file sonoff/sonoff_template.h provides the configuration on Sonoff 4CH and it is also possible to use GPIO16 (as in the screenshot above) but be aware that no interrupts can be used on GPIO16 and you could have problems with some sensors.","title":"Expanding 4CH"},{"location":"Expanding-Tasmota/","text":"You can wire peripherals (sensors, displays, switches, LED lights, ...) to available pins of the ESP8266 chip that controls these devices. To make a link between the different naming schemes the Pin Definition overview in the ESP8266 wiki is quite helpful. Examples ~ Connect switch If you take a Sonoff Basic and connect a switch between pin4 (GND) and pin5 (GPIO14) of the 5 pin programming header you now have a second switch connected to the device. You can set this through the module config page as option Switch1 (9) or from the command line with gpio14 9 . See Buttons and Switches for more information. Connect jack Instead of connecting a switch, you could connect a 4-pin 2.5mm jack, with the pins wired: Jack Pin ESP8266 tip 5 GPIO14 R1 no connection R2 1 GND R3 4 3.3V You can then plug a sensor into the jack like you would to a Sonoff TH and define what sensor you have connected to GPIO14. Danger If you can avoid it, don't use GPIOs: 0, 1, 2, 6-11, 15 and 16 . That leaves 4, 5, 12, 13, 14 as GPIOs without any constraints. 3 being RX is also good to avoid (PWM is not working on this GPIO). Others can be used but you have to mind the constraints outlined in this document . Danger The ESP8266 is a 3.3V microcontroller, so its I/O operates at 3.3V as well. The pins are not 5V tolerant, applying more than 3.6V on any pin will release the magic smoke (fry the chip). The maximum current that can be drawn from a single GPIO pin is 12mA. Danger The power supplied to the device is one of the most important elements for stable device operation. Many devices on the market have barely adequate power supplies for normal operation. Connected peripherals may strain the ability of the power supply on the device to deliver appropriate power to all the components, both on-board as well as externally connected. Voltage regulation issues typically result in fatal exception fault code 1 . You must ensure that the device receives sufficient power (current and appropriate voltage level). Take into account the current that each wired component (f.e. sensor) will draw from the device itself. Electrical Considerations ~ When you switch a GPIO pin to an input and hang a long wire off of it, that wire can pick up stray signals and cause the voltage on the GPIO pin to vary. This can cause the system to think the switch has changed. To fix this, there are several things you can do. add a pull-up resistor add a bypass capacitor shielding on the wire use twisted pair wiring A pull-up resistor is a resistor connected between the GPIO pin and 3.3v. The exact value of this is not critical, 4.7k is a common value to use, as is 10k. This ensures that when the switch it open, the GPIO pin will go high. A bypass capacitor is a small (pF range) capacitor that is connected between the GPIO and ground. This provides a path for any radio signals that are picked up by the wire to go to ground and not confuse the system. Shielding or using twisted pair wiring are other ways to reduce the effect of radio signals on the system. Example for 10K Resistor (issue #2708 ) The ESP8266 Hardware ~ Complete document available from https://tttapa.github.io/ESP8266/Chap04%20-%20Microcontroller.html Digital I/O ~ Just like a normal Arduino, the ESP8266 has digital input/output pins (I/O or GPIO, General Purpose Input/Output pins). As the name implies, they can be used as digital inputs to read a digital voltage, or as digital outputs to output either 0V (sink current) or 3.3V (source current). Usable pins ~ The ESP8266 and ESP8255 have 17 GPIO pins (0-16) but several are reserved or have constraints . Do not use any of the reserved pins. If you do, you might crash your program. On the ESP8266, six pins (GPIO 6 - 11) are used to interface the flash memory (the small 8-legged chip usually right next to the ESP8266). The ESP8255 has its flash memory integrated into the chip which frees up GPIO 9 and 10. GPIO 1 and 3 are used as TX and RX of the hardware Serial port (UART), so in most cases, you can\u2019t use them as normal I/O while sending/receiving serial data. Boot modes ~ Some I/O pins have a special function during boot: They select 1 of 3 boot modes: GPIO15 GPIO0 GPIO2 Mode 0V 0V 3.3V Uart Bootloader 0V 3.3V 3.3V Boot sketch (SPI flash) 3.3V x x SDIO mode (not used for Arduino) Note: you don\u2019t have to add an external pull-up resistor to GPIO2, the internal one is enabled at boot. We have to be sure that these conditions are met by adding external resistors, or the board manufacturer of your board has added them for you. This has some implications, however: GPIO15 is always pulled low, so you can\u2019t use the internal pull-up resistor. You have to keep this in mind when using GPIO15 as an input to read a switch or connect it to a device with an open-collector (or open-drain) output, like I\u00b2C. GPIO0 is pulled high during normal operation, so you can\u2019t use it as a Hi-Z input. GPIO2 can\u2019t be low at boot, so you can\u2019t connect a switch to it. Internal pull-up/-down resistors GPIO 0-15 all have a built-in pull-up resistor, just like in an Arduino. GPIO16 has a built-in pull-down resistor. PWM ~ Unlike most Atmel chips (Arduino), the ESP8266 doesn\u2019t support hardware PWM, however, software PWM is supported on all digital pins. The default PWM range is 10-bits @ 1kHz, but this can be changed (up to >14-bit@1kHz). Check Restrictions . Analog input ~ The ESP8266 has a single analog input, with an input range of 0 - 1.0V. If you supply 3.3V, for example, you will damage the chip. Some boards like the NodeMCU have an on-board resistive voltage divider, to get an easier 0 - 3.3V range. You could also just use a trimpot as a voltage divider. The ADC (analog to digital converter) has a resolution of 10 bits. Communication ~ Serial ~ The ESP8266 has two hardware UARTS (Serial ports): UART0 on pins 1 and 3 (TX0 and RX0 resp.), and UART1 on pins 2 and 8 (TX1 and RX1 resp.), however, GPIO8 is used to connect the flash chip. This means that UART1 can only transmit data. UART0 also has hardware flow control on pins 15 and 13 (RTS0 and CTS0 resp.). These two pins can also be used as alternative TX0 and RX0 pins. I\u00b2C ~ ESP8266 doesn\u2019t have a hardware TWI (Two Wire Interface) but it is implemented in software. This means that you can use pretty much any two digital pins. By default, the I\u00b2C library uses pin 4 as SDA and pin 5 as SCL. (The data sheet specifies GPIO2 as SDA and GPIO14 as SCL.) The maximum speed is approximately 450kHz. SPI ~ The ESP8266 has one SPI connection available to the user, referred to as HSPI. It uses GPIO14 as CLK, 12 as MISO, 13 as MOSI and 15 as Slave Select (SS). It can be used in both Slave and Master mode (in software). GPIO overview ~ NodeMCU Labelled Pin GPIO# Function State Restrictions D3 0 Boot mode select 3.3V No Hi-Z D10 1 TX0 - Not usable during Serial transmission D4 2 Boot mode select TX1 3.3V (boot only) Don\u2019t connect to ground at boot time Sends debug data at boot time D9 3 RX0 - Not usable during Serial transmission D2 4 SDA (I\u00b2C) - - D1 5 SCL (I\u00b2C) - - x 6 - 8 Flash connection x Not usable, and not broken out x 9, 10 Flash connection * Only available on the ESP8285 x 11 Flash connection x Not usable, and not broken out D6 12 MISO (SPI) - - D7 13 MOSI (SPI) - - D5 14 SCK (SPI) - - D8 15 SS (SPI) 0V Pull-up resistor not usable (extern pull down resistor) D0 16 Wake up from sleep - No pull-up resistor, but pull-down instead Should be connected to RST to wake up","title":"Expanding Tasmota"},{"location":"Expanding-Tasmota/#examples","text":"","title":"Examples"},{"location":"Expanding-Tasmota/#electrical-considerations","text":"When you switch a GPIO pin to an input and hang a long wire off of it, that wire can pick up stray signals and cause the voltage on the GPIO pin to vary. This can cause the system to think the switch has changed. To fix this, there are several things you can do. add a pull-up resistor add a bypass capacitor shielding on the wire use twisted pair wiring A pull-up resistor is a resistor connected between the GPIO pin and 3.3v. The exact value of this is not critical, 4.7k is a common value to use, as is 10k. This ensures that when the switch it open, the GPIO pin will go high. A bypass capacitor is a small (pF range) capacitor that is connected between the GPIO and ground. This provides a path for any radio signals that are picked up by the wire to go to ground and not confuse the system. Shielding or using twisted pair wiring are other ways to reduce the effect of radio signals on the system. Example for 10K Resistor (issue #2708 )","title":"Electrical Considerations"},{"location":"Expanding-Tasmota/#the-esp8266-hardware","text":"Complete document available from https://tttapa.github.io/ESP8266/Chap04%20-%20Microcontroller.html","title":"The ESP8266 Hardware"},{"location":"Expanding-Tasmota/#digital-io","text":"Just like a normal Arduino, the ESP8266 has digital input/output pins (I/O or GPIO, General Purpose Input/Output pins). As the name implies, they can be used as digital inputs to read a digital voltage, or as digital outputs to output either 0V (sink current) or 3.3V (source current).","title":"Digital I/O"},{"location":"Expanding-Tasmota/#usable-pins","text":"The ESP8266 and ESP8255 have 17 GPIO pins (0-16) but several are reserved or have constraints . Do not use any of the reserved pins. If you do, you might crash your program. On the ESP8266, six pins (GPIO 6 - 11) are used to interface the flash memory (the small 8-legged chip usually right next to the ESP8266). The ESP8255 has its flash memory integrated into the chip which frees up GPIO 9 and 10. GPIO 1 and 3 are used as TX and RX of the hardware Serial port (UART), so in most cases, you can\u2019t use them as normal I/O while sending/receiving serial data.","title":"Usable pins"},{"location":"Expanding-Tasmota/#boot-modes","text":"Some I/O pins have a special function during boot: They select 1 of 3 boot modes: GPIO15 GPIO0 GPIO2 Mode 0V 0V 3.3V Uart Bootloader 0V 3.3V 3.3V Boot sketch (SPI flash) 3.3V x x SDIO mode (not used for Arduino) Note: you don\u2019t have to add an external pull-up resistor to GPIO2, the internal one is enabled at boot. We have to be sure that these conditions are met by adding external resistors, or the board manufacturer of your board has added them for you. This has some implications, however: GPIO15 is always pulled low, so you can\u2019t use the internal pull-up resistor. You have to keep this in mind when using GPIO15 as an input to read a switch or connect it to a device with an open-collector (or open-drain) output, like I\u00b2C. GPIO0 is pulled high during normal operation, so you can\u2019t use it as a Hi-Z input. GPIO2 can\u2019t be low at boot, so you can\u2019t connect a switch to it. Internal pull-up/-down resistors GPIO 0-15 all have a built-in pull-up resistor, just like in an Arduino. GPIO16 has a built-in pull-down resistor.","title":"Boot modes"},{"location":"Expanding-Tasmota/#pwm","text":"Unlike most Atmel chips (Arduino), the ESP8266 doesn\u2019t support hardware PWM, however, software PWM is supported on all digital pins. The default PWM range is 10-bits @ 1kHz, but this can be changed (up to >14-bit@1kHz). Check Restrictions .","title":"PWM"},{"location":"Expanding-Tasmota/#analog-input","text":"The ESP8266 has a single analog input, with an input range of 0 - 1.0V. If you supply 3.3V, for example, you will damage the chip. Some boards like the NodeMCU have an on-board resistive voltage divider, to get an easier 0 - 3.3V range. You could also just use a trimpot as a voltage divider. The ADC (analog to digital converter) has a resolution of 10 bits.","title":"Analog input"},{"location":"Expanding-Tasmota/#communication","text":"","title":"Communication"},{"location":"Expanding-Tasmota/#serial","text":"The ESP8266 has two hardware UARTS (Serial ports): UART0 on pins 1 and 3 (TX0 and RX0 resp.), and UART1 on pins 2 and 8 (TX1 and RX1 resp.), however, GPIO8 is used to connect the flash chip. This means that UART1 can only transmit data. UART0 also has hardware flow control on pins 15 and 13 (RTS0 and CTS0 resp.). These two pins can also be used as alternative TX0 and RX0 pins.","title":"Serial"},{"location":"Expanding-Tasmota/#i2c","text":"ESP8266 doesn\u2019t have a hardware TWI (Two Wire Interface) but it is implemented in software. This means that you can use pretty much any two digital pins. By default, the I\u00b2C library uses pin 4 as SDA and pin 5 as SCL. (The data sheet specifies GPIO2 as SDA and GPIO14 as SCL.) The maximum speed is approximately 450kHz.","title":"I\u00b2C"},{"location":"Expanding-Tasmota/#spi","text":"The ESP8266 has one SPI connection available to the user, referred to as HSPI. It uses GPIO14 as CLK, 12 as MISO, 13 as MOSI and 15 as Slave Select (SS). It can be used in both Slave and Master mode (in software).","title":"SPI"},{"location":"Expanding-Tasmota/#gpio-overview","text":"NodeMCU Labelled Pin GPIO# Function State Restrictions D3 0 Boot mode select 3.3V No Hi-Z D10 1 TX0 - Not usable during Serial transmission D4 2 Boot mode select TX1 3.3V (boot only) Don\u2019t connect to ground at boot time Sends debug data at boot time D9 3 RX0 - Not usable during Serial transmission D2 4 SDA (I\u00b2C) - - D1 5 SCL (I\u00b2C) - - x 6 - 8 Flash connection x Not usable, and not broken out x 9, 10 Flash connection * Only available on the ESP8285 x 11 Flash connection x Not usable, and not broken out D6 12 MISO (SPI) - - D7 13 MOSI (SPI) - - D5 14 SCK (SPI) - - D8 15 SS (SPI) 0V Pull-up resistor not usable (extern pull down resistor) D0 16 Wake up from sleep - No pull-up resistor, but pull-down instead Should be connected to RST to wake up","title":"GPIO overview"},{"location":"FAQ/","text":"Wi-Fi ~ Cannot connect to Wi-Fi ~ If your device does not connect to your Wi-Fi and you've made sure the Wi-Fi credentials are correct, it is caused by using special chars or white spaces in your SSID or Password of your Wi-Fi. Remove them and try again. Other reason can be using an SSID longer than the allowed 32 characters. With some Wi-Fi routers (i.e. Linksys with DD-WRT), you may have conflicts with the 5GHz radio. Don't choose \"Mixed\" option. Select \"AC/N-Mixed\" instead. Moreover, you probably should disconnect 5GHz radio during the configuration process. DD-WRT also has Wi-Fi Multi-Media (WMM) enabled by default. Disabling WMM can resolve connectivity issues. I entered wrong Wi-Fi information ~ If you have a device with a button and the button is configured as a component in the Tasmota settings (e.g., GPIO0 - Button1), you can try pressing the button to force the device into Wi-Fi configuration mode with 4 short presses of the button. Note: Since version 8.3.0 this requires 6 short presses instead. If that didn't work reset your device using Fast power cycle device recovery If you are unsure what SSID you have entered, you can try to find that with special Wi-Fi sniffing tools. For example Nirsoft WifiChannelMonitor can show your mistakenly configured SSID name. Linux system example: apt install aircrack-ng wireshark airmon-ng check kill airmon-ng start (e.g. wlp58s0 or wlan0) wireshark Select your Wi-Fi device from the list. Plug in the mis-configured device and immediately watch SSIDs. You should see your mis-configured SSID fairly soon. If these methods don't work, it may still be possible to save the device without opening it to perform a serial flash. Since Tasmota uses GET request for forms, the password may be in your browser history. Search in your browser history for 192.168.4.1 (or whatever address you used for configuring it) There should be an entry similar to this: http://192.168.4.1/wi?s1=<mySSID>&p1=<myPassword>-********&s2=&p2=********&h=hostName&save= s1 is your first AP SSID p1 is the first AP password s2 and p2 are the same parameters but for the second AP h is the hostname given to the device by the Tasmota configuration After getting the incorrectly entered configuration from this URL, configure an access point with these settings as described above Access your device and set the correct Wi-Fi credentials If you flashed a light bulb or any device without a built-in button and entered wrong Wi-Fi password you now have a device that won't connect to your Wi-Fi and you have no button to force it into Wi-Fi configuration mode. This tip takes advantage of a security risk present in Arduino Cores prior to 2.6.0. It will not work with Tasmota binaries compiled with 2.6.0 or later. To solve this you can try creating a new Wi-Fi AP with the same SSID and no (none) authentication. Use an old router, a mobile phone or, if you're desperate, change the settings on your main router (but remember to turn authentication back on when you're done). Depending on the router/phone it will ignore the wrong Wi-Fi password since authentication is set to none and let your Tasmota flashed device connect to it. Now simply connect to the same AP and open the web UI, triple check your ssid and password, enter some simple info for SSID2 which you can create as a hotspot on your phone and save. Device disconnects from Wi-Fi often ~ First thing to try when having Wi-Fi issues: Reset 3 which will erase wi-fi calibration data only and will keep configuration intact. Make sure to power cycle restart after that. If that doesn't help try rebooting the router as well As a last resort try : Erase all flash using esptool.py or esptool.exe and flash via serial (as explained here ) using the latest precompiled binaries . This approach has solved many of the reported issues. Sometimes this is due to a bad flash, a bad OTA or invalid data that remains in the flash where the SDK memory is. If you still have issues, you should look into your Wi-Fi network: Some new routers have many modern features enabled with default which don't work well with the old ESP82xx chip. Disable any channel surfing, band changing and similar features. Check the Wi-Fi channel availability and noise with an Android app like Wi-Fi Analyzer. Disable Auto Channel in your Wi-Fi router and select any Wi-Fi channel that is not very congested in your area. Disable Wi-Fi Repeaters and Mesh Networks. Check Wi-Fi signal in your device. The same Mesh may be stable in one area and lead to unwanted Tasmota reconnects in other areas, presumably when the signals of access points overlap with similar strength. If disabling Mesh Networks is not an option, then keeping the network busy, e.g. by issuing a Ping from another host every 20 seconds has helped to avoid the reconnects. Wi-Fi Stops Working ~ There have been many reports of Wi-Fi no longer working after it was working for a while. Every time this has been reported, it's ended up being a hardware or signal interference problem. On the hardware side, we've seen reports of bad solder joints on the board that when touched up seem to solve the problem (capacitors being loose can cause this) or low quality/weak power supplies or voltage regulators that cannot cope with the power requirements of Tasmota or have degraded over time. We've also seen reports then when a specific LED light bulb was hooked up near one, the signal quality dropped to unusable. All you can really do is check the solder joints, move the device closer to your Access Point. If all else fails, replace the device. Weaker Wi-Fi signal after upgrade ~ On an ESP82xx, Wi-Fi calibration is sensitive to the power supplied. If this changes substantially (e.g., you add a sensor, configure a new Tasmota feature, upgrade the firmware or Arduino Core, etc.), the device's Wi-Fi calibration may not be set properly any longer. The Wi-Fi signal strength (RSSI) can drop significantly and impact Wi-Fi performance. In such a case, the Wi-Fi calibration needs to be deleted to force the device to re-calibrate Wi-Fi after it restarts. Run Reset 3 in the Console. The device will restart Cycle the power on the device. Wi-Fi calibration will not be done unless the device performs a cold boot from power up. WebUI unavailable but device can be controlled ~ Some routers have issues with ARP implementation. To help with that use SetOption41 to make your device send grauitous ARP in a desired interval (try 30 or 60 seconds for start). MQTT ~ Cannot connect to my MQTT broker ~ Make sure you've configured MQTT correctly. If that didn't solve the issue check your MQTT broker logs. Most likely problem is your broker doesn't allow logins for your Tasmota configure user and password or your ACL settings do not include your device. In some very specific cases the MQTT broker code clashes with the Arduino Core and doesn't allow a connection. In that case create a different user for your device, try another core binary or a different MQTT broker. Frequent MQTT reconnects ~ Most MQTT reconnect messages are linked with Wi-Fi instability first. Resolve any Wi-Fi issue first! If the console shows repeated messages like: 02 : 32 : 54 MQTT : tele /MYSONOFF/ LWT = Online ( retained ) 02 : 32 : 54 MQTT : cmnd /MYSONOFF/ POWER = 02 : 32 : 55 MQTT : Attempting connection ... 02 : 32 : 56 mDNS : Query done with 0 mqtt services found 02 : 32 : 56 MQTT : Connected or your mosquitto broker log shows messages like this - 1496455347 : New client connected from IP_addr_1 as SONOFF ( c1 , k15 , u 'SONOFF_USER' ). 1496455349 : New connection from IP_addr_1 on port 1883 . 1496455349 : Client SONOFF already connected , closing old connection . 1496455349 : Client SONOFF disconnected . 1496455349 : New client connected from IP_addr_2 as SONOFF ( c1 , k15 , u 'SONOFF_USER' ). 1496455350 : New connection from IP_addr_2 on port 1883 . 1496455350 : Client SONOFF already connected , closing old connection . 1496455350 : Client SONOFF disconnected . You have more than one device connected with the same %topic% defined. Its important that each device has a unique %topic% instead of the default sonoff . If that is not the issue, erase all flash using esptool.py or esptool.exe and flash again by wire (as explained here ) using the latest precompiled bins with core v2.7.1 . Configuration ~ Device reset to defaults on its own ~ Bad power supply Most common culprit is Power Cycle Recovery which can be activated if the device has a bad power supply or your power grid has fluctuations/brownouts. Disable the feature with SetOption65 1 Button in ON state when depressed If a button is configure to be in ON state when depressed it will activate \"Firmware Reset\" feature. Either change the button mode or use SetOption1 1 to disable factory reset mode. Frequent reboots/bootloops Your device may be in a boot loop - a restart caused by any exception or watchdog timer within less than BOOT_LOOP_TIME ( default 10 seconds ). The number of boot loops allowed before beginning to reset settings is determined by SetOption36 . When Tasmota reaches this situation, it will begin restoring default settings as follows: 1 st restart: disable ESP8285 generic GPIOs interfering with flash SPI 2 nd restart: disable rules causing boot loop 3 rd restart: disable all rules 4 th restart: reset user defined GPIOs to disable any attached peripherals 5 th restart: reset module to Sonoff Basic (1) Relay clicks and LED flashes at 1 second intervals ~ This indicates that your device did not get flashed properly. In this case it will toggle all it's pins at 1 sec intervals. A flash erase and a new flash is required. Status LED blinking ~ Your device status LED blinks repeatedly when Wi-Fi and/or MQTT is not connected. If you're not using MQTT and did not configure it the status LED will still keep blinking. You can disable status LED blinking using: Backlog LedPower 0; SetOption31 1 My device randomly switches on and off. Do I have ghosts in my house? ~ Most of the issues with random, or \"ghost\", switching are related to MQTT retain settings. In short, your MQTT broker is retaining a message with the POWER status of the device which gets applied on reboots. Solution here In some cases, adding a switch to a device causes ghost switching. In this case, you may need to add a low pass filter to dampen any spikes on the input. In the case of the Sonoff T1, a modification to change the filter capacitor on the PCB may be required. This short 10 minute video by TheHookUp nicely explains what it is and how to prevent it. Other cause can be of electrical nature. If you have connected an external switch using long wires they can pick up stray signals and cause the voltage on the GPIO to vary. Solution here Cannot find my device in Modules ~ If you flashed a device which is not listed in the Modules list, use Templates to configure your device. Try looking for it first in the Templates Repository . Device keeps restarting after changing config over MQTT ~ If you changed configurations over MQTT, the command can fail due to a bug and the command is repeatedly sent, causing the device to restart. The restart is normal if you change something at the device configuration. You need to clear the retain messages of your HA/Broker/MQTT Server. Read also: #2140 #2658 (comment) #2716 Tasmota is sending many status updates every 5 seconds ~ Turn off TasmoAdmin ! It is polling your device with STATUS 0 command with a HTTP request every 5 seconds which causes the status updates and unnecessary stress load on the device. In some cases it might even interfere with normal device operation. Web Interface Asks for Password ~ You modified the Web Admin password ( Configure Other ) and now you cannot access the web interface. You have set up a password for the web interface. You can login with the username admin and the password you entered. However, if you don't remember that password there are a few options you can try to gain access to the web interface again. Reset the password using the WebPassword command. If you have serial connection to the device: Execute WebPassword 0 using a serial terminal interface. If you have configured MQTT: Send 0 to cmnd/<device-topic>/WebPassword . You can send it from any MQTT client . You can also use another Tasmota device using the Publish command - Execute Publish cmnd/<device-topic>/WebPassword 0 from that device's Console. If the options above are not available: Since Tasmota uses GET request for forms, the password may be in your browser history. Look there for entries with the name you configured for the device. For example, in the following link: http://<device-ip>/co?t1={\"NAME\":\"Generic\"'\"GPIO\":[23'22'24'17'134'132'0'0'131'52'21'0'0]'\"FLAG\":0'\"BASE\":67}&p1=SecretPassword&b1=on&a1=Sonoff&a2=Sonoff2&a3=Sonoff3&a4=Sonoff4&b2=0&save= the p1 parameter contains the password for the web interface ( SecretPassword in this case). Note: special characters may appear as the characters' corresponding ASCII hexadecimal codes (e.g., \"{\" = '\\%7B', etc.) If you had set up WifiConfig 7 as your Wi-Fi fallback method (by previously executing WiFiConfig in the Console), you can reset the device by booting it into Wi-Fi Manager mode. If the SSID configured in the device is not available (e.g., turn off the router), the device will fallback to that restricted Wi-Fi Manager Mode. If your device has a physical push-button, reset the firmware to the default settings as detailed here . If nothing helps, then you have to flash the firmware again using the serial interface. Be sure to erase the flash memory before uploading the binary. Power monitoring shows wrong values ~ If the values shown in the Web UI don't seem right and you're using a Supported Module you need to calibrate the power monitoring sensor . In case you're using a template you created yourself or found in our Templates Repository try the calibration method first. If the values are still wrong or unrealistic the power monitoring sensors' GPIOs are not configured correctly and you will need to find the correct GPIO assignments before proceeding. Sensors do not show values ~ Make sure your sensor is properly wired and the GPIOs assigned. Your vanilla tasmota.bin doesn't have complete sensor support. Make sure you've installed tasmota-sensors.bin that support the largest number of sensors. Some sensors require enabling in the code and compiling your own binary. See Builds for a comprehensive list of supported components. Timers trigger at the wrong time ~ Tasmota devices must have a their time of day set properly in order for any timers to work properly. Check the log in the web UI Console to see if the device's time is set correctly. There are two elements to setting the time: 1. obtaining the UTC time, and, 2. local Daylight Saving Time policies. There are three methods available to set the device time: 1. NTP , 2. An RTC peripheral , or 3. the Time command. The typical method Tasmota uses to set its time is to obtain the time from an Internet NTP server. It can also query an NTP server on its local network (e.g., a network router with an NTP service, a Raspberry Pi running the NTP daemon, the Chrony add-on in Home Assistant, etc.). Check the information about your router's features. If the router provides an NTP server, be sure to configure it properly. If the Tasmota device receives its IP address via DHCP from the router, Tasmota will request its time sync from the router's time server. This is managed by the Arduino core, not Tasmota ( #5283 ). Therefore, if the NTP server on the router is not configured, or configured improperly, the time on the Tasmota device could be wrong. If the router does not have a time server, this is not the problem. If you cannot configure your router's time server to the correct time (e.g., a router provided by your ISP with no access to administration functions), you will need to set a static IP address on the Tasmota device. If the device does not request its address from a DHCP server (i.e., uses a static IP address), the time sync request is forced to NTPSERVER1 . If can't connect, it tries NTPSERVER2 . And finally NTPSERVER3 . Ensure that these parameters are set appropriately and that the device can reach at least one of these time servers. You may want to consider setting up an NTP server locally. As long as the computer is able to set its time at some point from an Internet time server, this computer can serve as an NTP server for your Tasmota device(s). This can be the same computer that hosts your MQTT broker or home automation hub. You must also set the TimeZone and Daylight Saving Time policies ( TimeDST / TimeSTD ). If you have timers that use the sunset or sunrise times, you must set your latitude and longitude in order for these times to be calculated correctly for your location. Auto-discovery in Home Assistant does not work ~ The tasmota-lite.bin firmware binary (which comes packaged with Tuya-Convert) does not support auto-discovery. Please upgrade to tasmota.bin or a similar firmware variant that supports this feature. Make sure its enabled in Tasmota it with SetOption19 1 and you configured the Home Assistant MQTT integration with Discovery enabled. Why is my changed configuration not loaded? ~ If you have flashed a precompiled binary, be aware that all the configuration made after the flash (Wi-Fi, MQTT, topics, names, rules, etc) will be lost in a factory firmware reset. In short : The CFG_HOLDER is the place where the config is stored on your device. The device checks if a config is saved in this CFG_HOLDER (value from the my_user_config.h) and always loads this if exists. => won't load new applied configs in your my_user_config.h To get the new config on your device, you need to change the CFG_HOLDER. BUT: You should always try to stay on the default CFG_HOLDER, to reach this, you need to flash two times change your config in the my_user_config.h or better user_config_override.h change the CFG_HOLDER number. +1 or -1 is enough (e.g. 0x20161208) flash change the CFG_HOLDER back to default ( 0x20161209 ) flash again After this, your new config is saved in the default CFG_HOLDER on your device. This is necessary to avoid losing your config if you update to a new firmware by using the pre-build images or if you forget to change the CFG_HOLDER to your custom one if you build the firmware yourself. How CFG_HOLDER works : The config of your Tasmota is stored in an area of the flash memory (flash config area or FCA ). Using a new device (where Tasmota firmware runs the first time) the FCA does not contain a Tasmota configuration so on the very first start of Tasmota it uses your settings from my_user_config.h or user_config_override.h and copy this into the FCA. To prevent that the following Tasmota starts will overwrite your FCA settings again (e.g. because you has changed some things using commands) the FCA will be marked by a header value to indicate not copy the values from my_user_config.h / user_config_override.h again. This header becomes the value from CFG_HOLDER. On every start the device compares the header of FCA with the CFG_HOLDER from your source code and only if this header value is not identical, Tasmotat will copy the data from my_user_config.h/user_config_override.h to flash settings area - this is normally only the case on a fresh device or if you has changed the CFG_HOLDER value. Summary : To force Tasmota to overwrite current (valid or invalid) settings in FCA with your settings from my_user_config.h / user_config_override.h you can change CFG_HOLDER value once, compile, reflash device (as described above). To avoid overwriting settings by new versions don't forget either repeat the step above using original CFG_HOLDER value or never forget to change CFG_HOLDER value for even all upcoming version to your value or use the command Reset 1 or Reset 2 after changes in your my_user_config.h / user_config_override.h without the need to double reflash your device and/or double change your CFG_HOLDER value: change values in my_user_config.h / user_config_override.h leave CFG_HOLDER as is start your device and issue command Reset 1 or Reset 2 How do I invert the output of the green LED on the Sonoff Basic so the LED is on when the relay is off? ~ LedState default value is 1 (on) - Show power state on LED. The LED can be disabled completely with LedState 0 (off). However, there is no option to invert the output of the green LED on the Sonoff Basic. Flashing ~ Cannot enter flash mode ~ Be sure to press the button correctly, you must \"feel\" a click. If your on-device button doesn't allow you to enter flash mode or there is no GPIO0 broken out to the PCB, you can always bridge GND to GPIO0 pin directly on the chip. Search on the Internet for your chip's pinouts and use the tutorial . Be sure to keep GPIO0 grounded long enough (3-5 seconds) before disconnecting to ensure the chip has booted completely into programming mode. On devices that do not provide a GPIO0 connected button, it may be easier to leave the wired bridge in place throughout the entire flashing process (erase & upload). Doing so will not create any problems for flashing the device. After the firmware is uploaded successfully, remove the bridge. This allows the device to boot normally. Flashing issues ~ Double check if you wired the device the serial-to-USB adapter correctly. Almost every device needs RX and TX pins switched to TX and RX. See Hardware Preparation for more. Another common problem are the jumper cables used. Try another cable if you keep getting connection errors or check the cables for connectivity. Most of them are made cheaply and it happens quite often that those cables do not offer a good connection because of bad crimping or broken copper lines in them. Be sure to use a USB Data Cable and not a cheap loading cable for mobile phones for connecting the serial-to-USB adapter to your computer. If you are unsure, just try another USB cable. Data USB cables are often thicker than the normal loading cables (and more expensive). Another problem can be the difficulties in getting the ESP chip into programming mode when it boots. If the flash still fails or the progress interrupts, it could be that your computer or serial-to-USB adapter doesn't provide enough power to the device. Try another computer or use an external power supply (3.3V one). More infos about insufficient power Use the correct serial-to-USB adapter driver. Check the model of your adapter chip and get the correct driver. If the flash completes successfully, but you get a hash mismatch (esptool.py error message A fatal error occurred: MD5 of file does not match data in flash! ) ensure that your 3.3v current is sufficient. Workarounds include using a dedicated bread board power supply or using the 3.3v output of an additional microcontroller. If using an additional power supply to power the device, be sure to use a common ground for the power supply, the device to be flashed and the serial-to-USB adapter. If esptool.py stops at \"Uploading stub...\", use --no-stub If the flash fails or the device does not operate as expected, try using the default ESP82xx boot ROM baud rate - 74880 . This is the baud rate the ESP82xx is set to by default when it boots into programming mode. It can be specified as a command line option in esptool.py ( -b ) and esptool.exe ( -cb ). You may also want to select a serial monitor/terminal capable of setting this \"unusual\" baud rate. In Termite, type this value ( 74880 ) in the baud rate selection text box when configuring the port. Having the option to specify this unusual baud rate will allow you to view the ESP8266 boot ROM log while the device is booting. Device is hot to the touch ~ Remember - NEVER EVER FLASH WITH 5V! ? Better unpower your device and check if the wiring is correct and the voltage is on your FTDI is set to 3.3V. If you've connected VCC to the wrong pin it might cause your device to overheat and destroy it. There was white smoke and the device does not work anymore! ~ Yes, you've released the fabled \"white smoke\", the mysterious substance all electronic devices work on. In the immortal words of Doctor Bones: It's dead Jim! Sonoff 4CH V2 / Sonoff Dual V2 will not flash ~ Testing with two different (fairly new) FTDI boards and two Sonoff 4CH v2.0 and the Sonoff Dual v2.0 boards I found that I was getting errors uploading sketches i.e. \"warning: espcomm_sync failed\" basically a lack of communication between the two devices. I found that the problem in both Sonoff's was that instead of the FTDI Sonoff cross-over TX->RX and RX->TX I had to do TX->TX RX->RX this then allowed me to upload the sketch. Flashing fails on MacOS High Sierra ~ Related to issue #957 . Solution: Install the VCP drivers for Mac from the FTDI website After install, reboot (it does not work if you do not reboot). After reboot, plug the FTDI USB/serial converter. Accept the security alert from MacOS. Restart the flash process. It works! Miscellaneous ~ Can you add this unsupported sensor to Tasmota ~ Short answer: NO! Long answer: There is not enough time in our coders lives to take requests, if you can code a driver for that sensor and submit a PR it will be considered, otherwise you can only wait for someone else to do it. Available Characters for HOSTNAME ~ 24 chars max only a..z A..Z 0..9 '-' no '-' as last char RFC952 ASSUMPTIONS A \"name\" (Net, Host, Gateway, or Domain name) is a text string up to 24 characters drawn from the alphabet (A-Z), digits (0-9), minus sign (-), and period (.). Note that periods are only allowed when they serve to delimit components of \"domain style names\". (See RFC-921, \"Domain Name System Implementation Schedule\", for background). No blank or space characters are permitted as part of a name. No distinction is made between upper and lower case. The first character must be an alpha character. The last character must not be a minus sign or period. A host which serves as a GATEWAY should have \"-GATEWAY\" or \"-GW\" as part of its name. Hosts which do not serve as Internet gateways should not use \"-GATEWAY\" and \"-GW\" as part of their names. A host which is a TAC should have \"-TAC\" as the last part of its host name, if it is a DoD host. Single character names or nicknames are not allowed. Flash Memory Considerations ~ To stop saving parameter changes to Flash or Spiffs use command SaveData off . To stop saving power changes only to Flash or Spiffs use command SetOption0 off . This will disable the relay from returning to the same state after power on UNLESS you use the MQTT retain flag in which case the MQTT broker will send the last known MQTT state on restart or power on. The command ButtonRetain on will configure the button to send a MQTT command with Topic and the MQTT retain flag set. What is an Arduino Core ~ Arduino Core (open source) are the core libraries for ESP8266/ESP8285 chips to make them Arduino Framework Compatible. This Core is programmed on top of the Espressif SDK (closed source). Tasmota is only using the core and does not maintain it or can help in solving issues with it. You can see the Arduino Core Version and the Espressif SDK Version on the Tasmota WebUI under the Information Menu entry. I Cannot Find An Answer Here! ~ Check the Troubleshooting section or join Discord , Telegram , Reddit or Google Groups for assistance from other Tasmota users.","title":"FAQ"},{"location":"FAQ/#wi-fi","text":"","title":"Wi-Fi"},{"location":"FAQ/#cannot-connect-to-wi-fi","text":"If your device does not connect to your Wi-Fi and you've made sure the Wi-Fi credentials are correct, it is caused by using special chars or white spaces in your SSID or Password of your Wi-Fi. Remove them and try again. Other reason can be using an SSID longer than the allowed 32 characters. With some Wi-Fi routers (i.e. Linksys with DD-WRT), you may have conflicts with the 5GHz radio. Don't choose \"Mixed\" option. Select \"AC/N-Mixed\" instead. Moreover, you probably should disconnect 5GHz radio during the configuration process. DD-WRT also has Wi-Fi Multi-Media (WMM) enabled by default. Disabling WMM can resolve connectivity issues.","title":"Cannot connect to Wi-Fi"},{"location":"FAQ/#i-entered-wrong-wi-fi-information","text":"If you have a device with a button and the button is configured as a component in the Tasmota settings (e.g., GPIO0 - Button1), you can try pressing the button to force the device into Wi-Fi configuration mode with 4 short presses of the button. Note: Since version 8.3.0 this requires 6 short presses instead. If that didn't work reset your device using Fast power cycle device recovery If you are unsure what SSID you have entered, you can try to find that with special Wi-Fi sniffing tools. For example Nirsoft WifiChannelMonitor can show your mistakenly configured SSID name. Linux system example: apt install aircrack-ng wireshark airmon-ng check kill airmon-ng start (e.g. wlp58s0 or wlan0) wireshark Select your Wi-Fi device from the list. Plug in the mis-configured device and immediately watch SSIDs. You should see your mis-configured SSID fairly soon. If these methods don't work, it may still be possible to save the device without opening it to perform a serial flash. Since Tasmota uses GET request for forms, the password may be in your browser history. Search in your browser history for 192.168.4.1 (or whatever address you used for configuring it) There should be an entry similar to this: http://192.168.4.1/wi?s1=<mySSID>&p1=<myPassword>-********&s2=&p2=********&h=hostName&save= s1 is your first AP SSID p1 is the first AP password s2 and p2 are the same parameters but for the second AP h is the hostname given to the device by the Tasmota configuration After getting the incorrectly entered configuration from this URL, configure an access point with these settings as described above Access your device and set the correct Wi-Fi credentials If you flashed a light bulb or any device without a built-in button and entered wrong Wi-Fi password you now have a device that won't connect to your Wi-Fi and you have no button to force it into Wi-Fi configuration mode. This tip takes advantage of a security risk present in Arduino Cores prior to 2.6.0. It will not work with Tasmota binaries compiled with 2.6.0 or later. To solve this you can try creating a new Wi-Fi AP with the same SSID and no (none) authentication. Use an old router, a mobile phone or, if you're desperate, change the settings on your main router (but remember to turn authentication back on when you're done). Depending on the router/phone it will ignore the wrong Wi-Fi password since authentication is set to none and let your Tasmota flashed device connect to it. Now simply connect to the same AP and open the web UI, triple check your ssid and password, enter some simple info for SSID2 which you can create as a hotspot on your phone and save.","title":"I entered wrong Wi-Fi information"},{"location":"FAQ/#device-disconnects-from-wi-fi-often","text":"First thing to try when having Wi-Fi issues: Reset 3 which will erase wi-fi calibration data only and will keep configuration intact. Make sure to power cycle restart after that. If that doesn't help try rebooting the router as well As a last resort try : Erase all flash using esptool.py or esptool.exe and flash via serial (as explained here ) using the latest precompiled binaries . This approach has solved many of the reported issues. Sometimes this is due to a bad flash, a bad OTA or invalid data that remains in the flash where the SDK memory is. If you still have issues, you should look into your Wi-Fi network: Some new routers have many modern features enabled with default which don't work well with the old ESP82xx chip. Disable any channel surfing, band changing and similar features. Check the Wi-Fi channel availability and noise with an Android app like Wi-Fi Analyzer. Disable Auto Channel in your Wi-Fi router and select any Wi-Fi channel that is not very congested in your area. Disable Wi-Fi Repeaters and Mesh Networks. Check Wi-Fi signal in your device. The same Mesh may be stable in one area and lead to unwanted Tasmota reconnects in other areas, presumably when the signals of access points overlap with similar strength. If disabling Mesh Networks is not an option, then keeping the network busy, e.g. by issuing a Ping from another host every 20 seconds has helped to avoid the reconnects.","title":"Device disconnects from Wi-Fi often"},{"location":"FAQ/#wi-fi-stops-working","text":"There have been many reports of Wi-Fi no longer working after it was working for a while. Every time this has been reported, it's ended up being a hardware or signal interference problem. On the hardware side, we've seen reports of bad solder joints on the board that when touched up seem to solve the problem (capacitors being loose can cause this) or low quality/weak power supplies or voltage regulators that cannot cope with the power requirements of Tasmota or have degraded over time. We've also seen reports then when a specific LED light bulb was hooked up near one, the signal quality dropped to unusable. All you can really do is check the solder joints, move the device closer to your Access Point. If all else fails, replace the device.","title":"Wi-Fi Stops Working"},{"location":"FAQ/#weaker-wi-fi-signal-after-upgrade","text":"On an ESP82xx, Wi-Fi calibration is sensitive to the power supplied. If this changes substantially (e.g., you add a sensor, configure a new Tasmota feature, upgrade the firmware or Arduino Core, etc.), the device's Wi-Fi calibration may not be set properly any longer. The Wi-Fi signal strength (RSSI) can drop significantly and impact Wi-Fi performance. In such a case, the Wi-Fi calibration needs to be deleted to force the device to re-calibrate Wi-Fi after it restarts. Run Reset 3 in the Console. The device will restart Cycle the power on the device. Wi-Fi calibration will not be done unless the device performs a cold boot from power up.","title":"Weaker Wi-Fi signal after upgrade"},{"location":"FAQ/#webui-unavailable-but-device-can-be-controlled","text":"Some routers have issues with ARP implementation. To help with that use SetOption41 to make your device send grauitous ARP in a desired interval (try 30 or 60 seconds for start).","title":"WebUI unavailable but device can be controlled"},{"location":"FAQ/#mqtt","text":"","title":"MQTT"},{"location":"FAQ/#cannot-connect-to-my-mqtt-broker","text":"Make sure you've configured MQTT correctly. If that didn't solve the issue check your MQTT broker logs. Most likely problem is your broker doesn't allow logins for your Tasmota configure user and password or your ACL settings do not include your device. In some very specific cases the MQTT broker code clashes with the Arduino Core and doesn't allow a connection. In that case create a different user for your device, try another core binary or a different MQTT broker.","title":"Cannot connect to my MQTT broker"},{"location":"FAQ/#frequent-mqtt-reconnects","text":"Most MQTT reconnect messages are linked with Wi-Fi instability first. Resolve any Wi-Fi issue first! If the console shows repeated messages like: 02 : 32 : 54 MQTT : tele /MYSONOFF/ LWT = Online ( retained ) 02 : 32 : 54 MQTT : cmnd /MYSONOFF/ POWER = 02 : 32 : 55 MQTT : Attempting connection ... 02 : 32 : 56 mDNS : Query done with 0 mqtt services found 02 : 32 : 56 MQTT : Connected or your mosquitto broker log shows messages like this - 1496455347 : New client connected from IP_addr_1 as SONOFF ( c1 , k15 , u 'SONOFF_USER' ). 1496455349 : New connection from IP_addr_1 on port 1883 . 1496455349 : Client SONOFF already connected , closing old connection . 1496455349 : Client SONOFF disconnected . 1496455349 : New client connected from IP_addr_2 as SONOFF ( c1 , k15 , u 'SONOFF_USER' ). 1496455350 : New connection from IP_addr_2 on port 1883 . 1496455350 : Client SONOFF already connected , closing old connection . 1496455350 : Client SONOFF disconnected . You have more than one device connected with the same %topic% defined. Its important that each device has a unique %topic% instead of the default sonoff . If that is not the issue, erase all flash using esptool.py or esptool.exe and flash again by wire (as explained here ) using the latest precompiled bins with core v2.7.1 .","title":"Frequent MQTT reconnects"},{"location":"FAQ/#configuration","text":"","title":"Configuration"},{"location":"FAQ/#device-reset-to-defaults-on-its-own","text":"","title":"Device reset to defaults on its own"},{"location":"FAQ/#relay-clicks-and-led-flashes-at-1-second-intervals","text":"This indicates that your device did not get flashed properly. In this case it will toggle all it's pins at 1 sec intervals. A flash erase and a new flash is required.","title":"Relay clicks and LED flashes at 1 second intervals"},{"location":"FAQ/#status-led-blinking","text":"Your device status LED blinks repeatedly when Wi-Fi and/or MQTT is not connected. If you're not using MQTT and did not configure it the status LED will still keep blinking. You can disable status LED blinking using: Backlog LedPower 0; SetOption31 1","title":"Status LED blinking"},{"location":"FAQ/#my-device-randomly-switches-on-and-off-do-i-have-ghosts-in-my-house","text":"Most of the issues with random, or \"ghost\", switching are related to MQTT retain settings. In short, your MQTT broker is retaining a message with the POWER status of the device which gets applied on reboots. Solution here In some cases, adding a switch to a device causes ghost switching. In this case, you may need to add a low pass filter to dampen any spikes on the input. In the case of the Sonoff T1, a modification to change the filter capacitor on the PCB may be required. This short 10 minute video by TheHookUp nicely explains what it is and how to prevent it. Other cause can be of electrical nature. If you have connected an external switch using long wires they can pick up stray signals and cause the voltage on the GPIO to vary. Solution here","title":"My device randomly switches on and off. Do I have ghosts in my house?"},{"location":"FAQ/#cannot-find-my-device-in-modules","text":"If you flashed a device which is not listed in the Modules list, use Templates to configure your device. Try looking for it first in the Templates Repository .","title":"Cannot find my device in Modules"},{"location":"FAQ/#device-keeps-restarting-after-changing-config-over-mqtt","text":"If you changed configurations over MQTT, the command can fail due to a bug and the command is repeatedly sent, causing the device to restart. The restart is normal if you change something at the device configuration. You need to clear the retain messages of your HA/Broker/MQTT Server. Read also: #2140 #2658 (comment) #2716","title":"Device keeps restarting after changing config over MQTT"},{"location":"FAQ/#tasmota-is-sending-many-status-updates-every-5-seconds","text":"Turn off TasmoAdmin ! It is polling your device with STATUS 0 command with a HTTP request every 5 seconds which causes the status updates and unnecessary stress load on the device. In some cases it might even interfere with normal device operation.","title":"Tasmota is sending many status updates every 5 seconds"},{"location":"FAQ/#web-interface-asks-for-password","text":"You modified the Web Admin password ( Configure Other ) and now you cannot access the web interface. You have set up a password for the web interface. You can login with the username admin and the password you entered. However, if you don't remember that password there are a few options you can try to gain access to the web interface again. Reset the password using the WebPassword command. If you have serial connection to the device: Execute WebPassword 0 using a serial terminal interface. If you have configured MQTT: Send 0 to cmnd/<device-topic>/WebPassword . You can send it from any MQTT client . You can also use another Tasmota device using the Publish command - Execute Publish cmnd/<device-topic>/WebPassword 0 from that device's Console. If the options above are not available: Since Tasmota uses GET request for forms, the password may be in your browser history. Look there for entries with the name you configured for the device. For example, in the following link: http://<device-ip>/co?t1={\"NAME\":\"Generic\"'\"GPIO\":[23'22'24'17'134'132'0'0'131'52'21'0'0]'\"FLAG\":0'\"BASE\":67}&p1=SecretPassword&b1=on&a1=Sonoff&a2=Sonoff2&a3=Sonoff3&a4=Sonoff4&b2=0&save= the p1 parameter contains the password for the web interface ( SecretPassword in this case). Note: special characters may appear as the characters' corresponding ASCII hexadecimal codes (e.g., \"{\" = '\\%7B', etc.) If you had set up WifiConfig 7 as your Wi-Fi fallback method (by previously executing WiFiConfig in the Console), you can reset the device by booting it into Wi-Fi Manager mode. If the SSID configured in the device is not available (e.g., turn off the router), the device will fallback to that restricted Wi-Fi Manager Mode. If your device has a physical push-button, reset the firmware to the default settings as detailed here . If nothing helps, then you have to flash the firmware again using the serial interface. Be sure to erase the flash memory before uploading the binary.","title":"Web Interface Asks for Password"},{"location":"FAQ/#power-monitoring-shows-wrong-values","text":"If the values shown in the Web UI don't seem right and you're using a Supported Module you need to calibrate the power monitoring sensor . In case you're using a template you created yourself or found in our Templates Repository try the calibration method first. If the values are still wrong or unrealistic the power monitoring sensors' GPIOs are not configured correctly and you will need to find the correct GPIO assignments before proceeding.","title":"Power monitoring shows wrong values"},{"location":"FAQ/#sensors-do-not-show-values","text":"Make sure your sensor is properly wired and the GPIOs assigned. Your vanilla tasmota.bin doesn't have complete sensor support. Make sure you've installed tasmota-sensors.bin that support the largest number of sensors. Some sensors require enabling in the code and compiling your own binary. See Builds for a comprehensive list of supported components.","title":"Sensors do not show values"},{"location":"FAQ/#timers-trigger-at-the-wrong-time","text":"Tasmota devices must have a their time of day set properly in order for any timers to work properly. Check the log in the web UI Console to see if the device's time is set correctly. There are two elements to setting the time: 1. obtaining the UTC time, and, 2. local Daylight Saving Time policies. There are three methods available to set the device time: 1. NTP , 2. An RTC peripheral , or 3. the Time command. The typical method Tasmota uses to set its time is to obtain the time from an Internet NTP server. It can also query an NTP server on its local network (e.g., a network router with an NTP service, a Raspberry Pi running the NTP daemon, the Chrony add-on in Home Assistant, etc.). Check the information about your router's features. If the router provides an NTP server, be sure to configure it properly. If the Tasmota device receives its IP address via DHCP from the router, Tasmota will request its time sync from the router's time server. This is managed by the Arduino core, not Tasmota ( #5283 ). Therefore, if the NTP server on the router is not configured, or configured improperly, the time on the Tasmota device could be wrong. If the router does not have a time server, this is not the problem. If you cannot configure your router's time server to the correct time (e.g., a router provided by your ISP with no access to administration functions), you will need to set a static IP address on the Tasmota device. If the device does not request its address from a DHCP server (i.e., uses a static IP address), the time sync request is forced to NTPSERVER1 . If can't connect, it tries NTPSERVER2 . And finally NTPSERVER3 . Ensure that these parameters are set appropriately and that the device can reach at least one of these time servers. You may want to consider setting up an NTP server locally. As long as the computer is able to set its time at some point from an Internet time server, this computer can serve as an NTP server for your Tasmota device(s). This can be the same computer that hosts your MQTT broker or home automation hub. You must also set the TimeZone and Daylight Saving Time policies ( TimeDST / TimeSTD ). If you have timers that use the sunset or sunrise times, you must set your latitude and longitude in order for these times to be calculated correctly for your location.","title":"Timers trigger at the wrong time"},{"location":"FAQ/#auto-discovery-in-home-assistant-does-not-work","text":"The tasmota-lite.bin firmware binary (which comes packaged with Tuya-Convert) does not support auto-discovery. Please upgrade to tasmota.bin or a similar firmware variant that supports this feature. Make sure its enabled in Tasmota it with SetOption19 1 and you configured the Home Assistant MQTT integration with Discovery enabled.","title":"Auto-discovery in Home Assistant does not work"},{"location":"FAQ/#why-is-my-changed-configuration-not-loaded","text":"If you have flashed a precompiled binary, be aware that all the configuration made after the flash (Wi-Fi, MQTT, topics, names, rules, etc) will be lost in a factory firmware reset. In short : The CFG_HOLDER is the place where the config is stored on your device. The device checks if a config is saved in this CFG_HOLDER (value from the my_user_config.h) and always loads this if exists. => won't load new applied configs in your my_user_config.h To get the new config on your device, you need to change the CFG_HOLDER. BUT: You should always try to stay on the default CFG_HOLDER, to reach this, you need to flash two times change your config in the my_user_config.h or better user_config_override.h change the CFG_HOLDER number. +1 or -1 is enough (e.g. 0x20161208) flash change the CFG_HOLDER back to default ( 0x20161209 ) flash again After this, your new config is saved in the default CFG_HOLDER on your device. This is necessary to avoid losing your config if you update to a new firmware by using the pre-build images or if you forget to change the CFG_HOLDER to your custom one if you build the firmware yourself. How CFG_HOLDER works : The config of your Tasmota is stored in an area of the flash memory (flash config area or FCA ). Using a new device (where Tasmota firmware runs the first time) the FCA does not contain a Tasmota configuration so on the very first start of Tasmota it uses your settings from my_user_config.h or user_config_override.h and copy this into the FCA. To prevent that the following Tasmota starts will overwrite your FCA settings again (e.g. because you has changed some things using commands) the FCA will be marked by a header value to indicate not copy the values from my_user_config.h / user_config_override.h again. This header becomes the value from CFG_HOLDER. On every start the device compares the header of FCA with the CFG_HOLDER from your source code and only if this header value is not identical, Tasmotat will copy the data from my_user_config.h/user_config_override.h to flash settings area - this is normally only the case on a fresh device or if you has changed the CFG_HOLDER value. Summary : To force Tasmota to overwrite current (valid or invalid) settings in FCA with your settings from my_user_config.h / user_config_override.h you can change CFG_HOLDER value once, compile, reflash device (as described above). To avoid overwriting settings by new versions don't forget either repeat the step above using original CFG_HOLDER value or never forget to change CFG_HOLDER value for even all upcoming version to your value or use the command Reset 1 or Reset 2 after changes in your my_user_config.h / user_config_override.h without the need to double reflash your device and/or double change your CFG_HOLDER value: change values in my_user_config.h / user_config_override.h leave CFG_HOLDER as is start your device and issue command Reset 1 or Reset 2","title":"Why is my changed configuration not loaded?"},{"location":"FAQ/#how-do-i-invert-the-output-of-the-green-led-on-the-sonoff-basic-so-the-led-is-on-when-the-relay-is-off","text":"LedState default value is 1 (on) - Show power state on LED. The LED can be disabled completely with LedState 0 (off). However, there is no option to invert the output of the green LED on the Sonoff Basic.","title":"How do I invert the output of the green LED on the Sonoff Basic so the LED is on when the relay is off?"},{"location":"FAQ/#flashing","text":"","title":"Flashing"},{"location":"FAQ/#cannot-enter-flash-mode","text":"Be sure to press the button correctly, you must \"feel\" a click. If your on-device button doesn't allow you to enter flash mode or there is no GPIO0 broken out to the PCB, you can always bridge GND to GPIO0 pin directly on the chip. Search on the Internet for your chip's pinouts and use the tutorial . Be sure to keep GPIO0 grounded long enough (3-5 seconds) before disconnecting to ensure the chip has booted completely into programming mode. On devices that do not provide a GPIO0 connected button, it may be easier to leave the wired bridge in place throughout the entire flashing process (erase & upload). Doing so will not create any problems for flashing the device. After the firmware is uploaded successfully, remove the bridge. This allows the device to boot normally.","title":"Cannot enter flash mode"},{"location":"FAQ/#flashing-issues","text":"Double check if you wired the device the serial-to-USB adapter correctly. Almost every device needs RX and TX pins switched to TX and RX. See Hardware Preparation for more. Another common problem are the jumper cables used. Try another cable if you keep getting connection errors or check the cables for connectivity. Most of them are made cheaply and it happens quite often that those cables do not offer a good connection because of bad crimping or broken copper lines in them. Be sure to use a USB Data Cable and not a cheap loading cable for mobile phones for connecting the serial-to-USB adapter to your computer. If you are unsure, just try another USB cable. Data USB cables are often thicker than the normal loading cables (and more expensive). Another problem can be the difficulties in getting the ESP chip into programming mode when it boots. If the flash still fails or the progress interrupts, it could be that your computer or serial-to-USB adapter doesn't provide enough power to the device. Try another computer or use an external power supply (3.3V one). More infos about insufficient power Use the correct serial-to-USB adapter driver. Check the model of your adapter chip and get the correct driver. If the flash completes successfully, but you get a hash mismatch (esptool.py error message A fatal error occurred: MD5 of file does not match data in flash! ) ensure that your 3.3v current is sufficient. Workarounds include using a dedicated bread board power supply or using the 3.3v output of an additional microcontroller. If using an additional power supply to power the device, be sure to use a common ground for the power supply, the device to be flashed and the serial-to-USB adapter. If esptool.py stops at \"Uploading stub...\", use --no-stub If the flash fails or the device does not operate as expected, try using the default ESP82xx boot ROM baud rate - 74880 . This is the baud rate the ESP82xx is set to by default when it boots into programming mode. It can be specified as a command line option in esptool.py ( -b ) and esptool.exe ( -cb ). You may also want to select a serial monitor/terminal capable of setting this \"unusual\" baud rate. In Termite, type this value ( 74880 ) in the baud rate selection text box when configuring the port. Having the option to specify this unusual baud rate will allow you to view the ESP8266 boot ROM log while the device is booting.","title":"Flashing issues"},{"location":"FAQ/#device-is-hot-to-the-touch","text":"Remember - NEVER EVER FLASH WITH 5V! ? Better unpower your device and check if the wiring is correct and the voltage is on your FTDI is set to 3.3V. If you've connected VCC to the wrong pin it might cause your device to overheat and destroy it.","title":"Device is hot to the touch"},{"location":"FAQ/#there-was-white-smoke-and-the-device-does-not-work-anymore","text":"Yes, you've released the fabled \"white smoke\", the mysterious substance all electronic devices work on. In the immortal words of Doctor Bones: It's dead Jim!","title":"There was white smoke and the device does not work anymore!"},{"location":"FAQ/#sonoff-4ch-v2-sonoff-dual-v2-will-not-flash","text":"Testing with two different (fairly new) FTDI boards and two Sonoff 4CH v2.0 and the Sonoff Dual v2.0 boards I found that I was getting errors uploading sketches i.e. \"warning: espcomm_sync failed\" basically a lack of communication between the two devices. I found that the problem in both Sonoff's was that instead of the FTDI Sonoff cross-over TX->RX and RX->TX I had to do TX->TX RX->RX this then allowed me to upload the sketch.","title":"Sonoff 4CH V2 / Sonoff Dual V2 will not flash"},{"location":"FAQ/#flashing-fails-on-macos-high-sierra","text":"Related to issue #957 . Solution: Install the VCP drivers for Mac from the FTDI website After install, reboot (it does not work if you do not reboot). After reboot, plug the FTDI USB/serial converter. Accept the security alert from MacOS. Restart the flash process. It works!","title":"Flashing fails on MacOS High Sierra"},{"location":"FAQ/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"FAQ/#can-you-add-this-unsupported-sensor-to-tasmota","text":"Short answer: NO! Long answer: There is not enough time in our coders lives to take requests, if you can code a driver for that sensor and submit a PR it will be considered, otherwise you can only wait for someone else to do it.","title":"Can you add this unsupported sensor to Tasmota"},{"location":"FAQ/#available-characters-for-hostname","text":"24 chars max only a..z A..Z 0..9 '-' no '-' as last char RFC952 ASSUMPTIONS A \"name\" (Net, Host, Gateway, or Domain name) is a text string up to 24 characters drawn from the alphabet (A-Z), digits (0-9), minus sign (-), and period (.). Note that periods are only allowed when they serve to delimit components of \"domain style names\". (See RFC-921, \"Domain Name System Implementation Schedule\", for background). No blank or space characters are permitted as part of a name. No distinction is made between upper and lower case. The first character must be an alpha character. The last character must not be a minus sign or period. A host which serves as a GATEWAY should have \"-GATEWAY\" or \"-GW\" as part of its name. Hosts which do not serve as Internet gateways should not use \"-GATEWAY\" and \"-GW\" as part of their names. A host which is a TAC should have \"-TAC\" as the last part of its host name, if it is a DoD host. Single character names or nicknames are not allowed.","title":"Available Characters for HOSTNAME"},{"location":"FAQ/#flash-memory-considerations","text":"To stop saving parameter changes to Flash or Spiffs use command SaveData off . To stop saving power changes only to Flash or Spiffs use command SetOption0 off . This will disable the relay from returning to the same state after power on UNLESS you use the MQTT retain flag in which case the MQTT broker will send the last known MQTT state on restart or power on. The command ButtonRetain on will configure the button to send a MQTT command with Topic and the MQTT retain flag set.","title":"Flash Memory Considerations"},{"location":"FAQ/#what-is-an-arduino-core","text":"Arduino Core (open source) are the core libraries for ESP8266/ESP8285 chips to make them Arduino Framework Compatible. This Core is programmed on top of the Espressif SDK (closed source). Tasmota is only using the core and does not maintain it or can help in solving issues with it. You can see the Arduino Core Version and the Espressif SDK Version on the Tasmota WebUI under the Information Menu entry.","title":"What is an Arduino Core"},{"location":"FAQ/#i-cannot-find-an-answer-here","text":"Check the Troubleshooting section or join Discord , Telegram , Reddit or Google Groups for assistance from other Tasmota users.","title":"I Cannot Find An Answer Here!"},{"location":"Features/","text":"Tasmota contains a myriad of features and supported peripherals (sensors, controllers and similar). Due to the flash size and memory constraints of ESP8266 not all features can be included in precompiled release binaries. To enable some of the features you have to compile your own binary. Each feature with such requirement has a warning with instructions on how to enable it.","title":"Introduction"},{"location":"Flash-Sonoff-using-Raspberry-Pi/","text":"If you don't have a USB-to-TTL serial adapter available, but you have a Raspberry Pi, you can use this procedure for flashing your device. Tutorial (a little outdated) Summarizing the process and needed connections based on the above blog, please refer there for a more detailed explanation Preparation of the Raspberry Pi ~ Install esptool (pip needed) sudo pip install esptool Prepare serial connection. Note: Use the correct serial connection as per your version of the Raspberry Pi. Device Serial Connection RaspberryPi 1/2/3 (BT disabled or miniuart) /dev/ttyAMA0 RaspberryPi 3 /dev/ttyS0 sudo systemctl stop serial-getty@ttyS0.service sudo systemctl disable serial-getty@ttyS0.service sudo cp /boot/cmdline.txt /boot/cmdline.bak (This backups the file ;)) sudo nano /boot/cmdline.txt -> delete \"console=serial0,115200\" option I don\u2019t know if this is necessary, but I did it as it was mentioned here: https://spellfoundry.com/2016/05/29/configuring-gpio-serial-port-raspbian-jessie-including-pi-3/ sudo nano /boot/config.txt -> add the line (at the bottom): enable_uart=1 Please note following overlays setting port to /dev/ttyAMA0 pi3-miniuart-bt pi3-disable-bt Reboot your Pi Connections ~ Connect GND, RX->TX and TX->RX as shown below. If you power the device with the 3.3V power from the RPi it will cause it to reboot when connecting. You can still enter flash mode if you power up the RPi with the 3.3v connected and pressing the connecting GPIO0 to ground (e.g., pressing the button on the Sonoff Basic) simultaneously. It's recommended to use either an external power supply for this or use the 5V GPIO and a 3.3V Voltage Regulator. ( issue #4807 ) Do not connect 3.3V yet! https://www.sigmdel.ca/michel/ha/sonoff/flashing_sonoff_en.html (For RaspberryPi 3 (40 GPIO pins) GND is the last pin on the left, the 39th pin.) This is how it looks in real-life \ud83d\ude06 Flashing the firmware ~ Erase flash memory: Connect 3.3V while button pressed for about 10 seconds to enter flash-mode. Then release and run: ```bash # if using Raspberry Pi 1/2 use # esptool.py --port /dev/ttyAMA0 erase_flash # if using Raspberry Pi 3 use esptool.py --port /dev/ttyS0 erase_flash ``` You should see output like this: bash \u279c ~ esptool.py --port /dev/ttyAMA0 erase_flash esptool.py v2.5.1 Serial port /dev/ttyAMA0 Connecting.... Detecting chip type... ESP8266 Chip is ESP8285 Features: WiFi, Embedded Flash MAC: dc:4f:22:ab:5e:dc Uploading stub... Running stub... Stub running... Erasing flash (this may take a while)... Chip erase completed successfully in 3.3s Hard resetting via RTS pin... \u279c ~ Flash .bin, which you can download from the release-section : Again connect 3.3V while pressing button for 10 seconds. Then release and run: ```bash # if using Raspberry Pi 1/2 use # esptool.py --port /dev/ttyAMA0 write_flash -fm dout 0x0 /path/to/downloaded/tasmota.bin # if using Raspberry Pi 3 use esptool.py --port /dev/ttyS0 write_flash -fm dout 0x0 /path/to/downloaded/tasmota.bin ``` You should see output like this: ```bash \u279c ~ esptool.py --port /dev/ttyAMA0 write_flash -fm dout 0x0 tasmota.bin esptool.py v2.5.1 Serial port /dev/ttyAMA0 Connecting..... Detecting chip type... ESP8266 Chip is ESP8285 Features: WiFi, Embedded Flash MAC: dc:4f:22 5e:dc Uploading stub... Running stub... Stub running... Configuring flash size... Auto-detected Flash size: 1MB Compressed 456000 bytes to 312426... Wrote 456000 bytes (312426 compressed) at 0x00000000 in 29.2 seconds (effective 124.8 kbit/s)... Hash of data verified. Leaving... Hard resetting via RTS pin... \u279c ~ ``` Setup Wi-Fi: Connect with an external device to the sonoff-xxxx Wi-Fi AP and configure over the browser. Alternative: Reboot your device after flashing (toggle power wire) and connect to the serial console via miniterm: ```bash # if using Raspberry Pi 1/2 use # miniterm.py /dev/ttyAMA0 115200 -e # if using Raspberry Pi 3 use miniterm.py /dev/ttyS0 115200 -e ``` You will see some output, after pressing enter. Now just type in, your SSID, press enter and then type the password\u2026 Backlog ssid yourSSID; password yourPassword That\u2019s it ~ Sources: Flashing commands https://spellfoundry.com/2016/05/29/configuring-gpio-serial-port-raspbian-jessie-including-pi-3/","title":"Flash Sonoff using Raspberry Pi"},{"location":"Flash-Sonoff-using-Raspberry-Pi/#preparation-of-the-raspberry-pi","text":"Install esptool (pip needed) sudo pip install esptool Prepare serial connection. Note: Use the correct serial connection as per your version of the Raspberry Pi. Device Serial Connection RaspberryPi 1/2/3 (BT disabled or miniuart) /dev/ttyAMA0 RaspberryPi 3 /dev/ttyS0 sudo systemctl stop serial-getty@ttyS0.service sudo systemctl disable serial-getty@ttyS0.service sudo cp /boot/cmdline.txt /boot/cmdline.bak (This backups the file ;)) sudo nano /boot/cmdline.txt -> delete \"console=serial0,115200\" option I don\u2019t know if this is necessary, but I did it as it was mentioned here: https://spellfoundry.com/2016/05/29/configuring-gpio-serial-port-raspbian-jessie-including-pi-3/ sudo nano /boot/config.txt -> add the line (at the bottom): enable_uart=1 Please note following overlays setting port to /dev/ttyAMA0 pi3-miniuart-bt pi3-disable-bt Reboot your Pi","title":"Preparation of the Raspberry Pi"},{"location":"Flash-Sonoff-using-Raspberry-Pi/#connections","text":"Connect GND, RX->TX and TX->RX as shown below. If you power the device with the 3.3V power from the RPi it will cause it to reboot when connecting. You can still enter flash mode if you power up the RPi with the 3.3v connected and pressing the connecting GPIO0 to ground (e.g., pressing the button on the Sonoff Basic) simultaneously. It's recommended to use either an external power supply for this or use the 5V GPIO and a 3.3V Voltage Regulator. ( issue #4807 ) Do not connect 3.3V yet! https://www.sigmdel.ca/michel/ha/sonoff/flashing_sonoff_en.html (For RaspberryPi 3 (40 GPIO pins) GND is the last pin on the left, the 39th pin.) This is how it looks in real-life \ud83d\ude06","title":"Connections"},{"location":"Flash-Sonoff-using-Raspberry-Pi/#flashing-the-firmware","text":"Erase flash memory: Connect 3.3V while button pressed for about 10 seconds to enter flash-mode. Then release and run: ```bash # if using Raspberry Pi 1/2 use # esptool.py --port /dev/ttyAMA0 erase_flash # if using Raspberry Pi 3 use esptool.py --port /dev/ttyS0 erase_flash ``` You should see output like this: bash \u279c ~ esptool.py --port /dev/ttyAMA0 erase_flash esptool.py v2.5.1 Serial port /dev/ttyAMA0 Connecting.... Detecting chip type... ESP8266 Chip is ESP8285 Features: WiFi, Embedded Flash MAC: dc:4f:22:ab:5e:dc Uploading stub... Running stub... Stub running... Erasing flash (this may take a while)... Chip erase completed successfully in 3.3s Hard resetting via RTS pin... \u279c ~ Flash .bin, which you can download from the release-section : Again connect 3.3V while pressing button for 10 seconds. Then release and run: ```bash # if using Raspberry Pi 1/2 use # esptool.py --port /dev/ttyAMA0 write_flash -fm dout 0x0 /path/to/downloaded/tasmota.bin # if using Raspberry Pi 3 use esptool.py --port /dev/ttyS0 write_flash -fm dout 0x0 /path/to/downloaded/tasmota.bin ``` You should see output like this: ```bash \u279c ~ esptool.py --port /dev/ttyAMA0 write_flash -fm dout 0x0 tasmota.bin esptool.py v2.5.1 Serial port /dev/ttyAMA0 Connecting..... Detecting chip type... ESP8266 Chip is ESP8285 Features: WiFi, Embedded Flash MAC: dc:4f:22 5e:dc Uploading stub... Running stub... Stub running... Configuring flash size... Auto-detected Flash size: 1MB Compressed 456000 bytes to 312426... Wrote 456000 bytes (312426 compressed) at 0x00000000 in 29.2 seconds (effective 124.8 kbit/s)... Hash of data verified. Leaving... Hard resetting via RTS pin... \u279c ~ ``` Setup Wi-Fi: Connect with an external device to the sonoff-xxxx Wi-Fi AP and configure over the browser. Alternative: Reboot your device after flashing (toggle power wire) and connect to the serial console via miniterm: ```bash # if using Raspberry Pi 1/2 use # miniterm.py /dev/ttyAMA0 115200 -e # if using Raspberry Pi 3 use miniterm.py /dev/ttyS0 115200 -e ``` You will see some output, after pressing enter. Now just type in, your SSID, press enter and then type the password\u2026 Backlog ssid yourSSID; password yourPassword","title":"Flashing the firmware"},{"location":"Flash-Sonoff-using-Raspberry-Pi/#thats-it","text":"Sources: Flashing commands https://spellfoundry.com/2016/05/29/configuring-gpio-serial-port-raspbian-jessie-including-pi-3/","title":"That\u2019s it"},{"location":"For-Developers/","text":"Information for tool developers: ~ API Sensor API JSON Status Responses Tasmota forks with added features ~ Time Proportioned Output Fork PID Control Fork","title":"For Developers"},{"location":"For-Developers/#information-for-tool-developers","text":"API Sensor API JSON Status Responses","title":"Information for tool developers:"},{"location":"For-Developers/#tasmota-forks-with-added-features","text":"Time Proportioned Output Fork PID Control Fork","title":"Tasmota forks with added features"},{"location":"GPIO-Conversion/","text":"GPIO functions define the action being taken by a device connected to it's pin. The current ESP8266 GPIO function configuration supports 216 GPIO functions like Relay1 (21) or Inverted Button1 (122). The current implementation supports up to 250 functions as it is confined to 8-bits uint8_t arrays. As more devices need to be connected it would become impossible to have them addressed with this 8-bit scheme. Another problem is that the current implementation would need GUI drop down boxes with up to 250 items which is hard to use. Also user templates still need to be able to address all possible GPIO functions. To solve this issue I needed to change from 8-bit uint8_t to 16-bit uint16_t arrays. Without further action this would result in even more entries in the GUI drop down boxes and made adding more relays/buttons/switches etc also very cumbersome. As the ESP32 would need to be supported too a challenge lay ahead. I decided for the following option where every GPIO function type (relays, buttons, switches) would have an id allowing for 32 devices. So every GPIO function would be offset by 32 (or 5-bits). These 5-bits can be used in the future to easily expand current max values like 4 buttons or 8 relays to max 32. How this works could have been seen in the ESP32 implementation as released some month ago. The GUI now contains two drop down boxes, one for the GPIO function (Relay) and one for the function index (1 to 8). For the ESP8266 the current maxed GPIO functions of 216 will be fixed an any new device will be using the GPIO addressing scheme. To make transistion transparent a table is used to convert current 216 GPIO 8-bit function numbers to new 16-bit function numbers. As both are offset from 0 there will be some duplication in numbering so the only way to distinguish them by external programs like TDM is by checking the Tasmota verion number; Below 9.0 will be 8-bit GPIO, Starting with development version 9.0.0.1 it will be 16-bit GPIO. See below how the numbers are being converted. The first number is 8-bit GPIO, the second the 16-bit GPIO. GPIO Conversion ~ Old GPIO New GPIO Name Description 255 1 User User 0 0 None Not used 1 1184 DHT11 DHT11 sensor 2 1216 AM2301 AM230X, DHT21 and DHT22 sensor 3 1248 SI7021 Only for Sonoff Si7021, not the i2c version 4 1312 DS18x20 Dallas Semiconductor DS18b20 1-Wire temperature sensor 5 608 I2C SCL I2C serial clock pin, used with any I2C component (sensors, displays, ...) 6 640 I2C SDA I2C serial data pin, used with any I2C component (sensors, displays, ...) 7 1376 WS2812 Addressable LEDs such as WS281X or Neopixel 8 1056 IRsend IR Transmitter LED 9 160 Switch1 Switch 10 161 Switch2 Switch 11 162 Switch3 Switch 12 163 Switch4 Switch 13 164 Switch5 Switch 14 165 Switch6 Switch 15 166 Switch7 Switch 16 167 Switch8 Switch 17 32 Button1 Button 18 33 Button2 Button 19 34 Button3 Button 20 35 Button4 Button 21 224 Relay1 Relay 22 225 Relay2 Relay 23 226 Relay3 Relay 24 227 Relay4 Relay 25 228 Relay5 Relay 26 229 Relay6 Relay 27 230 Relay7 Relay 28 231 Relay8 Relay 29 256 Relay1i Relay inverted 30 257 Relay2i Relay inverted 31 258 Relay3i Relay inverted 32 259 Relay4i Relay inverted 33 260 Relay5i Relay inverted 34 261 Relay6i Relay inverted 35 262 Relay7i Relay inverted 36 263 Relay8i Relay inverted 37 416 PWM1 Pulse Width Modulated Output 38 417 PWM2 Pulse Width Modulated Output 39 418 PWM3 Pulse Width Modulated Output 40 419 PWM4 Pulse Width Modulated Output 41 420 PWM5 Pulse Width Modulated Output 42 352 Counter1 Counter Input 43 353 Counter2 Counter Input 44 354 Counter3 Counter Input 45 355 Counter4 Counter Input 46 448 PWM1i Pulse Width Modulated inverted Output 47 449 PWM2i Pulse Width Modulated inverted Output 48 450 PWM3i Pulse Width Modulated inverted Output 49 451 PWM4i Pulse Width Modulated inverted Output 50 452 PWM5i Pulse Width Modulated inverted Output 51 1088 IRrecv IR Receiver Input (for example TSOP1838) 52 288 Led1 LED 53 289 Led2 LED 54 290 Led3 LED 55 291 Led4 LED 56 320 Led1i Inverted LED - default state ON 57 321 Led2i Inverted LED - default state ON 58 322 Led3i Inverted LED - default state ON 59 323 Led4i Inverted LED - default state ON 60 1408 MHZ Rx MHZ 19 CO2 Sensor 61 1440 MHZ Tx MHZ 19 CO2 Sensor 62 1472 PZEM0XX Tx Peacefair Pzem-0XX Power Meter Tx pin 63 1504 PZEM004 Rx Peacefair Pzem-004 Power Meter Rx pin 64 1600 SAir Rx Sensor Senseair 65 1632 SAir Tx Sensor Senseair 66 768 SPI CS SPI Interface (ePaper Display) 67 800 SPI DC SPI Interface (ePaper Display) 68 992 BkLight Backlight (Display) 69 1696 PMS5003 PMS5003 Air Quality Sensor 70 1760 SDS0X1 Rx Nova Fitness SDS011 Laser Dust Sensor Rx pin 71 1792 SerBr Rx Serial Bridge Receive 72 1824 SerBr Tx Serial Bridge Transmit 73 1856 SR04 Tri Ultrasonic Sensor HC-SR04 Trigger pin 74 1888 SR04 Ech Ultrasonic Sensor HC-SR04 Echo pin 75 1920 SDMx20 Tx SDMx20-Modbus Multifunction Power Analyser Tx pin 76 1952 SDMx20 Rx SDMx20-Modbus Multifunction Power Analyser Rx pin 77 1984 SDM630 Tx SDM630-Modbus Multifunction Power Analyser Tx pin 78 2016 SDM630 Rx SDM630-Modbus Multifunction Power Analyser Rx pin 79 2048 TM16 CLK TM1638 Switch Module 80 2080 TM16 DIO TM1638 Switch Module 81 2112 TM16 STB TM1638 Switch Module 82 192 Switch1n Switch, no pullup resistor 83 193 Switch2n Switch, no pullup resistor 84 194 Switch3n Switch, no pullup resistor 85 195 Switch4n Switch, no pullup resistor 86 196 Switch5n Switch, no pullup resistor 87 197 Switch6n Switch, no pullup resistor 88 198 Switch7n Switch, no pullup resistor 89 199 Switch8n Switch, no pullup resistor 90 64 Button1n Button, no pullup resistor 91 65 Button2n Button, no pullup resistor 92 66 Button3n Button, no pullup resistor 93 67 Button4n Button, no pullup resistor 94 384 Counter1n Counter sensor, no pullup resistor 95 385 Counter2n Counter sensor, no pullup resistor 96 386 Counter3n Counter sensor, no pullup resistor 97 387 Counter4n Counter sensor, no pullup resistor 98 1536 PZEM016 Rx Peacefair Pzem-016 Power Meter Rx pin 99 1568 PZEM017 Rx Peacefair Pzem-017 Power Meter Rx pin 100 2144 MP3 Player DF MP3 Player mini (Input) 101 1728 SDS0X1 Tx Nova Fitness SDS011 Laser Dust Sensor Tx pin 102 2176 HX711 SCK HX711 weight sensor serial clock input 103 2208 HX711 DAT HX711 weight sensor data output 104 2240 TX20 TX20 Wind Sensor Input (Tx from sensor) 105 1120 RFSend RF Emitter (433Mhz module needed; Requires self-compile with RF_SENSOR and USE_RC_SWITCH) 106 1152 RFrecv RF Receiver (433Mhz module needed; Requires self-compile with RF_SENSOR and USE_RC_SWITCH) 107 2272 Tuya Tx Tuya Transfer pin 108 2304 Tuya Rx Tuya Receive pin 109 2336 MGC3130 Xfr MGC3130 E-field Xfr pin 110 2368 MGC3130 Rst MGC3130 E-field Reset pin 111 832 SSPI MISO Software SPI MISO (Display) 112 864 SSPI MOSI Software SPI MOSI (Display) 113 896 SSPI SCLK Software SPI SCLK (Display) 114 928 SSPI CS Software SPI CS (Display) 115 960 SSPI DC Software SPI DC (Display) 116 2400 RF Sensor Theo Arendst RF433 Sensor 117 2432 AZ Rx AZ 7798 CO2 datalogger 118 2464 AZ Tx AZ 7798 CO2 datalogger 119 2496 MX31855 CS MAX31855 Thermocouple Sensor Chip Select pin 120 2528 MX31855 CLK MAX31855 Thermocouple Sensor Serial Clock pin 121 2560 MX31855 DO MAX31855 Thermocouple Sensor Digital Output pin 122 96 Button1i Button inverted 123 97 Button2i Button inverted 124 98 Button3i Button inverted 125 99 Button4i Button inverted 126 128 Button1in Button inverted, no pullup resistor 127 129 Button2in Button inverted, no pullup resistor 128 130 Button3in Button inverted, no pullup resistor 129 131 Button4in Button inverted, no pullup resistor 130 2592 HLWBL SEL Energy Monitoring (for example Pow) 131 2624 HLWBL SELi Energy Monitoring (for example Pow) 132 2656 HLWBL CF1 Energy Monitoring (for example Pow) 133 2688 HLW8012 CF HLW8012 Single Phase Energy Monitor Chip CF pin 134 2720 BL0937 CF BL0937 Single Phase Energy Monitor Chip CF pin 135 2752 MCP39F5 Tx Energy Monitoring (for example Shelly2) 136 2784 MCP39F5 Rx Energy Monitoring (for example Shelly2) 137 2816 MCP39F5 Rst Energy Monitoring (for example Shelly2) 138 2848 PN532 Tx PN532 RFID/NFC Reader Tx pin 139 2880 PN532 Rx PN532 RFID/NFC Reader Rx pin 140 2912 SM16716 CLK SM16716 Pixel LED Serial Clock pin 141 2944 SM16716 DAT SM16716 Pixel LED Data pin 142 2976 SM16716 PWR SM16716 Pixel LED Power pin 143 3008 MY92x1 DI Light Bulb with MY92x controller 144 3040 MY92x1 DCKI Light Bulb with MY92x controller 145 3072 CSE7766 Tx CSE7766 Single Phase Energy Monitor Chip Tx pin 146 3104 CSE7766 Rx CSE7766 Single Phase Energy Monitor Chip Rx pin 147 3136 ALux IrRcv AriLux RGB Controller IR receive (Input) 148 3200 Serial Tx Serial Transfer pin 149 3232 Serial Rx Serial Receive pin 150 3264 Rotary1a Rotary Encoder (Mi Desk Lamp) 151 3296 Rotary1b Rotary Encoder (Mi Desk Lamp) 152 3265 Rotary2a Rotary Encoder (Mi Desk Lamp) 153 3297 Rotary2b Rotary Encoder (Mi Desk Lamp) 154 3392 HRE CLOCK Clock/Power line for HR-E Water Meter 155 3424 HRE DATA Data line for HR-E Water Meter 156 3456 ADE7953_IRQ ADE7953 IRQ 157 544 LedLink Device Status LED 158 576 LedLinki Device Status LED, inverted 159 3168 ALux IrSel For AriLux devices - switches between IR/RF mode 160 480 Buzzer Sonoff iFan03 Buzzer 161 512 Buzzeri Sonoff iFan03 Buzzer inverted 162 1024 OLED Reset OLED Display Reset 163 3488 SolaxX1 Tx Solax Inverter Tx pin 164 3520 SolaxX1 Rx Solax Inverter Rx pin 165 3552 Zigbee Tx Zigbee Serial interface Tx 166 3584 Zigbee Rx Zigbee Serial interface Rx 167 3616 RDM6300 Rx RDM6300 RX 168 3648 iBeacon Tx HM17 iBeacon Tx 169 3680 iBeacon Rx HM17 iBeacon Rx 170 3712 A4988 DIR A4988 Motor Direction 171 3744 A4988 STP A4988 Step motor 172 3776 A4988 ENA A4988 Enable motor 173 3808 A4988 MS1 A4988 Microstep increment select pin1 174 3809 A4988 MS2 A4988 Microstep increment select pin2 175 3810 A4988 MS3 A4988 Microstep increment select pin3 176 3904 DDS238-2 Tx DDS2382 Serial interface Tx 177 3936 DDS238-2 Rx DDS2382 Serial interface Rx 178 3968 DDSU666 Tx DDSU666 Serial interface Tx 179 4000 DDSU666 Rx DDSU666 Serial interface Rx 180 4032 SM2135 CLK SM2135 Clk 181 4064 SM2135 DAT SM2135 Dat 182 4096 DeepSleep DeepSleep wake switch 183 4128 EXS Enable EXS Dimmer MCU Enable 184 4160 Slave TX TasmotaClient TX 185 4192 Slave RX TasmotaClient RX 186 4224 Slave RST TasmotaClient Reset Pin 187 4256 Slave RSTi TasmotaClient Reset Inverted 188 4288 HPMA RX Honeywell HPMA115S0 Serial Rx 189 4320 HPMA TX Honeywell HPMA115S0 Serial Tx 190 4352 GPS RX GPS Serial Tx 191 4384 GPS TX GPS Serial Tx 192 1344 DSB OUT Pseudo Single wire DS18B20 or DS18S20 193 1280 DHT11 OUT Pseudo Single wire DHT11, DHT21, DHT22, AM2301, AM2302, AM2321 194 4416 HM10 RX HM10-BLE-Mijia-bridge Serial 195 4448 HM10 TX HM10-BLE-Mijia-bridge Serial 196 4480 LE01MR RX F&F LE-01MR Energy Meter Serial 197 4512 LE01MR TX F&F LE-01MR Energy Meter Serial 198 4544 CC1101 GDO0 CC1101 RX Pin 199 4576 CC1101 GDO2 CC1101 TX Pin 200 4608 HRXL RX Data from MaxBotix HRXL sonar range sensor 201 4640 MOODL TX ElectriQ iQ-wifiMOODL Serial TX 202 4672 AS3935 Lightning Detector Interrupt Pin 203 1664 PMS5003 TX Plantower PMS5003 Serial interface 204 4928 Boiler OT Rx OpenTherm Boiler RX pin 205 4960 Boiler OT Tx OpenTherm Boiler TX pin 206 4992 Windmeter Speed WindMeter speed counter pin 207 5056 BL0940 RX BL0940 serial interface 208 5088 TCP TX TCP Serial bridge 209 5120 TCP RX TCP Serial bridge 210 5152 TELEINFO RX TELEINFO serial interface 211 5184 TELEINFO Enable TELEINFO Enable PIN 212 5216 LMT01 LMT01 input counting pin 213 5248 IEM3000 TX IEM3000 Serial interface 214 5280 IEM3000 RX IEM3000 Serial interface 215 5312 Zigbee RST Zigbee reset 216 5344 DYP Rx DYP-ME007 Rx pin ADC Conversion ~ Old ADC New ADC Option WebUI display MQTT mesage 0 0 None none none 1 4704 Analog Analog0 %value% {\"A0\":%value%} 2 4736 Temperature Temperature %value% \u00b0C (\u00b0F) {\"Temperature\":%value%},\"TempUnit\":\"C\"} 3 4768 Light Illuminance %value% lux {\"Illuminance\":%value%} 4 4800 Button none none 5 4832 Buttoni none none 6 4864 Range Range %value% {\"Range\":%value%} 7 4896 CT Power Voltage 230 V Current %value A Power %value W Energy Total %value kWh {\"Energy\": %value ,\"Power\": %value ,\"Voltage\":230,\"Current\": %value } 8 3328 Joystick none {\"ANALOG\":{\"Joy1\":%value%}","title":"GPIO Conversion"},{"location":"GPIO-Conversion/#gpio-conversion","text":"Old GPIO New GPIO Name Description 255 1 User User 0 0 None Not used 1 1184 DHT11 DHT11 sensor 2 1216 AM2301 AM230X, DHT21 and DHT22 sensor 3 1248 SI7021 Only for Sonoff Si7021, not the i2c version 4 1312 DS18x20 Dallas Semiconductor DS18b20 1-Wire temperature sensor 5 608 I2C SCL I2C serial clock pin, used with any I2C component (sensors, displays, ...) 6 640 I2C SDA I2C serial data pin, used with any I2C component (sensors, displays, ...) 7 1376 WS2812 Addressable LEDs such as WS281X or Neopixel 8 1056 IRsend IR Transmitter LED 9 160 Switch1 Switch 10 161 Switch2 Switch 11 162 Switch3 Switch 12 163 Switch4 Switch 13 164 Switch5 Switch 14 165 Switch6 Switch 15 166 Switch7 Switch 16 167 Switch8 Switch 17 32 Button1 Button 18 33 Button2 Button 19 34 Button3 Button 20 35 Button4 Button 21 224 Relay1 Relay 22 225 Relay2 Relay 23 226 Relay3 Relay 24 227 Relay4 Relay 25 228 Relay5 Relay 26 229 Relay6 Relay 27 230 Relay7 Relay 28 231 Relay8 Relay 29 256 Relay1i Relay inverted 30 257 Relay2i Relay inverted 31 258 Relay3i Relay inverted 32 259 Relay4i Relay inverted 33 260 Relay5i Relay inverted 34 261 Relay6i Relay inverted 35 262 Relay7i Relay inverted 36 263 Relay8i Relay inverted 37 416 PWM1 Pulse Width Modulated Output 38 417 PWM2 Pulse Width Modulated Output 39 418 PWM3 Pulse Width Modulated Output 40 419 PWM4 Pulse Width Modulated Output 41 420 PWM5 Pulse Width Modulated Output 42 352 Counter1 Counter Input 43 353 Counter2 Counter Input 44 354 Counter3 Counter Input 45 355 Counter4 Counter Input 46 448 PWM1i Pulse Width Modulated inverted Output 47 449 PWM2i Pulse Width Modulated inverted Output 48 450 PWM3i Pulse Width Modulated inverted Output 49 451 PWM4i Pulse Width Modulated inverted Output 50 452 PWM5i Pulse Width Modulated inverted Output 51 1088 IRrecv IR Receiver Input (for example TSOP1838) 52 288 Led1 LED 53 289 Led2 LED 54 290 Led3 LED 55 291 Led4 LED 56 320 Led1i Inverted LED - default state ON 57 321 Led2i Inverted LED - default state ON 58 322 Led3i Inverted LED - default state ON 59 323 Led4i Inverted LED - default state ON 60 1408 MHZ Rx MHZ 19 CO2 Sensor 61 1440 MHZ Tx MHZ 19 CO2 Sensor 62 1472 PZEM0XX Tx Peacefair Pzem-0XX Power Meter Tx pin 63 1504 PZEM004 Rx Peacefair Pzem-004 Power Meter Rx pin 64 1600 SAir Rx Sensor Senseair 65 1632 SAir Tx Sensor Senseair 66 768 SPI CS SPI Interface (ePaper Display) 67 800 SPI DC SPI Interface (ePaper Display) 68 992 BkLight Backlight (Display) 69 1696 PMS5003 PMS5003 Air Quality Sensor 70 1760 SDS0X1 Rx Nova Fitness SDS011 Laser Dust Sensor Rx pin 71 1792 SerBr Rx Serial Bridge Receive 72 1824 SerBr Tx Serial Bridge Transmit 73 1856 SR04 Tri Ultrasonic Sensor HC-SR04 Trigger pin 74 1888 SR04 Ech Ultrasonic Sensor HC-SR04 Echo pin 75 1920 SDMx20 Tx SDMx20-Modbus Multifunction Power Analyser Tx pin 76 1952 SDMx20 Rx SDMx20-Modbus Multifunction Power Analyser Rx pin 77 1984 SDM630 Tx SDM630-Modbus Multifunction Power Analyser Tx pin 78 2016 SDM630 Rx SDM630-Modbus Multifunction Power Analyser Rx pin 79 2048 TM16 CLK TM1638 Switch Module 80 2080 TM16 DIO TM1638 Switch Module 81 2112 TM16 STB TM1638 Switch Module 82 192 Switch1n Switch, no pullup resistor 83 193 Switch2n Switch, no pullup resistor 84 194 Switch3n Switch, no pullup resistor 85 195 Switch4n Switch, no pullup resistor 86 196 Switch5n Switch, no pullup resistor 87 197 Switch6n Switch, no pullup resistor 88 198 Switch7n Switch, no pullup resistor 89 199 Switch8n Switch, no pullup resistor 90 64 Button1n Button, no pullup resistor 91 65 Button2n Button, no pullup resistor 92 66 Button3n Button, no pullup resistor 93 67 Button4n Button, no pullup resistor 94 384 Counter1n Counter sensor, no pullup resistor 95 385 Counter2n Counter sensor, no pullup resistor 96 386 Counter3n Counter sensor, no pullup resistor 97 387 Counter4n Counter sensor, no pullup resistor 98 1536 PZEM016 Rx Peacefair Pzem-016 Power Meter Rx pin 99 1568 PZEM017 Rx Peacefair Pzem-017 Power Meter Rx pin 100 2144 MP3 Player DF MP3 Player mini (Input) 101 1728 SDS0X1 Tx Nova Fitness SDS011 Laser Dust Sensor Tx pin 102 2176 HX711 SCK HX711 weight sensor serial clock input 103 2208 HX711 DAT HX711 weight sensor data output 104 2240 TX20 TX20 Wind Sensor Input (Tx from sensor) 105 1120 RFSend RF Emitter (433Mhz module needed; Requires self-compile with RF_SENSOR and USE_RC_SWITCH) 106 1152 RFrecv RF Receiver (433Mhz module needed; Requires self-compile with RF_SENSOR and USE_RC_SWITCH) 107 2272 Tuya Tx Tuya Transfer pin 108 2304 Tuya Rx Tuya Receive pin 109 2336 MGC3130 Xfr MGC3130 E-field Xfr pin 110 2368 MGC3130 Rst MGC3130 E-field Reset pin 111 832 SSPI MISO Software SPI MISO (Display) 112 864 SSPI MOSI Software SPI MOSI (Display) 113 896 SSPI SCLK Software SPI SCLK (Display) 114 928 SSPI CS Software SPI CS (Display) 115 960 SSPI DC Software SPI DC (Display) 116 2400 RF Sensor Theo Arendst RF433 Sensor 117 2432 AZ Rx AZ 7798 CO2 datalogger 118 2464 AZ Tx AZ 7798 CO2 datalogger 119 2496 MX31855 CS MAX31855 Thermocouple Sensor Chip Select pin 120 2528 MX31855 CLK MAX31855 Thermocouple Sensor Serial Clock pin 121 2560 MX31855 DO MAX31855 Thermocouple Sensor Digital Output pin 122 96 Button1i Button inverted 123 97 Button2i Button inverted 124 98 Button3i Button inverted 125 99 Button4i Button inverted 126 128 Button1in Button inverted, no pullup resistor 127 129 Button2in Button inverted, no pullup resistor 128 130 Button3in Button inverted, no pullup resistor 129 131 Button4in Button inverted, no pullup resistor 130 2592 HLWBL SEL Energy Monitoring (for example Pow) 131 2624 HLWBL SELi Energy Monitoring (for example Pow) 132 2656 HLWBL CF1 Energy Monitoring (for example Pow) 133 2688 HLW8012 CF HLW8012 Single Phase Energy Monitor Chip CF pin 134 2720 BL0937 CF BL0937 Single Phase Energy Monitor Chip CF pin 135 2752 MCP39F5 Tx Energy Monitoring (for example Shelly2) 136 2784 MCP39F5 Rx Energy Monitoring (for example Shelly2) 137 2816 MCP39F5 Rst Energy Monitoring (for example Shelly2) 138 2848 PN532 Tx PN532 RFID/NFC Reader Tx pin 139 2880 PN532 Rx PN532 RFID/NFC Reader Rx pin 140 2912 SM16716 CLK SM16716 Pixel LED Serial Clock pin 141 2944 SM16716 DAT SM16716 Pixel LED Data pin 142 2976 SM16716 PWR SM16716 Pixel LED Power pin 143 3008 MY92x1 DI Light Bulb with MY92x controller 144 3040 MY92x1 DCKI Light Bulb with MY92x controller 145 3072 CSE7766 Tx CSE7766 Single Phase Energy Monitor Chip Tx pin 146 3104 CSE7766 Rx CSE7766 Single Phase Energy Monitor Chip Rx pin 147 3136 ALux IrRcv AriLux RGB Controller IR receive (Input) 148 3200 Serial Tx Serial Transfer pin 149 3232 Serial Rx Serial Receive pin 150 3264 Rotary1a Rotary Encoder (Mi Desk Lamp) 151 3296 Rotary1b Rotary Encoder (Mi Desk Lamp) 152 3265 Rotary2a Rotary Encoder (Mi Desk Lamp) 153 3297 Rotary2b Rotary Encoder (Mi Desk Lamp) 154 3392 HRE CLOCK Clock/Power line for HR-E Water Meter 155 3424 HRE DATA Data line for HR-E Water Meter 156 3456 ADE7953_IRQ ADE7953 IRQ 157 544 LedLink Device Status LED 158 576 LedLinki Device Status LED, inverted 159 3168 ALux IrSel For AriLux devices - switches between IR/RF mode 160 480 Buzzer Sonoff iFan03 Buzzer 161 512 Buzzeri Sonoff iFan03 Buzzer inverted 162 1024 OLED Reset OLED Display Reset 163 3488 SolaxX1 Tx Solax Inverter Tx pin 164 3520 SolaxX1 Rx Solax Inverter Rx pin 165 3552 Zigbee Tx Zigbee Serial interface Tx 166 3584 Zigbee Rx Zigbee Serial interface Rx 167 3616 RDM6300 Rx RDM6300 RX 168 3648 iBeacon Tx HM17 iBeacon Tx 169 3680 iBeacon Rx HM17 iBeacon Rx 170 3712 A4988 DIR A4988 Motor Direction 171 3744 A4988 STP A4988 Step motor 172 3776 A4988 ENA A4988 Enable motor 173 3808 A4988 MS1 A4988 Microstep increment select pin1 174 3809 A4988 MS2 A4988 Microstep increment select pin2 175 3810 A4988 MS3 A4988 Microstep increment select pin3 176 3904 DDS238-2 Tx DDS2382 Serial interface Tx 177 3936 DDS238-2 Rx DDS2382 Serial interface Rx 178 3968 DDSU666 Tx DDSU666 Serial interface Tx 179 4000 DDSU666 Rx DDSU666 Serial interface Rx 180 4032 SM2135 CLK SM2135 Clk 181 4064 SM2135 DAT SM2135 Dat 182 4096 DeepSleep DeepSleep wake switch 183 4128 EXS Enable EXS Dimmer MCU Enable 184 4160 Slave TX TasmotaClient TX 185 4192 Slave RX TasmotaClient RX 186 4224 Slave RST TasmotaClient Reset Pin 187 4256 Slave RSTi TasmotaClient Reset Inverted 188 4288 HPMA RX Honeywell HPMA115S0 Serial Rx 189 4320 HPMA TX Honeywell HPMA115S0 Serial Tx 190 4352 GPS RX GPS Serial Tx 191 4384 GPS TX GPS Serial Tx 192 1344 DSB OUT Pseudo Single wire DS18B20 or DS18S20 193 1280 DHT11 OUT Pseudo Single wire DHT11, DHT21, DHT22, AM2301, AM2302, AM2321 194 4416 HM10 RX HM10-BLE-Mijia-bridge Serial 195 4448 HM10 TX HM10-BLE-Mijia-bridge Serial 196 4480 LE01MR RX F&F LE-01MR Energy Meter Serial 197 4512 LE01MR TX F&F LE-01MR Energy Meter Serial 198 4544 CC1101 GDO0 CC1101 RX Pin 199 4576 CC1101 GDO2 CC1101 TX Pin 200 4608 HRXL RX Data from MaxBotix HRXL sonar range sensor 201 4640 MOODL TX ElectriQ iQ-wifiMOODL Serial TX 202 4672 AS3935 Lightning Detector Interrupt Pin 203 1664 PMS5003 TX Plantower PMS5003 Serial interface 204 4928 Boiler OT Rx OpenTherm Boiler RX pin 205 4960 Boiler OT Tx OpenTherm Boiler TX pin 206 4992 Windmeter Speed WindMeter speed counter pin 207 5056 BL0940 RX BL0940 serial interface 208 5088 TCP TX TCP Serial bridge 209 5120 TCP RX TCP Serial bridge 210 5152 TELEINFO RX TELEINFO serial interface 211 5184 TELEINFO Enable TELEINFO Enable PIN 212 5216 LMT01 LMT01 input counting pin 213 5248 IEM3000 TX IEM3000 Serial interface 214 5280 IEM3000 RX IEM3000 Serial interface 215 5312 Zigbee RST Zigbee reset 216 5344 DYP Rx DYP-ME007 Rx pin","title":"GPIO Conversion"},{"location":"GPIO-Conversion/#adc-conversion","text":"Old ADC New ADC Option WebUI display MQTT mesage 0 0 None none none 1 4704 Analog Analog0 %value% {\"A0\":%value%} 2 4736 Temperature Temperature %value% \u00b0C (\u00b0F) {\"Temperature\":%value%},\"TempUnit\":\"C\"} 3 4768 Light Illuminance %value% lux {\"Illuminance\":%value%} 4 4800 Button none none 5 4832 Buttoni none none 6 4864 Range Range %value% {\"Range\":%value%} 7 4896 CT Power Voltage 230 V Current %value A Power %value W Energy Total %value kWh {\"Energy\": %value ,\"Power\": %value ,\"Voltage\":230,\"Current\": %value } 8 3328 Joystick none {\"ANALOG\":{\"Joy1\":%value%}","title":"ADC Conversion"},{"location":"GPS-NTP-server/","text":"GPS-based NTP-server (Serial) ~ The foremost reason for the inclusion of this driver was to have a network unrelated time source, but besides this location data is provided too. Only u-blox-devices are supported The UBX binary protocol was chosen, because it is very memory efficient and all the needed data can be read without further parsing. The genereric NMEA-standard is NOT supported! The driver is tested on a NEO-6m and a Beitian-220. Series 7 should work too. These modules are quite cheap, starting at about 3.50\u20ac for the NEO-6m. Features: ~ simplified NTP-Server sets system time automatically and Settings.latitude and Settings.longitude via command get position and time data can log postion data with timestamp to flash with a small memory footprint of only 12 Bytes per record (!!EXPERIMENTAL!!) constructs a GPX-file for download of this data Web-UI and console command interface Connecting the GPS-device to a Wemos D1 mini ~ Wemos D1 Mini GPS VCC +3.3V Vin GND GND TX Rx RX Tx Tasmota Settings ~ In the Configuration -> Configure Module page, select the following for Wemos D1 mini: 1. Module Type: 18 Generic 2. TX GPIO1 Serial Out: GPX_TX 3. RX GPIO3 Serial In: GPX_RX No further installation steps needed. To get more debug information compile it with option \"DEBUG_TASMOTA_SENSOR\". The driver expects the device to be configured for 9600 baud, which is the default for most of these sensors. If necessary the configuration can be changed with the freely available \"u-center\"-software, which is windows-only but is reported to run quite well with WINE and can be confirmed to work with CrossOver on macOs Catalina. NTP-Server ~ Simply start the server with 'sensor60 9'. Flash-Log ~ This is highly experimental feature, which uses the OTA-partition to log position data. !! \u26a0\ufe0f FOR OBVIOUS REASONS THIS WILL SHORTEN THE LIFE OF THE FLASH MEMORY AND SHOULD BE USED WISELY \u26a0\ufe0f !! After the first recording, a download-link will appear in the web interface. By clicking on it, a GPX-file will be created on-the fly for download. All recorded data is lost after each OTA-update. Commands: ~ sensor60 0 write to all available sectors, then restart and overwrite the older ones sensor60 1 write to all available sectors, then restart and overwrite the older ones sensor60 2 filter out horizontal drift noise sensor60 3 turn off noise filter sensor60 4 start recording, new data will be appended sensor60 5 start new recording, old data will lost sensor60 6 stop recording, download link will be visible in Web-UI sensor60 7 send mqtt on new postion + TELE -> consider to set TELE to a very high value sensor60 8 only TELE message sensor60 9 start NTP-Server sensor60 10 deactivate NTP-Server sensor60 11 force update of Tasmota-system-UTC with every new GPS-time-message sensor60 12 do NOT update of Tasmota-system-UTC with every new GPS-time-message sensor60 13 set latitude and longitude in settings sensor60 14 open virtual serial port over TCP, usable for u-center: tcp://ip-address:port (default port: 1234) !! \u26a0\ufe0f misconfiguration via u-center can virtually brick the device \u26a0\ufe0f !! sensor60 15 pause virtual serial port over TCP (connection stays active in the background)","title":"GPS NTP server"},{"location":"GPS-NTP-server/#gps-based-ntp-server-serial","text":"The foremost reason for the inclusion of this driver was to have a network unrelated time source, but besides this location data is provided too. Only u-blox-devices are supported The UBX binary protocol was chosen, because it is very memory efficient and all the needed data can be read without further parsing. The genereric NMEA-standard is NOT supported! The driver is tested on a NEO-6m and a Beitian-220. Series 7 should work too. These modules are quite cheap, starting at about 3.50\u20ac for the NEO-6m.","title":"GPS-based NTP-server (Serial)"},{"location":"GPS-NTP-server/#features","text":"simplified NTP-Server sets system time automatically and Settings.latitude and Settings.longitude via command get position and time data can log postion data with timestamp to flash with a small memory footprint of only 12 Bytes per record (!!EXPERIMENTAL!!) constructs a GPX-file for download of this data Web-UI and console command interface","title":"Features:"},{"location":"GPS-NTP-server/#connecting-the-gps-device-to-a-wemos-d1-mini","text":"Wemos D1 Mini GPS VCC +3.3V Vin GND GND TX Rx RX Tx","title":"Connecting the GPS-device to a Wemos D1 mini"},{"location":"GPS-NTP-server/#tasmota-settings","text":"In the Configuration -> Configure Module page, select the following for Wemos D1 mini: 1. Module Type: 18 Generic 2. TX GPIO1 Serial Out: GPX_TX 3. RX GPIO3 Serial In: GPX_RX No further installation steps needed. To get more debug information compile it with option \"DEBUG_TASMOTA_SENSOR\". The driver expects the device to be configured for 9600 baud, which is the default for most of these sensors. If necessary the configuration can be changed with the freely available \"u-center\"-software, which is windows-only but is reported to run quite well with WINE and can be confirmed to work with CrossOver on macOs Catalina.","title":"Tasmota Settings"},{"location":"GPS-NTP-server/#ntp-server","text":"Simply start the server with 'sensor60 9'.","title":"NTP-Server"},{"location":"GPS-NTP-server/#flash-log","text":"This is highly experimental feature, which uses the OTA-partition to log position data. !! \u26a0\ufe0f FOR OBVIOUS REASONS THIS WILL SHORTEN THE LIFE OF THE FLASH MEMORY AND SHOULD BE USED WISELY \u26a0\ufe0f !! After the first recording, a download-link will appear in the web interface. By clicking on it, a GPX-file will be created on-the fly for download. All recorded data is lost after each OTA-update.","title":"Flash-Log"},{"location":"GPS-NTP-server/#commands","text":"sensor60 0 write to all available sectors, then restart and overwrite the older ones sensor60 1 write to all available sectors, then restart and overwrite the older ones sensor60 2 filter out horizontal drift noise sensor60 3 turn off noise filter sensor60 4 start recording, new data will be appended sensor60 5 start new recording, old data will lost sensor60 6 stop recording, download link will be visible in Web-UI sensor60 7 send mqtt on new postion + TELE -> consider to set TELE to a very high value sensor60 8 only TELE message sensor60 9 start NTP-Server sensor60 10 deactivate NTP-Server sensor60 11 force update of Tasmota-system-UTC with every new GPS-time-message sensor60 12 do NOT update of Tasmota-system-UTC with every new GPS-time-message sensor60 13 set latitude and longitude in settings sensor60 14 open virtual serial port over TCP, usable for u-center: tcp://ip-address:port (default port: 1234) !! \u26a0\ufe0f misconfiguration via u-center can virtually brick the device \u26a0\ufe0f !! sensor60 15 pause virtual serial port over TCP (connection stays active in the background)","title":"Commands:"},{"location":"Getting-Started/","text":"Prerequisites ~ Needed Hardware ~ ESP8266 or ESP8285 Device Any variation of the ESP8266 chip can be flashed with Tasmota. Serial-to-USB Adapter The power supplied to the device is one of the most important elements for both flashing the device and for stable operation. You must ensure that the device receives sufficient power (current AND appropriate voltage level) to properly flash the firmware on the device. CH340G is a reliable and very cheap adapter (example 1 , 2 ). FTDI FT232 - these adapters have a lot of fakes in the market so buy only from reliable sources ( example ). Buy only the variant with a separate 3.3V regulator on PCB! CP2102 or PL2303 - works with certain devices, but using an external 3.3V supply might be necessary. Not recommended for beginners! RaspberryPi - only for advanced users. External 3.3V supply necessary. NodeMCU and D1 mini (Pro/Lite) boards have a micro USB upload port and don't require an adapter. Note Don't forget to install drivers for your serial-to-USB adapter. Danger Some adapters can be switched between 3.3V and 5V for the data pins, but still provide 5V on the power pin which will fry your device. You MUST make sure both the data and VCC pins are set for 3.3V. Soldering Tools To solder you'll of course need a soldering iron, soldering tin and some flux. If you're new to soldering check out some soldering tutorial videos while you're at it. If you're intimidated by soldering you could get away with holding the headers with jumper wires in the pin holes during flashing but it is not a fool proof process and flashing might fail. Jumper wires You could use any kind of wire but jumper wires (also called DuPont wires) are more practical than soldering and desoldering. Pin Headers Pin headers come in male or female version. Choose according to your jumper wire connectors. Computer with Linux, Windows or MacOS You need a computer with a USB port to upload the firmware to your device and configure it. Smartphone Tasmota installed from a precompiled binary needs to be configured to work with your Wi-Fi network before you can access the Tasmota web UI. This is usually done by connecting to a Tasmota Wi-Fi Access Point with your smartphone (or tablet or computer with Wi-Fi). Needed Software ~ Tasmota Firmware Binary Download a Tasmota firmware binary file (.bin). If you're not sure which binary is the right one for you just start with tasmota.bin or consult the builds table to see which features you need. Official release binaries can be downloaded from GitHub releases or from our OTA server . Latest development branch binaries are available only from our OTA server . The latest merged development code is compiled hourly. Flashing Tool Tasmotizer - NEW flashing and firmware download tool just for Tasmota. (Windows, Linux or Mac) Tasmota PyFlasher - flashing tool intended for Tasmota. (Windows or Mac) NodeMCU PyFlasher - easy to use GUI flasher based on esptool.py. (Windows or Mac) Esptool.py - the official flashing tool from Espressif. (Requires Python) Esptool executable - Esptool in executable form, no Python required. (Windows, Linux or Mac) Serial Terminal A program that connects to your Tasmota device directly over the serial connection you used to flash it. This is an optional way to configure your device using Commands and Backlog . Termite - simple terminal for windows Termie - open source clone of Termite Putty - popular client available on every platform Minicom - one of many Linux terminals Tip Enable local echo so that you can see what is typed and transmitted to the device. Enable Append CR+LF since every request needs to end with <CR><LF> . MQTT Knowledge ~ Tasmota is designed to be controlled and communicate via MQTT . To use it to its fullest potential you need an MQTT broker . Read our article on MQTT to learn why it is essential in Tasmota. Compiling Tools (Optional) ~ If you want to modify the code or default settings and compile your own Tasmota firmware . Hardware Preparation ~ We need to connect to the serial programming interface of the ESP8266 chip. This is done by connecting our serial-to-USB converter TX and RX pins to the ESP8266 RX and TX pins and powering the chip with the 3.3V and GND pins. In most cases those pins are available on the PCB in the form of pin holes or solder pads but pin headers or jumper wires need to be soldered or otherwise applied. In some cases you will need to solder wires directly on the chip's pins which requires some experience and good soldering equipment. BEWARE! DO NOT CONNECT DEVICES TO MAINS POWER WHILE THE COVER IS OPEN AND CIRCUIT BOARD IS EXPOSED!!! NEVER TRY TO FLASH WHILE YOUR DEVICE IS CONNECTED TO MAINS POWER!!! YOU CAN BE ELECTROCUTED IF YOU DON'T KNOW WHAT YOU ARE DOING! If you are not careful, your own health will be in danger. Shorting your serial interface with mains AC power will fry your device and serial adapter and will also harm or destroy your computer. It is important to always have all mains power cables disconnected from the device while being connected via serial or even while the case of the device is opened. Serial Connection ~ Each device has its pins labelled differently. If the labelling isn't visible on the PCB please refer to the devices flashing guide or search the Internet for correct pin locations. Device specific instructions and restrictions are documented in the Tasmota Device Templates Repository . Pinouts for commonly used Wi-Fi modules are found here When you have identified pins on your device, connect wires according to the table: Serial adapter ESP8266 device 3V3 3V3 or VCC TX RX RX TX GND GND Note that TX from your adapter goes to RX on the ESP8266 device and RX from adapter goes to TX on the device! Programming Mode ~ ESP8266 needs to be put into programming mode or flash mode before the firmware can be uploaded. This is done by pulling the GPIO0 pin to GND while the chip is booting. On most devices the installed control button is connected to GPIO0 and GND, making entering Programming Mode very easy. On others you will need to bridge the pins on the PCB or directly on the chip with a jumper wire. GPIO0 is always in the same location on ESP8266 and ESP8285! Device specific instructions are documented in Tasmota Device Templates Repository . To put the ESP8266 into Programming Mode: Disconnect serial-to-USB adapter and power Bridge GPIO0 and GND (by pressing the on-board button or connection with a wire) Connect the serial-to-USB adapter to your computer After a few seconds disconnect GPIO0 from GND (release button or remove the wire connection). On devices that do not provide the GPIO0 connected button, it may be easier to leave the wired bridge in place throughout the entire flashing process (erase & upload). Doing so will not create any problems. After the firmware is uploaded successfully, remove the bridge. This allows the device to boot normally. You can test whether your device is in Programming Mode by attempting to read information from the ESP82xx chip. This requires esptool.py . Instructions on installing and using esptool are provided below . For example ( COM5 will be your COM port): esptool.py -p COM5 read_mac (It should read the MAC address. It may fail afterwards during Uploading and running a \"stub\". This is normal.) esptool.py -p COM5 flash_id If everything went well, you are now in Programming Mode and ready to continue with flashing . If the flashing process is unable to start, disconnect the device and retry the steps. Common Mistakes ~ Wire connections and solder joints - Double check all connections and also check for solder overflow. Use a USB data cable - Some USB cables are for charging only and do not connect the data lines needed to load the firmware onto the device. Insufficient power delivered over the serial-to-USB adapter. This leads to flashing failures or corrupted flash altogether. Supply more power with a separate 3.3V power supply or get an adapter with a better power supply. Be sure all DC voltages use the same GND reference. Recheck your serial-to-USB adapter so to ensure that it supplies 3.3V voltage and NOT 5V . 5V will damage the ESP chip! Releasing GPIO0 button/wire before booting is finished - It is safe to leave GPIO0 connected to GND during the entire programming process (erase & upload). Just be sure to remove the GPIO0 to GND bridge before booting the device for regular operation. Make sure that the RX pin is connected to the TX pin between the serial adapter and your ESP device, and vice versa. Erase the flash memory first and cycle power afterwards before uploading the Tasmota firmware binary. Not erasing can leave behind remnants of the previous flash contents which can interfere with the new firmware operation. Flashing ~ If you have followed Hardware preparation , your device should be in Flash Mode and ready for a Tasmota firmware binary file to be flashed. For that you need a flashing tool . Tip You may want to back up the device manufacturer's firmware on the one in a million chance you don't like Tasmota. Tasmotizer! ~ Tasmotizer! is specifically designed for use with Tasmota with an easy to use GUI and esptool.py under the hood. Download the latest release for your platform. In Windows just double click the downloaded file and it'll start, no installation required. For python follow the installation instructions . Video tutorial by SuperHouseTV Note If you get an anti-virus infection warning don't fret, it is a known false positive . If you're still apprehensive you can always run the Python version. It is time to Tasmotize! Connect your device to the serial-to-USB adapter or plug in NodeMCU/D1 mini. Check whether the correct serial port (COM or tty port) is selected. Tasmotizer! will try its best to select the right one for you. Choose Tasmota firmware binary: BIN file - browse to the Tasmota firmware binary you downloaded or compiled. Release - select from a list of available release binaries Development - select from a list of latest development binaries optional Backup the original device firmware Erase flash Danger Leave Erase before flashing checked if it is the first time flashing Tasmota on the device or you're experiencing issues with the existing flash and need to do a full erase. If you're upgrading an already flashed Tasmota and wish to keep your settings, uncheck Erase before flashing . Click Tasmotize and wait until done. If the flash was successful it will display: Unplug your serial programming adapter or device and plug it back in or connect to another power source. You can use Send Config Tasmotizer! button for the initial configuration of your device instead of webUI. esptool.py ~ Esptool is the official Espressif tool for flashing ESP8266 chips. It requires Python, if you do not have an installed copy of Python 2.x or 3.x download and install it from https://www.python.org. Download the esptool Source code to a folder of your choice. Go to the folder and install Esptool with command python setup.py install Upload Tasmota Make sure you followed the steps to put your device in flash mode. Place your chosen firmware binary file in the same folder as esptool.py. Esptool uses the serial interface to communicate with your device. On Windows these interfaces are named COM1, COM2, etc. and on Linux they are named /dev/ttyUSB0, /dev/ttyUSB1, etc. Before using esptool, make sure you know which serial port your programming adapter is connected to. The following use COM5 as an example. Change COM5 with your serial port designation. Ensure the device is in flash mode before each step. Backup Firmware (optional step) Backup the current firmware with the following command: esptool . py -- port COM5 read_flash 0x00000 0x100000 fwbackup . bin When the command completes the device is not in flash mode anymore. Repeat the process of putting your device in programming mode. Erase Flash Memory Erase the complete flash memory holding the firmware with the following command: esptool . py -- port COM5 erase_flash It only takes a few seconds to erase 1M of flash. When the command completes the device is not in flash mode anymore. Repeat the process of putting your device in programming mode. Upload Firmware Load the chosen Tasmota firmware file with the following command (e.g., tasmota.bin in this example): esptool . py -- port COM5 write_flash - fs 1 MB - fm dout 0x0 tasmota . bin Unplug your serial programming adapter or your device and plug it back in or connect to another power source. Your device is now ready for Initial configuration . For proper device initialization after the firmware upload completes, power down and power up the device. Esptool Executable ~ The executable version of esptool is maintained by Ivan Grokhotkov and releases are kept at https://github.com/igrr/esptool-ck/releases . Supports Linux, Linux ARM, Windows 32-bit and Mac First Step For the purpose of simplicity only the Windows version will be explained here, but the commands and parameters are the same for Windows, Linux and Mac. Download the latest release of Esptool-CK and extract the compressed file to a folder of your choice. Place your chosen firmware binary file (e.g., tasmota.bin in the example below) in the same folder as Esptool-CK to simplify the process. The following commands use COM5 as an example. Change COM5 with your port designation. Ensure the device is in flash mode before each step. Erase Flash Memory esptool - cp COM5 - ce - v Upload firmware Once the erase is complete, put device back into programming mode and upload the firmware esptool - cp COM5 - bm dout - cf tasmota . bin - v Unplug your serial programming adapter or your device and plug it back in or connect to another power source. Your device is now ready for Initial configuration . For proper device initialization after the firmware upload completes, power down and power up the device. OTA Conversion Tasmota is NOT a developer of these tools. For help and troubleshooting you will need to get support from those projects . Tuya-Convert - easy OTA flash for devices with Tuya chips, no disassembly required Sonoff DIY - OTA flash for select Sonoff devices (some disassembly required) You've successfully flashed your device with a downloaded binary of Tasmota but now you need to connect the tasmotised device to your Wi-Fi network. Initial Configuration ~ Using Web UI ~ Configure Wi-Fi Tasmota provides a wireless access point for easy Wi-Fi configuration. If you flashed using Tuya Convert this is the only option to set up your device. Connect your device to a power source and grab your smartphone (or tablet or laptop or any other web and Wi-Fi capable device). Search for a Wi-Fi AP named tasmota_XXXXXX-#### (where XXXXXX is a string derived from the device's MAC address and #### is a number) and connect to it. In this example the Wi-Fi AP is named tasmota_3D5E26-7718 . When it connects to the network, you may get a warning that there is no Internet connection and be prompted to connect to a different network. Do not allow the mobile device to select a different network . Warning Wi-Fi manager server is active for only 3 minutes. If you miss the window you might have to disconnect your device from power and reconnect. After you have connected to the Tasmota Wi-Fi AP, open http://192.168.4.1 in a web browser on the smartphone (or whatever device you used). Depending on the phone, it will take you to the Tasmota configuration page automatically, or you will get a prompt to sign in to Wi-Fi network or authorize . Tapping on the AP name should also open the configuration page. At this page you can have Tasmota scan for available Wi-Fi networks. Select the right network from the list or enter the following: AP1 SSid - your Wi-Fi network name SSID's are case sensitive AP1 Password - password for your Wi-Fi AP Wi-Fi password has to be under 32 characters and without special characters (e.g. asterisks) or white spaces Recommended: AP2 SSid - alternative Wi-Fi network SSID AP2 Password - password for your alternative Wi-Fi AP Click the checkbox to see the password you enter to ensure that it is correct and that your mobile device has not inadvertently capitalized the first letter if it is supposed to be lower case nor autocorrected what you entered. ~~Double~~ Triple check the Wi-Fi credentials and click on Save to apply the settings. The device will restart and connect to your home network. The tasmota_XXXXXX-#### network will not longer be present. Therefore your smartphone will automatically be disconnected and should connect back to its data network. Tip If you're not using a second Wi-Fi network you can enter an SSID without a password you can connect to as a backup in case something went wrong with your Wi-Fi credentials. Configure MQTT Look in your router for a newly connected device with the same name as the Wi-Fi access point. In our example it is tasmota_3D5E26-7718 . tasmota_XXXXXX is also the firmware default MQTT topic for that device If you don't have access to your router you can find your newly flashed device with an IP scanner: Fing - for Android or iOS Angry IP Scanner - open source for Linux, Windows and Mac. Requires Java. Super Scan - Windows only too (free) Tasmota Device Locator - Browser-based Open the IP address with your web browser and you have full access to Tasmota. Now is the time to set up MQTT and the last remaining, but equally important, step: Configure Template or Module Configure your device using Templates in Configuration - Configure Template or Modules in Configuration - Configure Module . Your device running Tasmota is now ready to be controlled . Check out all the supported devices in Tasmota Device Templates Repository Configure Other (optional) Configure your device name which is displayed in webUI and used for Home Assistant autodiscovery . Configure web admin password for the webUI. Default username is admin . This type of security is rudimentary since Tasmota doesn't use HTTPS, do not expose your device outside of your local network. Using Serial Terminal ~ If you flashed the device using serial-to-USB adapter (or it is a NodeMCU/D1 mini) you can take advantage of the existing connection and configure your device over the serial connection using Commands . First you will need a Serial Terminal program. In this example Termite on Windows is used. Download Termite and extract the .exe file, no installation necessary. Connect your serial-to-USB adapter or NodeMCU/D1 mini to the computer. Open Termite and set it to the proper COM port ( Termite selects the first available port by default ). Set Baud rate to 115200 and Forward to none. Connect your device to the serial-to-USB adapter. You should see the initial boot output in Termite. If your screen is empty type status in the bottom command bar and hit enter. If you get a return message from your device similar to the one displayed under purple status you're all set. To configure Tasmota you need to issue commands, some commands will reboot your device and to avoid that we will use the Backlog command feature. Configure your Wi-Fi network and a secondary Wi-Fi network Backlog ssid1 <yourssid>; password1 <your_password>; ssid2 <your_ssid2>; password2 <your_password> Device will restart and connect to your network. It will display your devices newly assigned IP. Direct your web browser to that IP address to access the Web UI for further configuration and contol. Configure MQTT broker address, MQTT credentials, unique device topic and OTA url to the latest official release Backlog mqtthost <yourhost>; mqttuser <user>; mqttpassword <password>; topic <unique_topic>; otaurl http://ota.tasmota.com/tasmota/release/tasmota.bin Tip Keep your personal configuration in a text file and simply copy and paste the backlog commands to a newly flashed device. After Configuration ~ Your device is connected to your network and to the MQTT broker. One last thing to do is configure your device using Templates in Configuration - Configure Template or Modules in Configuration - Configure Module . Check out all the supported devices in Tasmota Device Templates Repository Warning If you experience power fluctuations in your power grid its best to immediately disable Power Cycle Recovery feature with command SetOption65 1 immediately or you might end up with firmware defaults on your device. Commands and Backlog are powerful and in time you can learn to configure almost everything (NTP servers, longitude and latitude, custom device options, etc) with a few copy and paste moves.","title":"Getting Started"},{"location":"Getting-Started/#prerequisites","text":"","title":"Prerequisites"},{"location":"Getting-Started/#needed-hardware","text":"","title":"Needed Hardware"},{"location":"Getting-Started/#needed-software","text":"","title":"Needed Software"},{"location":"Getting-Started/#mqtt-knowledge","text":"Tasmota is designed to be controlled and communicate via MQTT . To use it to its fullest potential you need an MQTT broker . Read our article on MQTT to learn why it is essential in Tasmota.","title":"MQTT Knowledge"},{"location":"Getting-Started/#compiling-tools-optional","text":"If you want to modify the code or default settings and compile your own Tasmota firmware .","title":"Compiling Tools (Optional)"},{"location":"Getting-Started/#hardware-preparation","text":"We need to connect to the serial programming interface of the ESP8266 chip. This is done by connecting our serial-to-USB converter TX and RX pins to the ESP8266 RX and TX pins and powering the chip with the 3.3V and GND pins. In most cases those pins are available on the PCB in the form of pin holes or solder pads but pin headers or jumper wires need to be soldered or otherwise applied. In some cases you will need to solder wires directly on the chip's pins which requires some experience and good soldering equipment. BEWARE! DO NOT CONNECT DEVICES TO MAINS POWER WHILE THE COVER IS OPEN AND CIRCUIT BOARD IS EXPOSED!!! NEVER TRY TO FLASH WHILE YOUR DEVICE IS CONNECTED TO MAINS POWER!!! YOU CAN BE ELECTROCUTED IF YOU DON'T KNOW WHAT YOU ARE DOING! If you are not careful, your own health will be in danger. Shorting your serial interface with mains AC power will fry your device and serial adapter and will also harm or destroy your computer. It is important to always have all mains power cables disconnected from the device while being connected via serial or even while the case of the device is opened.","title":"Hardware Preparation"},{"location":"Getting-Started/#serial-connection","text":"Each device has its pins labelled differently. If the labelling isn't visible on the PCB please refer to the devices flashing guide or search the Internet for correct pin locations. Device specific instructions and restrictions are documented in the Tasmota Device Templates Repository . Pinouts for commonly used Wi-Fi modules are found here When you have identified pins on your device, connect wires according to the table: Serial adapter ESP8266 device 3V3 3V3 or VCC TX RX RX TX GND GND Note that TX from your adapter goes to RX on the ESP8266 device and RX from adapter goes to TX on the device!","title":"Serial Connection"},{"location":"Getting-Started/#programming-mode","text":"ESP8266 needs to be put into programming mode or flash mode before the firmware can be uploaded. This is done by pulling the GPIO0 pin to GND while the chip is booting. On most devices the installed control button is connected to GPIO0 and GND, making entering Programming Mode very easy. On others you will need to bridge the pins on the PCB or directly on the chip with a jumper wire. GPIO0 is always in the same location on ESP8266 and ESP8285! Device specific instructions are documented in Tasmota Device Templates Repository . To put the ESP8266 into Programming Mode: Disconnect serial-to-USB adapter and power Bridge GPIO0 and GND (by pressing the on-board button or connection with a wire) Connect the serial-to-USB adapter to your computer After a few seconds disconnect GPIO0 from GND (release button or remove the wire connection). On devices that do not provide the GPIO0 connected button, it may be easier to leave the wired bridge in place throughout the entire flashing process (erase & upload). Doing so will not create any problems. After the firmware is uploaded successfully, remove the bridge. This allows the device to boot normally. You can test whether your device is in Programming Mode by attempting to read information from the ESP82xx chip. This requires esptool.py . Instructions on installing and using esptool are provided below . For example ( COM5 will be your COM port): esptool.py -p COM5 read_mac (It should read the MAC address. It may fail afterwards during Uploading and running a \"stub\". This is normal.) esptool.py -p COM5 flash_id If everything went well, you are now in Programming Mode and ready to continue with flashing . If the flashing process is unable to start, disconnect the device and retry the steps.","title":"Programming Mode"},{"location":"Getting-Started/#common-mistakes","text":"Wire connections and solder joints - Double check all connections and also check for solder overflow. Use a USB data cable - Some USB cables are for charging only and do not connect the data lines needed to load the firmware onto the device. Insufficient power delivered over the serial-to-USB adapter. This leads to flashing failures or corrupted flash altogether. Supply more power with a separate 3.3V power supply or get an adapter with a better power supply. Be sure all DC voltages use the same GND reference. Recheck your serial-to-USB adapter so to ensure that it supplies 3.3V voltage and NOT 5V . 5V will damage the ESP chip! Releasing GPIO0 button/wire before booting is finished - It is safe to leave GPIO0 connected to GND during the entire programming process (erase & upload). Just be sure to remove the GPIO0 to GND bridge before booting the device for regular operation. Make sure that the RX pin is connected to the TX pin between the serial adapter and your ESP device, and vice versa. Erase the flash memory first and cycle power afterwards before uploading the Tasmota firmware binary. Not erasing can leave behind remnants of the previous flash contents which can interfere with the new firmware operation.","title":"Common Mistakes"},{"location":"Getting-Started/#flashing","text":"If you have followed Hardware preparation , your device should be in Flash Mode and ready for a Tasmota firmware binary file to be flashed. For that you need a flashing tool . Tip You may want to back up the device manufacturer's firmware on the one in a million chance you don't like Tasmota.","title":"Flashing"},{"location":"Getting-Started/#tasmotizer","text":"Tasmotizer! is specifically designed for use with Tasmota with an easy to use GUI and esptool.py under the hood. Download the latest release for your platform. In Windows just double click the downloaded file and it'll start, no installation required. For python follow the installation instructions . Video tutorial by SuperHouseTV Note If you get an anti-virus infection warning don't fret, it is a known false positive . If you're still apprehensive you can always run the Python version. It is time to Tasmotize! Connect your device to the serial-to-USB adapter or plug in NodeMCU/D1 mini. Check whether the correct serial port (COM or tty port) is selected. Tasmotizer! will try its best to select the right one for you. Choose Tasmota firmware binary: BIN file - browse to the Tasmota firmware binary you downloaded or compiled. Release - select from a list of available release binaries Development - select from a list of latest development binaries optional Backup the original device firmware Erase flash Danger Leave Erase before flashing checked if it is the first time flashing Tasmota on the device or you're experiencing issues with the existing flash and need to do a full erase. If you're upgrading an already flashed Tasmota and wish to keep your settings, uncheck Erase before flashing . Click Tasmotize and wait until done. If the flash was successful it will display: Unplug your serial programming adapter or device and plug it back in or connect to another power source. You can use Send Config Tasmotizer! button for the initial configuration of your device instead of webUI.","title":"Tasmotizer!"},{"location":"Getting-Started/#esptoolpy","text":"Esptool is the official Espressif tool for flashing ESP8266 chips. It requires Python, if you do not have an installed copy of Python 2.x or 3.x download and install it from https://www.python.org. Download the esptool Source code to a folder of your choice. Go to the folder and install Esptool with command python setup.py install","title":"esptool.py"},{"location":"Getting-Started/#esptool-executable","text":"The executable version of esptool is maintained by Ivan Grokhotkov and releases are kept at https://github.com/igrr/esptool-ck/releases . Supports Linux, Linux ARM, Windows 32-bit and Mac","title":"Esptool Executable"},{"location":"Getting-Started/#initial-configuration","text":"","title":"Initial Configuration"},{"location":"Getting-Started/#using-web-ui","text":"","title":"Using Web UI"},{"location":"Getting-Started/#using-serial-terminal","text":"If you flashed the device using serial-to-USB adapter (or it is a NodeMCU/D1 mini) you can take advantage of the existing connection and configure your device over the serial connection using Commands . First you will need a Serial Terminal program. In this example Termite on Windows is used. Download Termite and extract the .exe file, no installation necessary. Connect your serial-to-USB adapter or NodeMCU/D1 mini to the computer. Open Termite and set it to the proper COM port ( Termite selects the first available port by default ). Set Baud rate to 115200 and Forward to none. Connect your device to the serial-to-USB adapter. You should see the initial boot output in Termite. If your screen is empty type status in the bottom command bar and hit enter. If you get a return message from your device similar to the one displayed under purple status you're all set. To configure Tasmota you need to issue commands, some commands will reboot your device and to avoid that we will use the Backlog command feature. Configure your Wi-Fi network and a secondary Wi-Fi network Backlog ssid1 <yourssid>; password1 <your_password>; ssid2 <your_ssid2>; password2 <your_password> Device will restart and connect to your network. It will display your devices newly assigned IP. Direct your web browser to that IP address to access the Web UI for further configuration and contol. Configure MQTT broker address, MQTT credentials, unique device topic and OTA url to the latest official release Backlog mqtthost <yourhost>; mqttuser <user>; mqttpassword <password>; topic <unique_topic>; otaurl http://ota.tasmota.com/tasmota/release/tasmota.bin Tip Keep your personal configuration in a text file and simply copy and paste the backlog commands to a newly flashed device.","title":"Using Serial Terminal"},{"location":"Getting-Started/#after-configuration","text":"Your device is connected to your network and to the MQTT broker. One last thing to do is configure your device using Templates in Configuration - Configure Template or Modules in Configuration - Configure Module . Check out all the supported devices in Tasmota Device Templates Repository Warning If you experience power fluctuations in your power grid its best to immediately disable Power Cycle Recovery feature with command SetOption65 1 immediately or you might end up with firmware defaults on your device. Commands and Backlog are powerful and in time you can learn to configure almost everything (NTP servers, longitude and latitude, custom device options, etc) with a few copy and paste moves.","title":"After Configuration"},{"location":"Gitpod/","text":"Even though Tasmota offers several pre-compiled firmware variants, sometimes the ready-to-flash binaries aren't enough. If you need to enable or disable some features, or simply change some parameters, then you need to compile a firmware binary yourself. If you are not experienced enough or don't want to install an IDE (Integrated Development Environment) like PlatformIO or ATOM on your computer, compiling your own firmware is a breeze using Gitpod . Gitpod is a web browser based online IDE. All you need to use it is to link your GitHub account (or make a new one here ). Gitpod will take care of all the necessary software package dependencies for you. After you successfully sign in, you can start your personal project. The fastest way to load Tasmota into Gitpod is with one of the following links: Development Branch: https://gitpod.io#https://github.com/arendst/Tasmota/tree/development Master Release: https://gitpod.io#https://github.com/arendst/Tasmota/tree/master TasmoCompiler : https://gitpod.io/#https://github.com/benzino77/tasmocompiler Browser Extension Gitpod has a browser extension (Chrome and Firefox) which is handy to directly load a GitHub project into your personal Gitpod work-space. More information on the Gitpod browser extension . Using Gitpod ~ After Gitpod loads the project, you will be greeted by the main window. Gitpod will then automatically compile tasmota.bin . Wait for the compilation to complete. The display consists of three panels: Explorer Editor Terminal Customize Firmware Features and Settings ~ Warning The proper method of customizing firmware compilation options is to use the user_config_override.h file. You should not change the my_user_config.h file. To modify the stock configuration: Select the /tasmota folder in the Explorer (1) pane Create a new file called user_config_override.h In the Editor (2) pane, add, change, or remove anything you need in your configuration file to define your own settings. Refer to the user_config_override_sample.h file as well as my_user_config.h for #define options ( sample ). You can find a list of Tasmota features and settings listed here . Define the features you require in your configuration file. Click 'File' on the menu bar and 'Save' your edits. Prepare the IDE for Compilation ~ Open the platformio.ini file located in the /tasmota root directory (scroll to the bottom of the file Explorer (1) pane). In this file, removing a leading semicolon ; enables a statement. In the Editor (2) pane: If you are using your own user_config_override.h , you must tell the compiler to use it. Rename platformio_override_sample.ini to platformio_override.ini . This enables -DUSE_CONFIG_OVERRIDE . Default Tasmota Arduino Core will be compiled. If you wish to use a different Core, find the [core_active] section in the file and enable the platform and build_flags lines for the desired Core. Then click 'File' on the menu bar and 'Save' your edits. Compile Your Firmware ~ This action is done in the Terminal pane (3) with simple commands. The simplest one is platformio run -e tasmota . With this command, Gitpod will compile the Tasmota firmware with the features you selected. If you need a different variant, you can specify this option on the command line: platformio run -e <variant-name> Examples: platformio run -e tasmota-sensors platformio run -e tasmota-DE Compilation normally takes only a couple of minutes. The time it takes is directly related to how many variants you build. When done, you will find the firmware file in the folder /Tasmota/build_output/firmware/<variant-name>.bin in the Explorer (1) pane. Download <variant-name>.bin to your computer by right-clicking on the file and selecting 'Download'. You are now ready to flash your device. Watch a livestream video by digiblurDIY of compiling Tasmota using Gitpod. Flash Your Device ~ OTA Flash If you already have Tasmota flashed on your device, you can use the File Upload OTA method to load the new firmware binary file. Download tasmota-minimal.bin Make a backup of the device configuration using the web UI Configuration menu option. Upload tasmota-minimal.bin to your device using the web UI Firmware Upgrade selection. Choose Upgrade by file upload . After tasmota-minimal.bin is successfully loaded, select Firmware Upgrade once again and upload the firmware file compiled using Gitpod. Serial Flash Follow the same procedure for flashing as you would any new device.","title":"Gitpod"},{"location":"Gitpod/#using-gitpod","text":"After Gitpod loads the project, you will be greeted by the main window. Gitpod will then automatically compile tasmota.bin . Wait for the compilation to complete. The display consists of three panels: Explorer Editor Terminal","title":"Using Gitpod"},{"location":"Gitpod/#customize-firmware-features-and-settings","text":"Warning The proper method of customizing firmware compilation options is to use the user_config_override.h file. You should not change the my_user_config.h file. To modify the stock configuration: Select the /tasmota folder in the Explorer (1) pane Create a new file called user_config_override.h In the Editor (2) pane, add, change, or remove anything you need in your configuration file to define your own settings. Refer to the user_config_override_sample.h file as well as my_user_config.h for #define options ( sample ). You can find a list of Tasmota features and settings listed here . Define the features you require in your configuration file. Click 'File' on the menu bar and 'Save' your edits.","title":"Customize Firmware Features and Settings"},{"location":"Gitpod/#prepare-the-ide-for-compilation","text":"Open the platformio.ini file located in the /tasmota root directory (scroll to the bottom of the file Explorer (1) pane). In this file, removing a leading semicolon ; enables a statement. In the Editor (2) pane: If you are using your own user_config_override.h , you must tell the compiler to use it. Rename platformio_override_sample.ini to platformio_override.ini . This enables -DUSE_CONFIG_OVERRIDE . Default Tasmota Arduino Core will be compiled. If you wish to use a different Core, find the [core_active] section in the file and enable the platform and build_flags lines for the desired Core. Then click 'File' on the menu bar and 'Save' your edits.","title":"Prepare the IDE for Compilation"},{"location":"Gitpod/#compile-your-firmware","text":"This action is done in the Terminal pane (3) with simple commands. The simplest one is platformio run -e tasmota . With this command, Gitpod will compile the Tasmota firmware with the features you selected. If you need a different variant, you can specify this option on the command line: platformio run -e <variant-name> Examples: platformio run -e tasmota-sensors platformio run -e tasmota-DE Compilation normally takes only a couple of minutes. The time it takes is directly related to how many variants you build. When done, you will find the firmware file in the folder /Tasmota/build_output/firmware/<variant-name>.bin in the Explorer (1) pane. Download <variant-name>.bin to your computer by right-clicking on the file and selecting 'Download'. You are now ready to flash your device. Watch a livestream video by digiblurDIY of compiling Tasmota using Gitpod.","title":"Compile Your Firmware"},{"location":"Gitpod/#flash-your-device","text":"","title":"Flash Your Device"},{"location":"GladysAssistant/","text":"Tasmota supports Gladys Assistant MQTT for both relays and sensors. HTTP protocol incoming soon. Find below the procedure to configure Gladys Assistant and Tasmota. Prerequisites The following servers should be made available: You have installed Gladys Assistant (embedded MQTT broker available) You have installed/access to a MQTT broker server and made contact with your Tasmota device Automatic Disovery ~ Gladys Assistant automatically discovers Tasmota devices (once all are connected on same MQTT broker). On Gladys Assistant application: Go to Integration page Look for Tasmota element, click on it Then, MQTT discover Save to add device Try on Gladys Assistant demonstration website .","title":"GladysAssistant"},{"location":"GladysAssistant/#automatic-disovery","text":"Gladys Assistant automatically discovers Tasmota devices (once all are connected on same MQTT broker). On Gladys Assistant application: Go to Integration page Look for Tasmota element, click on it Then, MQTT discover Save to add device Try on Gladys Assistant demonstration website .","title":"Automatic Disovery"},{"location":"HC-SR04/","text":"HC-SR04 ultrasonic ranging sensor ~ This feature is included only in tasmota-sensors.bin HC-SR04 (HC-SR04P and JSN-SR04T) is an ultrasonic ranging sensor. Provides 2cm to 400cm of non-contact measurement functionality with a ranging accuracy that can reach up to 3mm. Each HC-SR04 module includes an ultrasonic transmitter, a receiver and a control circuit. See HC-SR04 Ultrasonic Sensor for more information. Buy example: - AliExpress - Sparkfun Configuration ~ Wiring ~ HC-SR04 ESP8266 Vcc 5V GND GND Trig GPIOx Echo use voltage divider! GPIOy The HC-SR04 operates at 5V and therefore the echo signal will be 5V as well. Connecting the echo pin via a voltage divider (see schematic) will divide the 5V to 3.3V, which is the operating voltage of an ESP8266. There is a variant of the HC-SR04, called HC-SR04P. It mainly operates at 3.3V and then it doesn't need the voltage divider but you will notice a range drop of about 1 meter. Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to SR04 Tri (69) GPIOy to SR04 Ech (70) Tasmota Main ~ After a reboot webUI displays the HC-SR04 distance. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-01-01T22:42:35\" , \"SR04\" :{ \"Distance\" : 16.754 }}","title":"HC-SR04 ultrasonic ranging sensor"},{"location":"HC-SR04/#hc-sr04-ultrasonic-ranging-sensor","text":"This feature is included only in tasmota-sensors.bin HC-SR04 (HC-SR04P and JSN-SR04T) is an ultrasonic ranging sensor. Provides 2cm to 400cm of non-contact measurement functionality with a ranging accuracy that can reach up to 3mm. Each HC-SR04 module includes an ultrasonic transmitter, a receiver and a control circuit. See HC-SR04 Ultrasonic Sensor for more information. Buy example: - AliExpress - Sparkfun","title":"HC-SR04 ultrasonic ranging sensor"},{"location":"HC-SR04/#configuration","text":"","title":"Configuration"},{"location":"HC-SR04/#wiring","text":"HC-SR04 ESP8266 Vcc 5V GND GND Trig GPIOx Echo use voltage divider! GPIOy The HC-SR04 operates at 5V and therefore the echo signal will be 5V as well. Connecting the echo pin via a voltage divider (see schematic) will divide the 5V to 3.3V, which is the operating voltage of an ESP8266. There is a variant of the HC-SR04, called HC-SR04P. It mainly operates at 3.3V and then it doesn't need the voltage divider but you will notice a range drop of about 1 meter.","title":"Wiring"},{"location":"HC-SR04/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to SR04 Tri (69) GPIOy to SR04 Ech (70)","title":"Tasmota Settings"},{"location":"HC-SR04/#tasmota-main","text":"After a reboot webUI displays the HC-SR04 distance. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-01-01T22:42:35\" , \"SR04\" :{ \"Distance\" : 16.754 }}","title":"Tasmota Main"},{"location":"HM-10/","text":"HM-10 Bluetooth module ~ This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_HM10 #define USE_HM10 // Add support BLE sensor bridge (+5k1 code) #endif #ifndef USE_IBEACON #define USE_IBEACON // Add support for bluetooth LE passive scan of ibeacon devices #endif HM-10 is a Bluetooth BLE V4.0 module based on TI CC254x chip. Originally manufactured by Jinan Huamao but there are many clones in the market ( MLT-BT05, CC41-A , JDY-08 , AT-09, ...) While they look similar and utilize the same CC254x Bluetooth chip, the firmware on them is different. In order to get any type of module to work work Tasmota it is mandatory to flash the original firmware on it . Use the newest V710 firmware but at least V609 is required to work with the Tasmota driver. Tip It is possible to do this without soldering by directly sticking male jumper wire connectors through the plastic foil on some boards or using some removable adhesives (bluetack). Configuration ~ Check whether your module is communicating properly over its TX/RX pins and that it has the required firmware (preferably HMSoft V707 ). Only when you're sure everything is ok proceed with the configuration. Wiring ~ HM-10 ESP8266 GND GND VCC 3.3V TX GPIOx RX GPIOy You can use TX and RX pins for GPIOx, GPIOy. Tasmota Settings for BLE sensors ~ In the Configuration -> Configure Module page assign: GPIOx to HM10 TX (195) GPIOy to HM10 RX (194) If you have the proper firmware, webUI in the Main Menu should show (in this case V707 is the flashed firmware version): If you have supported Bluetooth devices in range, they will soon be discovered and start to populate the webUI with data as it is transmitted: Warning Most of the self-flashed modules will still have their factory default settings with baud rate of 9600 but Tasmota requires 115200. To fix try commands from Tasmota console: HM10Baud 9600 (sets 9600 baud rate on Tasmota side) then HM10AT RENEW (reset HM10 to factory settings which should use 115200 baud rate on newer firmware) and reboot Tasmota. If that doesn't solve it you will have to connect to the HM-10 with serial-to-USB adapter and set the baudrate in a terminal using commands AT+RENEW then AT+BAUD? . If the output is 4 baudrate is properly set to 115200, if not use AT+BAUD4 For a complete overview of supported devices, commands and features read the Bluetooth article Tasmota Settings for iBeacon ~ In the Configuration -> Configure Module page assign: GPIOx to iBeacon TX (168) GPIOy to iBeacon RX (169) When first connected HM-10 is in peripheral mode. You have to change it to central mode using commands Sensor52 1 and Sensor52 2 . If you have supported iBeacon Bluetooth devices in range, they will be discovered and will start to populate the webUI with data: For a complete overview of supported devices, commands and features read the Bluetooth article Breakout Boards ~","title":"HM-10 Bluetooth module"},{"location":"HM-10/#hm-10-bluetooth-module","text":"This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_HM10 #define USE_HM10 // Add support BLE sensor bridge (+5k1 code) #endif #ifndef USE_IBEACON #define USE_IBEACON // Add support for bluetooth LE passive scan of ibeacon devices #endif HM-10 is a Bluetooth BLE V4.0 module based on TI CC254x chip. Originally manufactured by Jinan Huamao but there are many clones in the market ( MLT-BT05, CC41-A , JDY-08 , AT-09, ...) While they look similar and utilize the same CC254x Bluetooth chip, the firmware on them is different. In order to get any type of module to work work Tasmota it is mandatory to flash the original firmware on it . Use the newest V710 firmware but at least V609 is required to work with the Tasmota driver. Tip It is possible to do this without soldering by directly sticking male jumper wire connectors through the plastic foil on some boards or using some removable adhesives (bluetack).","title":"HM-10 Bluetooth module"},{"location":"HM-10/#configuration","text":"Check whether your module is communicating properly over its TX/RX pins and that it has the required firmware (preferably HMSoft V707 ). Only when you're sure everything is ok proceed with the configuration.","title":"Configuration"},{"location":"HM-10/#wiring","text":"HM-10 ESP8266 GND GND VCC 3.3V TX GPIOx RX GPIOy You can use TX and RX pins for GPIOx, GPIOy.","title":"Wiring"},{"location":"HM-10/#tasmota-settings-for-ble-sensors","text":"In the Configuration -> Configure Module page assign: GPIOx to HM10 TX (195) GPIOy to HM10 RX (194) If you have the proper firmware, webUI in the Main Menu should show (in this case V707 is the flashed firmware version): If you have supported Bluetooth devices in range, they will soon be discovered and start to populate the webUI with data as it is transmitted: Warning Most of the self-flashed modules will still have their factory default settings with baud rate of 9600 but Tasmota requires 115200. To fix try commands from Tasmota console: HM10Baud 9600 (sets 9600 baud rate on Tasmota side) then HM10AT RENEW (reset HM10 to factory settings which should use 115200 baud rate on newer firmware) and reboot Tasmota. If that doesn't solve it you will have to connect to the HM-10 with serial-to-USB adapter and set the baudrate in a terminal using commands AT+RENEW then AT+BAUD? . If the output is 4 baudrate is properly set to 115200, if not use AT+BAUD4 For a complete overview of supported devices, commands and features read the Bluetooth article","title":"Tasmota Settings for BLE sensors"},{"location":"HM-10/#tasmota-settings-for-ibeacon","text":"In the Configuration -> Configure Module page assign: GPIOx to iBeacon TX (168) GPIOy to iBeacon RX (169) When first connected HM-10 is in peripheral mode. You have to change it to central mode using commands Sensor52 1 and Sensor52 2 . If you have supported iBeacon Bluetooth devices in range, they will be discovered and will start to populate the webUI with data: For a complete overview of supported devices, commands and features read the Bluetooth article","title":"Tasmota Settings for iBeacon"},{"location":"HM-10/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"HM-17/","text":"HM-17 Bluetooth module ~ This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_IBEACON #define USE_IBEACON // Add support for bluetooth LE passive scan of ibeacon devices #endif HM-17 and HM-16 are a Bluetooth BLE V4.1 module based on TI CC2640R2f chip. Manufactured by Jinan Huamao Configuration ~ Check whether your module is communicating properly over its TX/RX pins and that it has the required firmware (firmware V120 or V110). Only when you're sure everything is ok proceed with the configuration. Wiring ~ HM-16/17 ESP8266 GND GND VCC 3.3V TX GPIOx RX GPIOy Tasmota Settings for iBeacon ~ In the Configuration -> Configure Module page assign: GPIOx to iBeacon TX (168) GPIOy to iBeacon RX (169) When first connected HM-16/17 is in peripheral mode. You have to change it to central mode using commands Sensor52 1 and Sensor52 2 . If you have supported iBeacon Bluetooth devices in range, they will be discovered and will start to populate the webUI with data: For a complete overview of supported devices, commands and features read the Bluetooth article Breakout Boards ~","title":"HM-17 Bluetooth module"},{"location":"HM-17/#hm-17-bluetooth-module","text":"This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_IBEACON #define USE_IBEACON // Add support for bluetooth LE passive scan of ibeacon devices #endif HM-17 and HM-16 are a Bluetooth BLE V4.1 module based on TI CC2640R2f chip. Manufactured by Jinan Huamao","title":"HM-17 Bluetooth module"},{"location":"HM-17/#configuration","text":"Check whether your module is communicating properly over its TX/RX pins and that it has the required firmware (firmware V120 or V110). Only when you're sure everything is ok proceed with the configuration.","title":"Configuration"},{"location":"HM-17/#wiring","text":"HM-16/17 ESP8266 GND GND VCC 3.3V TX GPIOx RX GPIOy","title":"Wiring"},{"location":"HM-17/#tasmota-settings-for-ibeacon","text":"In the Configuration -> Configure Module page assign: GPIOx to iBeacon TX (168) GPIOy to iBeacon RX (169) When first connected HM-16/17 is in peripheral mode. You have to change it to central mode using commands Sensor52 1 and Sensor52 2 . If you have supported iBeacon Bluetooth devices in range, they will be discovered and will start to populate the webUI with data: For a complete overview of supported devices, commands and features read the Bluetooth article","title":"Tasmota Settings for iBeacon"},{"location":"HM-17/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"Home-Assistant/","text":"Home Assistant ~ Home Assistant support is not built in to tasmota-lite.bin. Use the standard tasmota.bin or other binaries that include Home Assistant support. Home Assistant is an open source home automation solution that puts local control and privacy first. Tasmota communicates with Home Assistant using MQTT. Before going any further, make sure MQTT is properly set up in Home Assistant and Tasmota . Home Assistant has different options of adding Tasmota devices: Official Tasmota (beta) integration ( preferred ) MQTT discovery ( development halted ) Manual configuration by editing configuration.yaml Tasmota (beta) Integration ~ Once you configure the Home Assistant integration every new Tasmota device with SetOption19 0 set, will be discovered automatically. All Tasmota devices will be listed in their own Tasmota (beta) card in Configuration - Integrations menu in Home Assistant. Warning Do not change the FullTopic in order to use this feature. Leave it as default. Tasmota uses DeviceName to name the device in Tasmota (beta) integration and FriendlyName<x> to name power outputs (switch or light entities in HA). Supported Entities ~ Lights as light entities. Single channel Dimmers, RGB lights, RGB lights with Color Temperature control and RGB lights with White control are supported. Relays as switch entities With SetOption30 1 all relays one the device will be added as light entities instead Sensors as sensor entities Switches as binary_sensor entities or automation triggers depending on SwitchMode used when SetOption114 1 Buttons as automation triggers when SetOption73 is enabled Shutters as cover entities. Currently only shutter modes 1 to 4 are supported. Shutter mode 5 and Tuya shutters are not supported. Devices configured as iFan02 or iFan03 as fan entities. Tuya fans are not supported. Each discovered device will by default add 8 disabled sensors. Enable the ones you need. You cannot delete them, they will simply be re-added on a restart. Types of devices not listed above still require manual configuration Zigbee devices paired in Tasmota will NOT be discovered in Home Assistant Transition from MQTT Discovery ~ If you have been using SetOption19 1 for device discovery, setting it to SetOption19 0 will remove your Tasmota device from the MQTT device list and add it to the Tasmota integrations in HA. They will be treated as new entities in Home Assistant but if you previously used default values they will use the same entity_id as the MQTT discovery devices. Removing devices ~ You cannot as long as Home Assistant support is enabled in your Tasmota binary. Disable the device in Home Assistant instead. There is no setoption to disable all autodiscovery. Deleting them from Home Assistant while Tasmota device is still active will simply rediscover all the entities. If you opt to switch to MQTT Discovery, issuing SetOption19 1 command will remove all Tasmota (beta) entities and add new entities under the MQTT integration. Editing configuration.yaml ~ Adding devices manually is done by editing the configuration.yaml file and adding appropriate blocks of yaml code to the corresponding section. After every change to the configuration.yaml file you'll need to restart Home Assistant to make it aware of the changes. The advantage of manually configuring a device is that you maintain control of all aspects of the configuration. All the configurations are just examples. You need to be familiar with Home Assistant's configuration structure and procedures. Straight copy paste of the given examples into configuration.yaml will probably not work for you. If you are using a localized (non-english) version be sure to check the correct spelling and cases for values: 'payload_available' 'payload_not_available' 'payload_on' 'payload_off' Tip If you want the power states to be persistent in Tasmota and Home Assistant set PowerRetain 1 instead of using retain: true in Home Assistant Switches ~ Add in Home Assistant using the MQTT Switch integration. Required Commands SetOption59 1 - enables sending of tele/%topic%/STATE on POWER and light related commands Single Switch switch : - platform : mqtt name : \"Tasmota Switch\" state_topic : \"stat/tasmota/RESULT\" value_template : \"{{ value_json.POWER }}\" command_topic : \"cmnd/tasmota/POWER\" payload_on : \"ON\" payload_off : \"OFF\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false Multiple Switches When a device has more than one relay you need to create a new switch for each relay. For each relay use corresponding POWER<x> (POWER1, POWER2, etc) or if SetOption26 is enabled) switch : - platform : mqtt name : \"Tasmota Switch 1\" state_topic : \"stat/tasmota/RESULT\" value_template : \"{{ value_json.POWER1 }}\" command_topic : \"cmnd/tasmota/POWER1\" payload_on : \"ON\" payload_off : \"OFF\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false - platform : mqtt name : \"Tasmota Switch 2\" state_topic : \"stat/tasmota/RESULT\" value_template : \"{{ value_json.POWER2 }}\" command_topic : \"cmnd/tasmota/POWER2\" payload_on : \"ON\" payload_off : \"OFF\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false - platform : mqtt name : \"Tasmota Switch 3\" state_topic : \"stat/tasmota/RESULT\" value_template : \"{{ value_json.POWER3 }}\" command_topic : \"cmnd/tasmota/POWER3\" payload_on : \"ON\" payload_off : \"OFF\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false Dimmer Used for dimmers and dimmable lights (single channel lights). light : - platform : mqtt name : \"Dimmer\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"tele/tasmota/STATE\" state_value_template : \"{{value_json.POWER}}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"tele/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{value_json.Dimmer}}\" payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false Tip If you are using your device to control a light, you may want to use MQTT Light integration instead. Simply replace switch: with light: in the configuration keeping everything else the same. Lights ~ Add in Home Assistant using the MQTT Light integration. All configurations require SetOption59 1 - enables sending of tele/%topic%/STATE on POWER and light related commands Optional Commands Fade on - makes transitions smoother Speed 5 - set transition speed Dimmable Used with dimmers and dimmable only lights (single channel lights). light : - platform : mqtt name : \"Dimmer\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"tele/tasmota/STATE\" state_value_template : \"{{ value_json.POWER }}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"tele/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{ value_json.Dimmer }}\" payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false RGB Light Should also be used with lights using White Blend Mode SetOption17 1 - enables color status in decimals light : - platform : mqtt name : \"RGB Light\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"tele/tasmota/STATE\" state_value_template : \"{{ value_json.POWER }}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"tele/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{ value_json.Dimmer }}\" rgb_command_topic : \"cmnd/tasmota/Color2\" rgb_state_topic : \"tele/tasmota/STATE\" rgb_value_template : \"{{ value_json.Color.split(',')[0:3]|join(',') }}\" effect_command_topic : \"cmnd/tasmota/Scheme\" effect_state_topic : \"tele/tasmota/STATE\" effect_value_template : \"{{ value_json.Scheme }}\" effect_list : - 0 - 1 - 2 - 3 - 4 payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false RGB+W Light In this configuration RGB and white cannot be on at the same time. See Lights for options. SetOption17 1 - enables color status in decimals light : - platform : mqtt name : \"RGB+W Light\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"tele/tasmota/STATE\" state_value_template : \"{{ value_json.POWER }}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"tele/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{ value_json.Dimmer }}\" white_value_state_topic : \"tele/tasmota/STATE\" white_value_command_topic : \"cmnd/tasmota/White\" white_value_scale : 100 white_value_template : \"{{ value_json.White }}\" rgb_command_topic : \"cmnd/tasmota/Color2\" rgb_state_topic : \"tele/tasmota/STATE\" rgb_value_template : \"{{ value_json.Color.split(',')[0:3]|join(',') }}\" effect_command_topic : \"cmnd/tasmota/Scheme\" effect_state_topic : \"tele/tasmota/STATE\" effect_value_template : \"{{value_json.Scheme}}\" effect_list : - 0 - 1 - 2 - 3 - 4 payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false RGB+CCT Light Also called RGBWW, RGBCW or 5 channel lights SetOption17 1 - enables color status in decimals light : - platform : mqtt name : \"RGBCCT Light\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"tele/tasmota/STATE\" state_value_template : \"{{ value_json.POWER }}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"tele/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{ value_json.Dimmer }}\" color_temp_command_topic : \"cmnd/tasmota/CT\" color_temp_state_topic : \"tele/tasmota/STATE\" color_temp_value_template : \"{{ value_json.CT }}\" rgb_command_topic : \"cmnd/tasmota/Color2\" rgb_state_topic : \"tele/tasmota/STATE\" rgb_value_template : \"{{ value_json.Color.split(',')[0:3]|join(',') }}\" effect_command_topic : \"cmnd/tasmota/Scheme\" effect_state_topic : \"tele/tasmota/STATE\" effect_value_template : \"{{ value_json.Scheme }}\" effect_list : - 0 - 1 - 2 - 3 - 4 payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false Addressable LED Applies only to WS281x lights. light : - platform : mqtt name : \"Addressable LED\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"stat/tasmota/STATE\" state_value_template : \"{{ value_json.POWER }}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"stat/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{ value_json.Dimmer }}\" rgb_command_topic : \"cmnd/tasmota/Color2\" rgb_state_topic : \"tele/tasmota/STATE\" rgb_value_template : \"{{ value_json.Color.split(',')[0:3]|join(',') }}\" effect_command_topic : \"cmnd/tasmota/Scheme\" effect_state_topic : \"stat/tasmota/STATE\" effect_value_template : \"{{ value_json.Scheme }}\" effect_list : - 0 - 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10 - 11 - 12 payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false RGB with hex values If you don't want to use SetOption17 1 with decimal values and use default hex values, change: rgb_value_template : \"{{value_json.Color.split(',')[0:3]|join(',')}}\" to rgb_command_template : \"{{ '%02X%02X%02X' | format(red, green, blue)}}\" rgb_value_template : \"{{ (value_json.Color[0:2]|int(base=16),value_json.Color[2:4]|int(base=16),value_json.Color[4:6]|int(base=16)) | join(',')}}\" Control RGB and White independently Using color picker will keep white light on. If you use the white slider RGB light will get turned off. White value and dimmer value are connected, to have more granular control you will have to split the lights . Replace rgb_value_template : \"{{value_json.Color.split(',')[0:3]|join(',')}}\" to rgb_command_template : \"{{ '%02X%02X%02X=' | format(red, green, blue)}}\" rgb_value_template : \"{{ (value_json.Color[0:2]|int(base=16),value_json.Color[2:4]|int(base=16),value_json.Color[4:6]|int(base=16)) | join(',')}}\" The key is the = after color string in hex. It will retain current white value while changing color. Using schema: template light Thorough explanation of template: schema lights and its features on https://blakadder.com/template_schema_lights/ Sensors ~ Add in Home Assistant using the MQTT Sensor integration. A sensor will send its data in set intervals defined by TelePeriod (default every 5 minutes). Temperature Check your sensor name in Tasmota and change accordingly. This example uses the DHT22 sensor. sensor : - platform : mqtt name : \"Tasmota Temperature\" state_topic : \"tele/tasmota/SENSOR\" value_template : \"{{ value_json['DHT22'].Temperature }}\" unit_of_measurement : \"\u00b0C\" # \"F\" if using Fahrenheit availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" device_class : temperature Humidity Check your sensor name in Tasmota and change accordingly. This example uses the DHT22 sensor. sensor : - platform : mqtt name : \"Tasmota Humidity\" state_topic : \"tele/tasmota/SENSOR\" value_template : \"{{ value_json['DHT22'].Humidity }}\" unit_of_measurement : \"%\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" device_class : humidity Pressure Check your sensor name in Tasmota and change accordingly. This example uses the BMP280 sensor. sensor : - platform : mqtt name : \"Tasmota Pressure\" state_topic : \"tele/tasmota/SENSOR\" value_template : \"{{ value_json.BMP280.Pressure }}\" unit_of_measurement : \"hPa\" device_class : pressure Change unit_of_measurement to \"mmHg\" if SetOption24 1 Wi-Fi Signal Quality Monitor the relative Wi-Fi signal quality of a device. sensor : - platform : mqtt name : \"Tasmota Wi-Fi Quality\" state_topic : \"tele/tasmota/STATE\" unit_of_measurement : \"%\" value_template : \"{{value_json['Wifi'].RSSI }}\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" device_class : signal_strength Power Monitoring ~ Add in Home Assistant using the MQTT Sensor integration. Power monitoring sensors will send their data in set intervals defined by TelePeriod (default every 5 minutes). To get all the data in Home Assistant requires multiple sensors which you can later group to your liking in Lovelace UI Power Monitoring sensor : - platform : mqtt name : \"Energy Today\" state_topic : \"tele/tasmota/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Today\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Power\" state_topic : \"tele/tasmota/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Power\"] }}' unit_of_measurement : \"W\" - platform : mqtt name : \"Voltage\" state_topic : \"tele/tasmota/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Voltage\"] }}' unit_of_measurement : \"V\" - platform : mqtt name : \"Current\" state_topic : \"tele/tasmota/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Current\"] }}' unit_of_measurement : \"A\" Tip For additional sensors use \"Total\";\"Yesterday\";\"Period\",\"ApparentPower\",\"ReactivePower\";\"Factor\" in value_template string Video tutorial on a power monitoring plug setup by Digiblur Binary Sensors ~ Add in Home Assistant using the MQTT Binary Sensor integration. PIR Sensor Used for a configured PIR Sensor and requires this rule: Required Commands Rule1 on Switch1#State=1 do Publish stat/hall/MOTION ON endon on Switch1#State=1 do Publish stat/hall/MOTION OFF endon Rule1 1 binary_sensor : - platform : mqtt name : \"Tasmota Motion Sensor\" state_topic : \"stat/tasmota/MOTION\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" device_class : motion qos : 1 Door Sensor Requires a reed switch configured in Tasmota. Required Commands Rule1 on Switch1#State=1 do Publish stat/hall/MOTION ON endon on Switch1#State=1 do Publish stat/hall/MOTION OFF endon Rule1 1 binary_sensor : - platform : mqtt name : \"Tasmota Motion Sensor\" state_topic : \"stat/tasmota/MOTION\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" device_class : door # also: window, garage_door or opening qos : 1 RF Bridge An RF door sensor configured with an RF receiver in Tasmota. binary_sensor : - platform : mqtt name : \"RF bridge rfkey\" payload_on : \"1\" payload_off : \"0\" device_class : opening state_topic : \"tele/tasmota/RESULT\" value_template : '{{ value_json.RfReceived.RfKey }}' Fans ~ Add in Home Assistant using the MQTT Fan integration. Fan Derived from #2839 by @kbickar and @finity69x2 # Example configuration.yaml entry fan : - platform : mqtt name : \"Tasmota Fan\" command_topic : \"cmnd/tasmota/FanSpeed\" speed_command_topic : \"cmnd/tasmota/FanSpeed\" state_topic : \"stat/tasmota/RESULT\" speed_state_topic : \"stat/tasmota/RESULT\" state_value_template : > {% if value_json.FanSpeed is defined %} {% if value_json.FanSpeed == 0 -%}0{%- elif value_json.FanSpeed > 0 -%}4{%- endif %} {% else %} {% if states.fan.tasmota.state == 'off' -%}0{%- elif states.fan.tasmota.state == 'on' -%}4{%- endif %} {% endif %} speed_value_template : \"{{ value_json.FanSpeed }}\" availability_topic : tele/tasmota/LWT payload_off : \"0\" payload_on : \"4\" payload_low_speed : \"1\" payload_medium_speed : \"2\" payload_high_speed : \"3\" payload_available : Online payload_not_available : Offline speeds : - off - low - medium - high Covers ~ Add in Home Assistant using the MQTT Cover integration. TuyaMCU Curtain/Shade Motor Requires SetOption66 1 . In this example dpId1 is for open/close/stop of the motor, dpId2 sets position and dpId3 displays the current position. # Example configuration.yaml entry cover : - platform : mqtt name : \"Tuya Curtain\" command_topic : \"cmnd/tasmota/TuyaSend4\" payload_open : \"1,0\" payload_close : \"1,2\" payload_stop : \"1,1\" position_open : 0 position_closed : 100 position_topic : \"tele/tasmota/RESULT\" value_template : >- {% if value_json.TuyaReceived.DpType2Id3 is defined %} {{ value_json.TuyaReceived.DpType2Id3 }} {% else %} {{ state_attr('cover.tuya_curtain','current_position') | int }} {% endif %} set_position_topic : \"cmnd/tasmota/TuyaSend2\" set_position_template : '2,{{ position }}' availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" If you change name: make sure to reflect that change in the value_template cover name! Device Specific ~ iFan02 Combination of configs found in issue #2839 and Home Assistant forum thread Sonoff IFan02 (Tasmota) MQTT Fan . fan : - platform : mqtt name : \"Pat Ceiling Fan\" state_topic : \"stat/ifan02/RESULT\" speed_state_topic : \"stat/ifan02/RESULT\" state_value_template : > {% if value_json.FanSpeed is defined %} {% if value_json.FanSpeed == 0 -%}0{%- elif value_json.FanSpeed > 0 -%}2{%- endif %} {% else %} {% if states.fan.pat_ceiling_fan.state == 'off' -%}0{%- elif states.fan.pat_ceiling_fan.state == 'on' -%}2{%- endif %} {% endif %} speed_value_template : \"{{ value_json.FanSpeed }}\" availability_topic : tele/ifan02/LWT payload_available : Online payload_not_available : Offline speed_command_topic : \"cmnd/ifan02/FanSpeed\" payload_low_speed : \"1\" payload_medium_speed : \"2\" payload_high_speed : \"3\" command_topic : \"cmnd/ifan02/FanSpeed\" payload_off : \"0\" payload_on : \"2\" qos : 1 retain : false speeds : - low - medium - high light : - platform : mqtt name : \"Pat Ceiling Light\" state_topic : \"tele/ifan02/STATE\" value_template : \"{{ value_json.POWER }}\" command_topic : \"cmnd/ifan02/POWER\" availability_topic : \"tele/ifan02/LWT\" qos : 1 payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" retain : false Sonoff S31 Configure the device as Sonoff S31, and run:\\ SetOption4 1 SetOption59 1 switch : - platform : mqtt name : \"s31 power\" state_topic : \"tele/s31/STATE\" value_template : \"{{ value_json.POWER }}\" command_topic : \"cmnd/s31/POWER\" availability_topic : \"tele/s31/LWT\" qos : 1 payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" retain : false sensor : - platform : mqtt name : \"s31 Voltage\" state_topic : \"tele/s31/SENSOR\" value_template : \"{{ value_json['ENERGY'].Voltage }}\" unit_of_measurement : \"V\" availability_topic : \"tele/s31/LWT\" qos : 1 payload_available : \"Online\" payload_not_available : \"Offline\" - platform : mqtt name : \"s31 Current\" state_topic : \"tele/s31/SENSOR\" value_template : \"{{ value_json['ENERGY'].Current | round(2) }}\" unit_of_measurement : \"A\" availability_topic : \"tele/s31/LWT\" qos : 1 payload_available : \"Online\" payload_not_available : \"Offline\" - platform : mqtt name : \"s31 Power\" state_topic : \"tele/s31/SENSOR\" value_template : \"{{ value_json['ENERGY'].Power }}\" unit_of_measurement : \"W\" availability_topic : \"tele/s31/LWT\" qos : 1 payload_available : \"Online\" payload_not_available : \"Offline\" device_class : power - platform : mqtt name : \"s31 Power Factor\" state_topic : \"tele/s31/SENSOR\" value_template : \"{{ value_json['ENERGY'].Factor }}\" availability_topic : \"tele/s31/LWT\" qos : 1 payload_available : \"Online\" payload_not_available : \"Offline\" - platform : mqtt name : \"s31 Energy Today\" state_topic : \"tele/s31/SENSOR\" value_template : \"{{ value_json['ENERGY'].Today }}\" unit_of_measurement : \"kWh\" availability_topic : \"tele/s31/LWT\" qos : 1 payload_available : \"Online\" payload_not_available : \"Offline\" - platform : mqtt name : \"s31 Energy Yesterday\" state_topic : \"tele/s31/SENSOR\" value_template : \"{{ value_json['ENERGY'].Yesterday }}\" unit_of_measurement : \"kWh\" availability_topic : \"tele/s31/LWT\" qos : 1 payload_available : \"Online\" payload_not_available : \"Offline\" - platform : mqtt name : \"s31 Energy Total\" state_topic : \"tele/s31/SENSOR\" value_template : \"{{ value_json['ENERGY'].Total }}\" unit_of_measurement : \"kWh\" availability_topic : \"tele/s31/LWT\" qos : 1 payload_available : \"Online\" payload_not_available : \"Offline\" Covers For shutter position to persist in Home Assistant through device reboots, execute PowerRetain 1 . These sample configurations should allow the shutter work in Home Assistant. This is only an example and may need further modification to work in your environment. This example uses a new configuration for roller shutters with options for positioning. It assumes that %prefix%/%topic%/ is configured in the Tasmota Full Topic MQTT parameter. cover : - platform : mqtt name : \"Balcony Blinds\" availability_topic : \"tele/%topic%/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" position_topic : stat/%topic%/Shutter1 position_open : 100 position_closed : 0 set_position_topic : \"cmnd/%topic%/ShutterPosition1\" command_topic : \"cmnd/%topic%/Backlog\" payload_open : \"ShutterOpen1\" payload_close : \"ShutterClose1\" payload_stop : \"ShutterStop1\" retain : false optimistic : false qos : 1 Check Issue 130 for more information about this configuration. Another integration example: cover : - platform : mqtt name : \"Test\" availability_topic : \"tele/%topic%/LWT\" state_topic : \"stat/%topic%/RESULT\" command_topic : \"cmnd/%topic%/Backlog\" value_template : '{{ value | int }}' qos : 1 retain : false payload_open : \"ShutterOpen1\" payload_close : \"ShutterClose1\" payload_stop : \"ShutterStop1\" state_open : \"ON\" state_closed : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" optimistic : false tilt_command_topic : 'cmnd/%topic%/ShutterPosition1' tilt_status_topic : 'cmnd/%topic%/ShutterPosition1' set_position_topic : 'cmnd/%topic%/ShutterPosition1' position_topic : \"stat/%topic%/SHUTTER1\" tilt_min : 0 tilt_max : 100 tilt_closed_value : 0 tilt_opened_value : 100 Integration example with position updated during movement (Tasmota versions >= v8.1.0.5): cover : - platform : mqtt name : \"Balcony Blinds\" availability_topic : \"tele/%topic%/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" position_topic : \"stat/%topic%/RESULT\" value_template : > {% if ('Shutter1' in value_json) and ('Position' in value_json.Shutter1) %} {{ value_json.Shutter1.Position }} {% else %} {% if is_state('cover.balcony_blinds', 'unknown') %} 50 {% else %} {{ state_attr('cover.balcony_blinds','current_position') }} {% endif %} {% endif %} position_open : 100 position_closed : 0 set_position_topic : \"cmnd/%topic%/ShutterPosition1\" command_topic : \"cmnd/%topic%/Backlog\" payload_open : \"ShutterOpen1\" payload_close : \"ShutterClose1\" payload_stop : \"ShutterStop1\" retain : false optimistic : false qos : 1 In addition, add to your home assistant start up automation a query for the current shutter position: - alias : \"Power state on HA start-up\" trigger : platform : homeassistant event : start action : - service : mqtt.publish data : topic : \"cmnd/%shutters grouptopic%/shutterposition\" payload : \"\" Zigbee Devices ~ Dimmable Light This configuration is for a dimmable light reporting on 0xE1F9 using endpoint 1, cluster 8 for brightness. ZbRead part in the template is needed to always update the brightness values. # Example configuration.yaml entry light : - platform : mqtt schema : template name : \"Fire Light\" command_topic : \"cmnd/zigbee-gateway/Backlog\" state_topic : \"tele/zigbee-gateway/SENSOR\" command_on_template : > {%- if brightness is defined -%} ZbSend { \"device\":\"0xE1F9\", \"send\":{\"Dimmer\":{{ brightness }} } }; ZbSend { \"device\":\"0xE1F9\", \"send\":{\"Power\":true} }; delay 20; ZbRead { \"device\":\"0xE1F9\", \"endpoint\":1, \"cluster\":8, \"read\":0 } {%- else -%} ZbSend { \"device\":\"0xE1F9\", \"send\":{\"Power\":true} }; delay 20; ZbRead { \"device\":\"0xE1F9\", \"endpoint\":1, \"cluster\":8, \"read\":0 } {%- endif -%} command_off_template : 'ZbSend { \"device\":\"0xE1F9\", \"send\":{\"Power\":false} }; delay 20; ZbRead { \"device\":\"0xE1F9\", \"endpoint\":1, \"cluster\":8, \"read\":0 }' state_template : > {% if value_json.ZbReceived is defined and value_json.ZbReceived['0xE1F9'] is defined and value_json.ZbReceived['0xE1F9'].Power is defined %} {% if value_json.ZbReceived['0xE1F9'].Power == true %} on {% else %} off {% endif %} {% else %} {{ states('light.fire_light') }} {% endif %} brightness_template : > {%- if value_json.ZbReceived is defined and value_json.ZbReceived['0xE1F9'] is defined and value_json.ZbReceived['0xE1F9'].Dimmer is defined -%} {{ value_json['ZbReceived']['0xE1F9'].Dimmer | int }} {%- else -%} {{ state_attr('light.fire_light', 'brightness') | int }} {%- endif -%} Water Leak Sensor This specific configuration is for Xiaomi Aqara Water Leak sensor reporting on 0x099F . # Example configuration.yaml entry binary_sensor : - platform : mqtt name : \"Water Leak\" state_topic : \"tele/zigbee-gateway/SENSOR\" value_template : > {%- if value_json.ZbReceived is defined and value_json.ZbReceived['0x099F'] is defined -%} {%- if value_json.ZbReceived['0x099F']['0500!00'] == '010000FF0000' -%} ON {% else %} OFF {% endif %} {% else %} {{ states('binary_sensor.water_leak') }} {% endif %} availability_topic : \"tele/zigbee-gateway/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 device_class : moisture Enable join switch - platform : mqtt name : Zigbee2Tasmota enable join state_topic : \"tele/zigbee/RESULT\" command_topic : \"cmnd/zigbee/ZbPermitJoin\" payload_on : \"1\" payload_off : \"0\" state_on : \"Enable Pairing mode for 60 seconds\" state_off : \"off\" optimistic : false qos : 1 retain : false value_template : '{{value_json.ZbState.Message }}' icon : mdi:zigbee Useful Automations ~ Extended device information Wi-Fi signal quality can be added as a parameter to any previous configuration by appending this section to the existing configuration yaml json_attributes_topic : \"tele/tasmota/STATE\" json_attributes_template : \"{{ value_json.Wifi | tojson }}\" Sync Power State When MQTT broker or Home Assistant is restarted, or there is a WiFi outage, Tasmota device states may not be synced with Home Assistant. Use this automation to keep your devices in sync, including power state, immediately after Home Assistant is started. automation : - id : Sync Tasmota states alias : Sync Tasmota states initial_state : true trigger : platform : homeassistant event : start action : # sync state for devices with default fulltopics - service : mqtt.publish data : topic : cmnd/tasmotas/state payload : '' # sync state for pre8.2 autodiscovery devices - service : mqtt.publish data : topic : tasmotas/cmnd/state payload : '' To sync a single TuyaMCU device states add this block with your %topic% to the automation. !!! bug You could use tasmotas but SerialSend might cause issues on other devices so proceed with caution. - service : mqtt.publish data : topic : cmnd/%topic%/serialsend5 payload : 55aa0001000000 Sync Zigbee device states. Add this block with your %topic% and your Zigbee device name, endpoint and cluster. Example for a dimmable light - service : mqtt.publish data : topic : cmnd/zigbee-gateway/Backlog payload : ZbRead { \"device\":\"0xE1F9\", \"endpoint\":1, \"cluster\":6, \"read\":0 }; delay 5; ZbRead { \"device\":\"0xE1F9\", \"endpoint\":1, \"cluster\":8, \"read\":0 } Report Firmware Version Add a sensor like below for each Tasmota device whose firmware version you want to track. # Example configuration.yaml entry sensor : - platform : mqtt name : \"Tasmota\" state_topic : \"stat/tasmota/STATUS2\" value_template : \"{{value_json['StatusFWR'].Version }}\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 0 Automation to have each device report firmware version on Home Assistant reboot. You can manually trigger this automation from Home Assistant UI. automation : - alias : \"Tasmota Firmware Version Check\" trigger : platform : homeassistant event : start action : - service : mqtt.publish data : topic : \"cmnd/tasmotas/STATUS\" payload : \"2\" Tip If you want all your devices to switch to autodiscovery method go through Developer tools - MQTT by publishing to grouptopic cmnd/tasmotas/SetOption19 with payload 1 MQTT Discovery ~ Development of this component is halted in favor of Tasmota (beta) integration Home Assistant has a feature called MQTT discovery . With MQTT discovery no user interaction or configuration file editing is needed to add new devices in Home Assistant. Most of the changes will be updated in HA automatically. Enable Autodiscovery ~ Enable autodiscovery on a device with the command: SetOption19 1 After the automatic discovery feature is enabled a retained MQTT message starting with topic \"homeassistant/\" is sent to the broker. That message contains your device configuration which will be picked up and used by Home Assistant to automatically add your device to MQTT integrations. Tasmota uses DeviceName to identify the device in Home Assistant MQTT integration and FriendlyName<x> to identify power outputs (switch or light entities in HA). When changing some settings you might need a reboot or use SetOption19 1 again to see the new changes under Home Assistant. Special settings for each device type: Finalising Setup ~ All automatically discovered entities will show up under Configuration -> Integrations -> MQTT card. The entities are grouped under a device defined by DeviceName and identified by Tasmota as the \"manufacturer\": Overview of a Tasmota device in Home Assistant integration compared to Configuration -> Configure Other : For every device an informative sensor will be created automatically: This sensor will update on TelePeriod which is 5 minutes by default It will show as \"Unavailable\" until the first TelePeriod MQTT message You can further customise your device in Home Assistant by clicking on the entity name. Enabling discovery will automatically change some SetOptions to suit the new configuration SetOption4 to 0 : Return MQTT response always as RESULT and not as %COMMAND% topic SetOption17 to 1 : Show Color as a comma-separated decimal string instead of hexadecimal SetOption59 to 1 : Send tele/%topic%/STATE in addition to stat/%topic%/RESULT for commands State , Power and any command causing a light to be turned on. Supported Entities ~ Buttons Announced to Home Assistant as Automation Trigger . To have buttons discovered SetOption73 must be set to 1 and it will automatically start to listen and publish using /stat/%topic%/BUTTON<x>T topic. Discovery will follow all the possible combinations made using SetOption1, SetOption11 and Setoption13. Lights Announced to Home Assistant as MQTT Light . Discovery supports single channel Dimmer as well as multi-channel RGB, RGBW, RGBCCT and CCT lights. To have multi-channel PWM instead of a single light entity under Home Assistant use SetOption68 1 . If you have a light with 4 or 5 channels (RGB+W or RGB+CCT) you can split them into two separate lights, first one for RGB and second for White/CT. Note Tasmota will no longer switch %prefix% and %topic% and will keep the default topic structure. This could lead to a very long topic for a light and autodiscovery could fail to parse the necessary code for Home Assistant. In this case a warning will be shown in the logs and Tasmota Console. To avoid this issue keep your Topic and/or FriendlyName as short as possible. Alternatively you can configure it manually using Light integration. Warning Pay attention to the order of the relays when used in conjunction with lights. The relays have priority over the lights, an incorrect order could lead to an erroneous light control. Add them starting from relay1. Entities for relays and lights will not be available in Home Assistant until the configuration will be updated. Relays Announced to Home Assistant as MQTT Switch . To make a relay discovered as \"light\" in Home Assistant use command SetOption30 1 Alternatively you can configure it manually using Light Switch integration. Warning Pay attention to the order of the relays when used in conjunction with lights. The relays have priority over the lights, an incorrect order could lead to an erroneous light control. Add them starting from relay1. Entities for relays and lights will not be available in Home Assistant until the configuration will be updated. Sensors Announced to Home Assistant as MQTT Sensor . When discovery is enabled Tasmota will send all the sensors information to Home Assistant. For each sensor present, entities will be created in numbers equal to the items present below him. Example: An AM2301 sensor will generate one entity for Temperature, one for Humidity and one for Dew point. Warning Please be advised that not all sensors can be correctly rendered under Home Assistant. In those cases a fallback function will be used to create a generic sensor and the correct operation is not guaranteed. Switches Announced to Home Assistant as MQTT Binary Sensor and/or as an Automation Trigger . To have switches discovered SwitchTopic must be set to a custom name and it will automatically start to listen and publish using stat/%topic%/SWITCH<x> (binary sensor) or stat/%topic%/SWITCH<x>T (trigger) topics. Depending by the SwitchMode used, a switch can be a Trigger ( TOGGLE or HOLD ), a Binary Sensor ( ON / OFF ) or both at the same time. Example: When using with SwitchMode 0 Tasmota will create just one Trigger for TOGGLE . When using with SwitchMode 1 Tasmota will create a Binary Sensor with ON and OFF Payloads. When using with Switchmode 5 Tasmota will create a Binary Sensor with ON and OFF Payloads and a Trigger for TOGGLE . All switchmodes are supported with the sole exception of SwitchMode11 and SwitchMode12 able to generate just a TOGGLE trigger. When a switch is set to a different topic than 0 is not possible to use Switch#State as a trigger for rules. Types of devices not listed above (covers, etc) require manual configuration Disabling ~ To disable MQTT discovery and remove the retained message, execute SetOption19 0 . The \"homeassistant/\" topic is removed from Home Assistant and MQTT broker. Changed setoptions will not revert to defaults! Troubleshooting ~ Test if Tasmota and Home Assistant can communicate properly. In Home Assistant web UI go to Configuration - Integrations , locate MQTT broker card and click on CONFIGURE . Subscribe to tele/%topic%/STATE and click START LISTENING . You should see a JSON response from your device inside 5 minutes. To test control of a relay or light, as Publish a packet topic enter cmnd/%topic%/POWER with payload toggle . When you click PUBLISH your device should switch state and a JSON resc","title":"Home Assistant"},{"location":"Home-Assistant/#home-assistant","text":"Home Assistant support is not built in to tasmota-lite.bin. Use the standard tasmota.bin or other binaries that include Home Assistant support. Home Assistant is an open source home automation solution that puts local control and privacy first. Tasmota communicates with Home Assistant using MQTT. Before going any further, make sure MQTT is properly set up in Home Assistant and Tasmota . Home Assistant has different options of adding Tasmota devices: Official Tasmota (beta) integration ( preferred ) MQTT discovery ( development halted ) Manual configuration by editing configuration.yaml","title":"Home Assistant"},{"location":"Home-Assistant/#tasmota-beta-integration","text":"Once you configure the Home Assistant integration every new Tasmota device with SetOption19 0 set, will be discovered automatically. All Tasmota devices will be listed in their own Tasmota (beta) card in Configuration - Integrations menu in Home Assistant. Warning Do not change the FullTopic in order to use this feature. Leave it as default. Tasmota uses DeviceName to name the device in Tasmota (beta) integration and FriendlyName<x> to name power outputs (switch or light entities in HA).","title":"Tasmota (beta) Integration"},{"location":"Home-Assistant/#supported-entities","text":"Lights as light entities. Single channel Dimmers, RGB lights, RGB lights with Color Temperature control and RGB lights with White control are supported. Relays as switch entities With SetOption30 1 all relays one the device will be added as light entities instead Sensors as sensor entities Switches as binary_sensor entities or automation triggers depending on SwitchMode used when SetOption114 1 Buttons as automation triggers when SetOption73 is enabled Shutters as cover entities. Currently only shutter modes 1 to 4 are supported. Shutter mode 5 and Tuya shutters are not supported. Devices configured as iFan02 or iFan03 as fan entities. Tuya fans are not supported. Each discovered device will by default add 8 disabled sensors. Enable the ones you need. You cannot delete them, they will simply be re-added on a restart. Types of devices not listed above still require manual configuration Zigbee devices paired in Tasmota will NOT be discovered in Home Assistant","title":"Supported Entities"},{"location":"Home-Assistant/#transition-from-mqtt-discovery","text":"If you have been using SetOption19 1 for device discovery, setting it to SetOption19 0 will remove your Tasmota device from the MQTT device list and add it to the Tasmota integrations in HA. They will be treated as new entities in Home Assistant but if you previously used default values they will use the same entity_id as the MQTT discovery devices.","title":"Transition from MQTT Discovery"},{"location":"Home-Assistant/#removing-devices","text":"You cannot as long as Home Assistant support is enabled in your Tasmota binary. Disable the device in Home Assistant instead. There is no setoption to disable all autodiscovery. Deleting them from Home Assistant while Tasmota device is still active will simply rediscover all the entities. If you opt to switch to MQTT Discovery, issuing SetOption19 1 command will remove all Tasmota (beta) entities and add new entities under the MQTT integration.","title":"Removing devices"},{"location":"Home-Assistant/#editing-configurationyaml","text":"Adding devices manually is done by editing the configuration.yaml file and adding appropriate blocks of yaml code to the corresponding section. After every change to the configuration.yaml file you'll need to restart Home Assistant to make it aware of the changes. The advantage of manually configuring a device is that you maintain control of all aspects of the configuration. All the configurations are just examples. You need to be familiar with Home Assistant's configuration structure and procedures. Straight copy paste of the given examples into configuration.yaml will probably not work for you. If you are using a localized (non-english) version be sure to check the correct spelling and cases for values: 'payload_available' 'payload_not_available' 'payload_on' 'payload_off' Tip If you want the power states to be persistent in Tasmota and Home Assistant set PowerRetain 1 instead of using retain: true in Home Assistant","title":"Editing configuration.yaml"},{"location":"Home-Assistant/#switches","text":"Add in Home Assistant using the MQTT Switch integration. Required Commands SetOption59 1 - enables sending of tele/%topic%/STATE on POWER and light related commands Single Switch switch : - platform : mqtt name : \"Tasmota Switch\" state_topic : \"stat/tasmota/RESULT\" value_template : \"{{ value_json.POWER }}\" command_topic : \"cmnd/tasmota/POWER\" payload_on : \"ON\" payload_off : \"OFF\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false Multiple Switches When a device has more than one relay you need to create a new switch for each relay. For each relay use corresponding POWER<x> (POWER1, POWER2, etc) or if SetOption26 is enabled) switch : - platform : mqtt name : \"Tasmota Switch 1\" state_topic : \"stat/tasmota/RESULT\" value_template : \"{{ value_json.POWER1 }}\" command_topic : \"cmnd/tasmota/POWER1\" payload_on : \"ON\" payload_off : \"OFF\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false - platform : mqtt name : \"Tasmota Switch 2\" state_topic : \"stat/tasmota/RESULT\" value_template : \"{{ value_json.POWER2 }}\" command_topic : \"cmnd/tasmota/POWER2\" payload_on : \"ON\" payload_off : \"OFF\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false - platform : mqtt name : \"Tasmota Switch 3\" state_topic : \"stat/tasmota/RESULT\" value_template : \"{{ value_json.POWER3 }}\" command_topic : \"cmnd/tasmota/POWER3\" payload_on : \"ON\" payload_off : \"OFF\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false Dimmer Used for dimmers and dimmable lights (single channel lights). light : - platform : mqtt name : \"Dimmer\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"tele/tasmota/STATE\" state_value_template : \"{{value_json.POWER}}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"tele/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{value_json.Dimmer}}\" payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false Tip If you are using your device to control a light, you may want to use MQTT Light integration instead. Simply replace switch: with light: in the configuration keeping everything else the same.","title":"Switches"},{"location":"Home-Assistant/#lights","text":"Add in Home Assistant using the MQTT Light integration. All configurations require SetOption59 1 - enables sending of tele/%topic%/STATE on POWER and light related commands Optional Commands Fade on - makes transitions smoother Speed 5 - set transition speed Dimmable Used with dimmers and dimmable only lights (single channel lights). light : - platform : mqtt name : \"Dimmer\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"tele/tasmota/STATE\" state_value_template : \"{{ value_json.POWER }}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"tele/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{ value_json.Dimmer }}\" payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false RGB Light Should also be used with lights using White Blend Mode SetOption17 1 - enables color status in decimals light : - platform : mqtt name : \"RGB Light\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"tele/tasmota/STATE\" state_value_template : \"{{ value_json.POWER }}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"tele/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{ value_json.Dimmer }}\" rgb_command_topic : \"cmnd/tasmota/Color2\" rgb_state_topic : \"tele/tasmota/STATE\" rgb_value_template : \"{{ value_json.Color.split(',')[0:3]|join(',') }}\" effect_command_topic : \"cmnd/tasmota/Scheme\" effect_state_topic : \"tele/tasmota/STATE\" effect_value_template : \"{{ value_json.Scheme }}\" effect_list : - 0 - 1 - 2 - 3 - 4 payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false RGB+W Light In this configuration RGB and white cannot be on at the same time. See Lights for options. SetOption17 1 - enables color status in decimals light : - platform : mqtt name : \"RGB+W Light\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"tele/tasmota/STATE\" state_value_template : \"{{ value_json.POWER }}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"tele/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{ value_json.Dimmer }}\" white_value_state_topic : \"tele/tasmota/STATE\" white_value_command_topic : \"cmnd/tasmota/White\" white_value_scale : 100 white_value_template : \"{{ value_json.White }}\" rgb_command_topic : \"cmnd/tasmota/Color2\" rgb_state_topic : \"tele/tasmota/STATE\" rgb_value_template : \"{{ value_json.Color.split(',')[0:3]|join(',') }}\" effect_command_topic : \"cmnd/tasmota/Scheme\" effect_state_topic : \"tele/tasmota/STATE\" effect_value_template : \"{{value_json.Scheme}}\" effect_list : - 0 - 1 - 2 - 3 - 4 payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false RGB+CCT Light Also called RGBWW, RGBCW or 5 channel lights SetOption17 1 - enables color status in decimals light : - platform : mqtt name : \"RGBCCT Light\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"tele/tasmota/STATE\" state_value_template : \"{{ value_json.POWER }}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"tele/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{ value_json.Dimmer }}\" color_temp_command_topic : \"cmnd/tasmota/CT\" color_temp_state_topic : \"tele/tasmota/STATE\" color_temp_value_template : \"{{ value_json.CT }}\" rgb_command_topic : \"cmnd/tasmota/Color2\" rgb_state_topic : \"tele/tasmota/STATE\" rgb_value_template : \"{{ value_json.Color.split(',')[0:3]|join(',') }}\" effect_command_topic : \"cmnd/tasmota/Scheme\" effect_state_topic : \"tele/tasmota/STATE\" effect_value_template : \"{{ value_json.Scheme }}\" effect_list : - 0 - 1 - 2 - 3 - 4 payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false Addressable LED Applies only to WS281x lights. light : - platform : mqtt name : \"Addressable LED\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"stat/tasmota/STATE\" state_value_template : \"{{ value_json.POWER }}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"stat/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{ value_json.Dimmer }}\" rgb_command_topic : \"cmnd/tasmota/Color2\" rgb_state_topic : \"tele/tasmota/STATE\" rgb_value_template : \"{{ value_json.Color.split(',')[0:3]|join(',') }}\" effect_command_topic : \"cmnd/tasmota/Scheme\" effect_state_topic : \"stat/tasmota/STATE\" effect_value_template : \"{{ value_json.Scheme }}\" effect_list : - 0 - 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10 - 11 - 12 payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false RGB with hex values If you don't want to use SetOption17 1 with decimal values and use default hex values, change: rgb_value_template : \"{{value_json.Color.split(',')[0:3]|join(',')}}\" to rgb_command_template : \"{{ '%02X%02X%02X' | format(red, green, blue)}}\" rgb_value_template : \"{{ (value_json.Color[0:2]|int(base=16),value_json.Color[2:4]|int(base=16),value_json.Color[4:6]|int(base=16)) | join(',')}}\" Control RGB and White independently Using color picker will keep white light on. If you use the white slider RGB light will get turned off. White value and dimmer value are connected, to have more granular control you will have to split the lights . Replace rgb_value_template : \"{{value_json.Color.split(',')[0:3]|join(',')}}\" to rgb_command_template : \"{{ '%02X%02X%02X=' | format(red, green, blue)}}\" rgb_value_template : \"{{ (value_json.Color[0:2]|int(base=16),value_json.Color[2:4]|int(base=16),value_json.Color[4:6]|int(base=16)) | join(',')}}\" The key is the = after color string in hex. It will retain current white value while changing color. Using schema: template light Thorough explanation of template: schema lights and its features on https://blakadder.com/template_schema_lights/","title":"Lights"},{"location":"Home-Assistant/#sensors","text":"Add in Home Assistant using the MQTT Sensor integration. A sensor will send its data in set intervals defined by TelePeriod (default every 5 minutes). Temperature Check your sensor name in Tasmota and change accordingly. This example uses the DHT22 sensor. sensor : - platform : mqtt name : \"Tasmota Temperature\" state_topic : \"tele/tasmota/SENSOR\" value_template : \"{{ value_json['DHT22'].Temperature }}\" unit_of_measurement : \"\u00b0C\" # \"F\" if using Fahrenheit availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" device_class : temperature Humidity Check your sensor name in Tasmota and change accordingly. This example uses the DHT22 sensor. sensor : - platform : mqtt name : \"Tasmota Humidity\" state_topic : \"tele/tasmota/SENSOR\" value_template : \"{{ value_json['DHT22'].Humidity }}\" unit_of_measurement : \"%\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" device_class : humidity Pressure Check your sensor name in Tasmota and change accordingly. This example uses the BMP280 sensor. sensor : - platform : mqtt name : \"Tasmota Pressure\" state_topic : \"tele/tasmota/SENSOR\" value_template : \"{{ value_json.BMP280.Pressure }}\" unit_of_measurement : \"hPa\" device_class : pressure Change unit_of_measurement to \"mmHg\" if SetOption24 1 Wi-Fi Signal Quality Monitor the relative Wi-Fi signal quality of a device. sensor : - platform : mqtt name : \"Tasmota Wi-Fi Quality\" state_topic : \"tele/tasmota/STATE\" unit_of_measurement : \"%\" value_template : \"{{value_json['Wifi'].RSSI }}\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" device_class : signal_strength","title":"Sensors"},{"location":"Home-Assistant/#power-monitoring","text":"Add in Home Assistant using the MQTT Sensor integration. Power monitoring sensors will send their data in set intervals defined by TelePeriod (default every 5 minutes). To get all the data in Home Assistant requires multiple sensors which you can later group to your liking in Lovelace UI Power Monitoring sensor : - platform : mqtt name : \"Energy Today\" state_topic : \"tele/tasmota/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Today\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Power\" state_topic : \"tele/tasmota/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Power\"] }}' unit_of_measurement : \"W\" - platform : mqtt name : \"Voltage\" state_topic : \"tele/tasmota/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Voltage\"] }}' unit_of_measurement : \"V\" - platform : mqtt name : \"Current\" state_topic : \"tele/tasmota/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Current\"] }}' unit_of_measurement : \"A\" Tip For additional sensors use \"Total\";\"Yesterday\";\"Period\",\"ApparentPower\",\"ReactivePower\";\"Factor\" in value_template string Video tutorial on a power monitoring plug setup by Digiblur","title":"Power Monitoring"},{"location":"Home-Assistant/#binary-sensors","text":"Add in Home Assistant using the MQTT Binary Sensor integration. PIR Sensor Used for a configured PIR Sensor and requires this rule: Required Commands Rule1 on Switch1#State=1 do Publish stat/hall/MOTION ON endon on Switch1#State=1 do Publish stat/hall/MOTION OFF endon Rule1 1 binary_sensor : - platform : mqtt name : \"Tasmota Motion Sensor\" state_topic : \"stat/tasmota/MOTION\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" device_class : motion qos : 1 Door Sensor Requires a reed switch configured in Tasmota. Required Commands Rule1 on Switch1#State=1 do Publish stat/hall/MOTION ON endon on Switch1#State=1 do Publish stat/hall/MOTION OFF endon Rule1 1 binary_sensor : - platform : mqtt name : \"Tasmota Motion Sensor\" state_topic : \"stat/tasmota/MOTION\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" device_class : door # also: window, garage_door or opening qos : 1 RF Bridge An RF door sensor configured with an RF receiver in Tasmota. binary_sensor : - platform : mqtt name : \"RF bridge rfkey\" payload_on : \"1\" payload_off : \"0\" device_class : opening state_topic : \"tele/tasmota/RESULT\" value_template : '{{ value_json.RfReceived.RfKey }}'","title":"Binary Sensors"},{"location":"Home-Assistant/#fans","text":"Add in Home Assistant using the MQTT Fan integration. Fan Derived from #2839 by @kbickar and @finity69x2 # Example configuration.yaml entry fan : - platform : mqtt name : \"Tasmota Fan\" command_topic : \"cmnd/tasmota/FanSpeed\" speed_command_topic : \"cmnd/tasmota/FanSpeed\" state_topic : \"stat/tasmota/RESULT\" speed_state_topic : \"stat/tasmota/RESULT\" state_value_template : > {% if value_json.FanSpeed is defined %} {% if value_json.FanSpeed == 0 -%}0{%- elif value_json.FanSpeed > 0 -%}4{%- endif %} {% else %} {% if states.fan.tasmota.state == 'off' -%}0{%- elif states.fan.tasmota.state == 'on' -%}4{%- endif %} {% endif %} speed_value_template : \"{{ value_json.FanSpeed }}\" availability_topic : tele/tasmota/LWT payload_off : \"0\" payload_on : \"4\" payload_low_speed : \"1\" payload_medium_speed : \"2\" payload_high_speed : \"3\" payload_available : Online payload_not_available : Offline speeds : - off - low - medium - high","title":"Fans"},{"location":"Home-Assistant/#covers","text":"Add in Home Assistant using the MQTT Cover integration. TuyaMCU Curtain/Shade Motor Requires SetOption66 1 . In this example dpId1 is for open/close/stop of the motor, dpId2 sets position and dpId3 displays the current position. # Example configuration.yaml entry cover : - platform : mqtt name : \"Tuya Curtain\" command_topic : \"cmnd/tasmota/TuyaSend4\" payload_open : \"1,0\" payload_close : \"1,2\" payload_stop : \"1,1\" position_open : 0 position_closed : 100 position_topic : \"tele/tasmota/RESULT\" value_template : >- {% if value_json.TuyaReceived.DpType2Id3 is defined %} {{ value_json.TuyaReceived.DpType2Id3 }} {% else %} {{ state_attr('cover.tuya_curtain','current_position') | int }} {% endif %} set_position_topic : \"cmnd/tasmota/TuyaSend2\" set_position_template : '2,{{ position }}' availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" If you change name: make sure to reflect that change in the value_template cover name!","title":"Covers"},{"location":"Home-Assistant/#device-specific","text":"iFan02 Combination of configs found in issue #2839 and Home Assistant forum thread Sonoff IFan02 (Tasmota) MQTT Fan . fan : - platform : mqtt name : \"Pat Ceiling Fan\" state_topic : \"stat/ifan02/RESULT\" speed_state_topic : \"stat/ifan02/RESULT\" state_value_template : > {% if value_json.FanSpeed is defined %} {% if value_json.FanSpeed == 0 -%}0{%- elif value_json.FanSpeed > 0 -%}2{%- endif %} {% else %} {% if states.fan.pat_ceiling_fan.state == 'off' -%}0{%- elif states.fan.pat_ceiling_fan.state == 'on' -%}2{%- endif %} {% endif %} speed_value_template : \"{{ value_json.FanSpeed }}\" availability_topic : tele/ifan02/LWT payload_available : Online payload_not_available : Offline speed_command_topic : \"cmnd/ifan02/FanSpeed\" payload_low_speed : \"1\" payload_medium_speed : \"2\" payload_high_speed : \"3\" command_topic : \"cmnd/ifan02/FanSpeed\" payload_off : \"0\" payload_on : \"2\" qos : 1 retain : false speeds : - low - medium - high light : - platform : mqtt name : \"Pat Ceiling Light\" state_topic : \"tele/ifan02/STATE\" value_template : \"{{ value_json.POWER }}\" command_topic : \"cmnd/ifan02/POWER\" availability_topic : \"tele/ifan02/LWT\" qos : 1 payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" retain : false Sonoff S31 Configure the device as Sonoff S31, and run:\\ SetOption4 1 SetOption59 1 switch : - platform : mqtt name : \"s31 power\" state_topic : \"tele/s31/STATE\" value_template : \"{{ value_json.POWER }}\" command_topic : \"cmnd/s31/POWER\" availability_topic : \"tele/s31/LWT\" qos : 1 payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" retain : false sensor : - platform : mqtt name : \"s31 Voltage\" state_topic : \"tele/s31/SENSOR\" value_template : \"{{ value_json['ENERGY'].Voltage }}\" unit_of_measurement : \"V\" availability_topic : \"tele/s31/LWT\" qos : 1 payload_available : \"Online\" payload_not_available : \"Offline\" - platform : mqtt name : \"s31 Current\" state_topic : \"tele/s31/SENSOR\" value_template : \"{{ value_json['ENERGY'].Current | round(2) }}\" unit_of_measurement : \"A\" availability_topic : \"tele/s31/LWT\" qos : 1 payload_available : \"Online\" payload_not_available : \"Offline\" - platform : mqtt name : \"s31 Power\" state_topic : \"tele/s31/SENSOR\" value_template : \"{{ value_json['ENERGY'].Power }}\" unit_of_measurement : \"W\" availability_topic : \"tele/s31/LWT\" qos : 1 payload_available : \"Online\" payload_not_available : \"Offline\" device_class : power - platform : mqtt name : \"s31 Power Factor\" state_topic : \"tele/s31/SENSOR\" value_template : \"{{ value_json['ENERGY'].Factor }}\" availability_topic : \"tele/s31/LWT\" qos : 1 payload_available : \"Online\" payload_not_available : \"Offline\" - platform : mqtt name : \"s31 Energy Today\" state_topic : \"tele/s31/SENSOR\" value_template : \"{{ value_json['ENERGY'].Today }}\" unit_of_measurement : \"kWh\" availability_topic : \"tele/s31/LWT\" qos : 1 payload_available : \"Online\" payload_not_available : \"Offline\" - platform : mqtt name : \"s31 Energy Yesterday\" state_topic : \"tele/s31/SENSOR\" value_template : \"{{ value_json['ENERGY'].Yesterday }}\" unit_of_measurement : \"kWh\" availability_topic : \"tele/s31/LWT\" qos : 1 payload_available : \"Online\" payload_not_available : \"Offline\" - platform : mqtt name : \"s31 Energy Total\" state_topic : \"tele/s31/SENSOR\" value_template : \"{{ value_json['ENERGY'].Total }}\" unit_of_measurement : \"kWh\" availability_topic : \"tele/s31/LWT\" qos : 1 payload_available : \"Online\" payload_not_available : \"Offline\" Covers For shutter position to persist in Home Assistant through device reboots, execute PowerRetain 1 . These sample configurations should allow the shutter work in Home Assistant. This is only an example and may need further modification to work in your environment. This example uses a new configuration for roller shutters with options for positioning. It assumes that %prefix%/%topic%/ is configured in the Tasmota Full Topic MQTT parameter. cover : - platform : mqtt name : \"Balcony Blinds\" availability_topic : \"tele/%topic%/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" position_topic : stat/%topic%/Shutter1 position_open : 100 position_closed : 0 set_position_topic : \"cmnd/%topic%/ShutterPosition1\" command_topic : \"cmnd/%topic%/Backlog\" payload_open : \"ShutterOpen1\" payload_close : \"ShutterClose1\" payload_stop : \"ShutterStop1\" retain : false optimistic : false qos : 1 Check Issue 130 for more information about this configuration. Another integration example: cover : - platform : mqtt name : \"Test\" availability_topic : \"tele/%topic%/LWT\" state_topic : \"stat/%topic%/RESULT\" command_topic : \"cmnd/%topic%/Backlog\" value_template : '{{ value | int }}' qos : 1 retain : false payload_open : \"ShutterOpen1\" payload_close : \"ShutterClose1\" payload_stop : \"ShutterStop1\" state_open : \"ON\" state_closed : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" optimistic : false tilt_command_topic : 'cmnd/%topic%/ShutterPosition1' tilt_status_topic : 'cmnd/%topic%/ShutterPosition1' set_position_topic : 'cmnd/%topic%/ShutterPosition1' position_topic : \"stat/%topic%/SHUTTER1\" tilt_min : 0 tilt_max : 100 tilt_closed_value : 0 tilt_opened_value : 100 Integration example with position updated during movement (Tasmota versions >= v8.1.0.5): cover : - platform : mqtt name : \"Balcony Blinds\" availability_topic : \"tele/%topic%/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" position_topic : \"stat/%topic%/RESULT\" value_template : > {% if ('Shutter1' in value_json) and ('Position' in value_json.Shutter1) %} {{ value_json.Shutter1.Position }} {% else %} {% if is_state('cover.balcony_blinds', 'unknown') %} 50 {% else %} {{ state_attr('cover.balcony_blinds','current_position') }} {% endif %} {% endif %} position_open : 100 position_closed : 0 set_position_topic : \"cmnd/%topic%/ShutterPosition1\" command_topic : \"cmnd/%topic%/Backlog\" payload_open : \"ShutterOpen1\" payload_close : \"ShutterClose1\" payload_stop : \"ShutterStop1\" retain : false optimistic : false qos : 1 In addition, add to your home assistant start up automation a query for the current shutter position: - alias : \"Power state on HA start-up\" trigger : platform : homeassistant event : start action : - service : mqtt.publish data : topic : \"cmnd/%shutters grouptopic%/shutterposition\" payload : \"\"","title":"Device Specific"},{"location":"Home-Assistant/#zigbee-devices","text":"Dimmable Light This configuration is for a dimmable light reporting on 0xE1F9 using endpoint 1, cluster 8 for brightness. ZbRead part in the template is needed to always update the brightness values. # Example configuration.yaml entry light : - platform : mqtt schema : template name : \"Fire Light\" command_topic : \"cmnd/zigbee-gateway/Backlog\" state_topic : \"tele/zigbee-gateway/SENSOR\" command_on_template : > {%- if brightness is defined -%} ZbSend { \"device\":\"0xE1F9\", \"send\":{\"Dimmer\":{{ brightness }} } }; ZbSend { \"device\":\"0xE1F9\", \"send\":{\"Power\":true} }; delay 20; ZbRead { \"device\":\"0xE1F9\", \"endpoint\":1, \"cluster\":8, \"read\":0 } {%- else -%} ZbSend { \"device\":\"0xE1F9\", \"send\":{\"Power\":true} }; delay 20; ZbRead { \"device\":\"0xE1F9\", \"endpoint\":1, \"cluster\":8, \"read\":0 } {%- endif -%} command_off_template : 'ZbSend { \"device\":\"0xE1F9\", \"send\":{\"Power\":false} }; delay 20; ZbRead { \"device\":\"0xE1F9\", \"endpoint\":1, \"cluster\":8, \"read\":0 }' state_template : > {% if value_json.ZbReceived is defined and value_json.ZbReceived['0xE1F9'] is defined and value_json.ZbReceived['0xE1F9'].Power is defined %} {% if value_json.ZbReceived['0xE1F9'].Power == true %} on {% else %} off {% endif %} {% else %} {{ states('light.fire_light') }} {% endif %} brightness_template : > {%- if value_json.ZbReceived is defined and value_json.ZbReceived['0xE1F9'] is defined and value_json.ZbReceived['0xE1F9'].Dimmer is defined -%} {{ value_json['ZbReceived']['0xE1F9'].Dimmer | int }} {%- else -%} {{ state_attr('light.fire_light', 'brightness') | int }} {%- endif -%} Water Leak Sensor This specific configuration is for Xiaomi Aqara Water Leak sensor reporting on 0x099F . # Example configuration.yaml entry binary_sensor : - platform : mqtt name : \"Water Leak\" state_topic : \"tele/zigbee-gateway/SENSOR\" value_template : > {%- if value_json.ZbReceived is defined and value_json.ZbReceived['0x099F'] is defined -%} {%- if value_json.ZbReceived['0x099F']['0500!00'] == '010000FF0000' -%} ON {% else %} OFF {% endif %} {% else %} {{ states('binary_sensor.water_leak') }} {% endif %} availability_topic : \"tele/zigbee-gateway/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 device_class : moisture Enable join switch - platform : mqtt name : Zigbee2Tasmota enable join state_topic : \"tele/zigbee/RESULT\" command_topic : \"cmnd/zigbee/ZbPermitJoin\" payload_on : \"1\" payload_off : \"0\" state_on : \"Enable Pairing mode for 60 seconds\" state_off : \"off\" optimistic : false qos : 1 retain : false value_template : '{{value_json.ZbState.Message }}' icon : mdi:zigbee","title":"Zigbee Devices"},{"location":"Home-Assistant/#useful-automations","text":"Extended device information Wi-Fi signal quality can be added as a parameter to any previous configuration by appending this section to the existing configuration yaml json_attributes_topic : \"tele/tasmota/STATE\" json_attributes_template : \"{{ value_json.Wifi | tojson }}\" Sync Power State When MQTT broker or Home Assistant is restarted, or there is a WiFi outage, Tasmota device states may not be synced with Home Assistant. Use this automation to keep your devices in sync, including power state, immediately after Home Assistant is started. automation : - id : Sync Tasmota states alias : Sync Tasmota states initial_state : true trigger : platform : homeassistant event : start action : # sync state for devices with default fulltopics - service : mqtt.publish data : topic : cmnd/tasmotas/state payload : '' # sync state for pre8.2 autodiscovery devices - service : mqtt.publish data : topic : tasmotas/cmnd/state payload : '' To sync a single TuyaMCU device states add this block with your %topic% to the automation. !!! bug You could use tasmotas but SerialSend might cause issues on other devices so proceed with caution. - service : mqtt.publish data : topic : cmnd/%topic%/serialsend5 payload : 55aa0001000000 Sync Zigbee device states. Add this block with your %topic% and your Zigbee device name, endpoint and cluster. Example for a dimmable light - service : mqtt.publish data : topic : cmnd/zigbee-gateway/Backlog payload : ZbRead { \"device\":\"0xE1F9\", \"endpoint\":1, \"cluster\":6, \"read\":0 }; delay 5; ZbRead { \"device\":\"0xE1F9\", \"endpoint\":1, \"cluster\":8, \"read\":0 } Report Firmware Version Add a sensor like below for each Tasmota device whose firmware version you want to track. # Example configuration.yaml entry sensor : - platform : mqtt name : \"Tasmota\" state_topic : \"stat/tasmota/STATUS2\" value_template : \"{{value_json['StatusFWR'].Version }}\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 0 Automation to have each device report firmware version on Home Assistant reboot. You can manually trigger this automation from Home Assistant UI. automation : - alias : \"Tasmota Firmware Version Check\" trigger : platform : homeassistant event : start action : - service : mqtt.publish data : topic : \"cmnd/tasmotas/STATUS\" payload : \"2\" Tip If you want all your devices to switch to autodiscovery method go through Developer tools - MQTT by publishing to grouptopic cmnd/tasmotas/SetOption19 with payload 1","title":"Useful Automations"},{"location":"Home-Assistant/#mqtt-discovery","text":"Development of this component is halted in favor of Tasmota (beta) integration Home Assistant has a feature called MQTT discovery . With MQTT discovery no user interaction or configuration file editing is needed to add new devices in Home Assistant. Most of the changes will be updated in HA automatically.","title":"MQTT Discovery"},{"location":"Home-Assistant/#enable-autodiscovery","text":"Enable autodiscovery on a device with the command: SetOption19 1 After the automatic discovery feature is enabled a retained MQTT message starting with topic \"homeassistant/\" is sent to the broker. That message contains your device configuration which will be picked up and used by Home Assistant to automatically add your device to MQTT integrations. Tasmota uses DeviceName to identify the device in Home Assistant MQTT integration and FriendlyName<x> to identify power outputs (switch or light entities in HA). When changing some settings you might need a reboot or use SetOption19 1 again to see the new changes under Home Assistant. Special settings for each device type:","title":"Enable Autodiscovery"},{"location":"Home-Assistant/#finalising-setup","text":"All automatically discovered entities will show up under Configuration -> Integrations -> MQTT card. The entities are grouped under a device defined by DeviceName and identified by Tasmota as the \"manufacturer\": Overview of a Tasmota device in Home Assistant integration compared to Configuration -> Configure Other : For every device an informative sensor will be created automatically: This sensor will update on TelePeriod which is 5 minutes by default It will show as \"Unavailable\" until the first TelePeriod MQTT message You can further customise your device in Home Assistant by clicking on the entity name. Enabling discovery will automatically change some SetOptions to suit the new configuration SetOption4 to 0 : Return MQTT response always as RESULT and not as %COMMAND% topic SetOption17 to 1 : Show Color as a comma-separated decimal string instead of hexadecimal SetOption59 to 1 : Send tele/%topic%/STATE in addition to stat/%topic%/RESULT for commands State , Power and any command causing a light to be turned on.","title":"Finalising Setup"},{"location":"Home-Assistant/#supported-entities_1","text":"Buttons Announced to Home Assistant as Automation Trigger . To have buttons discovered SetOption73 must be set to 1 and it will automatically start to listen and publish using /stat/%topic%/BUTTON<x>T topic. Discovery will follow all the possible combinations made using SetOption1, SetOption11 and Setoption13. Lights Announced to Home Assistant as MQTT Light . Discovery supports single channel Dimmer as well as multi-channel RGB, RGBW, RGBCCT and CCT lights. To have multi-channel PWM instead of a single light entity under Home Assistant use SetOption68 1 . If you have a light with 4 or 5 channels (RGB+W or RGB+CCT) you can split them into two separate lights, first one for RGB and second for White/CT. Note Tasmota will no longer switch %prefix% and %topic% and will keep the default topic structure. This could lead to a very long topic for a light and autodiscovery could fail to parse the necessary code for Home Assistant. In this case a warning will be shown in the logs and Tasmota Console. To avoid this issue keep your Topic and/or FriendlyName as short as possible. Alternatively you can configure it manually using Light integration. Warning Pay attention to the order of the relays when used in conjunction with lights. The relays have priority over the lights, an incorrect order could lead to an erroneous light control. Add them starting from relay1. Entities for relays and lights will not be available in Home Assistant until the configuration will be updated. Relays Announced to Home Assistant as MQTT Switch . To make a relay discovered as \"light\" in Home Assistant use command SetOption30 1 Alternatively you can configure it manually using Light Switch integration. Warning Pay attention to the order of the relays when used in conjunction with lights. The relays have priority over the lights, an incorrect order could lead to an erroneous light control. Add them starting from relay1. Entities for relays and lights will not be available in Home Assistant until the configuration will be updated. Sensors Announced to Home Assistant as MQTT Sensor . When discovery is enabled Tasmota will send all the sensors information to Home Assistant. For each sensor present, entities will be created in numbers equal to the items present below him. Example: An AM2301 sensor will generate one entity for Temperature, one for Humidity and one for Dew point. Warning Please be advised that not all sensors can be correctly rendered under Home Assistant. In those cases a fallback function will be used to create a generic sensor and the correct operation is not guaranteed. Switches Announced to Home Assistant as MQTT Binary Sensor and/or as an Automation Trigger . To have switches discovered SwitchTopic must be set to a custom name and it will automatically start to listen and publish using stat/%topic%/SWITCH<x> (binary sensor) or stat/%topic%/SWITCH<x>T (trigger) topics. Depending by the SwitchMode used, a switch can be a Trigger ( TOGGLE or HOLD ), a Binary Sensor ( ON / OFF ) or both at the same time. Example: When using with SwitchMode 0 Tasmota will create just one Trigger for TOGGLE . When using with SwitchMode 1 Tasmota will create a Binary Sensor with ON and OFF Payloads. When using with Switchmode 5 Tasmota will create a Binary Sensor with ON and OFF Payloads and a Trigger for TOGGLE . All switchmodes are supported with the sole exception of SwitchMode11 and SwitchMode12 able to generate just a TOGGLE trigger. When a switch is set to a different topic than 0 is not possible to use Switch#State as a trigger for rules. Types of devices not listed above (covers, etc) require manual configuration","title":"Supported Entities"},{"location":"Home-Assistant/#disabling","text":"To disable MQTT discovery and remove the retained message, execute SetOption19 0 . The \"homeassistant/\" topic is removed from Home Assistant and MQTT broker. Changed setoptions will not revert to defaults!","title":"Disabling"},{"location":"Home-Assistant/#troubleshooting","text":"Test if Tasmota and Home Assistant can communicate properly. In Home Assistant web UI go to Configuration - Integrations , locate MQTT broker card and click on CONFIGURE . Subscribe to tele/%topic%/STATE and click START LISTENING . You should see a JSON response from your device inside 5 minutes. To test control of a relay or light, as Publish a packet topic enter cmnd/%topic%/POWER with payload toggle . When you click PUBLISH your device should switch state and a JSON resc","title":"Troubleshooting"},{"location":"HomeSeer/","text":"For those knowing more about HomeSeer please update this page. About HomeSeer HS3 is the industry standard for flexible, powerful, home automation software. A wide selection of software drivers (plug-ins) is available for use with scores of home automation technologies and products. The following forum link provides a guide to upload Tasmota to an S20 using SonOTA and integrate it with HomeSeer HS3 using the mcsMQTT plugin. Here is a guide for integrating HomeSeer HS3 with the Sonoff 4CH Pro and Tasmota firmware as a Garage Door controller using the mcsMQTT plugin. Requirements for HomeSeer HS3 and Tasmota devices: * HomeSeer HS3 * MQTT server * A MQTT plugin for HS3 Currently there are two plugins, both free: \"MQTT\" and \"mcsMQTT\". The former is more intuitive but hasn't been updated for a while, the latter is newer and constantly updated. If you use \"MQTT\" plugin you need to synch the virtual device to reflect the status of the physical button, this can be done with a plugin: * EasyTrigger plugin - costs 25$ (used to synchronise the status of the virtual device in HomeSeer when the Sonoff Tasmota module is operated from the physical button) If you use \"mcsMQTT\", starting from ver 3.0.3+ it allows to create a device that both report and control the status of the Sonoff. More info here: https://forums.homeseer.com/showthread.php?t=192675 Tasmota Plug-in If your interested in a FREE specific plug-in for Sonoff + Tasmota, then Instructions are HERE and you can install it from the Homeseer Plug-ins Manager, in Primary Technology as TasMQTT. This plug-in takes care of two-way updates so wall switches update Homseer devices and homeseer changes update Sonoff devices. The plug-in also takes care of monitoring sonoff availability and optionally flags homeseer devices as offline so events can take that into consideration before making changes. When devices come back online Homeseer is updated with the current status of the devices. The plug-in also supports Tasmota Sensors such as the Sonoff TH1 etc. The plug-in has so far been tested extensively with the entire Sonoff Portfolio and as new devices become available we'll test those too. This plug-in has been in beta for 6 months and has now reached production. Beta's will continue to be released to support any new Tasmota enabled devices.","title":"HomeSeer"},{"location":"Homebridge/","text":"Homebridge is a NodeJS server which emulates the iOS HomeKit API to enable support for non-native devices (like Sonoff and Magichome devices). Tasmota compatible plugins have been developed by macwyznawca and arachnetech as well as others to add support for these devices in Apple's Home app and through iCloud for automation (iPad, HomePod/Apple TV 4 or newer required). Note these plugins are not necessarily specific to Sonoff devices. The homebridge-mqttthing package has support for many types of devices and is quite flexible with different options especially for RGB/RGBW LED strips. As of 1.0.11 homebridge-mqttthing supports the following Homekit device types: * Light bulb * Switch * Outlet * Motion Sensor * Occupancy Sensor * Light Sensor * Contact Sensor * Doorbell * Security System * Smoke Sensor * Temperature Sensor * Humidity Sensor * Stateless Programmable Switch * Garage Door * Garage Door Opener Check out macwyznawca's packages for supported functions, each in a separate package. To use Homebridge with Tasmota you need to have an existing MQTT broker set up ( see wiki article ) and each of your Sonoff devices should have a unique topic set. Example screenshot from Apple Home.app","title":"Homebridge"},{"location":"Honeywell-HIH/","text":"Honeywell HIH temperature and humidity sensor ~ This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_HIH6 #define USE_HIH6 // Enable Honeywell HIH (I2C address 0x27) (+0k6) #endif Honeywell HumidIcon\u2122 Digital Humidity and Temperature Sensors HIH Series Configuration ~ Wiring ~ Get the 4 pin SIP version if possible, as this will be easier to solder than the 8 pin SMD version. Looking at the side of the sensor with a filter: * Pin 1 VDD 1. connect via 0.22 uF to ground 1. connect to 3v3 on the ESP * Pin 2 GND 1. connect to GND on the ESP * Pin 3 SCL 1. connect via 2k2 resistor to 3v3 1. connect to TX on the ESP * Pin 4 SDA 1. connect via 2k2 resistor to 3v3 1. connect to RX on the ESP Remember to peel off the white sticker over the filter before use. I have tested several of these without the 0.22 uF capacitor and without the pull-up resistors, and I haven't seen any difference in the readings. The cap is probably more important that the resistors, since the internal pull-ups in the ESP8266 will work. That said, if I was installing these in a hard-to-service location, I would follow the wiring diagram exactly. I have noticed that temperature readings tend to be a degree or so high if the sensor is wired directly to the ESP: Soldering a 1-2\" piece of wire between the ESP and the HIH7121 fixes this issue: Tasmota Settings ~ In the Configuration -> Configure Module page assign: 1. GPIO RX to I2C SDA (6) 2. GPIO TX to I2C SCL (5) After a reboot the driver will detect the HIHxxxx automatically and display sensor data. <--- if you have an LCD display also configured, run I2CDriver3 0 More documentation on this is in the I2CDEVICES.md file. Why the Honeywell HIH series sensors? ~ The go-to humidity sensor for the DIY Arduino/ESP8266 community is the DHT22. Unfortunately, this sensor has a tendency to collect condensation and give false readings (usually 99.9% RH) in wet environments like a bathroom or outside. Not being able to use a humidity sensor in a wet area (IMHO) defeats the point of a humidity sensor, so I set about looking for alternatives. After looking at several options, I found the Honeywell HIHxxxx sensors. Different models of the HIH line have different features and work over different ranges of humidity, but most of them use the same I2C protocol, which is now supported in Tasmota. Check the datasheets to compare sensors. One of the most critical features to look for is a hydrophobic filter which allows humid air through, but blocks water droplets from entering the sensor. This is listed on the datasheets as \"with filter,condensation resistant\". Also keep in mind the humidity range you'll be measuring. For my purposes (bathroom humidity sensor), there was a clear choice in the HIH7121-021 ( datasheet , non-affiliate direct link to product on Mouser , which works over a range of 0-100% RH, supports I2C, is accurate to within 3%, and has a hydrophobic filter. The article focuses on that sensor, but I suspect much of the information will be applicable to other HIHxxxx sensors. by @thepotoo","title":"Honeywell HIH temperature and humidity sensor"},{"location":"Honeywell-HIH/#honeywell-hih-temperature-and-humidity-sensor","text":"This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_HIH6 #define USE_HIH6 // Enable Honeywell HIH (I2C address 0x27) (+0k6) #endif Honeywell HumidIcon\u2122 Digital Humidity and Temperature Sensors HIH Series","title":"Honeywell HIH temperature and humidity sensor"},{"location":"Honeywell-HIH/#configuration","text":"","title":"Configuration"},{"location":"Honeywell-HIH/#wiring","text":"Get the 4 pin SIP version if possible, as this will be easier to solder than the 8 pin SMD version. Looking at the side of the sensor with a filter: * Pin 1 VDD 1. connect via 0.22 uF to ground 1. connect to 3v3 on the ESP * Pin 2 GND 1. connect to GND on the ESP * Pin 3 SCL 1. connect via 2k2 resistor to 3v3 1. connect to TX on the ESP * Pin 4 SDA 1. connect via 2k2 resistor to 3v3 1. connect to RX on the ESP Remember to peel off the white sticker over the filter before use. I have tested several of these without the 0.22 uF capacitor and without the pull-up resistors, and I haven't seen any difference in the readings. The cap is probably more important that the resistors, since the internal pull-ups in the ESP8266 will work. That said, if I was installing these in a hard-to-service location, I would follow the wiring diagram exactly. I have noticed that temperature readings tend to be a degree or so high if the sensor is wired directly to the ESP: Soldering a 1-2\" piece of wire between the ESP and the HIH7121 fixes this issue:","title":"Wiring"},{"location":"Honeywell-HIH/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: 1. GPIO RX to I2C SDA (6) 2. GPIO TX to I2C SCL (5) After a reboot the driver will detect the HIHxxxx automatically and display sensor data. <--- if you have an LCD display also configured, run I2CDriver3 0 More documentation on this is in the I2CDEVICES.md file.","title":"Tasmota Settings"},{"location":"Honeywell-HIH/#why-the-honeywell-hih-series-sensors","text":"The go-to humidity sensor for the DIY Arduino/ESP8266 community is the DHT22. Unfortunately, this sensor has a tendency to collect condensation and give false readings (usually 99.9% RH) in wet environments like a bathroom or outside. Not being able to use a humidity sensor in a wet area (IMHO) defeats the point of a humidity sensor, so I set about looking for alternatives. After looking at several options, I found the Honeywell HIHxxxx sensors. Different models of the HIH line have different features and work over different ranges of humidity, but most of them use the same I2C protocol, which is now supported in Tasmota. Check the datasheets to compare sensors. One of the most critical features to look for is a hydrophobic filter which allows humid air through, but blocks water droplets from entering the sensor. This is listed on the datasheets as \"with filter,condensation resistant\". Also keep in mind the humidity range you'll be measuring. For my purposes (bathroom humidity sensor), there was a clear choice in the HIH7121-021 ( datasheet , non-affiliate direct link to product on Mouser , which works over a range of 0-100% RH, supports I2C, is accurate to within 3%, and has a hydrophobic filter. The article focuses on that sensor, but I suspect much of the information will be applicable to other HIHxxxx sensors. by @thepotoo","title":"Why the Honeywell HIH series sensors?"},{"location":"How-to-Expand-Sonoff-Basic-to-4MB-Flash/","text":"Heya, In this memo I'll describe how to expand the flash of a sonoff basic from 1MB to 4MB. The advantage for this change is, to avoid to double flash with the minimal and then with the normal firmware and to use more features like Webserver and SSL encryption. It was hard to find those information, I'll give credits to some users from the german CreationX Forum. Because to unsolder the flash isn't that easy as just solder in pins, this is only for advanced users . Don't forget, it's at your own risk and the device could be damaged permanently. The Hardware ~ Soldering iron Tin Tweezers The Flash ~ The origin flash block is a XTX PN25F08B 1725XDG. We exchange it with a WINBOND W25Q32FVSIG 1416. You can find the WINBOND Flash on eBay ( another ebay ) or AliExpress Those China flash memory ICs are cheap productions, means the chance to solder in a new defect not working flash block is high! Be ready to re-do the operation if the upload fails. If you want to test the flash block, build yourself a test module, something like this for easy soldering in a flash and test it before soldering it in another sonoff basics board. The Operation ~ You will notice that the LED is in the way. Get a pen and mark on of its Pin with the board, so you can solder it in back later in the correct Position. Its a Red-Green LED, if you solder it in the wrong way, it will light up in red. After the LED is out of the way, you give some tin on the pins from the flash block and connect all 4 pins in a row together with tin. This way it will be easier to desolder it, because you need to melt all pins at the same time. Now get a thin object between the flash and the board, try to gently lift the flash up and at the same time melt both rows of the flash pins tin rotatory. If you got enough space between the board and the flash change to the tweezers and finally take the flash block off. Now refresh the contacts on the board for the new flash block with a lil bit of fresh tin. Don't forget to give a lil bit tin to the new pins of the flash block, too! Now put it on the contacts on the board and try to lock it with the tweezers. Next take the solder iron and head just one pin and try to arrange the flashblock in the center now. Finally, heat and solder the other pins to the board. You can also use a hot air rework station, this would be much safer, but also more expensive ( Amazon ). Be sure to protect the rest of the board if using the heat gun! Good job, you are done :) Flashing ~ The next step is to tell Atom (i did not do it with Arduino IDE, sry) to use the whole new 4MB Flash. Note: You can only use 3MB, because 1MB is needed for SPIFFS. To do this, you need to edit the platformio.ini file. Search for your prefered language Block and copy the whole Block. Rename it to e.g. Sonoff-DE-4M Now change the following line build_flags = -Wl,-Tesp8266.flash.1m0.ld -DMY_LANGUAGE=de-DE to build_flags = -Wl,-Tesp8266.flash.4m1m.ld -DMY_LANGUAGE=de-DE Now scroll back to the top and enter a new default environment with the name of your newly created block env_default = sonoff-DE-4M You are done with the preparations, connect the Sonoff with the 4MB Flash in flash mode (hold button while powering it up), click clean, click build, click upload. Result ~ On the Information Page on the tasmota web interface you can now see the 4MB flash :)","title":"How to Expand Sonoff Basic to 4MB Flash"},{"location":"How-to-Expand-Sonoff-Basic-to-4MB-Flash/#the-hardware","text":"Soldering iron Tin Tweezers","title":"The Hardware"},{"location":"How-to-Expand-Sonoff-Basic-to-4MB-Flash/#the-flash","text":"The origin flash block is a XTX PN25F08B 1725XDG. We exchange it with a WINBOND W25Q32FVSIG 1416. You can find the WINBOND Flash on eBay ( another ebay ) or AliExpress Those China flash memory ICs are cheap productions, means the chance to solder in a new defect not working flash block is high! Be ready to re-do the operation if the upload fails. If you want to test the flash block, build yourself a test module, something like this for easy soldering in a flash and test it before soldering it in another sonoff basics board.","title":"The Flash"},{"location":"How-to-Expand-Sonoff-Basic-to-4MB-Flash/#the-operation","text":"You will notice that the LED is in the way. Get a pen and mark on of its Pin with the board, so you can solder it in back later in the correct Position. Its a Red-Green LED, if you solder it in the wrong way, it will light up in red. After the LED is out of the way, you give some tin on the pins from the flash block and connect all 4 pins in a row together with tin. This way it will be easier to desolder it, because you need to melt all pins at the same time. Now get a thin object between the flash and the board, try to gently lift the flash up and at the same time melt both rows of the flash pins tin rotatory. If you got enough space between the board and the flash change to the tweezers and finally take the flash block off. Now refresh the contacts on the board for the new flash block with a lil bit of fresh tin. Don't forget to give a lil bit tin to the new pins of the flash block, too! Now put it on the contacts on the board and try to lock it with the tweezers. Next take the solder iron and head just one pin and try to arrange the flashblock in the center now. Finally, heat and solder the other pins to the board. You can also use a hot air rework station, this would be much safer, but also more expensive ( Amazon ). Be sure to protect the rest of the board if using the heat gun! Good job, you are done :)","title":"The Operation"},{"location":"How-to-Expand-Sonoff-Basic-to-4MB-Flash/#flashing","text":"The next step is to tell Atom (i did not do it with Arduino IDE, sry) to use the whole new 4MB Flash. Note: You can only use 3MB, because 1MB is needed for SPIFFS. To do this, you need to edit the platformio.ini file. Search for your prefered language Block and copy the whole Block. Rename it to e.g. Sonoff-DE-4M Now change the following line build_flags = -Wl,-Tesp8266.flash.1m0.ld -DMY_LANGUAGE=de-DE to build_flags = -Wl,-Tesp8266.flash.4m1m.ld -DMY_LANGUAGE=de-DE Now scroll back to the top and enter a new default environment with the name of your newly created block env_default = sonoff-DE-4M You are done with the preparations, connect the Sonoff with the 4MB Flash in flash mode (hold button while powering it up), click clean, click build, click upload.","title":"Flashing"},{"location":"How-to-Expand-Sonoff-Basic-to-4MB-Flash/#result","text":"On the Information Page on the tasmota web interface you can now see the 4MB flash :)","title":"Result"},{"location":"I2CDevices/","text":"I2C devices ~ Tasmota supports several I2C devices but to use them they mostly need to be enabled at compile time to solve possible address conflicts. Look at Pre-Compiled Builds to see, which Driver is compiled in the release binarys. ~ Using command I2cDriver individual drivers can be enabled or disabled at runtime allowing duplicate I2C addresses at compile time. Use the Index from the table below to control I2C drivers like I2cDriver10 0 for disabling BMP support. Supported I2C devices ~ The following table lists the supported I2C devices Index Define Driver Device Address(es) Description 1 USE_PCA9685 xdrv_15 PCA9685 0x40 - 0x47 16-channel 12-bit pwm driver 2 USE_PCF8574 xdrv_28 PCF8574 0x20 - 0x26 8-bit I/O expander 2 USE_PCF8574 xdrv_28 PCF8574A 0x39 - 0x3F 8-bit I/O expander 3 USE_DISPLAY_LCD xdsp_01 0x27, 0x3F LCD display 4 USE_DISPLAY_SSD1306 xdsp_02 SSD1306 0x3C - 0x3D Oled display 5 USE_DISPLAY_MATRIX xdsp_03 HT16K33 0x70 - 0x77 8x8 led matrix 6 USE_DISPLAY_SH1106 xdsp_07 SH1106 0x3C - 0x3D Oled display 7 USE_ADE7953 xnrg_07 ADE7953 0x38 Energy monitor 8 USE_SHT xsns_07 SHT1X Any Temperature and Humidity sensor 9 USE_HTU xsns_08 HTU21 0x40 Temperature and Humidity sensor 9 USE_HTU xsns_08 SI7013 0x40 Temperature and Humidity sensor 9 USE_HTU xsns_08 SI7020 0x40 Temperature and Humidity sensor 9 USE_HTU xsns_08 SI7021 0x40 Temperature and Humidity sensor 10 USE_BMP xsns_09 BMP085 0x76 - 0x77 Pressure and temperature sensor 10 USE_BMP xsns_09 BMP180 0x76 - 0x77 Pressure and temperature sensor 10 USE_BMP xsns_09 BMP280 0x76 - 0x77 Pressure and temperature sensor 10 USE_BMP xsns_09 BME280 0x76 - 0x77 Pressure, temperature and humidity sensor 10 USE_BMP xsns_09 BME680 0x76 - 0x77 Pressure, temperature, humidity and gas sensor 11 USE_BH1750 xsns_10 BH1750 0x23, 0x5C Ambient light intensity sensor 12 USE_VEML6070 xsns_11 VEML6070 0x38 - 0x39 Ultra violet light intensity sensor 13 USE_ADS1115 xsns_12 ADS1115 0x48 - 0x4B 4-channel 16-bit A/D converter 14 USE_INA219 xsns_13 INA219 0x40 - 0x41, 0x44 - 0x45 Low voltage current sensor 15 USE_SHT3X xsns_14 SHT3X 0x44 - 0x45 Temperature and Humidity sensor 15 USE_SHT3X xsns_14 SHTC3 0x70 Temperature and Humidity sensor 16 USE_TSL2561 xsns_16 TSL2561 0x29, 0x39, 0x49 Light intensity sensor 17 USE_MGS xsns_19 Grove 0x04 Multichannel gas sensor 18 USE_SGP30 xsns_21 SGP30 0x58 Gas (TVOC) and air quality sensor 19 USE_SI1145 xsns_24 SI1145 0x60 Ultra violet index and light sensor 19 USE_SI1145 xsns_24 SI1146 0x60 Ultra violet index and light sensor 19 USE_SI1145 xsns_24 SI1147 0x60 Ultra violet index and light sensor 20 USE_LM75AD xsns_26 LM75AD 0x48 - 0x4F Temperature sensor 21 USE_APDS9960 xsns_27 APDS9960 0x39 Proximity ambient light RGB and gesture sensor 22 USE_MCP230xx xsns_29 MCP23008 0x20 - 0x26 16-bit I/O expander 22 USE_MCP230xx xsns_29 MCP23017 0x20 - 0x26 16-bit I/O expander 23 USE_MPR121 xsns_30 MPR121 0x5A - 0x5D Proximity capacitive touch sensor 24 USE_CCS811 xsns_31 CCS811 0x5A Gas (TVOC) and air quality sensor 25 USE_MPU6050 xsns_32 MPU6050 0x68 - 0x69 3-axis gyroscope and temperature sensor 26 USE_DS3231 xsns_33 DS3231 0x68 Real time clock 27 USE_MGC3130 xsns_36 MGC3130 0x42 Electric field sensor 28 USE_MAX44009 xsns_41 MAX44009 0x4A - 0x4B Ambient light intensity sensor 29 USE_SCD30 xsns_42 SCD30 0x61 CO2 sensor 30 USE_SPS30 xsns_44 SPS30 0x69 Particle sensor 31 USE_VL53L0X xsns_45 VL53L0X 0x29 Time-of-flight (ToF) distance sensor 32 USE_MLX90614 xsns_46 MLX90614 0x5A Infra red temperature sensor 33 USE_CHIRP xsns_48 CHIRP 0x20 Soil moisture sensor 34 USE_PAJ7620 xsns_50 PAJ7620 0x73 Gesture sensor 35 USE_INA226 xsns_54 INA226 0x40 - 0x41, 0x44 - 0x45 Low voltage current sensor 36 USE_HIH6 xsns_55 HIH6130 0x27 Temperature and Humidity sensor 37 USE_24C256 xdrv_10 24C256 0x50 Scripter EEPROM storage 38 USE_DISPLAY_ILI9488 xdsp_08 FT6236 0x38 Touch panel controller 39 USE_DISPLAY_RA8876 xdsp_10 FT5316 0x38 Touch panel controller 40 USE_TSL2591 xsns_57 TLS2591 0x29 Light intensity sensor 41 USE_DHT12 xsns_58 DHT12 0x5C Temperature and humidity sensor 42 USE_DS1624 xsns_59 DS1621 0x48 - 0x4F Temperature sensor 42 USE_DS1624 xsns_59 DS1624 0x48 - 0x4F Temperature sensor 43 USE_AHT1x xsns_63 AHT10/15 0x38 or 0x39 Temperature and humidity sensor 43 USE_AHT2x xsns_63 AHT20 0x38 Temperature and humidity sensor 44 USE_WEMOS_MOTOR_V1 xdrv_34 0x2D - 0x30 WEMOS motor shield v1.0.0 (6612FNG) 45 USE_HDC1080 xsns_65 HDC1080 0x40 Temperature and Humidity sensor 46 USE_IAQ xsns_66 IAQ 0x5a Air quality sensor 47 USE_DISPLAY_SEVENSEG xdsp_11 HT16K33 0x70 - 0x77 Seven segment LED 48 USE_AS3935 xsns_67 AS3935 0x03 Franklin Lightning Sensor 49 USE_VEML6075 xsns_70 VEML6075 0x10 UVA/UVB/UVINDEX Sensor 50 USE_VEML7700 xsns_71 VEML7700 0x10 Ambient light intensity sensor 51 USE_MCP9808 xsns_72 MCP9808 0x18 - 0x1F Temperature sensor 52 USE_HP303B xsns_73 HP303B 0x76 - 0x77 Pressure and temperature sensor","title":"I2C Devices"},{"location":"I2CDevices/#i2c-devices","text":"Tasmota supports several I2C devices but to use them they mostly need to be enabled at compile time to solve possible address conflicts.","title":"I2C devices"},{"location":"I2CDevices/#look-at-pre-compiled-builds-to-see-which-driver-is-compiled-in-the-release-binarys","text":"Using command I2cDriver individual drivers can be enabled or disabled at runtime allowing duplicate I2C addresses at compile time. Use the Index from the table below to control I2C drivers like I2cDriver10 0 for disabling BMP support.","title":"Look at Pre-Compiled Builds to see, which Driver is compiled in the release binarys."},{"location":"I2CDevices/#supported-i2c-devices","text":"The following table lists the supported I2C devices Index Define Driver Device Address(es) Description 1 USE_PCA9685 xdrv_15 PCA9685 0x40 - 0x47 16-channel 12-bit pwm driver 2 USE_PCF8574 xdrv_28 PCF8574 0x20 - 0x26 8-bit I/O expander 2 USE_PCF8574 xdrv_28 PCF8574A 0x39 - 0x3F 8-bit I/O expander 3 USE_DISPLAY_LCD xdsp_01 0x27, 0x3F LCD display 4 USE_DISPLAY_SSD1306 xdsp_02 SSD1306 0x3C - 0x3D Oled display 5 USE_DISPLAY_MATRIX xdsp_03 HT16K33 0x70 - 0x77 8x8 led matrix 6 USE_DISPLAY_SH1106 xdsp_07 SH1106 0x3C - 0x3D Oled display 7 USE_ADE7953 xnrg_07 ADE7953 0x38 Energy monitor 8 USE_SHT xsns_07 SHT1X Any Temperature and Humidity sensor 9 USE_HTU xsns_08 HTU21 0x40 Temperature and Humidity sensor 9 USE_HTU xsns_08 SI7013 0x40 Temperature and Humidity sensor 9 USE_HTU xsns_08 SI7020 0x40 Temperature and Humidity sensor 9 USE_HTU xsns_08 SI7021 0x40 Temperature and Humidity sensor 10 USE_BMP xsns_09 BMP085 0x76 - 0x77 Pressure and temperature sensor 10 USE_BMP xsns_09 BMP180 0x76 - 0x77 Pressure and temperature sensor 10 USE_BMP xsns_09 BMP280 0x76 - 0x77 Pressure and temperature sensor 10 USE_BMP xsns_09 BME280 0x76 - 0x77 Pressure, temperature and humidity sensor 10 USE_BMP xsns_09 BME680 0x76 - 0x77 Pressure, temperature, humidity and gas sensor 11 USE_BH1750 xsns_10 BH1750 0x23, 0x5C Ambient light intensity sensor 12 USE_VEML6070 xsns_11 VEML6070 0x38 - 0x39 Ultra violet light intensity sensor 13 USE_ADS1115 xsns_12 ADS1115 0x48 - 0x4B 4-channel 16-bit A/D converter 14 USE_INA219 xsns_13 INA219 0x40 - 0x41, 0x44 - 0x45 Low voltage current sensor 15 USE_SHT3X xsns_14 SHT3X 0x44 - 0x45 Temperature and Humidity sensor 15 USE_SHT3X xsns_14 SHTC3 0x70 Temperature and Humidity sensor 16 USE_TSL2561 xsns_16 TSL2561 0x29, 0x39, 0x49 Light intensity sensor 17 USE_MGS xsns_19 Grove 0x04 Multichannel gas sensor 18 USE_SGP30 xsns_21 SGP30 0x58 Gas (TVOC) and air quality sensor 19 USE_SI1145 xsns_24 SI1145 0x60 Ultra violet index and light sensor 19 USE_SI1145 xsns_24 SI1146 0x60 Ultra violet index and light sensor 19 USE_SI1145 xsns_24 SI1147 0x60 Ultra violet index and light sensor 20 USE_LM75AD xsns_26 LM75AD 0x48 - 0x4F Temperature sensor 21 USE_APDS9960 xsns_27 APDS9960 0x39 Proximity ambient light RGB and gesture sensor 22 USE_MCP230xx xsns_29 MCP23008 0x20 - 0x26 16-bit I/O expander 22 USE_MCP230xx xsns_29 MCP23017 0x20 - 0x26 16-bit I/O expander 23 USE_MPR121 xsns_30 MPR121 0x5A - 0x5D Proximity capacitive touch sensor 24 USE_CCS811 xsns_31 CCS811 0x5A Gas (TVOC) and air quality sensor 25 USE_MPU6050 xsns_32 MPU6050 0x68 - 0x69 3-axis gyroscope and temperature sensor 26 USE_DS3231 xsns_33 DS3231 0x68 Real time clock 27 USE_MGC3130 xsns_36 MGC3130 0x42 Electric field sensor 28 USE_MAX44009 xsns_41 MAX44009 0x4A - 0x4B Ambient light intensity sensor 29 USE_SCD30 xsns_42 SCD30 0x61 CO2 sensor 30 USE_SPS30 xsns_44 SPS30 0x69 Particle sensor 31 USE_VL53L0X xsns_45 VL53L0X 0x29 Time-of-flight (ToF) distance sensor 32 USE_MLX90614 xsns_46 MLX90614 0x5A Infra red temperature sensor 33 USE_CHIRP xsns_48 CHIRP 0x20 Soil moisture sensor 34 USE_PAJ7620 xsns_50 PAJ7620 0x73 Gesture sensor 35 USE_INA226 xsns_54 INA226 0x40 - 0x41, 0x44 - 0x45 Low voltage current sensor 36 USE_HIH6 xsns_55 HIH6130 0x27 Temperature and Humidity sensor 37 USE_24C256 xdrv_10 24C256 0x50 Scripter EEPROM storage 38 USE_DISPLAY_ILI9488 xdsp_08 FT6236 0x38 Touch panel controller 39 USE_DISPLAY_RA8876 xdsp_10 FT5316 0x38 Touch panel controller 40 USE_TSL2591 xsns_57 TLS2591 0x29 Light intensity sensor 41 USE_DHT12 xsns_58 DHT12 0x5C Temperature and humidity sensor 42 USE_DS1624 xsns_59 DS1621 0x48 - 0x4F Temperature sensor 42 USE_DS1624 xsns_59 DS1624 0x48 - 0x4F Temperature sensor 43 USE_AHT1x xsns_63 AHT10/15 0x38 or 0x39 Temperature and humidity sensor 43 USE_AHT2x xsns_63 AHT20 0x38 Temperature and humidity sensor 44 USE_WEMOS_MOTOR_V1 xdrv_34 0x2D - 0x30 WEMOS motor shield v1.0.0 (6612FNG) 45 USE_HDC1080 xsns_65 HDC1080 0x40 Temperature and Humidity sensor 46 USE_IAQ xsns_66 IAQ 0x5a Air quality sensor 47 USE_DISPLAY_SEVENSEG xdsp_11 HT16K33 0x70 - 0x77 Seven segment LED 48 USE_AS3935 xsns_67 AS3935 0x03 Franklin Lightning Sensor 49 USE_VEML6075 xsns_70 VEML6075 0x10 UVA/UVB/UVINDEX Sensor 50 USE_VEML7700 xsns_71 VEML7700 0x10 Ambient light intensity sensor 51 USE_MCP9808 xsns_72 MCP9808 0x18 - 0x1F Temperature sensor 52 USE_HP303B xsns_73 HP303B 0x76 - 0x77 Pressure and temperature sensor","title":"Supported I2C devices"},{"location":"IAQ/","text":"iAQ-Core indoor air quality sensor ~ This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_IAQ #define USE_IAQ // [ I2cDriver46 ] Enable iAQ - core air quality sensor ( I2C address 0x5a ) ( + 0 k6 code ) #endif The iAQ-core indoor air quality module is a low-cost, ultra compact solution for detecting poor air quality. This module uses micro-machined metal oxide semiconductor (MOS) technology to detect a broad range of VOCs while correlating directly with CO2 and TVOC levels in the room. Warning All testing and driver programming has been done using iAQ-Core C sensor model. We don't know whether iAQ-Core P will work with this driver. Configuration ~ Wiring Follow datasheet for required pull-ups when connecting the bare sensor module directly to ESP8266. Wemos and NodeMCU board include the required pull-up. Breakout ESP8266 VCC/VIN +3.3VDC GND GND SCL GPIOy SDA GPIOx Tasmota Settings In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) After configuring the GPIO's the driver will detect iAQ-Core automatically. On every power on sensor will run in Warm up mode for 5 minutes to calibrate. During this webUI shows: and console displays iAQ: Error 10 When warm-up is finished, sensor will show readings in web UI: and in MQTT topic (according to TelePeriod): {\"Time\":\"2020-01-01T00:00:00\",\"IAQ\":{\"eCO2\":450,\"TVOC\":125,\"Resistance\":76827}} Usage ~ Typical sensor reading should be around 450 ppm eCO2 and 125 ppb TVOC. Resistance is sensor's gas resistance in Ohm and is the baseline reading from which eCO2 and TVOC are calculated from If you see error messages in console, take appropriate action: iAQ: Error 1 During use, a message iAQ: Error 1 will randomly appear. This is normal, it's a skipped reading due to sensor still taking environment data during polling. iAQ: Error 80 If this error persists, the sensor is broken and should be replaced. iAQ: Error ff General connection error. Check your wiring and if the power supply supplies enough power to the sensor. Run I2CScan to check if the sensor can be found on 0x5a I 2 C address. Breakout Boards ~ Where to get AliExpress sensor module Aliexpress breakout board Mouser DigiKey iAQ-Core Datasheet","title":"iAQ-Core indoor air quality sensor"},{"location":"IAQ/#iaq-core-indoor-air-quality-sensor","text":"This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_IAQ #define USE_IAQ // [ I2cDriver46 ] Enable iAQ - core air quality sensor ( I2C address 0x5a ) ( + 0 k6 code ) #endif The iAQ-core indoor air quality module is a low-cost, ultra compact solution for detecting poor air quality. This module uses micro-machined metal oxide semiconductor (MOS) technology to detect a broad range of VOCs while correlating directly with CO2 and TVOC levels in the room. Warning All testing and driver programming has been done using iAQ-Core C sensor model. We don't know whether iAQ-Core P will work with this driver.","title":"iAQ-Core indoor air quality sensor"},{"location":"IAQ/#configuration","text":"","title":"Configuration"},{"location":"IAQ/#usage","text":"Typical sensor reading should be around 450 ppm eCO2 and 125 ppb TVOC. Resistance is sensor's gas resistance in Ohm and is the baseline reading from which eCO2 and TVOC are calculated from If you see error messages in console, take appropriate action: iAQ: Error 1 During use, a message iAQ: Error 1 will randomly appear. This is normal, it's a skipped reading due to sensor still taking environment data during polling. iAQ: Error 80 If this error persists, the sensor is broken and should be replaced. iAQ: Error ff General connection error. Check your wiring and if the power supply supplies enough power to the sensor. Run I2CScan to check if the sensor can be found on 0x5a I 2 C address.","title":"Usage"},{"location":"IAQ/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"IP-Symcon/","text":"For users knowing more about integrating Tasmota with IP-Symcon please update this page. The Tasmota IP-Symcon interface can be found at https://github.com/Schnittcher/IPS-Tasmota There are currently two modules for IP Symcon Conditions ~ Mosquitto Broker MQTT Client - currently a modified version of IPS_MQTT by thomasf68 IP-Symcon version 4.1 or higher IPS-TasmotaConfigurator ~ With the configurator it is possible to generate automatically the IP Symcon instances for the Tasmota devices. IPS-Tasmota ~ With this Module it is possible to map devices that contain standard functions of the Tasmota firmware. For example: Sonoff Switch, Sonoff POW, Sonoff 4CH, Sonoff TH IPS-TasmotaLED ~ With the IPS-TasmotaLED module it is possible to map the LED modules that run with the Tasmota firmware. For example: WS2812, AiLight, Sonoff Led, B1, BN-SZ01, H801 and MagicHome Installation ~ Github Repositorys in IP Symcon via Core Instances -> Modules -> Add IPS-KS-MQTT Client: ~ https://github.com/Schnittcher/IPS-KS-MQTT.git IPS-Tasmota: ~ https://github.com/Schnittcher/IPS-Tasmota.git","title":"IP Symcon"},{"location":"IP-Symcon/#conditions","text":"Mosquitto Broker MQTT Client - currently a modified version of IPS_MQTT by thomasf68 IP-Symcon version 4.1 or higher","title":"Conditions"},{"location":"IP-Symcon/#ips-tasmotaconfigurator","text":"With the configurator it is possible to generate automatically the IP Symcon instances for the Tasmota devices.","title":"IPS-TasmotaConfigurator"},{"location":"IP-Symcon/#ips-tasmota","text":"With this Module it is possible to map devices that contain standard functions of the Tasmota firmware. For example: Sonoff Switch, Sonoff POW, Sonoff 4CH, Sonoff TH","title":"IPS-Tasmota"},{"location":"IP-Symcon/#ips-tasmotaled","text":"With the IPS-TasmotaLED module it is possible to map the LED modules that run with the Tasmota firmware. For example: WS2812, AiLight, Sonoff Led, B1, BN-SZ01, H801 and MagicHome","title":"IPS-TasmotaLED"},{"location":"IP-Symcon/#installation","text":"Github Repositorys in IP Symcon via Core Instances -> Modules -> Add","title":"Installation"},{"location":"IP-Symcon/#ips-ks-mqtt-client","text":"https://github.com/Schnittcher/IPS-KS-MQTT.git","title":"IPS-KS-MQTT Client:"},{"location":"IP-Symcon/#ips-tasmota_1","text":"https://github.com/Schnittcher/IPS-Tasmota.git","title":"IPS-Tasmota:"},{"location":"IR-Remote/","text":"IR Remote driver enables sending IR codes through an IR transmitter and receiving them through an IR receiver via IRremoteESP8266 library . Most builds support only most common IR protocols, but tasmota-ir.bin supports almost all protocols available in the IRremoteESP8266 library. IR Transmitter ~ Common transmitter modules in the market have a weak IR LED, thus effective transmit distance is really short. If you need range it is best to build your own . For the LED we recommend TSAL6400 for best performance. YT-IRTM transmitter/receiver board is serial only and does not work with this driver (its also limited to only NEC IR protocol). Wiring ~ IR w/ 2N222 ESP266 data GPIOx + 3.3v/5v - GND Tasmota ~ In the Configuration -> Configure Module page assign: GPIOx to IRsend (8) See IR commands for use. IR Receiver ~ IR Receiver is used to capture IR codes. Those codes can be sent using IRSend or used as a rule trigger. Example uses the widely available KY-022 breakout board. Wiring ~ KY-022 ESP266 S GPIOx + 5v - GND Tasmota ~ In the Configuration -> Configure Module page assign: GPIOx to IRrecv (51) On a captured code IR receiver sends a tele/%topic%/RESULT JSON reponse: { \"Time\" : \"2019-01-01T00:00:00\" , \"IrReceived\" : { \"Protocol\" : \"NEC\" , \"Bits\" : 32 , \"Data\" : \"0x00FF00FF\" } } Further Reading ~ This covers only the basic IR protocols. Read Complete IR Remote Protocols for more advanced applications. IR Send RAW configuration and use User maintained codes database for IR Linux Infrared Remote Control (LIRC) for more information. Related Projects ~ IR Blaster with Tasmota Sonoff Basic IR \"hat\" Example circuit with transmitter and receiver:","title":"IR Remote"},{"location":"IR-Remote/#ir-transmitter","text":"Common transmitter modules in the market have a weak IR LED, thus effective transmit distance is really short. If you need range it is best to build your own . For the LED we recommend TSAL6400 for best performance. YT-IRTM transmitter/receiver board is serial only and does not work with this driver (its also limited to only NEC IR protocol).","title":"IR Transmitter"},{"location":"IR-Remote/#wiring","text":"IR w/ 2N222 ESP266 data GPIOx + 3.3v/5v - GND","title":"Wiring"},{"location":"IR-Remote/#tasmota","text":"In the Configuration -> Configure Module page assign: GPIOx to IRsend (8) See IR commands for use.","title":"Tasmota"},{"location":"IR-Remote/#ir-receiver","text":"IR Receiver is used to capture IR codes. Those codes can be sent using IRSend or used as a rule trigger. Example uses the widely available KY-022 breakout board.","title":"IR Receiver"},{"location":"IR-Remote/#wiring_1","text":"KY-022 ESP266 S GPIOx + 5v - GND","title":"Wiring"},{"location":"IR-Remote/#tasmota_1","text":"In the Configuration -> Configure Module page assign: GPIOx to IRrecv (51) On a captured code IR receiver sends a tele/%topic%/RESULT JSON reponse: { \"Time\" : \"2019-01-01T00:00:00\" , \"IrReceived\" : { \"Protocol\" : \"NEC\" , \"Bits\" : 32 , \"Data\" : \"0x00FF00FF\" } }","title":"Tasmota"},{"location":"IR-Remote/#further-reading","text":"This covers only the basic IR protocols. Read Complete IR Remote Protocols for more advanced applications. IR Send RAW configuration and use User maintained codes database for IR Linux Infrared Remote Control (LIRC) for more information.","title":"Further Reading"},{"location":"IR-Remote/#related-projects","text":"IR Blaster with Tasmota Sonoff Basic IR \"hat\" Example circuit with transmitter and receiver:","title":"Related Projects"},{"location":"IRSend-RAW-Encoding/","text":"New IR Raw compact encoding ~ (available since v9.0.0.1) We had numerous requests from users to expand the buffer sizes because many IR codes would exceed the MQTT/Web/Serial buffer size. Instead, we changed the IR Raw encoding to shrink the size necessary to encode almost any IR code. Before (buffer overflow): {\"IrReceived\":{\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55A50AFA55A50AF\",\"DataLSB\":\"0xA55A0AF5A55A0AF5\",\"Repeat\":0,\"RawData\":[8574,4224,574,1558,572,502,570,1562,570,502,572,502,570,1562,570,502,570,1562,572,500,572,1560,572,500,572,1560,572,1560,570,504,568,1560,570,502,572,502,570,1562,570,502,570,1560,570,502,572,500,570,502,572,502,570,1560,570,504,572,1558,572,502,570,1564,568,1562,570,1560,572,1560,572,25258,8574,4222,572,1560,570,502,572,1558,572,502,570,502,572,1558,572,500,570,1560,570,502,570,1560,570,502,570,1560,570,1560,570,504,570,1560,572,502,570,502,570,1560,572,502,570,1560,570,502,570,502,570,502,570,502,570,1560,570,502,570,1560,572,502,570 ... After (no overflow): {\"IrReceived\":{\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55A50AFA55A50AF\",\"DataLSB\":\"0xA55A0AF5A55A0AF5\",\"Repeat\":0,\"RawData\":[+8570-4240+550-1580C-510+565-1565F-505Fh+570gFhIdChIgFeFgFgIhFgIhF-525C-1560IhIkI-520ChFhFhFgFhIkIhIgIgIkIkI-25270A-4225IkIhIgIhIhIkFhIkFjCgIhIkIkI-500IkIhIhIkFhIgIl+545hIhIoIgIhIkFhFgIkIgFgI],\"RawDataInfo\":[135,135,0]}} The new format still encodes timings for High/low pulses. - First the timings are rounded to the closest 5 microsec value. - Instead of using commas, values are prefixed with + if it's a HIGH signal, or - if it's a LOW signal. - Each new timing value is assigned a letter starting with 'A' - If a timing value matches a previously found value, it is replaced with the letter, in uppercase for a HIGH signal, or lowercase for a LOW signal. Ex: +8570-4240+550-1580C-510+565-1565F-505Fh \\__/ \\__/ \\_/ \\__/C \\_/ \\_/ \\__/F \\_/Fh A B C D E F G H Which translates to: +8570-4240+550-1580+550-510+565-1565+565-505+565-505 or 8570,4240,550,1580,550,510,565,1565,565,505,565,505 If you need to transform the compact format in the legacy format, you can use the online tool: https://tasmota.hadinger.fr/util IRSend for raw IR ~ There are two command syntax forms for sending a remote control code in RAW format with IRsend : IRSend<x> <frequency>,<rawdata1>,<rawdata2>,..,<rawdataN> e.g., IRsend 0,926,844,958,832,1798,868,902,848,900,870,900,852,908,918,958,794,934,874,928,1738,934,856,1764 or IRSend 0,+8570-4240+550-1580C-510+565-1565F-505Fh+570gFhIdChIgFeFgFgIhFgIhF-525C-1560IhIkI-520ChFhFhFgFhIkIhIgIgIkIkI-25270A-4225IkIhIgIhIhIkFhIkFjCgIhIkIkI-500IkIhIhIkFhIgIl+545hIhIoIgIhIkFhFgIkIgFgI IRSend<x> raw,<frequency>[,<header_mark>,<header_space>,<bit_mark>],<zero_space>[, [<one_multiple>] | <one_space>],<bit_stream> Where Parameter Description <frequency> carrier frequency (default 0 = 38kHz) <header_mark> ** header mark duration (\u00b5s) (optional for some protocols) <header_space> ** header space duration (\u00b5s) (optional for some protocols) <bit_mark> bit mark duration (\u00b5s) (optional for some protocols) <zero_space> zero space duration (\u00b5s) <one_multiple> used to specify the one space duration if the one space duration is an integral multiple of the zero space duration. This parameter may be omitted if the multiple is 2. Use of this parameter is mutually exclusive with the <one_space> parameter <one_space> one space duration (\u00b5s). Use this parameter if the one space duration is not an integral multiple of <zero_space> Use of this parameter is mutually exclusive with the <one_multiple> parameter <bit_stream> bit stream data (stream of ones and zeroes) ** If header_mark and header_space are specified, the gap will be computed as (header_mark + header_space) * 3 with a high limit of 65ms (65,000\u00b5s) to avoid 16 bits overflow. If header_mark and header_space are not specified, the gap will be 40ms (40,000\u00b5s). This command syntax version makes use of the output of the raw IR decoder from ToniA/Raw-IR-decoder-for-Arduino Examples for bitstream command syntax ~ rawirdecode output: ~ Number of symbols: 75 Symbols: Hh010101101000111011001110000000001100110000000001100000000000000010001100 Bytes: 00: 0101|0110 | 6A | 01101010 01: 1000|1110 | 71 | 01110001 02: 1100|1110 | 73 | 01110011 03: 0000|0000 | 00 | 00000000 04: 1100|1100 | 33 | 00110011 05: 0000|0001 | 80 | 10000000 06: 1000|0000 | 01 | 00000001 07: 0000|0000 | 00 | 00000000 08: 1000|1100 | 31 | 00110001 6A,71,73,00,33,80,01,00,31 Timings (in us): PAUSE SPACE: 0 HEADER MARK: 8620 HEADER SPACE: 4260 BIT MARK: 544 ZERO SPACE: 411 ONE SPACE: 1496 Decoding known protocols... Unknown protocol Bytecount: 9 Corresponding command: IRSend<x> raw,0,8620,4260,544,411,1496,010101101000111011001110000000001100110000000001100000000000000010001100 Gree air conditioner Power On ~ {8956, 4560, 546, 1710, 588, 616, 584, 618, 584, 1712, 586, 1712, 588, 614, 586, 614, 586, 618, 586, 1706, 590, 616 , 586, 1708, 590, 616, 588, 610, 590, 612, 590, 612, 590, 618, 584, 618, 584, 616, 586, 614, 588, 612, 590, 612, 590, 1712, 586 , 616, 588, 612, 590, 614, 588, 614, 586, 618, 586, 616, 586, 1710, 588, 614, 586, 1708, 590, 610, 592, 612, 590, 1708, 588, 614 , 588, 20084, 548, 612, 590, 614, 588, 614, 588, 616, 586, 654, 546, 616, 586, 616, 586, 614, 588, 612, 588, 610, 592, 612, 590 , 612, 590, 614, 586, 1712, 586, 616, 586, 612, 588, 614, 588, 614, 586, 616, 586, 612, 590, 614, 588, 610, 590, 616, 586, 614 , 588, 612, 590, 612, 590, 614, 588, 614, 588, 614, 588, 1708, 590, 612, 590, 1708, 590} Arrange the data into pairs: MARK SPACE BIT 8956 4560 (header) 546 1710 1 588 616 0 584 618 0 584 1712 1 586 1712 1 588 614 0 586 614 0 ... 590 612 0 590 614 0 588 614 0 588 614 0 588 1708 1 590 612 0 590 1708 1 590 (ignore) The header is always the first pair, the zeroes have the shortest space duration and the ones have the longest space duration. header mark is 8956 header space is 4560 bit mark, get the average, say 590 zero space, say 615 one space, say 1710 Corresponding command: IRSend<x> raw,0,8956,4560,590,615,1710,1001100 ... 0000101 Understanding IR encoding ~ Below are several topics that may help you decoding and understanding what your IR remotes are sending (ex: HVAC) or convert from popular IR formats like PRONTO or Broadlink. First, have a look at the excellent article from Elektor IR Remote Control Codes Decoding IR codes by hand ~ From discussion with @johan1111 on Discord. Let's suppose you have an unsupported HVAL and record the following raw IR codes using Tasmota: [3094,3062,3092,4442,576,1652,578,528,576,1650,580,528,576,528,576,1650,...] IR messages typically start with a long Mark (IR on), followed by a long Space (IR off). Here we see a double sequence of Mark (3094 \u00b5s) - Space (3062 \u00b5s) - Mark (3092 \u00b5s) - Space (4442 \u00b5s). The actual bitstream is 576,1652,578,528,576,1650,580,528,576,528,576,1650,... . You need to take timing by pairs, again the first value is Mark (IR on), the second Space (IR off). The Mark is typically of constant time, and the space will vary from short (~528 \u00b5s) for bit 0 to long (~1650 \u00b5s) for bit 1 . So the first bits of the bitstream are: 101001... Pioneer IR enconding ~ Pioneer IR encoding is very similar to NEC encoding for the bitstream. When capturing IR codes, they will easily be recognized as NEC codes. But they have subtle differences. First, the Frequency if 40KHz for Pioneer vs 38KHz for NEC. The number of IR pulses are the same, so all Pioneer timings are 5% shorter than Nec equivalent. Most Pioneer will tolerate the difference, but some won't. If you have a Pioneer device, prefer the Pioneer encoding. Second, Pioneer introduced 64 bits messages vs 32 bits for NEC. Most simple Pioneer commands still use 32 bits, but newer require 64 bits. 64 bits messages are actually sent as 2x 32 bits messages with a very short pause in between. Example, Pioneer Vol+ is 32 bits message and must be sent twice. You can either send the same message 0xA55A50AF twice with IRSend2 or send a 64 bits message with twice the same 32 payload: 0xA55A50AFA55A50AF . IRSend2 {\"Protocol\":\"PIONEER\",\"Bits\":32,\"Data\":\"0xA55A50AF\"} or IRSend {\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55A50AFA55A50AF\"} Example 2: Pioneer Stereo: IRSend {\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55AF906A55A03FC\"} How to convert Pioneer codes to Tasmota ~ Pioneer kindly publishes all IR Codes online on its website. Let's take a Pioneer Receiver like VSX-820. Choose the right Excel file and navigate in the corresponding tab. Pioneer codes are in short format. For example \"TV / SAT\" code is A59B+A5CD . You now need to convert these short codes into 64 bits IRRemote8266 codes. Steps: 1. Take the first byte: 0xA5 or 0b10100101 . Pioneer codes are LSB, but we need MSB. So read backwards all bits to 0b10100101 and back to hex A5 . Your first byte is A5 . Note: You can see here that 0xA5 is a palindrome. 2. Invert all bits of previous byte: 0b01011010 . Your second byte is 5A . 3. Take the second byte 0x9B or 0b10011011 . Read backwards all bits giving 0b11011001. Your third byte is D9 . 4. Invert all bits from previous byte: 0b00100110 . Your fourth byte is 26 . Do the same with the second sequence A5CD , you should find the following sequence: A55AB3CD . The final sequence is: IRSend {\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55AD926A55AB3CD\"} Converting Pronto IR codes to Tasmota ~ Pronto is a very common and early format to describe raw IR codes. It is fully described in this excellent series of articles The Pronto's IR Code Format Pronto is commonly represented as a series of 4-digits HEX numbers in unsigned 16-bits format. Example, from Foxtel Vol+: Vol + 0000 0073 0000 0012 000F 000A 0006 000A 0006 0016 0006 000A 0006 0010 0006 0016 0006 0016 0006 000A 0006 000A 0006 000A 0006 0016 0006 0010 0006 0016 0006 000A 0006 0010 0006 000A 0006 000A 0006 0CA0 To convert from Pronto to IRSend by hand it requires extra work. Ignore first 0000 0073 is the IR frequency, compute as \"Frequency = 1000000/(N * .241246)\". So for 0x73 (115), this gives 36KHz. First value for IRSend is 36 . 0000 is the length of the One Time Burst. There is no one time burst 0012 - Decimal 18 is the length of the repeat burst. There are 18 bits (Burst pairs) in this code. Next pulses are measured in pulses of the IR clock, so it depends on the frequency. With 36KHz, each pulse is (1000/36) 27.7 microseconds So you need to multiply by 27.7 for Tasmota to get actual \u00b5s 000F 000A - becomes 415,277 0006 000A - becomes 166,277 And so on... In the end, it will look like: IRSend 36,415,277,166,277,... Converting Broadlink IR codes to Tasmota ~ Broadlink is another popular device to send and receive IR/RF codes. Unfortunately, it does not run ESP8266, so it cannot be Tasmotized. Broadlink codes come either in Base64 format or in Hex format. Below will use Hex format which is easier to work by hand. Example: \"Code\": \"2600700000015692171117111612171116121612161117111735173517361636161117351735173517111636161216121611171116121612163616111735173517351735173517351700053D0001554916000C4E0001554916000C4E0001564817000C4D0001564917000C4C0001564917000D050000000000000000\", \"Base64\": \"JgBwAAABVpIXERcRFhIXERYSFhIWERcRFzUXNRc2FjYWERc1FzUXNRcRFjYWEhYSFhEXERYSFhIWNhYRFzUXNRc1FzUXNRc1FwAFPQABVUkWAAxOAAFVSRYADE4AAVZIFwAMTQABVkkXAAxMAAFWSRcADQUAAAAAAAAAAA== The Broadling protocol is described here: Broadlink RM2 network protocol Here is a copy of the part specifically describing Offset Contents 0x00 0x26 = IR, 0xb2 for RF 433Mhz, 0xd7 for RF 315Mhz 0x01 repeat count, (0 = no repeat, 1 send twice, .....) 0x02-0x03 Length of the following data in little endian 0x04 .... Pulse lengths in 2^-15 s units (\u00b5s * 269 / 8192 works very well) .... 0x0d 0x05 at the end for IR only Each value is represented by one byte. If the length exceeds one byte then it is stored big endian with a leading 0. Example: The header for an Optoma projector is 8920 4450 8920 * 269 / 8192 = 0x124 4450 * 269 / 8192 = 0x92 ... which would be encoded as 0x00 0x1 0x24 0x92 in broalink format. You have all the needed information to convert from Broadlink to Tasmota...","title":"IRSend RAW Encoding"},{"location":"IRSend-RAW-Encoding/#new-ir-raw-compact-encoding","text":"(available since v9.0.0.1) We had numerous requests from users to expand the buffer sizes because many IR codes would exceed the MQTT/Web/Serial buffer size. Instead, we changed the IR Raw encoding to shrink the size necessary to encode almost any IR code. Before (buffer overflow): {\"IrReceived\":{\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55A50AFA55A50AF\",\"DataLSB\":\"0xA55A0AF5A55A0AF5\",\"Repeat\":0,\"RawData\":[8574,4224,574,1558,572,502,570,1562,570,502,572,502,570,1562,570,502,570,1562,572,500,572,1560,572,500,572,1560,572,1560,570,504,568,1560,570,502,572,502,570,1562,570,502,570,1560,570,502,572,500,570,502,572,502,570,1560,570,504,572,1558,572,502,570,1564,568,1562,570,1560,572,1560,572,25258,8574,4222,572,1560,570,502,572,1558,572,502,570,502,572,1558,572,500,570,1560,570,502,570,1560,570,502,570,1560,570,1560,570,504,570,1560,572,502,570,502,570,1560,572,502,570,1560,570,502,570,502,570,502,570,502,570,1560,570,502,570,1560,572,502,570 ... After (no overflow): {\"IrReceived\":{\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55A50AFA55A50AF\",\"DataLSB\":\"0xA55A0AF5A55A0AF5\",\"Repeat\":0,\"RawData\":[+8570-4240+550-1580C-510+565-1565F-505Fh+570gFhIdChIgFeFgFgIhFgIhF-525C-1560IhIkI-520ChFhFhFgFhIkIhIgIgIkIkI-25270A-4225IkIhIgIhIhIkFhIkFjCgIhIkIkI-500IkIhIhIkFhIgIl+545hIhIoIgIhIkFhFgIkIgFgI],\"RawDataInfo\":[135,135,0]}} The new format still encodes timings for High/low pulses. - First the timings are rounded to the closest 5 microsec value. - Instead of using commas, values are prefixed with + if it's a HIGH signal, or - if it's a LOW signal. - Each new timing value is assigned a letter starting with 'A' - If a timing value matches a previously found value, it is replaced with the letter, in uppercase for a HIGH signal, or lowercase for a LOW signal. Ex: +8570-4240+550-1580C-510+565-1565F-505Fh \\__/ \\__/ \\_/ \\__/C \\_/ \\_/ \\__/F \\_/Fh A B C D E F G H Which translates to: +8570-4240+550-1580+550-510+565-1565+565-505+565-505 or 8570,4240,550,1580,550,510,565,1565,565,505,565,505 If you need to transform the compact format in the legacy format, you can use the online tool: https://tasmota.hadinger.fr/util","title":"New IR Raw compact encoding"},{"location":"IRSend-RAW-Encoding/#irsend-for-raw-ir","text":"There are two command syntax forms for sending a remote control code in RAW format with IRsend : IRSend<x> <frequency>,<rawdata1>,<rawdata2>,..,<rawdataN> e.g., IRsend 0,926,844,958,832,1798,868,902,848,900,870,900,852,908,918,958,794,934,874,928,1738,934,856,1764 or IRSend 0,+8570-4240+550-1580C-510+565-1565F-505Fh+570gFhIdChIgFeFgFgIhFgIhF-525C-1560IhIkI-520ChFhFhFgFhIkIhIgIgIkIkI-25270A-4225IkIhIgIhIhIkFhIkFjCgIhIkIkI-500IkIhIhIkFhIgIl+545hIhIoIgIhIkFhFgIkIgFgI IRSend<x> raw,<frequency>[,<header_mark>,<header_space>,<bit_mark>],<zero_space>[, [<one_multiple>] | <one_space>],<bit_stream> Where Parameter Description <frequency> carrier frequency (default 0 = 38kHz) <header_mark> ** header mark duration (\u00b5s) (optional for some protocols) <header_space> ** header space duration (\u00b5s) (optional for some protocols) <bit_mark> bit mark duration (\u00b5s) (optional for some protocols) <zero_space> zero space duration (\u00b5s) <one_multiple> used to specify the one space duration if the one space duration is an integral multiple of the zero space duration. This parameter may be omitted if the multiple is 2. Use of this parameter is mutually exclusive with the <one_space> parameter <one_space> one space duration (\u00b5s). Use this parameter if the one space duration is not an integral multiple of <zero_space> Use of this parameter is mutually exclusive with the <one_multiple> parameter <bit_stream> bit stream data (stream of ones and zeroes) ** If header_mark and header_space are specified, the gap will be computed as (header_mark + header_space) * 3 with a high limit of 65ms (65,000\u00b5s) to avoid 16 bits overflow. If header_mark and header_space are not specified, the gap will be 40ms (40,000\u00b5s). This command syntax version makes use of the output of the raw IR decoder from ToniA/Raw-IR-decoder-for-Arduino","title":"IRSend for raw IR"},{"location":"IRSend-RAW-Encoding/#examples-for-bitstream-command-syntax","text":"","title":"Examples for bitstream command syntax"},{"location":"IRSend-RAW-Encoding/#rawirdecode-output","text":"Number of symbols: 75 Symbols: Hh010101101000111011001110000000001100110000000001100000000000000010001100 Bytes: 00: 0101|0110 | 6A | 01101010 01: 1000|1110 | 71 | 01110001 02: 1100|1110 | 73 | 01110011 03: 0000|0000 | 00 | 00000000 04: 1100|1100 | 33 | 00110011 05: 0000|0001 | 80 | 10000000 06: 1000|0000 | 01 | 00000001 07: 0000|0000 | 00 | 00000000 08: 1000|1100 | 31 | 00110001 6A,71,73,00,33,80,01,00,31 Timings (in us): PAUSE SPACE: 0 HEADER MARK: 8620 HEADER SPACE: 4260 BIT MARK: 544 ZERO SPACE: 411 ONE SPACE: 1496 Decoding known protocols... Unknown protocol Bytecount: 9 Corresponding command: IRSend<x> raw,0,8620,4260,544,411,1496,010101101000111011001110000000001100110000000001100000000000000010001100","title":"rawirdecode output:"},{"location":"IRSend-RAW-Encoding/#gree-air-conditioner-power-on","text":"{8956, 4560, 546, 1710, 588, 616, 584, 618, 584, 1712, 586, 1712, 588, 614, 586, 614, 586, 618, 586, 1706, 590, 616 , 586, 1708, 590, 616, 588, 610, 590, 612, 590, 612, 590, 618, 584, 618, 584, 616, 586, 614, 588, 612, 590, 612, 590, 1712, 586 , 616, 588, 612, 590, 614, 588, 614, 586, 618, 586, 616, 586, 1710, 588, 614, 586, 1708, 590, 610, 592, 612, 590, 1708, 588, 614 , 588, 20084, 548, 612, 590, 614, 588, 614, 588, 616, 586, 654, 546, 616, 586, 616, 586, 614, 588, 612, 588, 610, 592, 612, 590 , 612, 590, 614, 586, 1712, 586, 616, 586, 612, 588, 614, 588, 614, 586, 616, 586, 612, 590, 614, 588, 610, 590, 616, 586, 614 , 588, 612, 590, 612, 590, 614, 588, 614, 588, 614, 588, 1708, 590, 612, 590, 1708, 590} Arrange the data into pairs: MARK SPACE BIT 8956 4560 (header) 546 1710 1 588 616 0 584 618 0 584 1712 1 586 1712 1 588 614 0 586 614 0 ... 590 612 0 590 614 0 588 614 0 588 614 0 588 1708 1 590 612 0 590 1708 1 590 (ignore) The header is always the first pair, the zeroes have the shortest space duration and the ones have the longest space duration. header mark is 8956 header space is 4560 bit mark, get the average, say 590 zero space, say 615 one space, say 1710 Corresponding command: IRSend<x> raw,0,8956,4560,590,615,1710,1001100 ... 0000101","title":"Gree air conditioner Power On"},{"location":"IRSend-RAW-Encoding/#understanding-ir-encoding","text":"Below are several topics that may help you decoding and understanding what your IR remotes are sending (ex: HVAC) or convert from popular IR formats like PRONTO or Broadlink. First, have a look at the excellent article from Elektor IR Remote Control Codes","title":"Understanding IR encoding"},{"location":"IRSend-RAW-Encoding/#decoding-ir-codes-by-hand","text":"From discussion with @johan1111 on Discord. Let's suppose you have an unsupported HVAL and record the following raw IR codes using Tasmota: [3094,3062,3092,4442,576,1652,578,528,576,1650,580,528,576,528,576,1650,...] IR messages typically start with a long Mark (IR on), followed by a long Space (IR off). Here we see a double sequence of Mark (3094 \u00b5s) - Space (3062 \u00b5s) - Mark (3092 \u00b5s) - Space (4442 \u00b5s). The actual bitstream is 576,1652,578,528,576,1650,580,528,576,528,576,1650,... . You need to take timing by pairs, again the first value is Mark (IR on), the second Space (IR off). The Mark is typically of constant time, and the space will vary from short (~528 \u00b5s) for bit 0 to long (~1650 \u00b5s) for bit 1 . So the first bits of the bitstream are: 101001...","title":"Decoding IR codes by hand"},{"location":"IRSend-RAW-Encoding/#pioneer-ir-enconding","text":"Pioneer IR encoding is very similar to NEC encoding for the bitstream. When capturing IR codes, they will easily be recognized as NEC codes. But they have subtle differences. First, the Frequency if 40KHz for Pioneer vs 38KHz for NEC. The number of IR pulses are the same, so all Pioneer timings are 5% shorter than Nec equivalent. Most Pioneer will tolerate the difference, but some won't. If you have a Pioneer device, prefer the Pioneer encoding. Second, Pioneer introduced 64 bits messages vs 32 bits for NEC. Most simple Pioneer commands still use 32 bits, but newer require 64 bits. 64 bits messages are actually sent as 2x 32 bits messages with a very short pause in between. Example, Pioneer Vol+ is 32 bits message and must be sent twice. You can either send the same message 0xA55A50AF twice with IRSend2 or send a 64 bits message with twice the same 32 payload: 0xA55A50AFA55A50AF . IRSend2 {\"Protocol\":\"PIONEER\",\"Bits\":32,\"Data\":\"0xA55A50AF\"} or IRSend {\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55A50AFA55A50AF\"} Example 2: Pioneer Stereo: IRSend {\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55AF906A55A03FC\"}","title":"Pioneer IR enconding"},{"location":"IRSend-RAW-Encoding/#how-to-convert-pioneer-codes-to-tasmota","text":"Pioneer kindly publishes all IR Codes online on its website. Let's take a Pioneer Receiver like VSX-820. Choose the right Excel file and navigate in the corresponding tab. Pioneer codes are in short format. For example \"TV / SAT\" code is A59B+A5CD . You now need to convert these short codes into 64 bits IRRemote8266 codes. Steps: 1. Take the first byte: 0xA5 or 0b10100101 . Pioneer codes are LSB, but we need MSB. So read backwards all bits to 0b10100101 and back to hex A5 . Your first byte is A5 . Note: You can see here that 0xA5 is a palindrome. 2. Invert all bits of previous byte: 0b01011010 . Your second byte is 5A . 3. Take the second byte 0x9B or 0b10011011 . Read backwards all bits giving 0b11011001. Your third byte is D9 . 4. Invert all bits from previous byte: 0b00100110 . Your fourth byte is 26 . Do the same with the second sequence A5CD , you should find the following sequence: A55AB3CD . The final sequence is: IRSend {\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55AD926A55AB3CD\"}","title":"How to convert Pioneer codes to Tasmota"},{"location":"IRSend-RAW-Encoding/#converting-pronto-ir-codes-to-tasmota","text":"Pronto is a very common and early format to describe raw IR codes. It is fully described in this excellent series of articles The Pronto's IR Code Format Pronto is commonly represented as a series of 4-digits HEX numbers in unsigned 16-bits format. Example, from Foxtel Vol+: Vol + 0000 0073 0000 0012 000F 000A 0006 000A 0006 0016 0006 000A 0006 0010 0006 0016 0006 0016 0006 000A 0006 000A 0006 000A 0006 0016 0006 0010 0006 0016 0006 000A 0006 0010 0006 000A 0006 000A 0006 0CA0 To convert from Pronto to IRSend by hand it requires extra work. Ignore first 0000 0073 is the IR frequency, compute as \"Frequency = 1000000/(N * .241246)\". So for 0x73 (115), this gives 36KHz. First value for IRSend is 36 . 0000 is the length of the One Time Burst. There is no one time burst 0012 - Decimal 18 is the length of the repeat burst. There are 18 bits (Burst pairs) in this code. Next pulses are measured in pulses of the IR clock, so it depends on the frequency. With 36KHz, each pulse is (1000/36) 27.7 microseconds So you need to multiply by 27.7 for Tasmota to get actual \u00b5s 000F 000A - becomes 415,277 0006 000A - becomes 166,277 And so on... In the end, it will look like: IRSend 36,415,277,166,277,...","title":"Converting Pronto IR codes to Tasmota"},{"location":"IRSend-RAW-Encoding/#converting-broadlink-ir-codes-to-tasmota","text":"Broadlink is another popular device to send and receive IR/RF codes. Unfortunately, it does not run ESP8266, so it cannot be Tasmotized. Broadlink codes come either in Base64 format or in Hex format. Below will use Hex format which is easier to work by hand. Example: \"Code\": \"2600700000015692171117111612171116121612161117111735173517361636161117351735173517111636161216121611171116121612163616111735173517351735173517351700053D0001554916000C4E0001554916000C4E0001564817000C4D0001564917000C4C0001564917000D050000000000000000\", \"Base64\": \"JgBwAAABVpIXERcRFhIXERYSFhIWERcRFzUXNRc2FjYWERc1FzUXNRcRFjYWEhYSFhEXERYSFhIWNhYRFzUXNRc1FzUXNRc1FwAFPQABVUkWAAxOAAFVSRYADE4AAVZIFwAMTQABVkkXAAxMAAFWSRcADQUAAAAAAAAAAA== The Broadling protocol is described here: Broadlink RM2 network protocol Here is a copy of the part specifically describing Offset Contents 0x00 0x26 = IR, 0xb2 for RF 433Mhz, 0xd7 for RF 315Mhz 0x01 repeat count, (0 = no repeat, 1 send twice, .....) 0x02-0x03 Length of the following data in little endian 0x04 .... Pulse lengths in 2^-15 s units (\u00b5s * 269 / 8192 works very well) .... 0x0d 0x05 at the end for IR only Each value is represented by one byte. If the length exceeds one byte then it is stored big endian with a leading 0. Example: The header for an Optoma projector is 8920 4450 8920 * 269 / 8192 = 0x124 4450 * 269 / 8192 = 0x92 ... which would be encoded as 0x00 0x1 0x24 0x92 in broalink format. You have all the needed information to convert from Broadlink to Tasmota...","title":"Converting Broadlink IR codes to Tasmota"},{"location":"Integrations/","text":"Introduction ~ Tasmota easily integrates with many home automation solutions reporting status and sensor data and allowing complete control.","title":"Introduction"},{"location":"Integrations/#introduction","text":"Tasmota easily integrates with many home automation solutions reporting status and sensor data and allowing complete control.","title":"Introduction"},{"location":"JSON-Status-Responses/","text":"JSON Changes ~ temp note: for now (6.0.0a) the statetext overwrites the json power result (e.g. \"ON\" => \"AN\" or any other statetext the users enter) Basic Response ~ { \"Status\": { \"Module\": 1, \"FriendlyName\": \"XXX\", \"Topic\": \"sonoff\", \"ButtonTopic\": \"0\", \"Power\": 0, \"PowerOnState\": 0, \"LedState\": 1, \"SaveData\": 0, \"SaveState\": 1, \"ButtonRetain\": 0, \"PowerRetain\": 0 }, \"StatusPRM\": { \"Baudrate\": 115200, \"GroupTopic\": \"sonoffs\", \"OtaUrl\": \"XXX\", \"Uptime\": \"1 02:33:26\", \"Sleep\": 150, \"BootCount\": 32, \"SaveCount\": 72, \"SaveAddress\": \"FB000\" }, \"StatusFWR\": { \"Version\": \"5.12.0a\", \"BuildDateTime\": \"2018.02.11 16:15:40\", \"Boot\": 31, \"Core\": \"2_4_0\", \"SDK\": \"2.1.0(deb1901)\" }, \"StatusLOG\": { \"SerialLog\": 0, \"WebLog\": 4, \"SysLog\": 0, \"LogHost\": \"domus1\", \"LogPort\": 514, \"SSId1\": \"XXX\", \"SSId2\": \"XXX\", \"TelePeriod\": 300, \"SetOption\": \"00000001\" }, \"StatusMEM\": { \"ProgramSize\": 457, \"Free\": 544, \"Heap\": 23, \"ProgramFlashSize\": 1024, \"FlashSize\": 1024, \"FlashMode\": 3 }, \"StatusNET\": { \"Hostname\": \"XXX\", \"IPAddress\": \"192.168.178.XX\", \"Gateway\": \"192.168.178.XX\", \"Subnetmask\": \"255.255.255.XX\", \"DNSServer\": \"192.168.178.XX\", \"Mac\": \"2C:3A:E8:XX:XX:XX\", \"Webserver\": 2, \"WifiConfig\": 4 }, \"StatusTIM\": { \"UTC\": \"Thu Feb 15 00:00:50 2018\", \"Local\": \"Thu Feb 15 01:00:50 2018\", \"StartDST\": \"Sun Mar 25 02:00:00 2018\", \"EndDST\": \"Sun Oct 28 03:00:00 2018\", \"Timezone\": 1 }, \"StatusSNS\": { \"Time\": \"2018.02.15 01:00:50\", \"Switch1\": \"OFF\" }, \"StatusSTS\": { \"Time\": \"2018.02.15 01:00:50\", \"Uptime\": \"1 02:33:26\", \"Vcc\": 3.504, \"POWER\": \"OFF\", \"Wifi\": { \"AP\": 1, \"SSId\": \"XXX\", \"RSSI\": 100, \"APMac\": \"34:31:C4:XX:XX:XX\" } } } MQTT ~ After StatusNET \"StatusMQT\": { \"MqttHost\": \"192.168.XXX.XX\", \"MqttPort\": 1883, \"MqttClientMask\": \"DVES_%06X\", \"MqttClient\": \"DVES_4AXXXX\", \"MqttUser\": \"admin\", \"MAX_PACKET_SIZE\": 1000, \"KEEPALIVE\": 15 }, Domoticz ~ idx, nvalue, svalue without array ...\"StatusTIM\": { \"UTC\": \"Thu Feb 01 20:29:40 2018\", \"Local\": \"Thu Feb 01 21:29:40 2018\", \"StartDST\": \"Sun Mar 25 02:00:00 2018\", \"EndDST\": \"Sun Oct 28 03:00:00 2018\", \"Timezone\": 1 }, \"idx\": 286, \"nvalue\": 0, \"svalue\": \"19.7\", \"StatusSNS\": { \"Time\": \"2018.02.01 21:29:40\", \"DS18B20\": { \"Temperature\": 19.7 }, \"TempUnit\": \"C\" }, \"StatusSTS\": { ... POW ~ After StatusTIM \"StatusPTH\": { \"PowerLow\": 0, \"PowerHigh\": 0, \"VoltageLow\": 0, \"VoltageHigh\": 0, \"CurrentLow\": 0, \"CurrentHigh\": 0 }, \"StatusSNS\": { \"Time\": \"2018.02.04 23:17:01\", \"ENERGY\": { \"Total\": 3.185, \"Yesterday\": 3.058, \"Today\": 0.127, \"Power\": 0, \"Factor\": 0.00, \"Voltage\": 221, \"Current\": 0.000 } }, Sensors ~ AM2301 ~ \"StatusSNS\": { \"Time\": \"2018.02.01 22:52:09\", \"AM2301\": { \"Temperature\": 15.5, \"Humidity\": 50.6 }, \"TempUnit\": \"C\" }, BMP280 ~ { \"StatusSNS\": { \"Time\": \"2018-02-10T22:46:34\", \"BMP280\": { \"Temperature\": 80.9, \"Pressure\": 984.4 } } } DHT11 ~ \"StatusSNS\": { \"Time\": \"2018.02.01 22:48:39\", \"DHT11\": { \"Temperature\": 12.0, \"Humidity\": 42.0 }, \"TempUnit\": \"C\" }, DS18B20 ~ \"StatusSNS\": { \"Time\": \"2018.02.01 21:29:40\", \"DS18B20\": { \"Temperature\": 19.7 }, \"TempUnit\": \"C\" }, SHT3X (and DHT11, multiple Sensor example) ~ { \"StatusSNS\": { \"Time\": \"2018-02-07T20:16:19\", \"DHT11\": { \"Temperature\": 78.8, \"Humidity\": 27.0 }, \"SHT3X\": { \"Temperature\": 74.8, \"Humidity\": 18.9 }, \"TempUnit\": \"F\" } } Sonoff SC ~ \"StatusSNS\": { \"Time\": \"2018-02-16T16:18:49\", \"Temperature\": 25, \"Humidity\": 83, \"Light\": 10, \"Noise\": 20, \"AirQuality\": 100, \"TempUnit\": \"C\" }, PMS5003 and HTU21 ~ \"StatusSNS\": { \"Time\": \"2018-02-16T16:22:12\", \"HTU21\": { \"Temperature\": 24.7, \"Humidity\": 32.1 }, \"PMS5003\": { \"CF1\": 1, \"CF2.5\": 2, \"CF10\": 2, \"PM1\": 1, \"PM2.5\": 2, \"PM10\": 2, \"PB0.3\": 423, \"PB0.5\": 116, \"PB1\": 17, \"PB2.5\": 1, \"PB5\": 0, \"PB10\": 0 }, \"TempUnit\": \"C\" },","title":"JSON Status Responses"},{"location":"JSON-Status-Responses/#json-changes","text":"temp note: for now (6.0.0a) the statetext overwrites the json power result (e.g. \"ON\" => \"AN\" or any other statetext the users enter)","title":"JSON Changes"},{"location":"JSON-Status-Responses/#basic-response","text":"{ \"Status\": { \"Module\": 1, \"FriendlyName\": \"XXX\", \"Topic\": \"sonoff\", \"ButtonTopic\": \"0\", \"Power\": 0, \"PowerOnState\": 0, \"LedState\": 1, \"SaveData\": 0, \"SaveState\": 1, \"ButtonRetain\": 0, \"PowerRetain\": 0 }, \"StatusPRM\": { \"Baudrate\": 115200, \"GroupTopic\": \"sonoffs\", \"OtaUrl\": \"XXX\", \"Uptime\": \"1 02:33:26\", \"Sleep\": 150, \"BootCount\": 32, \"SaveCount\": 72, \"SaveAddress\": \"FB000\" }, \"StatusFWR\": { \"Version\": \"5.12.0a\", \"BuildDateTime\": \"2018.02.11 16:15:40\", \"Boot\": 31, \"Core\": \"2_4_0\", \"SDK\": \"2.1.0(deb1901)\" }, \"StatusLOG\": { \"SerialLog\": 0, \"WebLog\": 4, \"SysLog\": 0, \"LogHost\": \"domus1\", \"LogPort\": 514, \"SSId1\": \"XXX\", \"SSId2\": \"XXX\", \"TelePeriod\": 300, \"SetOption\": \"00000001\" }, \"StatusMEM\": { \"ProgramSize\": 457, \"Free\": 544, \"Heap\": 23, \"ProgramFlashSize\": 1024, \"FlashSize\": 1024, \"FlashMode\": 3 }, \"StatusNET\": { \"Hostname\": \"XXX\", \"IPAddress\": \"192.168.178.XX\", \"Gateway\": \"192.168.178.XX\", \"Subnetmask\": \"255.255.255.XX\", \"DNSServer\": \"192.168.178.XX\", \"Mac\": \"2C:3A:E8:XX:XX:XX\", \"Webserver\": 2, \"WifiConfig\": 4 }, \"StatusTIM\": { \"UTC\": \"Thu Feb 15 00:00:50 2018\", \"Local\": \"Thu Feb 15 01:00:50 2018\", \"StartDST\": \"Sun Mar 25 02:00:00 2018\", \"EndDST\": \"Sun Oct 28 03:00:00 2018\", \"Timezone\": 1 }, \"StatusSNS\": { \"Time\": \"2018.02.15 01:00:50\", \"Switch1\": \"OFF\" }, \"StatusSTS\": { \"Time\": \"2018.02.15 01:00:50\", \"Uptime\": \"1 02:33:26\", \"Vcc\": 3.504, \"POWER\": \"OFF\", \"Wifi\": { \"AP\": 1, \"SSId\": \"XXX\", \"RSSI\": 100, \"APMac\": \"34:31:C4:XX:XX:XX\" } } }","title":"Basic Response"},{"location":"JSON-Status-Responses/#mqtt","text":"After StatusNET \"StatusMQT\": { \"MqttHost\": \"192.168.XXX.XX\", \"MqttPort\": 1883, \"MqttClientMask\": \"DVES_%06X\", \"MqttClient\": \"DVES_4AXXXX\", \"MqttUser\": \"admin\", \"MAX_PACKET_SIZE\": 1000, \"KEEPALIVE\": 15 },","title":"MQTT"},{"location":"JSON-Status-Responses/#domoticz","text":"idx, nvalue, svalue without array ...\"StatusTIM\": { \"UTC\": \"Thu Feb 01 20:29:40 2018\", \"Local\": \"Thu Feb 01 21:29:40 2018\", \"StartDST\": \"Sun Mar 25 02:00:00 2018\", \"EndDST\": \"Sun Oct 28 03:00:00 2018\", \"Timezone\": 1 }, \"idx\": 286, \"nvalue\": 0, \"svalue\": \"19.7\", \"StatusSNS\": { \"Time\": \"2018.02.01 21:29:40\", \"DS18B20\": { \"Temperature\": 19.7 }, \"TempUnit\": \"C\" }, \"StatusSTS\": { ...","title":"Domoticz"},{"location":"JSON-Status-Responses/#pow","text":"After StatusTIM \"StatusPTH\": { \"PowerLow\": 0, \"PowerHigh\": 0, \"VoltageLow\": 0, \"VoltageHigh\": 0, \"CurrentLow\": 0, \"CurrentHigh\": 0 }, \"StatusSNS\": { \"Time\": \"2018.02.04 23:17:01\", \"ENERGY\": { \"Total\": 3.185, \"Yesterday\": 3.058, \"Today\": 0.127, \"Power\": 0, \"Factor\": 0.00, \"Voltage\": 221, \"Current\": 0.000 } },","title":"POW"},{"location":"JSON-Status-Responses/#sensors","text":"","title":"Sensors"},{"location":"JSON-Status-Responses/#am2301","text":"\"StatusSNS\": { \"Time\": \"2018.02.01 22:52:09\", \"AM2301\": { \"Temperature\": 15.5, \"Humidity\": 50.6 }, \"TempUnit\": \"C\" },","title":"AM2301"},{"location":"JSON-Status-Responses/#bmp280","text":"{ \"StatusSNS\": { \"Time\": \"2018-02-10T22:46:34\", \"BMP280\": { \"Temperature\": 80.9, \"Pressure\": 984.4 } } }","title":"BMP280"},{"location":"JSON-Status-Responses/#dht11","text":"\"StatusSNS\": { \"Time\": \"2018.02.01 22:48:39\", \"DHT11\": { \"Temperature\": 12.0, \"Humidity\": 42.0 }, \"TempUnit\": \"C\" },","title":"DHT11"},{"location":"JSON-Status-Responses/#ds18b20","text":"\"StatusSNS\": { \"Time\": \"2018.02.01 21:29:40\", \"DS18B20\": { \"Temperature\": 19.7 }, \"TempUnit\": \"C\" },","title":"DS18B20"},{"location":"JSON-Status-Responses/#sht3x-and-dht11-multiple-sensor-example","text":"{ \"StatusSNS\": { \"Time\": \"2018-02-07T20:16:19\", \"DHT11\": { \"Temperature\": 78.8, \"Humidity\": 27.0 }, \"SHT3X\": { \"Temperature\": 74.8, \"Humidity\": 18.9 }, \"TempUnit\": \"F\" } }","title":"SHT3X (and DHT11, multiple Sensor example)"},{"location":"JSON-Status-Responses/#sonoff-sc","text":"\"StatusSNS\": { \"Time\": \"2018-02-16T16:18:49\", \"Temperature\": 25, \"Humidity\": 83, \"Light\": 10, \"Noise\": 20, \"AirQuality\": 100, \"TempUnit\": \"C\" },","title":"Sonoff SC"},{"location":"JSON-Status-Responses/#pms5003-and-htu21","text":"\"StatusSNS\": { \"Time\": \"2018-02-16T16:22:12\", \"HTU21\": { \"Temperature\": 24.7, \"Humidity\": 32.1 }, \"PMS5003\": { \"CF1\": 1, \"CF2.5\": 2, \"CF10\": 2, \"PM1\": 1, \"PM2.5\": 2, \"PM10\": 2, \"PB0.3\": 423, \"PB0.5\": 116, \"PB1\": 17, \"PB2.5\": 1, \"PB5\": 0, \"PB10\": 0 }, \"TempUnit\": \"C\" },","title":"PMS5003 and HTU21"},{"location":"KNX/","text":"This feature is included only in tasmota-knx build To use in other builds you must compile your own build . Add the following to user_config_override.h : #ifndef USE_KNX #define USE_KNX // Enable KNX IP Protocol Support (+9.4k code, +3k7 mem) #endif What is KNX? ~ The KNX IP Protocol is an international open standard for smart homes and smart buildings automation. It is a decentralized system. Each device can talk directly to each other without the need of a central controller or server. Any panel or server is just for telesupervision and for sending requests. KNX IP Protocol uses a UDP multicast on 224.0.23.12 : 3671 , so there is no need for a KNX Router unless you want to communicate to KNX Devices that are not in the WIFI Network (Twisted Pair, RF, Powerline). Each device has a physical address (like a fixed IP) as 1 . 1 . 0 and that address is used for configuration purposes. Each device can be configured with group addresses as 2 / 2 / 1 and that address can be used for sending/receiving commands. So, for example, if 2 devices that are configured with the 2 / 2 / 1 for turning on/off their outputs, and other device send Turn ON command to 2 / 2 / 1 , both devices will turn on their outputs. Integration ~ Several home automation systems have KNX support. For example, Home Assistant has a XKNX Python Library to connect to KNX devices using a KNX Router. If you don't have a KNX Router , you can use a Software KNX Router like KNXd on the same Raspberry Pi than Home Assistant. KNXd is used by Home Assistant for reading this UDP Multicast, although KNXd has other cool features that need extra hardware like connect to KNX devices by Twister Pair, Power Line or RF. If using the Home Assistant distribution called Hassio , everything for KNX is already included by default. If you use the ETS (KNX Configurator Software) you can add any TasmotaTasmota KNX as a dummy device. If the Tasmotadevice is connecting to a Wifi Repeater you might experience some issues receiving KNX Telegrams. This also applies to mDNS and Emulation features. Implemented Features ~ The implemented features, up to now, in KNX for Tasmota are: General: buttons (just push) relays (on/off/toggle) lights (led strips, etc. but just on/off) Sensor lists that you can use in KNX is (only one sensor per type): Temperature Humidity Energy (v, i, power) For using rules: send KNX command (on/off) receive KNX command (on/off) send values by KNX (any float type, temperature for example) receive a KNX read request send and receive SCENE commands Usage Examples ~ There are multiple possible configurations. Here are explained just a few as example. The options for selecting relays, buttons, sensors, etc. are only available if were configured on Configure Module Menu . To configure KNX, enter on the Configuration Menu of Tasmota and select Configure KNX. Note on KNX communication enhancement option: As Wifi Multicast communication is not reliable in some wifi router due to IGMP problems or Snooping, an enhancement was implemented. This option increase the reliability by reducing the chances of losing telegrams, sending the same telegram 3 times. In practice it works really good and it is enough for normal home use. When this option is on, Tasmota will ignore toggle commands by KNX if those are sent more than 1 toggle per second. Just 1 toggle per second is working fine. 1) Setting Several Tasmota to be controlled as one by a Home Automation System: ~ We can set one of the group address to be the same in all the devices so as to turn them on or off at the same time. In this case, so as to inform the status of all the relays to the Automation System, just one of the devices have to be configured as the responder. If you use the same Group Address for sending and receiving, you have to take into account not to make loops. DEVICE 1 DEVICE 2 2) Setting 2 Tasmota to be linked as stair lights: ~ We can set one device to send the status of its output and another to read that and follow. And the second device can send the status of its button and the first device will toggle. With this configuration we can avoid to make a loop. DEVICE 1 DEVICE 2 3) Setting a button as initiator of a scene: ~ Just setting one device to send the push of a button, and the rest just use that value to turn them on. In this case, there is no toggle. Every time the button is pushed, the turn on command is sent. DEVICE 1 DEVICE 2 4) Setting a Temperature sensor: ~ We can configure to send the value of temperature or humidity every teleperiod. This teleperiod can be configured. See TasmotaTasmota docs . It is recommended also to set the reply temperature address. 5) Using rules: ~ More functionality can be added to Tasmota using rules. In the KNX Menu, can be set a Group Address to send data or commands by rules, as KNX TX1 to KNX TX5 In rules we can use the command KnxTx_Cmnd1 1 to send an ON state command to the group address set in KNX TX1 slot of the KNX menu. Also, we can use the command KnxTx_Val1 15 to send a 15 value to the group address set in KNX TX1 slot of the KNX menu. In the KNX Menu can be set a Group Address to receive commands by rules as KNX RX1 to KNX RX5 In rules we can use the events to catch the reception of COMMANDS from KNX to those RX Slots. Example: rule on event#knxrx_cmnd1 do var1 %value% endon to store the command received in the variable VAR1 In rules we can use the events to catch the reception of VALUES from KNX to those RX Slots. Example: rule on event#knxrx_val1 do var1 %value% endon to store the value received in the variable VAR1 Also, if a Read request is received from KNX Network, we can use that in a rule as for example: rule on event#knxrx_req1 do knxtx_val1 %var3% endon NOTE: KnxTX_valn command, KNXRX_Reqn trigger and sensors' telegrams, uses KNX DPT14 (32 bits float) since 9.1.0.2 . Old versions use DPT9 (16 bits float). Old and new versions can not send values between each other. Only commands. It is recommended to have all devices on the same version. 6) Rule to send KNX Telegram with BH1750 Sensor Data: ~ If you want to send your sensor values by KNX every teleperiod time to the Group Address defined in KNX_TX1, you can use the following rule: rule1 1 rule1 on tele-BH1750#Illuminance do knxtx_val1 %value% endon If you want to send your sensor values by KNX only when it changes in a delta of 10 lx to the Group Address defined in KNX_TX1, you can use the following rule: rule1 1 rule1 on system #boot do backlog var1 0; var2 0 endon on BH1750#Illuminance>%var1% do backlog var1 %value%; knxtx_val1 %value%; var2 %value%; add1 5; sub2 5 endon on BH1750#Illuminance<%var2% do backlog var2 %value%; knxtx_val1 %value%; var1 %value%; add1 5; sub2 5 endon","title":"KNX"},{"location":"KNX/#what-is-knx","text":"The KNX IP Protocol is an international open standard for smart homes and smart buildings automation. It is a decentralized system. Each device can talk directly to each other without the need of a central controller or server. Any panel or server is just for telesupervision and for sending requests. KNX IP Protocol uses a UDP multicast on 224.0.23.12 : 3671 , so there is no need for a KNX Router unless you want to communicate to KNX Devices that are not in the WIFI Network (Twisted Pair, RF, Powerline). Each device has a physical address (like a fixed IP) as 1 . 1 . 0 and that address is used for configuration purposes. Each device can be configured with group addresses as 2 / 2 / 1 and that address can be used for sending/receiving commands. So, for example, if 2 devices that are configured with the 2 / 2 / 1 for turning on/off their outputs, and other device send Turn ON command to 2 / 2 / 1 , both devices will turn on their outputs.","title":"What is KNX?"},{"location":"KNX/#integration","text":"Several home automation systems have KNX support. For example, Home Assistant has a XKNX Python Library to connect to KNX devices using a KNX Router. If you don't have a KNX Router , you can use a Software KNX Router like KNXd on the same Raspberry Pi than Home Assistant. KNXd is used by Home Assistant for reading this UDP Multicast, although KNXd has other cool features that need extra hardware like connect to KNX devices by Twister Pair, Power Line or RF. If using the Home Assistant distribution called Hassio , everything for KNX is already included by default. If you use the ETS (KNX Configurator Software) you can add any TasmotaTasmota KNX as a dummy device. If the Tasmotadevice is connecting to a Wifi Repeater you might experience some issues receiving KNX Telegrams. This also applies to mDNS and Emulation features.","title":"Integration"},{"location":"KNX/#implemented-features","text":"The implemented features, up to now, in KNX for Tasmota are: General: buttons (just push) relays (on/off/toggle) lights (led strips, etc. but just on/off) Sensor lists that you can use in KNX is (only one sensor per type): Temperature Humidity Energy (v, i, power) For using rules: send KNX command (on/off) receive KNX command (on/off) send values by KNX (any float type, temperature for example) receive a KNX read request send and receive SCENE commands","title":"Implemented Features"},{"location":"KNX/#usage-examples","text":"There are multiple possible configurations. Here are explained just a few as example. The options for selecting relays, buttons, sensors, etc. are only available if were configured on Configure Module Menu . To configure KNX, enter on the Configuration Menu of Tasmota and select Configure KNX. Note on KNX communication enhancement option: As Wifi Multicast communication is not reliable in some wifi router due to IGMP problems or Snooping, an enhancement was implemented. This option increase the reliability by reducing the chances of losing telegrams, sending the same telegram 3 times. In practice it works really good and it is enough for normal home use. When this option is on, Tasmota will ignore toggle commands by KNX if those are sent more than 1 toggle per second. Just 1 toggle per second is working fine.","title":"Usage Examples"},{"location":"KNX/#1-setting-several-tasmota-to-be-controlled-as-one-by-a-home-automation-system","text":"We can set one of the group address to be the same in all the devices so as to turn them on or off at the same time. In this case, so as to inform the status of all the relays to the Automation System, just one of the devices have to be configured as the responder. If you use the same Group Address for sending and receiving, you have to take into account not to make loops. DEVICE 1 DEVICE 2","title":"1) Setting Several Tasmota to be controlled as one by a Home Automation System:"},{"location":"KNX/#2-setting-2-tasmota-to-be-linked-as-stair-lights","text":"We can set one device to send the status of its output and another to read that and follow. And the second device can send the status of its button and the first device will toggle. With this configuration we can avoid to make a loop. DEVICE 1 DEVICE 2","title":"2) Setting 2 Tasmota to be linked as stair lights:"},{"location":"KNX/#3-setting-a-button-as-initiator-of-a-scene","text":"Just setting one device to send the push of a button, and the rest just use that value to turn them on. In this case, there is no toggle. Every time the button is pushed, the turn on command is sent. DEVICE 1 DEVICE 2","title":"3) Setting a button as initiator of a scene:"},{"location":"KNX/#4-setting-a-temperature-sensor","text":"We can configure to send the value of temperature or humidity every teleperiod. This teleperiod can be configured. See TasmotaTasmota docs . It is recommended also to set the reply temperature address.","title":"4) Setting a Temperature sensor:"},{"location":"KNX/#5-using-rules","text":"More functionality can be added to Tasmota using rules. In the KNX Menu, can be set a Group Address to send data or commands by rules, as KNX TX1 to KNX TX5 In rules we can use the command KnxTx_Cmnd1 1 to send an ON state command to the group address set in KNX TX1 slot of the KNX menu. Also, we can use the command KnxTx_Val1 15 to send a 15 value to the group address set in KNX TX1 slot of the KNX menu. In the KNX Menu can be set a Group Address to receive commands by rules as KNX RX1 to KNX RX5 In rules we can use the events to catch the reception of COMMANDS from KNX to those RX Slots. Example: rule on event#knxrx_cmnd1 do var1 %value% endon to store the command received in the variable VAR1 In rules we can use the events to catch the reception of VALUES from KNX to those RX Slots. Example: rule on event#knxrx_val1 do var1 %value% endon to store the value received in the variable VAR1 Also, if a Read request is received from KNX Network, we can use that in a rule as for example: rule on event#knxrx_req1 do knxtx_val1 %var3% endon NOTE: KnxTX_valn command, KNXRX_Reqn trigger and sensors' telegrams, uses KNX DPT14 (32 bits float) since 9.1.0.2 . Old versions use DPT9 (16 bits float). Old and new versions can not send values between each other. Only commands. It is recommended to have all devices on the same version.","title":"5) Using rules:"},{"location":"KNX/#6-rule-to-send-knx-telegram-with-bh1750-sensor-data","text":"If you want to send your sensor values by KNX every teleperiod time to the Group Address defined in KNX_TX1, you can use the following rule: rule1 1 rule1 on tele-BH1750#Illuminance do knxtx_val1 %value% endon If you want to send your sensor values by KNX only when it changes in a delta of 10 lx to the Group Address defined in KNX_TX1, you can use the following rule: rule1 1 rule1 on system #boot do backlog var1 0; var2 0 endon on BH1750#Illuminance>%var1% do backlog var1 %value%; knxtx_val1 %value%; var2 %value%; add1 5; sub2 5 endon on BH1750#Illuminance<%var2% do backlog var2 %value%; knxtx_val1 %value%; var1 %value%; add1 5; sub2 5 endon","title":"6) Rule to send KNX Telegram with BH1750 Sensor Data:"},{"location":"LM75AD/","text":"This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_LM75AD #define USE_LM75AD // [ I2cDriver20 ] Enable LM75AD sensor ( I2C addresses 0x48 - 0x4F ) ( + 0 k5 code ) #endif The LM75AD is an I 2 C temperature sensor that converts temperature directly to digital signals from -55\u00b0C to +125\u00b0C and achieves an accuracy of 0.125\u00b0C Some features of the LM75A chip not implemented in this driver: - Programmable temperature threshold and hysteresis set points - Stand-alone operation as thermostat at power-up LM75A Datasheet Configuration ~ Wiring ~ LM75AD ESP8266 VCC 3.3V GND GND SDA GPIOx SCL GPIOy OS not used The driver currently only allows the use of a single LM75AD sensor on any of the addresses configurable through pins A0, A1 and A2. These are conveniently broken out on the breakout board either as pins or as solderable joints as can be seen on the example breakout board. These pins need to be tied down to either GND or VCC (3.3V) and the resulting I 2 C address will be set during power-up according to the table: Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) After a reboot the driver will detect LM75AD automatically and display Temperature. Commands ~ TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device. Breakout Boards ~ Can also be used standalone if soldered to a board given the diagram is used R1 and R2 are pull-up resistors which are required by the I 2 C bus to operate properly. If you have other I 2 C sensors with pull-up resistors connected to the same I 2 C bus it's probably not necessary to have them.","title":"LM75AD temperature sensor"},{"location":"LM75AD/#configuration","text":"","title":"Configuration"},{"location":"LM75AD/#wiring","text":"LM75AD ESP8266 VCC 3.3V GND GND SDA GPIOx SCL GPIOy OS not used The driver currently only allows the use of a single LM75AD sensor on any of the addresses configurable through pins A0, A1 and A2. These are conveniently broken out on the breakout board either as pins or as solderable joints as can be seen on the example breakout board. These pins need to be tied down to either GND or VCC (3.3V) and the resulting I 2 C address will be set during power-up according to the table:","title":"Wiring"},{"location":"LM75AD/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) After a reboot the driver will detect LM75AD automatically and display Temperature.","title":"Tasmota Settings"},{"location":"LM75AD/#commands","text":"TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device.","title":"Commands"},{"location":"LM75AD/#breakout-boards","text":"Can also be used standalone if soldered to a board given the diagram is used R1 and R2 are pull-up resistors which are required by the I 2 C bus to operate properly. If you have other I 2 C sensors with pull-up resistors connected to the same I 2 C bus it's probably not necessary to have them.","title":"Breakout Boards"},{"location":"LMT01/","text":"LMT01 temperature sensor ~ This feature is included only in tasmota-sensors.bin Otherwise you must compile your build and define USE_LMT01 . The Texas Instruments LMT01 is 2-pin digital output temperature sensor that converts temperature directly to a sequence of digital pulses, reading a range from -50\u00b0C to +150\u00b0C with up to 0.5\u00b0C accuracy. It is available in a DIY-friendly small TO-92 package. Connection is by a single GPIO to count the pulses, which needs a driver transistor to convert the small current changes into logic level voltage swings. LMT01 data sheet LMT01 product page with links to evaluation board and training video and sample code . Limitations of current implementation : Only the simple linear conversion is used. The datasheet suggests the use of a look-up table to improve the accuracy at the edges of the range, this is not yet implemented. The sensor code only supports one LMT01 instance. Configuration ~ Choose a pin GPIOx. The GPIO can be connected to the LMT01 via a NPN transistor, so current pulses pull the GPIO line low: see Figure 32 in the LMT01 datasheet. In the Configuration -> Configure Module page assign: GPIOx to LMT01 Pulse After a reboot the sensor will be detected and displayed. If the connection is not working, the pulse counting will timeout and you will see null displayed for the temperature.","title":"LMT01 temperature sensor"},{"location":"LMT01/#lmt01-temperature-sensor","text":"This feature is included only in tasmota-sensors.bin Otherwise you must compile your build and define USE_LMT01 . The Texas Instruments LMT01 is 2-pin digital output temperature sensor that converts temperature directly to a sequence of digital pulses, reading a range from -50\u00b0C to +150\u00b0C with up to 0.5\u00b0C accuracy. It is available in a DIY-friendly small TO-92 package. Connection is by a single GPIO to count the pulses, which needs a driver transistor to convert the small current changes into logic level voltage swings. LMT01 data sheet LMT01 product page with links to evaluation board and training video and sample code . Limitations of current implementation : Only the simple linear conversion is used. The datasheet suggests the use of a look-up table to improve the accuracy at the edges of the range, this is not yet implemented. The sensor code only supports one LMT01 instance.","title":"LMT01 temperature sensor"},{"location":"LMT01/#configuration","text":"Choose a pin GPIOx. The GPIO can be connected to the LMT01 via a NPN transistor, so current pulses pull the GPIO line low: see Figure 32 in the LMT01 datasheet. In the Configuration -> Configure Module page assign: GPIOx to LMT01 Pulse After a reboot the sensor will be detected and displayed. If the connection is not working, the pulse counting will timeout and you will see null displayed for the temperature.","title":"Configuration"},{"location":"LedMask/","text":"LedMask command allows setting a bitmask which specifies which relays control the LED indicator used to display whether a relay is latched/powered. The order of the <bitmask> is from most significant bit (MSB) to least significant bit (LSB). Bit 15 (MSB) masks Relay16 through bit 0 (LSB) which masks Relay1, respectively. For each relay to be included in controlling the power LED, set its corresponding bit in the <bitmask> to 1 . <bitmask> bits without corresponding configured relay components have no effect and can be ignored. <bitmask> = bitwise value representing each relay. Values may be entered as either hexadecimal or decimal values (e.g., 0xFFFF = 65535). 0xFFFF (= 1111 1111 1111 1111) All relays control the power LED (default) LedState must be enabled (i.e., != 0 ) in order for LedMask to take effect. Examples: `LedMask 0xFFFD` Every relay, except Relay2, controls the power LED (0xFFFD = 1111 1111 1111 1101) `LedMask 0x0002` Only Relay 2 controls the power LED (0x0002 = 0000 0000 0000 0010)","title":"LedMask"},{"location":"Lights/","text":"You know what lights do.... Right? \ud83d\udca1 Control Lights ~ with WebUI ~ Tasmota webUI displays Brightness , CT , White , Color Picker , Color Saturation or PWM Level sliders depending on the light component, the number of PWM channels configured and SetOptions used. Tasmota uses a HSB color model, which besides other more subtile differences compared to HSL means, that the color must be desaturated to reach complete black or white. Control Range Commands and details Brightness 0..100 (percent) Dimmer , HSBColor3 : Brightness of the light Hue 0..359 (degrees) HSBColor1 : Color as an angle in the color wheel Sat 0..100 (percent) HSBColor2 : saturation of the color, 0=grey/white, 100=pure color CT 153..500 (mireds) CT : white color temperature, from 153 (Cold White) to 500(Warm White) with Commands ~ See light commands for how to control lights. Light Types ~ Switched Lights aka Relays ~ Switched or On/Off lights are controlled through Relay GPIOs. If you define multiple relays, they are controlled with Power<x> starting at x=1 . Alexa : you can use Wemo emulation, your device will appear as a switch. You can change it to a light in the Alexa app. Alexa : if you have one or multiple relays, you can use Philips Hue emulation. All devices will appear as On/Off lights, and named accordingly to FriendlyName . Note: if you have only Echo Spot 2nd generation, your light will have a dummy dimmer. Configuration (see below) Commands Power Configuration none 1 Channel - Dimmable Light ~ 1 channel lights are often white lights with On/Off controls and Dimmer. Alexa : you can use Philips Hue emulation, the light will appear as White light with Dimmer. Leading edge dimmer You can also configure a leading edge dimmer on 230V with the 1 Channel configuration. In this case you need a TRIAC and a zero-Cross detection that give a pulse with every crossing of the 0V of the sinus curve. For example: Define a COUNTER with the same number as the PWM (e.g. COUNTER1, PWM1). Set SETOPTION99 1 to enable detection of the raising edge of the zero-crossing. Connect zero-Crossing to COUNTER and PWM to PWM. Set PWMFREQUENCY 100 or 120 depending on the frequency of the main in your country. Additionally it is recommended to set LEDTABLE 0 for normal lamps or motors. Configuration (see below) Commands Power , Dimmer Options Auto Power On , PWM Channel Configuration , Gamma Correction 2 Channels - CCT Light ~ 2 channels lights are white lights with correlated color temperature (CCT) controls from Cold White (CT=153) to Warm White (CT=500). Alexa : you can use Philips Hue emulation, the light will appear as White light with Color Temperature. Control through the Alexa app is limited to the CT range 199..383 . Configuration (see below) Commands Power , Dimmer , Color , White , CT Options Auto Power On , PWM Channel Configuration , Gamma Correction , PWM CT 3 Channels - RGB Lights ~ 3 channel lights are RGB color lights. You can set color either via RGB or HSB ( not HSL ). Alexa support also allows XY color, but that is not supported through commands. Alexa : you can use Philips Hue emulation, the light will appear as Color light. Configuration (see below) Commands Power , Dimmer , Color , HSBColor Options Auto Power On , PWM Channel Configuration , Gamma Correction , Channel Remapping 4 Channels - RGBW Lights ~ 4 channel lights are RGBW, i.e. RGB light and an additional White light. White can be either Warm White or Cold White depending on the manufacturer. Alexa : you can use Philips Hue emulation, the light will appear as Color light and White light with CT control. The CT control is only present to force pure white instead of RGB white. Changin CT will have no effect. There is no White only slider in the UI for 4 channel lights Use White commands or set up White Blend Mode or RGB and White Split . Configuration (see below) Commands Power , Dimmer , Color , HSBColor , White Options Auto Power On , PWM Channel Configuration , Gamma Correction , Channel Remapping , White Blend Mode , RGB and White Split Danger Some lights have limited power supply that do not allow all channels to be at full power at the same time. Be careful not to burn out your light if you force all channels to be on using Color or RGB and White Split . 5 Channels - RGBCCT Lights ~ 5 channel lights are RGBCCT - a 3 channel RGB light and an additional 2 channel CCT light. Alexa : you can use Philips Hue emulation, the light will appear as Color light and White light with CT control. Configuration (see below) Commands Power , Dimmer , Color , HSBColor , White , CT Options Auto Power On , PWM Channel Configuration , Gamma Correction , Channel Remapping , White Blend Mode , RGB and White Split Danger Some lights have limited power supply that do not allow all channels to be at full power at the same time. Be careful not to burn out your light if you force all channels via Color or RGB and White Split Independent PWM Channels ~ Any combination of Relays and PWMs, when enabling SetOption68 1 . Splits off the light into individually controlled Channels (Useful when connecting multiple 1 channel strips to a single controller) Configuration (see below) Commands Power , Channel , Color Options Auto Power On , PWM Channel Configuration , Gamma Correction Light Options ~ Gamma Correction ~ Gamma Correction is enabled by default in Tasmota ( LedTable 1 ). Human eye perception of brightness is non linear, bringing back linearity needs a trick called Gamma Correction . Some lights have hardware gamma correction (f.e. Sonoff B1)., in which case software gamma correction should be disabled with LedTable 0 . The curve used: orange=ideal, blue=tasmota. How do I know if I have hardware gamma correction? If you find your light very dark even with Dimmer 40 , it can mean either you have hardware PWM, disable it with LedTable 0 , or you need to apply a minimum PWM value, use DimmerRange 40,100 (adapt to the best value). Internally Tasmota uses 10 bits resolution PWM to get smoother levels at low brightness. White Blend Mode ~ White Blend Mode mixes in the white channel with RGB colors while controlling the RGB light which results in a better and brighter color output. It is used only with 4 channel (RGBW) and 5 channel (RGBCCT) lights. Enable it with SetOption105 1 . For Tasmota versions before 8.5 use command RGBWWTable 255,255,255,0 instead. Calibration (optional) Generally white LEDs are brighter than RGB LEDs. If you want to keep the same brightness, you need to calibrate the white level. In this mode, any white component will be removed from RGB LEDs and sent to the white LEDs. This makes whites look much better. Example Color 30508000 will be converted to Color 0020503000 (0x30 is subtracted from RGB channels and added to the White channel) To calibrate a RGBW light: Color FFFFFF00 RGBWWTable 255,255,255,255,255 - reset to RGB mode RGBWWTable 255,255,255,<n>,0 - (begin the calibration process with <n> == 150) If too bright, decrease <n> . If too dim, increase <n> Go back to step 2 and iterate until satisfied with the color intensities. Calibration examples for specific devices: Sonoff B1: RGBWWTable 255,255,255,35,0 Teckin SB50: RGBWWTable 255,255,255,80,0 RGB and White Split ~ SetOption37 128 By default RGBW and RGBCCT lights can only be controlled in single mode, either RGB or White (f.e. Turning on CT lights turns off RGB lights and vice versa). Use SetOption37 128 to split RGB and White into 2 independent lights. If you are already using Channel Remapping, just add 128 to the value of SetOption37 . Channel Remapping ~ SetOption37 Read More Disable Auto Power On ~ Lights are always powered on when a light command or a webUI slider is used and automatically powered off when color is set to black or Dimmer is set to 0 . When enabling SetOption20 1 any change to webUI sliders or using commands CT , Dimmer , HSBColor3 , Color or Channel will not automatically power on the light if it is off. PWM CT ~ Module 48 or SetOption92 1 Some CCT lights use PWM1 for brightness and PWM2 for color temperature (instead of PWM1 for Cold White and PWM2 for Warm White). For these lights, use Module 48 aka Philips Xiaomi mode, or SetOption92 1 (supported since v.8.2.0.5) Virtual CT ~ this feature is experimental and will probably not give brilliant results Used with 4 channel RGBW lights to simulate the missing white channel (cold or warm) using RGB channels. Enable Virtual CT with SetOption 106 1 then choose which type of white you're simulating with SetOption 107 where 0 is warm white and 1 is cold white Light Categories ~ Lights come in various shapes (bulb, strips, ceiling lights, ...) but in Tasmota they are separated in 3 categories: Channel Controlled LEDs Addressable LEDs Status LEDs Channel Controlled Lights ~ PWM Lights Lights controlled using up to 5 channels (red, green, blue, cold white, warm white). Channels are controlled using PWM or APDM. PWM (Pulse Width Modulation) is the most common method of controlling LED lights. These lights are configured by assigning PWM1(i) through PWM5(i) components to their GPIOs; PWM<x>i means PWM is inverted. Depending on the number of used PWMs Tasmota will recognize the light as Channels PWM1 PWM2 PWM3 PWM4 PWM5 1 Brightness 2 Cold White Warm White 3 Red Green Blue 4 Red Green Blue White 5 Red Green Blue Cold White Warm White MY92xx MY92xx family of drivers uses Adaptive Pulse Density Modulation. Configured in Tasmota by assigning MY92x1 DI and MY92x DCKI components to their GPIOs (some devices might have more than one MY92xx controller) Channel mapping for such devices is dependent on the controllers but is easily remapped using SetOption37 . SM16716 SM16716 LEDs, sometimes mislabelled as WS2801. Configured in Tasmota by assigning SM16716 CLK , SM16716 DAT and SM16716 PWR component to their GPIOs. Some SM16716 bulbs have BGR order and need SetOption37 54 to work properly. PWM Dimmer Switches ~ Specific module (requires a custom binary) for Martin Jerry/acenx/Tessan/NTONPOWER SD0x PWM dimmer switches. Brightness of the load for these dimmers is controlled by a PWM GPIO pin. They typically have power, up and down buttons, a power status LED, five brightness LEDs and another status LED. Read more... Addressable LEDs ~ Lights where each LED is individually controlled. In these lights it is possible to adjust each LEDs power, color and brightness, all just with the use of a single GPIO pin. WebUI shows hue, saturation and brightness sliders and power toggle for these lights. Red and green color may be mixed up (observed for clone of Wemos RGB shield using Tasmota 8.1.0). WS2812 Any light using WS2811, WS2812b, WS2813 or SK6812 LEDs falls into this component. They're also commonly called Neopixel lights. Configured in Tasmota by assigning WS2812 (7) component to its GPIO. For wiring, see instructions for LED strip or Wemos RGB shield . Status LEDs ~ Status LEDs are the LEDs on the device used to display device information Those LEDs are defined in a template or module using Led1 , Led2 , Led3 or Led4 (or Led1i , Led2i , Led3i or Led4i ) and additionally using LedLink or LedLinki ( LedLink was introduced in version 6.5.0.12). It is not recommended to assign Led<x> and Led<x>i with the same <x> number. Prior to version 6.5.0.12, Tasmota only supported up to two LED components to indicate the power state of the relay(s), and the Wi-Fi/MQTT connectivity status. It is possible to wire in your own LED and assign it as any of the above mentioned but that's outside the scope of this article If only one LED is configured, it serves both purposes; the link status LED and/or the LED that indicates the power state of the relay(s). If more than one LED component is defined, Led1 / Led1i will act as the Wi-Fi/MQTT status LED and the next defined LED (e.g., Led2 / Led2i ) will act as the LED that indicates the power state of the relay(s). This is the default behavior . Configuring a GPIO as an LEDLink / LEDLinki component changes this behavior. For example, on a Sonoff Basic the green LED is used as the link status LED. Once the device connects, the LED is used to indicate the relay's power status. Link status LED Link status LED shows the network state, more specifically the Wi-Fi and MQTT connection status. It blinks if the device is not connected to your Wi-Fi AP and MQTT broker (if MQTT is enabled). You can change this behaviour with LedState or turn it off with SetOption31 . Power status LED Power status LED shows the power status of relay component(s). LedMask determines which relay(s) are associated with the power status LED. This behavior can be modified with the LedState command. The LED is turned off by default when the relay is OFF and turned on when the relay switches ON. Note Depending on the device design, some LEDs are connected to the same GPIO as the relay. Those cannot be independently controlled since they have to follow the relay state. If you have more than one LED wired independently and you want it to show the power state of the relay, you must assign an LedLink GPIO. PWM LED Mode Using LedPwmMode you can change the LED display mode from simple on/off to a PWM controlled LED which will enable you to f.e. display a brighter LED when the relay is on and a dimmer LED when its OFF so you can locate the switch in the dark but not have it obnoxiously bright. LedPwmOff and LedPwmOn control the preset LED brightness in their respective states. LedPower Command When you use LedPower you take over control of that particular LED and it stops being linked to its corresponding relay and being its power status LED. Using LedLink LedLink / LedLinki is used to assign the link status LED. If your device does not have an LED for link status (or you want to use that LED for a different purpose), you can assign LedLink to an available free GPIO. When LedLink(i) is assigned, other LEDs are automatically linked to their corresponding relay and serve as that relay's power status LED - i.e., Led<x>(i) links to Relay<x>(i)","title":"Lights"},{"location":"Lights/#control-lights","text":"","title":"Control Lights"},{"location":"Lights/#with-webui","text":"Tasmota webUI displays Brightness , CT , White , Color Picker , Color Saturation or PWM Level sliders depending on the light component, the number of PWM channels configured and SetOptions used. Tasmota uses a HSB color model, which besides other more subtile differences compared to HSL means, that the color must be desaturated to reach complete black or white. Control Range Commands and details Brightness 0..100 (percent) Dimmer , HSBColor3 : Brightness of the light Hue 0..359 (degrees) HSBColor1 : Color as an angle in the color wheel Sat 0..100 (percent) HSBColor2 : saturation of the color, 0=grey/white, 100=pure color CT 153..500 (mireds) CT : white color temperature, from 153 (Cold White) to 500(Warm White)","title":"with WebUI"},{"location":"Lights/#with-commands","text":"See light commands for how to control lights.","title":"with Commands"},{"location":"Lights/#light-types","text":"","title":"Light Types"},{"location":"Lights/#switched-lights-aka-relays","text":"Switched or On/Off lights are controlled through Relay GPIOs. If you define multiple relays, they are controlled with Power<x> starting at x=1 . Alexa : you can use Wemo emulation, your device will appear as a switch. You can change it to a light in the Alexa app. Alexa : if you have one or multiple relays, you can use Philips Hue emulation. All devices will appear as On/Off lights, and named accordingly to FriendlyName . Note: if you have only Echo Spot 2nd generation, your light will have a dummy dimmer. Configuration (see below) Commands Power Configuration none","title":"Switched Lights aka Relays"},{"location":"Lights/#1-channel-dimmable-light","text":"1 channel lights are often white lights with On/Off controls and Dimmer. Alexa : you can use Philips Hue emulation, the light will appear as White light with Dimmer. Leading edge dimmer You can also configure a leading edge dimmer on 230V with the 1 Channel configuration. In this case you need a TRIAC and a zero-Cross detection that give a pulse with every crossing of the 0V of the sinus curve. For example: Define a COUNTER with the same number as the PWM (e.g. COUNTER1, PWM1). Set SETOPTION99 1 to enable detection of the raising edge of the zero-crossing. Connect zero-Crossing to COUNTER and PWM to PWM. Set PWMFREQUENCY 100 or 120 depending on the frequency of the main in your country. Additionally it is recommended to set LEDTABLE 0 for normal lamps or motors. Configuration (see below) Commands Power , Dimmer Options Auto Power On , PWM Channel Configuration , Gamma Correction","title":"1 Channel - Dimmable Light"},{"location":"Lights/#2-channels-cct-light","text":"2 channels lights are white lights with correlated color temperature (CCT) controls from Cold White (CT=153) to Warm White (CT=500). Alexa : you can use Philips Hue emulation, the light will appear as White light with Color Temperature. Control through the Alexa app is limited to the CT range 199..383 . Configuration (see below) Commands Power , Dimmer , Color , White , CT Options Auto Power On , PWM Channel Configuration , Gamma Correction , PWM CT","title":"2 Channels - CCT Light"},{"location":"Lights/#3-channels-rgb-lights","text":"3 channel lights are RGB color lights. You can set color either via RGB or HSB ( not HSL ). Alexa support also allows XY color, but that is not supported through commands. Alexa : you can use Philips Hue emulation, the light will appear as Color light. Configuration (see below) Commands Power , Dimmer , Color , HSBColor Options Auto Power On , PWM Channel Configuration , Gamma Correction , Channel Remapping","title":"3 Channels - RGB Lights"},{"location":"Lights/#4-channels-rgbw-lights","text":"4 channel lights are RGBW, i.e. RGB light and an additional White light. White can be either Warm White or Cold White depending on the manufacturer. Alexa : you can use Philips Hue emulation, the light will appear as Color light and White light with CT control. The CT control is only present to force pure white instead of RGB white. Changin CT will have no effect. There is no White only slider in the UI for 4 channel lights Use White commands or set up White Blend Mode or RGB and White Split . Configuration (see below) Commands Power , Dimmer , Color , HSBColor , White Options Auto Power On , PWM Channel Configuration , Gamma Correction , Channel Remapping , White Blend Mode , RGB and White Split Danger Some lights have limited power supply that do not allow all channels to be at full power at the same time. Be careful not to burn out your light if you force all channels to be on using Color or RGB and White Split .","title":"4 Channels - RGBW Lights"},{"location":"Lights/#5-channels-rgbcct-lights","text":"5 channel lights are RGBCCT - a 3 channel RGB light and an additional 2 channel CCT light. Alexa : you can use Philips Hue emulation, the light will appear as Color light and White light with CT control. Configuration (see below) Commands Power , Dimmer , Color , HSBColor , White , CT Options Auto Power On , PWM Channel Configuration , Gamma Correction , Channel Remapping , White Blend Mode , RGB and White Split Danger Some lights have limited power supply that do not allow all channels to be at full power at the same time. Be careful not to burn out your light if you force all channels via Color or RGB and White Split","title":"5 Channels - RGBCCT Lights"},{"location":"Lights/#independent-pwm-channels","text":"Any combination of Relays and PWMs, when enabling SetOption68 1 . Splits off the light into individually controlled Channels (Useful when connecting multiple 1 channel strips to a single controller) Configuration (see below) Commands Power , Channel , Color Options Auto Power On , PWM Channel Configuration , Gamma Correction","title":"Independent PWM Channels"},{"location":"Lights/#light-options","text":"","title":"Light Options"},{"location":"Lights/#gamma-correction","text":"Gamma Correction is enabled by default in Tasmota ( LedTable 1 ). Human eye perception of brightness is non linear, bringing back linearity needs a trick called Gamma Correction . Some lights have hardware gamma correction (f.e. Sonoff B1)., in which case software gamma correction should be disabled with LedTable 0 . The curve used: orange=ideal, blue=tasmota. How do I know if I have hardware gamma correction? If you find your light very dark even with Dimmer 40 , it can mean either you have hardware PWM, disable it with LedTable 0 , or you need to apply a minimum PWM value, use DimmerRange 40,100 (adapt to the best value). Internally Tasmota uses 10 bits resolution PWM to get smoother levels at low brightness.","title":"Gamma Correction"},{"location":"Lights/#white-blend-mode","text":"White Blend Mode mixes in the white channel with RGB colors while controlling the RGB light which results in a better and brighter color output. It is used only with 4 channel (RGBW) and 5 channel (RGBCCT) lights. Enable it with SetOption105 1 . For Tasmota versions before 8.5 use command RGBWWTable 255,255,255,0 instead.","title":"White Blend Mode"},{"location":"Lights/#rgb-and-white-split","text":"SetOption37 128 By default RGBW and RGBCCT lights can only be controlled in single mode, either RGB or White (f.e. Turning on CT lights turns off RGB lights and vice versa). Use SetOption37 128 to split RGB and White into 2 independent lights. If you are already using Channel Remapping, just add 128 to the value of SetOption37 .","title":"RGB and White Split"},{"location":"Lights/#channel-remapping","text":"SetOption37 Read More","title":"Channel Remapping"},{"location":"Lights/#disable-auto-power-on","text":"Lights are always powered on when a light command or a webUI slider is used and automatically powered off when color is set to black or Dimmer is set to 0 . When enabling SetOption20 1 any change to webUI sliders or using commands CT , Dimmer , HSBColor3 , Color or Channel will not automatically power on the light if it is off.","title":"Disable Auto Power On"},{"location":"Lights/#pwm-ct","text":"Module 48 or SetOption92 1 Some CCT lights use PWM1 for brightness and PWM2 for color temperature (instead of PWM1 for Cold White and PWM2 for Warm White). For these lights, use Module 48 aka Philips Xiaomi mode, or SetOption92 1 (supported since v.8.2.0.5)","title":"PWM CT"},{"location":"Lights/#virtual-ct","text":"this feature is experimental and will probably not give brilliant results Used with 4 channel RGBW lights to simulate the missing white channel (cold or warm) using RGB channels. Enable Virtual CT with SetOption 106 1 then choose which type of white you're simulating with SetOption 107 where 0 is warm white and 1 is cold white","title":"Virtual CT"},{"location":"Lights/#light-categories","text":"Lights come in various shapes (bulb, strips, ceiling lights, ...) but in Tasmota they are separated in 3 categories: Channel Controlled LEDs Addressable LEDs Status LEDs","title":"Light Categories"},{"location":"Lights/#channel-controlled-lights","text":"","title":"Channel Controlled Lights"},{"location":"Lights/#pwm-dimmer-switches","text":"Specific module (requires a custom binary) for Martin Jerry/acenx/Tessan/NTONPOWER SD0x PWM dimmer switches. Brightness of the load for these dimmers is controlled by a PWM GPIO pin. They typically have power, up and down buttons, a power status LED, five brightness LEDs and another status LED. Read more...","title":"PWM Dimmer Switches"},{"location":"Lights/#addressable-leds","text":"Lights where each LED is individually controlled. In these lights it is possible to adjust each LEDs power, color and brightness, all just with the use of a single GPIO pin. WebUI shows hue, saturation and brightness sliders and power toggle for these lights. Red and green color may be mixed up (observed for clone of Wemos RGB shield using Tasmota 8.1.0).","title":"Addressable LEDs"},{"location":"Lights/#status-leds","text":"Status LEDs are the LEDs on the device used to display device information Those LEDs are defined in a template or module using Led1 , Led2 , Led3 or Led4 (or Led1i , Led2i , Led3i or Led4i ) and additionally using LedLink or LedLinki ( LedLink was introduced in version 6.5.0.12). It is not recommended to assign Led<x> and Led<x>i with the same <x> number. Prior to version 6.5.0.12, Tasmota only supported up to two LED components to indicate the power state of the relay(s), and the Wi-Fi/MQTT connectivity status. It is possible to wire in your own LED and assign it as any of the above mentioned but that's outside the scope of this article If only one LED is configured, it serves both purposes; the link status LED and/or the LED that indicates the power state of the relay(s). If more than one LED component is defined, Led1 / Led1i will act as the Wi-Fi/MQTT status LED and the next defined LED (e.g., Led2 / Led2i ) will act as the LED that indicates the power state of the relay(s). This is the default behavior . Configuring a GPIO as an LEDLink / LEDLinki component changes this behavior. For example, on a Sonoff Basic the green LED is used as the link status LED. Once the device connects, the LED is used to indicate the relay's power status.","title":"Status LEDs"},{"location":"MCP230xx/","text":"MCP23008 / MCP23017 GPIO Expander ~ Technical Data from the manufacturer: * Microchip MCP23008 * Microchip MCP23017 Generally available breakout boards for the MCP23017 look similar to this: The MCP23008 has 8 IO pins which the MCP230xx driver uses as D0 - D7. The MCP23017 has 16 IO pins which the MCP230xx driver uses as D0 - D15. This is visualized in the circuit diagram below but it's important to note that the MCP23017 actually differentiates between PORTA (being A0 to A7) and PORTB (being B0 to B7) - The MCP230xx driver combines the two ports in sequence to translate to pins represented as D0 through D15 for the MCP23017. The chip can be connected quite easily, especially if you can source the DIP version of the chip. Here's a basic outline of what a typical circuit would require to be functional: You will need to pick an I2C address in either of the above scenario's using the address mapping according to pin A0, A1, and A2 as from the datasheet as follows: You will need to define the address you are using in user_config_override.h for the driver to know on which address the MCP23008/MCP23017 is expected to be found. #define USE_MCP230xx_ADDR 0x20 The MCP23008/MCP23017 chips allow for both INPUT and OUTPUT - Most of the functionality of the driver is focused on INPUT mode - especially since they allow interrupt reporting and are 5V tolerant. OUTPUT functionality is however available as pinmode 5 (Documented later in this Wiki) as an additional option for those who want to use the OUTPUT functionality using the Sensor29 command which consumes ~1Kbyte of flash. The driver is disabled by default in the Tasmota firmware so the only way to gain its use would be to perform a manual compilation of your own firmware. There are three different levels in which functionality may be enabled, in the following order, by adding these lines in user_config_override.h : #define USE_MCP230xx // Enable INPUT mode (pinmode 1 through 4) #define USE_MCP230xx_OUTPUT // Enable OUTPUT mode (pinmode 5) #define USE_MCP230xx_DISPLAYOUTPUT // Display state of OUTPUT pins on main Tasmota web interface The ESP8266 will automatically detect whether you have connected an MCP23008 (8 input) or MCP23017 (16 input) and will provide telemetry data in accordance with how the device was configured from within the Tasmota firmware. If OUTPUT is enabled, telemetry data for the current state of OUTPUT pins will also be provided by telemetry. MCP23008 / MCP23017 Pin numbers in Tasmota compared to datasheets ~ The table below outlines how the pins of the MCP23008/MCP23017 are assigned: Usage of the driver ~ The MCP230xx chip (or breakout board) must be connected to the ESP8266 and the I2C pins must be configured for the module similar to the following: One that is complete you may want to confirm that the Tasmota firmware is finding your MCP23008/MCP23017 chip by sending the command through serial or MQTT: I2Cscan You should see a response giving you an address within the range of the MCP23008/MCP23017 chip (0x20 through 0x27) which may look as follows MQT: stat/tasmota/RESULT = {\"I2CScan\":\"Device(s) found at 0x20\"} If the extender is not detected, check your wiring and pin configuration. The configuration of MCP23008/MCP23017 by using Sensor29 commands via the Console or MQTT messages. In order to use the MCP23008/MCP23017, add the following two lines in your user_config_override.h as the MCP chip support is not enabled by default. #define USE_MCP230xx #define USE_MCP230xx_ADDR 0x20 The MCP23008/MCP23017 supports I 2 C address range of 0x20 through 0x27. Take care that you are not using an address which is already used by another device (e.g., 0x27 is a known address for some I 2 C Liquid Crystal Displays). Device Configuration ~ The behavior of all pins on the MCP23008/MCP23017 can be reset to a specific setting/mode globally to simplify the initial configuration as follows Command Parameters Sensor29 MCP23008 / MCP23017 I 2 C GPIO Expander configuration Reset<x> = reset all pins x = 1..6 1 = INPUT mode, no reporting, no pull-up 2 = INPUT mode, report on CHANGE, pull-up enabled 3 = INPUT mode, report on LOW, pull-up enabled 4 = INPUT mode, report on HIGH, pull-up enabled 5 = OUTPUT mode (if enabled by #define USE_MCP230xx_OUTPUT ) 6 = inverted OUTPUT mode (if enabled by #define USE_MCP230xx_OUTPUT ) pin,pinmode{,intpullup|outstate{,repmode}} pin = the I/O pin on the MCP230xx chip 0..7 for MCP23008 0..15 for the MCP23017) pinmode = operational mode of the pin ( ?, 0..5 ) ? = query pin configuration 0 = Disabled (deprecated, but will be default for previously unconfigured devices) 1 = INPUT (Floating - only telemetry data will be sent according to configuration TelePeriod intervals) 2 = INPUT with INTERRUPT on CHANGE (will send an MQTT output on state change from LOW to HIGH and HIGH to LOW) 3 = INPUT with INTERRUPT on CHANGE to LOW (will send an MQTT output on state change only from HIGH to LOW) 4 = INPUT with INTERRUPT on CHANGE to HIGH (will send an MQTT output on state change only from LOW to HIGH) 5 = OUTPUT (if enabled with #define USE_MCP230xx_OUTPUT ) 6 = inverted OUTPUT (if enabled with #define USE_MCP230xx_OUTPUT ) intpullup (pinmode 1..4 ) . Pull-up resistors are disabled by default for pin mode 1 whilst enabled by default for pin modes 2..4 (because they are interrupt enabled pins and we do not want signal bounce). The internal pull-up on these pins may be disabled if necessary if you are biasing them externally. 0 = weak internal pull-up disabled (default for pinmode 1 ) 1 = weak internal pull-up enabled (default for pinmode 2..4 ) outstate (pinmode 5..6 ) = set the default state of an OUTPUT pin on reset/power-up. If your device is configured to save state ( SetOption0 = 1 ), the outstate setting will be ignored and the last known state of the pin will be applied during power-up/reset. 0/off = set output pin to OFF 1/on = set output pin state to ON 2/toggle = toggle output pin state repmode = reporting mode (optional). Applicable only for pinmode 2..4 . Reporting mode is disabled for pinmode 1 and for output pinmodes ( 5..6 ) 0 = interrupt using Event and report using telemetry (default) 1 = interrupt using Event only (no telemetry reported) 2 = report using telemetry only (no Event triggered) Examples: Sensor29 Reset1 MQT: stat/tasmota/RESULT = {\"Sensor29_D99\":{\"MODE\":1,\"PULL_UP\":\"OFF\",\"INT_MODE\":\"DISABLED\",\"STATE\":\"\"}} Pin and State is reported as 99 because it is set across all pins. Mode should correspond with the reset pinmode option used. Sensor29 0,? MQT: stat/tasmota/RESULT = {\"Sensor29_D0\":{\"MODE\":1,\"PULL_UP\":\"OFF\",\"INT_MODE\":\"DISABLED\",\"STATE\":\"ON\"}} Confirming that the pin is in pinmode 1 and that the pull-up resistor is not enabled. INT_MODE indicates the interrupt mode for pins which are interrupt enabled (pinmode 2 through 4) - In the example above it is disabled for pin mode 1 (INPUT without INTERRUPT) The current STATE of the pin as ON or OFF is reported as at the time the command is issued is also reported. IMPORTANT NOTICE ON USE OF INTERRUPTS ~ Only use interrupts on pins which are either explicitly pulled down GND or up to VCC externally as floating pins may cause unintended MQTT responses for pins which are floating. So unless your connected wire/device explicitly pulls the pin to GND or VCC only when conditions of an interrupt would be met it is recommended that you either do not set a pin for an interrupt mode or at least enable pull-up resistors for the unused pins with pullup = 1 when you perform your sensor29 pin,pinmode,pullup command. Examples of some pin configuration options: sensor29 4,1,0 - Will enable D4 for INPUT without internal pull-up resistor sensor29 3,1,1 - Will enable D3 for INPUT with the internal pull-up resistor ENABLED sensor29 5,2,1 - Will enable D5 for INPUT and report on change state from LOW to HIGH and HIGH to LOW via MQTT sensor29 6,3,1 - Will enable D6 for INPUT and report on change state from HIGH to LOW (note pull-up is also enabled) sensor29 2,4,0 - Will enable D2 for INPUT and report on change state from LOW to HIGH (note pull-up is not enabled) Pull-up resistor support is valid for all modes from 1 through 4 Default telemetry logging will occur for all pins as per the configured logging interval of the ESP8266 as configured in the Tasmota firmware options. The telemetry logging will push out to log and MQTT a JSON as follows: tele/tasmota/SENSOR = {\"Time\":\"2018-08-18T16:13:47\",\"MCP230XX\": \"D0\":0,\"D1\":0,\"D2\":1,\"D3\":0,\"D4\":0,\"D5\":0,\"D6\":0,\"D7\":1}} Again, this will depend on whether an MCP23008 or MCP23017 is used insofar that the number of pins/bits reported will be 8 (0 to 7) or 16 (0 to 15) respectively. INTERRUPT MODES AND USAGE ~ Interrupts will report for individual pins as and when the conditions which were configured are met and will look something like this: Interrupt message on HIGH for input pin 0 MQT : stat /tasmota/ RESULT = { \"Time\" : \"2018-08-19T16:04:50\" , \"MCP230XX_INT\" :{ \"D0\" : 1 , \"MS\" : 301 }} Interrupt message on LOW for input pin 1 MQT : stat /tasmota/ RESULT = { \"Time\" : \"2018-08-19T16:04:50\" , \"MCP230XX_INT\" :{ \"D1\" : 0 , \"MS\" : 519 }} The state of the pin captured during the interrupt is reported as Dx=y where x is the pin number and y is the state of the pin. In addition the number of milliseconds since the last interrupt occurred for the particular pin is also reported as MS=xx where xx is the number of milliseconds recorded. In addition to the MQTT message the driver will also execute an event command in the following format: event MCPINT_Dxx=y Where xx = the pin number from 0 through 7 (MCP23008) or 0 through 15 (MCP23017) and y the state of the pin as it was captured by the interrupt register of the MCP23008/MCP23017 chip. The complete output for an interrupt enabled pin would look like this: MQT : stat /tasmota/ RESULT = { \"Time\" : \"2018-08-19T16:08:28\" , \"MCP230XX_INT\" :{ \"D0\" : 0 , \"MS\" : 217353 }} SRC : Rule RSL : Group 0 , Index 1 , Command EVENT , Data MCPINT_D0 = 0 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } MQT : stat /tasmota/ RESULT = { \"Time\" : \"2018-08-19T16:08:46\" , \"MCP230XX_INT\" :{ \"D0\" : 1 , \"MS\" : 18101 }} SRC : Rule RSL : Group 0 , Index 1 , Command EVENT , Data MCPINT_D0 = 1 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } The latter makes it possible to integrate interrupt responses with rules for example: rule on event#MCPINT_D0=1 do power on endon on event#MCPINT_D0=0 do power off endon In the example above the rule would respond to an interrupt of HIGH on pin 0 of the MCP by executing command \"power on\" and respond to an interrupt of LOW on pin 0 with the command \"power off\" See the Wiki on Using Rules for more information on how this can be helpful to your requirements. If you require only one of the two reporting methods you may use the sensor29 command to configure the interrupt behavior according to your requirements using command: sensor29 pin,pinmode,pullup,intmode The intmode parameter is optional for pin modes 2 through 4 (those that support interrupts) and may be configured according to the table below depending on your requirements: Keep in mind that the MCP23008/MCP23017 chip will only store the last interrupt registered in the interrupt register and capture register - Because the interrupt register is only checked every 50 milliseconds by the Tasmota firmware you may experience missed interrupts if your incoming signals fluctuate/change faster than 20 times per second. HOME ASSISTANT TIPS ~ You can use SetOption59 1 in order to get extra SENSOR status telemetry messages in addition to event-triggered RESULT messages. This allows very good integration with Home Assistant because it needs to monitor only one payload for both periodic and instant messages using binary_sensor : - platform : mqtt name : \"MCP23017 Teszt D0 SENSOR\" state_topic : \"tele/tasmota/SENSOR\" value_template : \"{{ value_json['MCP230XX'].D0 }}\" payload_on : \"1\" payload_off : \"0\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 0 device_class : door ADVANCED FUNCTIONS ~ Several advanced functions have been added to extend the flexibility and interoperability of the MCP23008/MCP23017 with specific focus on adding functionality which is not present on the hardware's built-in GPIO pins and offloading some of the functionality that would normally be performed by rules or counters on the Tasmota device into the driver of the MCP23008/MCP23017. These include the following * INTPRI - Interrupt Priority, being able to control the rate at which the MCP23008/MCP23017 is polled to see if any interrupts has occurred since the previous poll. * INTDEF - Interrupt Deffer, being able to control the number of interrupts that are ignored on a specific pin before reporting would occur via telemetry and/or EVENT. * INTTIMER - Interrupt Timer which allows for time based counter reporting, specifically reporting the number of times an interrupt has occurred on interrupt enabled pins. * INTCNT - Works with INTTIMER to enable/disable counting for a specific pin. * INTRETAIN - Keep track of whether an interrupt occurred or not and defer reporting to next telemetry message. The above additions are described in further detail below. ADVANCED FUNCTION #1 - INTERRUPT PRIORITY (INTPRI) ~ The maximum interrupt polling rate is once per approximately 50 milliseconds - This is what the Tasmota firmware allows as a maximum and how it is configured in the MCP23008/MCP23017 driver by default. If you want to reduce the number of interrupt polls per second you may use the INTPRI command parameter as follows: sensor29 intpri Will give you the current setting via JSON response as follows: MQT: stat/tasmota/RESULT = {\"MCP230xx_INTPRI\":{\"D_99\":0}} To change the value you may use command as follows: sensor29 intpri,x Where x is the number of 50ms cycles (between 0 and 20) which will be skipped before the MCP23008/MCP23017 chip is polled for interrupt. The last interrupt recorded by the MCP23008/MCP23017 will be reported via the configured method. For example, lets assume you only want the interrupt polling to occur every 500ms (i.e. twice per second) you could do command: sensor29 intpri,10 // interrupt polled every 10*50 milliseconds, approximated ADVANCED FUNCTION #2 - INTERRUPT DEFER (INTDEF) ~ This setting is useful if you need to defer the reporting of an interrupt by event or telemetry until it has occurred at least X number of times. Syntax: sensor29 intdef,pin // Will provide current setting of pin sensor29 intdef,pin,x // Will set new deffer value to x (0-15) Examples: sensor29 intdef,pin,5 // Will only report interrupt when it occurs 5 times sensor29 intdef,pin,10 // Will only report interrupt when it has occured 10 times Interrupts occurring a number of times prior to the setting will be counted but ignored for reporting purposes. ADVANCED FUNCTION #3 - INTERRUPT TIMER (INTTIMER) ~ This function is used in conjunction with INTCOUNT (Documented below) It allows a timer to be configured over which period the number of interrupts will be counted. Syntax: sensor29 inttimer // Will provide the current amount of seconds for timer sensor29 inttimer,x // Allows setting number of seconds (x) for timer interval ADVANCED FUNCTION #4 - INTERRUPT COUNTER ENABLE (INTCNT) ~ Enable interrupt counting for a particular pin. This functionality works in conjunction with INTTIMER (Documented above) Syntax: sensor29 intcnt,pin // Readback current setting of interrupt counting for pin (0=OFF/1=ON) sensor29 intcnt,pin,x // Enable/Disable interrupt counting for pin (x=0=OFF,x=1=ON) Use case example could be if you want to count the number of times an interrupt occurred on a D0 over a period of 60 seconds. For this we will need the following: sensor29 inttimer,60 // Enable interrupt timer for 60 second interval sensor29 intcnt,0,1 // Enable interrupt counter for pin D0 The above will result in the number of interrupts that occur within the 60 second period configured to be counted and then reported via telemetry at the end of the 60 second time. A use case for this would be to determine the RPM of something, or perhaps the number of pulses received from an energy meter within a 60 second period to determine energy usage on a per minute bases... or wind speed from impulses received from an anemometer. ADVANCED FUNCTION #5 - INTERRUPT RETAIN (INTRETAIN) ~ This functionality disables immediate even and/or telemetry reporting for a specific pin that has been configured for any of the interrupt modes listed above. If this is enabled for a particular pin and the pin has an interrupt mode configured the fact that an interrupt condition was met will be remembered (but not reported immediately) and will be reported in a MQTT message when the next telemetry period occurs in the following format: {\"Time\":\"2018-12-06T23:59:26\",\"MCP_INTRETAIN\": {\"D0\":1,\"D1\":0,\"D2\":1,\"D3\":1,\"D4\":0,\"Value\":13}} In the example above it means that an interrupt occurred at some point during the previous telemetry period for pins D0, D2, and D3 as indicated by the 1's present for each pin - Pins with a value of 0 means that although the pin was configured for interrupt retain that no interrupt occurred during the previous telemetry period for that particular pin. For the sake of handling bit-wise operations within your home automation software the decimal value of the respective bits are also aggregated into the Value output included in the telemetry message. Syntax: sensor29 intretain,pin // Readback current setting of interrupt retain for a pin (0=OFF/1=ON) sensor29 intretain,pin,x // Enable/Disable interrupt counting for pin (x=0=OFF,x=1=ON) OUTPUT FUNCTIONS (PIN MODES 5 AND 6) ~ Enable OUTPUT support by removing the comment (#) for the following compiler directive to your user_config_override.h #define USE_MCP230xx_OUTPUT This will extend the sensor29 command enabling pinmode 5 and 6 (inverted) for output, for example: sensor29 0,5,0 // Configure pin 0 as OUTPUT and default to OFF on reset/power-up sensor29 0,5,1 // Configure pin 0 as OUTPUT and default to ON on reset/power-up sensor29 0,6,0 // Configure pin 0 as INVERTED OUTPUT and default to ON on reset/power-up sensor29 0,6,1 // Configure pin 0 as INVERTED OUTPUT and default to OFF on reset/power-up Confirmation will be sent using MQT, for example: MQT : stat /tasmota/ RESULT = { \"Sensor29_D2\" :{ \"MODE\" : 5 , \"PULL_UP\" : \"OFF\" , \"INT_MODE\" : \"DISABLED\" , \"STATE\" : \"OFF\" }} The only difference between pinmode 5 and pinmode 6 is that pinmode 5 will result in normal output state, i.e. pin will be LOW when OFF whereas pinmode 6 will cause the pin to be HIGH when OFF. This is useful when using relays which have inverted inputs. If SAVE_STATE / setoption0 is enabled in your firmware configuration then the last known state of the pin will be used on power-up/reset thereby ignoring the pull-up parameter in the commands above. To change the state of an output pin you may use: sensor29 0,ON // Turn pin ON (HIGH if pinmode 5 or LOW if pinmode 6(inverted)) sensor29 0,OFF // Turn pin OFF (LOW if pinmode 5 or HIGH if pinmode 6(inverted)) sensor29 0,T // Toggle the current state of pin from ON to OFF, or OFF to ON Additionally all OUTPUT pins will be exposed as RELAYS and ordered behind the normal GPIO based RELAYS. Instead of the above sensor command you can also use the POWERxx command like for any RELAY. If you define INTERLOCK and/or INTERLOCK groups these will also take care about the out pins. The numbering of the RELAY's is following the standard tasmota behavior. Counting from D0 any defined OUT pin will add a new RELAY. Example: D0, D2, D3, D7 are out pins, then D0=POWER1, D2=POWER2, D3=POWER3 and D7=POWER4. Same behavior you can expect when defining PULSETIME for RELAYS. Telemetry response will be provided accordingly, for example: MQT : stat /tasmota/ RESULT = { \"S29cmnd_D0\" :{ \"COMMAND\" : \"ON\" , \"STATE\" : \"ON\" }} MQT : stat /tasmota/ RESULT = { \"S29cmnd_D0\" :{ \"COMMAND\" : \"OFF\" , \"STATE\" : \"OFF\" }} MQT : stat /tasmota/ RESULT = { \"S29cmnd_D0\" :{ \"COMMAND\" : \"TOGGLE\" , \"STATE\" : \"ON\" }} COMMAND = Command which was sent STATE = New state after execution of command Telemetry data is provided for pins which are enabled for output. For example, if pin 0 was enabled for OUTPUT the following additional telemetry message will be sent by MQTT at the same time as the normal telemetry interval occurs which reports the current states of pins. Additionally you can also use the standard POWERxx reporting. MQT : tele /tasmota/ SENSOR = { \"Time\" : \"2018-08-18T16:41:20\" , \"MCP230XX\" :{ \"D0\" : 0 , \"D1\" : 0 , \"D2\" : 1 , \"D3\" : 0 , \"D4\" : 0 , \"D5\" : 0 , \"D6\" : 0 , \"D7\" : 0 }, \"MCP230_OUT\" : { \"OUT_D4\" : \"OFF\" , \"END\" : 1 }} Note the MCP230XX telemetry which provides the current logic state of all the pins and then the second MQT telemetry as MCP230_OUT which indicates the current state of pins configured for OUTPUT - In this case pin 4 or D4 Remember to adhere to the current limitations of OUTPUT pins when using the device for switching external devices such as LED's. That being said most readily available relay pc boards available from vendors are optically isolated from the input so these will work perfectly.","title":"MCP23008 / MCP23017 GPIO Expander"},{"location":"MCP230xx/#mcp23008-mcp23017-gpio-expander","text":"Technical Data from the manufacturer: * Microchip MCP23008 * Microchip MCP23017 Generally available breakout boards for the MCP23017 look similar to this: The MCP23008 has 8 IO pins which the MCP230xx driver uses as D0 - D7. The MCP23017 has 16 IO pins which the MCP230xx driver uses as D0 - D15. This is visualized in the circuit diagram below but it's important to note that the MCP23017 actually differentiates between PORTA (being A0 to A7) and PORTB (being B0 to B7) - The MCP230xx driver combines the two ports in sequence to translate to pins represented as D0 through D15 for the MCP23017. The chip can be connected quite easily, especially if you can source the DIP version of the chip. Here's a basic outline of what a typical circuit would require to be functional: You will need to pick an I2C address in either of the above scenario's using the address mapping according to pin A0, A1, and A2 as from the datasheet as follows: You will need to define the address you are using in user_config_override.h for the driver to know on which address the MCP23008/MCP23017 is expected to be found. #define USE_MCP230xx_ADDR 0x20 The MCP23008/MCP23017 chips allow for both INPUT and OUTPUT - Most of the functionality of the driver is focused on INPUT mode - especially since they allow interrupt reporting and are 5V tolerant. OUTPUT functionality is however available as pinmode 5 (Documented later in this Wiki) as an additional option for those who want to use the OUTPUT functionality using the Sensor29 command which consumes ~1Kbyte of flash. The driver is disabled by default in the Tasmota firmware so the only way to gain its use would be to perform a manual compilation of your own firmware. There are three different levels in which functionality may be enabled, in the following order, by adding these lines in user_config_override.h : #define USE_MCP230xx // Enable INPUT mode (pinmode 1 through 4) #define USE_MCP230xx_OUTPUT // Enable OUTPUT mode (pinmode 5) #define USE_MCP230xx_DISPLAYOUTPUT // Display state of OUTPUT pins on main Tasmota web interface The ESP8266 will automatically detect whether you have connected an MCP23008 (8 input) or MCP23017 (16 input) and will provide telemetry data in accordance with how the device was configured from within the Tasmota firmware. If OUTPUT is enabled, telemetry data for the current state of OUTPUT pins will also be provided by telemetry.","title":"MCP23008 / MCP23017 GPIO Expander"},{"location":"MCP230xx/#mcp23008-mcp23017-pin-numbers-in-tasmota-compared-to-datasheets","text":"The table below outlines how the pins of the MCP23008/MCP23017 are assigned:","title":"MCP23008 / MCP23017 Pin numbers in Tasmota compared to datasheets"},{"location":"MCP230xx/#usage-of-the-driver","text":"The MCP230xx chip (or breakout board) must be connected to the ESP8266 and the I2C pins must be configured for the module similar to the following: One that is complete you may want to confirm that the Tasmota firmware is finding your MCP23008/MCP23017 chip by sending the command through serial or MQTT: I2Cscan You should see a response giving you an address within the range of the MCP23008/MCP23017 chip (0x20 through 0x27) which may look as follows MQT: stat/tasmota/RESULT = {\"I2CScan\":\"Device(s) found at 0x20\"} If the extender is not detected, check your wiring and pin configuration. The configuration of MCP23008/MCP23017 by using Sensor29 commands via the Console or MQTT messages. In order to use the MCP23008/MCP23017, add the following two lines in your user_config_override.h as the MCP chip support is not enabled by default. #define USE_MCP230xx #define USE_MCP230xx_ADDR 0x20 The MCP23008/MCP23017 supports I 2 C address range of 0x20 through 0x27. Take care that you are not using an address which is already used by another device (e.g., 0x27 is a known address for some I 2 C Liquid Crystal Displays).","title":"Usage of the driver"},{"location":"MCP230xx/#device-configuration","text":"The behavior of all pins on the MCP23008/MCP23017 can be reset to a specific setting/mode globally to simplify the initial configuration as follows Command Parameters Sensor29 MCP23008 / MCP23017 I 2 C GPIO Expander configuration Reset<x> = reset all pins x = 1..6 1 = INPUT mode, no reporting, no pull-up 2 = INPUT mode, report on CHANGE, pull-up enabled 3 = INPUT mode, report on LOW, pull-up enabled 4 = INPUT mode, report on HIGH, pull-up enabled 5 = OUTPUT mode (if enabled by #define USE_MCP230xx_OUTPUT ) 6 = inverted OUTPUT mode (if enabled by #define USE_MCP230xx_OUTPUT ) pin,pinmode{,intpullup|outstate{,repmode}} pin = the I/O pin on the MCP230xx chip 0..7 for MCP23008 0..15 for the MCP23017) pinmode = operational mode of the pin ( ?, 0..5 ) ? = query pin configuration 0 = Disabled (deprecated, but will be default for previously unconfigured devices) 1 = INPUT (Floating - only telemetry data will be sent according to configuration TelePeriod intervals) 2 = INPUT with INTERRUPT on CHANGE (will send an MQTT output on state change from LOW to HIGH and HIGH to LOW) 3 = INPUT with INTERRUPT on CHANGE to LOW (will send an MQTT output on state change only from HIGH to LOW) 4 = INPUT with INTERRUPT on CHANGE to HIGH (will send an MQTT output on state change only from LOW to HIGH) 5 = OUTPUT (if enabled with #define USE_MCP230xx_OUTPUT ) 6 = inverted OUTPUT (if enabled with #define USE_MCP230xx_OUTPUT ) intpullup (pinmode 1..4 ) . Pull-up resistors are disabled by default for pin mode 1 whilst enabled by default for pin modes 2..4 (because they are interrupt enabled pins and we do not want signal bounce). The internal pull-up on these pins may be disabled if necessary if you are biasing them externally. 0 = weak internal pull-up disabled (default for pinmode 1 ) 1 = weak internal pull-up enabled (default for pinmode 2..4 ) outstate (pinmode 5..6 ) = set the default state of an OUTPUT pin on reset/power-up. If your device is configured to save state ( SetOption0 = 1 ), the outstate setting will be ignored and the last known state of the pin will be applied during power-up/reset. 0/off = set output pin to OFF 1/on = set output pin state to ON 2/toggle = toggle output pin state repmode = reporting mode (optional). Applicable only for pinmode 2..4 . Reporting mode is disabled for pinmode 1 and for output pinmodes ( 5..6 ) 0 = interrupt using Event and report using telemetry (default) 1 = interrupt using Event only (no telemetry reported) 2 = report using telemetry only (no Event triggered) Examples: Sensor29 Reset1 MQT: stat/tasmota/RESULT = {\"Sensor29_D99\":{\"MODE\":1,\"PULL_UP\":\"OFF\",\"INT_MODE\":\"DISABLED\",\"STATE\":\"\"}} Pin and State is reported as 99 because it is set across all pins. Mode should correspond with the reset pinmode option used. Sensor29 0,? MQT: stat/tasmota/RESULT = {\"Sensor29_D0\":{\"MODE\":1,\"PULL_UP\":\"OFF\",\"INT_MODE\":\"DISABLED\",\"STATE\":\"ON\"}} Confirming that the pin is in pinmode 1 and that the pull-up resistor is not enabled. INT_MODE indicates the interrupt mode for pins which are interrupt enabled (pinmode 2 through 4) - In the example above it is disabled for pin mode 1 (INPUT without INTERRUPT) The current STATE of the pin as ON or OFF is reported as at the time the command is issued is also reported.","title":"Device Configuration"},{"location":"MCP230xx/#important-notice-on-use-of-interrupts","text":"Only use interrupts on pins which are either explicitly pulled down GND or up to VCC externally as floating pins may cause unintended MQTT responses for pins which are floating. So unless your connected wire/device explicitly pulls the pin to GND or VCC only when conditions of an interrupt would be met it is recommended that you either do not set a pin for an interrupt mode or at least enable pull-up resistors for the unused pins with pullup = 1 when you perform your sensor29 pin,pinmode,pullup command. Examples of some pin configuration options: sensor29 4,1,0 - Will enable D4 for INPUT without internal pull-up resistor sensor29 3,1,1 - Will enable D3 for INPUT with the internal pull-up resistor ENABLED sensor29 5,2,1 - Will enable D5 for INPUT and report on change state from LOW to HIGH and HIGH to LOW via MQTT sensor29 6,3,1 - Will enable D6 for INPUT and report on change state from HIGH to LOW (note pull-up is also enabled) sensor29 2,4,0 - Will enable D2 for INPUT and report on change state from LOW to HIGH (note pull-up is not enabled) Pull-up resistor support is valid for all modes from 1 through 4 Default telemetry logging will occur for all pins as per the configured logging interval of the ESP8266 as configured in the Tasmota firmware options. The telemetry logging will push out to log and MQTT a JSON as follows: tele/tasmota/SENSOR = {\"Time\":\"2018-08-18T16:13:47\",\"MCP230XX\": \"D0\":0,\"D1\":0,\"D2\":1,\"D3\":0,\"D4\":0,\"D5\":0,\"D6\":0,\"D7\":1}} Again, this will depend on whether an MCP23008 or MCP23017 is used insofar that the number of pins/bits reported will be 8 (0 to 7) or 16 (0 to 15) respectively.","title":"IMPORTANT NOTICE ON USE OF INTERRUPTS"},{"location":"MCP230xx/#interrupt-modes-and-usage","text":"Interrupts will report for individual pins as and when the conditions which were configured are met and will look something like this: Interrupt message on HIGH for input pin 0 MQT : stat /tasmota/ RESULT = { \"Time\" : \"2018-08-19T16:04:50\" , \"MCP230XX_INT\" :{ \"D0\" : 1 , \"MS\" : 301 }} Interrupt message on LOW for input pin 1 MQT : stat /tasmota/ RESULT = { \"Time\" : \"2018-08-19T16:04:50\" , \"MCP230XX_INT\" :{ \"D1\" : 0 , \"MS\" : 519 }} The state of the pin captured during the interrupt is reported as Dx=y where x is the pin number and y is the state of the pin. In addition the number of milliseconds since the last interrupt occurred for the particular pin is also reported as MS=xx where xx is the number of milliseconds recorded. In addition to the MQTT message the driver will also execute an event command in the following format: event MCPINT_Dxx=y Where xx = the pin number from 0 through 7 (MCP23008) or 0 through 15 (MCP23017) and y the state of the pin as it was captured by the interrupt register of the MCP23008/MCP23017 chip. The complete output for an interrupt enabled pin would look like this: MQT : stat /tasmota/ RESULT = { \"Time\" : \"2018-08-19T16:08:28\" , \"MCP230XX_INT\" :{ \"D0\" : 0 , \"MS\" : 217353 }} SRC : Rule RSL : Group 0 , Index 1 , Command EVENT , Data MCPINT_D0 = 0 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } MQT : stat /tasmota/ RESULT = { \"Time\" : \"2018-08-19T16:08:46\" , \"MCP230XX_INT\" :{ \"D0\" : 1 , \"MS\" : 18101 }} SRC : Rule RSL : Group 0 , Index 1 , Command EVENT , Data MCPINT_D0 = 1 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } The latter makes it possible to integrate interrupt responses with rules for example: rule on event#MCPINT_D0=1 do power on endon on event#MCPINT_D0=0 do power off endon In the example above the rule would respond to an interrupt of HIGH on pin 0 of the MCP by executing command \"power on\" and respond to an interrupt of LOW on pin 0 with the command \"power off\" See the Wiki on Using Rules for more information on how this can be helpful to your requirements. If you require only one of the two reporting methods you may use the sensor29 command to configure the interrupt behavior according to your requirements using command: sensor29 pin,pinmode,pullup,intmode The intmode parameter is optional for pin modes 2 through 4 (those that support interrupts) and may be configured according to the table below depending on your requirements: Keep in mind that the MCP23008/MCP23017 chip will only store the last interrupt registered in the interrupt register and capture register - Because the interrupt register is only checked every 50 milliseconds by the Tasmota firmware you may experience missed interrupts if your incoming signals fluctuate/change faster than 20 times per second.","title":"INTERRUPT MODES AND USAGE"},{"location":"MCP230xx/#home-assistant-tips","text":"You can use SetOption59 1 in order to get extra SENSOR status telemetry messages in addition to event-triggered RESULT messages. This allows very good integration with Home Assistant because it needs to monitor only one payload for both periodic and instant messages using binary_sensor : - platform : mqtt name : \"MCP23017 Teszt D0 SENSOR\" state_topic : \"tele/tasmota/SENSOR\" value_template : \"{{ value_json['MCP230XX'].D0 }}\" payload_on : \"1\" payload_off : \"0\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 0 device_class : door","title":"HOME ASSISTANT TIPS"},{"location":"MCP230xx/#advanced-functions","text":"Several advanced functions have been added to extend the flexibility and interoperability of the MCP23008/MCP23017 with specific focus on adding functionality which is not present on the hardware's built-in GPIO pins and offloading some of the functionality that would normally be performed by rules or counters on the Tasmota device into the driver of the MCP23008/MCP23017. These include the following * INTPRI - Interrupt Priority, being able to control the rate at which the MCP23008/MCP23017 is polled to see if any interrupts has occurred since the previous poll. * INTDEF - Interrupt Deffer, being able to control the number of interrupts that are ignored on a specific pin before reporting would occur via telemetry and/or EVENT. * INTTIMER - Interrupt Timer which allows for time based counter reporting, specifically reporting the number of times an interrupt has occurred on interrupt enabled pins. * INTCNT - Works with INTTIMER to enable/disable counting for a specific pin. * INTRETAIN - Keep track of whether an interrupt occurred or not and defer reporting to next telemetry message. The above additions are described in further detail below.","title":"ADVANCED FUNCTIONS"},{"location":"MCP230xx/#advanced-function-1-interrupt-priority-intpri","text":"The maximum interrupt polling rate is once per approximately 50 milliseconds - This is what the Tasmota firmware allows as a maximum and how it is configured in the MCP23008/MCP23017 driver by default. If you want to reduce the number of interrupt polls per second you may use the INTPRI command parameter as follows: sensor29 intpri Will give you the current setting via JSON response as follows: MQT: stat/tasmota/RESULT = {\"MCP230xx_INTPRI\":{\"D_99\":0}} To change the value you may use command as follows: sensor29 intpri,x Where x is the number of 50ms cycles (between 0 and 20) which will be skipped before the MCP23008/MCP23017 chip is polled for interrupt. The last interrupt recorded by the MCP23008/MCP23017 will be reported via the configured method. For example, lets assume you only want the interrupt polling to occur every 500ms (i.e. twice per second) you could do command: sensor29 intpri,10 // interrupt polled every 10*50 milliseconds, approximated","title":"ADVANCED FUNCTION #1 - INTERRUPT PRIORITY (INTPRI)"},{"location":"MCP230xx/#advanced-function-2-interrupt-defer-intdef","text":"This setting is useful if you need to defer the reporting of an interrupt by event or telemetry until it has occurred at least X number of times. Syntax: sensor29 intdef,pin // Will provide current setting of pin sensor29 intdef,pin,x // Will set new deffer value to x (0-15) Examples: sensor29 intdef,pin,5 // Will only report interrupt when it occurs 5 times sensor29 intdef,pin,10 // Will only report interrupt when it has occured 10 times Interrupts occurring a number of times prior to the setting will be counted but ignored for reporting purposes.","title":"ADVANCED FUNCTION #2 - INTERRUPT DEFER (INTDEF)"},{"location":"MCP230xx/#advanced-function-3-interrupt-timer-inttimer","text":"This function is used in conjunction with INTCOUNT (Documented below) It allows a timer to be configured over which period the number of interrupts will be counted. Syntax: sensor29 inttimer // Will provide the current amount of seconds for timer sensor29 inttimer,x // Allows setting number of seconds (x) for timer interval","title":"ADVANCED FUNCTION #3 - INTERRUPT TIMER (INTTIMER)"},{"location":"MCP230xx/#advanced-function-4-interrupt-counter-enable-intcnt","text":"Enable interrupt counting for a particular pin. This functionality works in conjunction with INTTIMER (Documented above) Syntax: sensor29 intcnt,pin // Readback current setting of interrupt counting for pin (0=OFF/1=ON) sensor29 intcnt,pin,x // Enable/Disable interrupt counting for pin (x=0=OFF,x=1=ON) Use case example could be if you want to count the number of times an interrupt occurred on a D0 over a period of 60 seconds. For this we will need the following: sensor29 inttimer,60 // Enable interrupt timer for 60 second interval sensor29 intcnt,0,1 // Enable interrupt counter for pin D0 The above will result in the number of interrupts that occur within the 60 second period configured to be counted and then reported via telemetry at the end of the 60 second time. A use case for this would be to determine the RPM of something, or perhaps the number of pulses received from an energy meter within a 60 second period to determine energy usage on a per minute bases... or wind speed from impulses received from an anemometer.","title":"ADVANCED FUNCTION #4 - INTERRUPT COUNTER ENABLE (INTCNT)"},{"location":"MCP230xx/#advanced-function-5-interrupt-retain-intretain","text":"This functionality disables immediate even and/or telemetry reporting for a specific pin that has been configured for any of the interrupt modes listed above. If this is enabled for a particular pin and the pin has an interrupt mode configured the fact that an interrupt condition was met will be remembered (but not reported immediately) and will be reported in a MQTT message when the next telemetry period occurs in the following format: {\"Time\":\"2018-12-06T23:59:26\",\"MCP_INTRETAIN\": {\"D0\":1,\"D1\":0,\"D2\":1,\"D3\":1,\"D4\":0,\"Value\":13}} In the example above it means that an interrupt occurred at some point during the previous telemetry period for pins D0, D2, and D3 as indicated by the 1's present for each pin - Pins with a value of 0 means that although the pin was configured for interrupt retain that no interrupt occurred during the previous telemetry period for that particular pin. For the sake of handling bit-wise operations within your home automation software the decimal value of the respective bits are also aggregated into the Value output included in the telemetry message. Syntax: sensor29 intretain,pin // Readback current setting of interrupt retain for a pin (0=OFF/1=ON) sensor29 intretain,pin,x // Enable/Disable interrupt counting for pin (x=0=OFF,x=1=ON)","title":"ADVANCED FUNCTION #5 - INTERRUPT RETAIN (INTRETAIN)"},{"location":"MCP230xx/#output-functions-pin-modes-5-and-6","text":"Enable OUTPUT support by removing the comment (#) for the following compiler directive to your user_config_override.h #define USE_MCP230xx_OUTPUT This will extend the sensor29 command enabling pinmode 5 and 6 (inverted) for output, for example: sensor29 0,5,0 // Configure pin 0 as OUTPUT and default to OFF on reset/power-up sensor29 0,5,1 // Configure pin 0 as OUTPUT and default to ON on reset/power-up sensor29 0,6,0 // Configure pin 0 as INVERTED OUTPUT and default to ON on reset/power-up sensor29 0,6,1 // Configure pin 0 as INVERTED OUTPUT and default to OFF on reset/power-up Confirmation will be sent using MQT, for example: MQT : stat /tasmota/ RESULT = { \"Sensor29_D2\" :{ \"MODE\" : 5 , \"PULL_UP\" : \"OFF\" , \"INT_MODE\" : \"DISABLED\" , \"STATE\" : \"OFF\" }} The only difference between pinmode 5 and pinmode 6 is that pinmode 5 will result in normal output state, i.e. pin will be LOW when OFF whereas pinmode 6 will cause the pin to be HIGH when OFF. This is useful when using relays which have inverted inputs. If SAVE_STATE / setoption0 is enabled in your firmware configuration then the last known state of the pin will be used on power-up/reset thereby ignoring the pull-up parameter in the commands above. To change the state of an output pin you may use: sensor29 0,ON // Turn pin ON (HIGH if pinmode 5 or LOW if pinmode 6(inverted)) sensor29 0,OFF // Turn pin OFF (LOW if pinmode 5 or HIGH if pinmode 6(inverted)) sensor29 0,T // Toggle the current state of pin from ON to OFF, or OFF to ON Additionally all OUTPUT pins will be exposed as RELAYS and ordered behind the normal GPIO based RELAYS. Instead of the above sensor command you can also use the POWERxx command like for any RELAY. If you define INTERLOCK and/or INTERLOCK groups these will also take care about the out pins. The numbering of the RELAY's is following the standard tasmota behavior. Counting from D0 any defined OUT pin will add a new RELAY. Example: D0, D2, D3, D7 are out pins, then D0=POWER1, D2=POWER2, D3=POWER3 and D7=POWER4. Same behavior you can expect when defining PULSETIME for RELAYS. Telemetry response will be provided accordingly, for example: MQT : stat /tasmota/ RESULT = { \"S29cmnd_D0\" :{ \"COMMAND\" : \"ON\" , \"STATE\" : \"ON\" }} MQT : stat /tasmota/ RESULT = { \"S29cmnd_D0\" :{ \"COMMAND\" : \"OFF\" , \"STATE\" : \"OFF\" }} MQT : stat /tasmota/ RESULT = { \"S29cmnd_D0\" :{ \"COMMAND\" : \"TOGGLE\" , \"STATE\" : \"ON\" }} COMMAND = Command which was sent STATE = New state after execution of command Telemetry data is provided for pins which are enabled for output. For example, if pin 0 was enabled for OUTPUT the following additional telemetry message will be sent by MQTT at the same time as the normal telemetry interval occurs which reports the current states of pins. Additionally you can also use the standard POWERxx reporting. MQT : tele /tasmota/ SENSOR = { \"Time\" : \"2018-08-18T16:41:20\" , \"MCP230XX\" :{ \"D0\" : 0 , \"D1\" : 0 , \"D2\" : 1 , \"D3\" : 0 , \"D4\" : 0 , \"D5\" : 0 , \"D6\" : 0 , \"D7\" : 0 }, \"MCP230_OUT\" : { \"OUT_D4\" : \"OFF\" , \"END\" : 1 }} Note the MCP230XX telemetry which provides the current logic state of all the pins and then the second MQT telemetry as MCP230_OUT which indicates the current state of pins configured for OUTPUT - In this case pin 4 or D4 Remember to adhere to the current limitations of OUTPUT pins when using the device for switching external devices such as LED's. That being said most readily available relay pc boards available from vendors are optically isolated from the input so these will work perfectly.","title":"OUTPUT FUNCTIONS (PIN MODES 5 AND 6)"},{"location":"MCP9808/","text":"This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_MCP9808 #define USE_MCP9808 // [ I2cDriver51 ] Enable MCP9808 temperature sensor ( I2C addresses 0x18 - 0x1F ) ( + 0 k9 code ) #endif the MCP9808 is an I 2 C temperature sensor. Tasmota support up to 8 devices. Configuration ~ Wiring ~ MCP9808 ESP8266 VCC 3.3V GND GND SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) After a reboot the driver will detect automatically up to 8 MCP9808 and display sensor readings. and in MQTT topic (according to TelePeriod): {\"Time\":\"2020-01-01T00:00:00\",\"MCP9808\":{\"Temperature\":24.7},\"TempUnit\":\"C\"} Breakout Boards ~ Datasheet ~ MCP9808","title":"MCP9808 temperature sensor"},{"location":"MCP9808/#configuration","text":"","title":"Configuration"},{"location":"MCP9808/#wiring","text":"MCP9808 ESP8266 VCC 3.3V GND GND SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"MCP9808/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) After a reboot the driver will detect automatically up to 8 MCP9808 and display sensor readings. and in MQTT topic (according to TelePeriod): {\"Time\":\"2020-01-01T00:00:00\",\"MCP9808\":{\"Temperature\":24.7},\"TempUnit\":\"C\"}","title":"Tasmota Settings"},{"location":"MCP9808/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"MCP9808/#datasheet","text":"MCP9808","title":"Datasheet"},{"location":"MGC3130/","text":"MGC3130 3D tracking and gesture controller ~ The MGC3130 is an electrical-field (E-field) based three-dimensional (3D) tracking and gesture controller from Microchip. There are several boards available, which are connected via I 2 C. USAGE: ~ Add #define USE_MGC3130 in sonoff/user_config_override.h flash the device before connecting the sensor board wire up SDA and SDL and configure as usual in TASMOTA wire up RESET and TRFR (names may vary on different boards) to free GPIO's and configure them accordingly (TRFR is GPIO: MGC3130_XFER) EXPECTED BEHAVIOUR: ~ after boot gestures (FLICK, EDGE_FLICK, TOUCH, TAP, DOUBLE_TAP) will be sensed and published via MQTT Flicks: Taps: you can select different modes with the COMMANDS, touch will always be sensed and report the duration in 1/20 seconds. Touch: the airwheel gesture will be sensed and published as \"AW\" via MQTT with values between 0 and 1023 - clockwise up Airwheel: after entering position mode the values for x,y,z will be sensed and published via MQTT with values between 0 and 1023 for x,y. Data is only published, when z is in the upper half (z values are between 0 and 511). Location sensing in active volume: near the surface you can move your finger without producing location data, i.e. to change the mode. at the moment the circle gestures ((COUNTER)CLOCKWISE) must be activated with the COMMAND: SENSOR91 1 (we must wait 250 ms after the start and can not activate it in the init function, this might differ depending on the board firmware) COMMANDS: ~ SENSOR36 0 - next mode SENSOR36 1 - gesture mode SENSOR36 2 - airwheel mode SENSOR36 3 - position mode (ATTENTION: this will send a lot of data!) MQTT-messages: ~ The terminology follows the documentation from MICROCHIP, but is shortened to save space especially for RULES. The board is to be viewed like a map, where UP is NORTH and RIGHT is EAST an so on. The big central part of the surface is CENTRE. A movement (FLICK) from LEFT to RIGHT is translated to FLICK-WEST-EAST and then finally shortened to {FL_WE:1}. If you only do a flick at the left edge (with a short movement to the right) this will be EDGE-FLICK-WEST-EAST and then in the final message: {E_FL_WE:1}. A TOUCH (leaving your finger on the board) reports the location and the duration (in counts of 50ms). So touching the centre for a second, publishes messages from {TH_C:1} up to (approx.) {TH_C:20}. Touching for less than 1,25 seconds triggers a TAP-message in the moment of leaving the surface, so on the lower edge we will see: {TP_S:1} (plus some {TH_S:1...x} for the contact duration). Double Tap (like a double click on your mouse) works similar, but will (at the moment) always trigger a (single) TAP at the same position. Example for the upper edge: {DT_N:1} and before that: {TP_N:1} and some {TH_N:1...x}. Airwheel is a circular finger movement above the sensor, which will trigger a message {AW:0 ... 1023}. In position mode we get {X:0...1023,Y:0...1023,Z:0...511}, where X and Y are 0 in the lower left (west-south) corner. The z value is not published in close proximity to the surface in order to have a chance to switch to another mode with a TOUCH, TAP or DOUBLE-TAP. So the active sensing volume is in the upper z-half of the theoretical maximum sensing volume. EXAMPLES: ~ A possible solution to cycle through the modes only with the sensor by double tapping the centre is using RULES: rule1 on Tele-MGC3130#DT_C do sensor91 0 endon or with a \"long\" touch of a second rule1 on Tele-MGC3130#TH_C > 20 do sensor91 0 endon CONSIDERATIONS: ~ This is an extremely versatile sensor and the main problem is not to get it to work somehow in TASMOTA, but to make it usable in a sensible way. We can measure and publish all kinds of data in parallel, but this will likely end up in an unusable situation. It is important to have a basic understanding of the sensor, to not get confused with seemingly unreasonable messages (DOUBLE TAP triggers a TOUCH (or more than one), then a TAP (after the first lift of the finger) and then a DOUBLE TAP. The naming conventions of the gestures are according to the data sheets from Microchip, because if we only would have simple FLICKS, it would have made it easy to use: UP, DOWN, LEFT, RIGHT. But we have EDGE FLICKS and various TOUCHES too, and so the direction name could be ambiguous. That's why we (have to) use NORTH-SOUTH, EAST-WEST ... and NORTH, SOUTH, .... and CENTRE. To make the MQTT messages not too long, some useful abbreviations have to be found. This is definitely work in progress. KNOWN ISSUES: ~ After the initial flashing the ESP8266/TASMOTA can freeze at startup with a connected sensor board. If this happens disconnect the wires from the MGC3130-board (I 2 C-wires should be enough), reboot and reconnect. Keep in mind, that in general many things will interfere with an electrical field. In certain places it can simply be impossible to use such kind of sensor. For testing reasons it is fine to connect the ESP8266-device to the USB-Port of a computer (for POWER and SERIAL), but this will likely lead to weird effects in some cases (i.e. reading of nonsense-location-data by simply touching the keyboard of a connected laptop). The chip can saturate the I 2 C-bus and additional I 2 C-devices can lead to problems. The driver was developed and tested on a SKYWRITER-board from PIMORONI. The behavior of other boards can not be guaranteed. TO-BE-DONE: ~ Ideas are welcome and will be integrated if possible.","title":"MGC3130 3D tracking and gesture controller"},{"location":"MGC3130/#mgc3130-3d-tracking-and-gesture-controller","text":"The MGC3130 is an electrical-field (E-field) based three-dimensional (3D) tracking and gesture controller from Microchip. There are several boards available, which are connected via I 2 C.","title":"MGC3130 3D tracking and gesture controller"},{"location":"MGC3130/#usage","text":"Add #define USE_MGC3130 in sonoff/user_config_override.h flash the device before connecting the sensor board wire up SDA and SDL and configure as usual in TASMOTA wire up RESET and TRFR (names may vary on different boards) to free GPIO's and configure them accordingly (TRFR is GPIO: MGC3130_XFER)","title":"USAGE:"},{"location":"MGC3130/#expected-behaviour","text":"after boot gestures (FLICK, EDGE_FLICK, TOUCH, TAP, DOUBLE_TAP) will be sensed and published via MQTT Flicks: Taps: you can select different modes with the COMMANDS, touch will always be sensed and report the duration in 1/20 seconds. Touch: the airwheel gesture will be sensed and published as \"AW\" via MQTT with values between 0 and 1023 - clockwise up Airwheel: after entering position mode the values for x,y,z will be sensed and published via MQTT with values between 0 and 1023 for x,y. Data is only published, when z is in the upper half (z values are between 0 and 511). Location sensing in active volume: near the surface you can move your finger without producing location data, i.e. to change the mode. at the moment the circle gestures ((COUNTER)CLOCKWISE) must be activated with the COMMAND: SENSOR91 1 (we must wait 250 ms after the start and can not activate it in the init function, this might differ depending on the board firmware)","title":"EXPECTED BEHAVIOUR:"},{"location":"MGC3130/#commands","text":"SENSOR36 0 - next mode SENSOR36 1 - gesture mode SENSOR36 2 - airwheel mode SENSOR36 3 - position mode (ATTENTION: this will send a lot of data!)","title":"COMMANDS:"},{"location":"MGC3130/#mqtt-messages","text":"The terminology follows the documentation from MICROCHIP, but is shortened to save space especially for RULES. The board is to be viewed like a map, where UP is NORTH and RIGHT is EAST an so on. The big central part of the surface is CENTRE. A movement (FLICK) from LEFT to RIGHT is translated to FLICK-WEST-EAST and then finally shortened to {FL_WE:1}. If you only do a flick at the left edge (with a short movement to the right) this will be EDGE-FLICK-WEST-EAST and then in the final message: {E_FL_WE:1}. A TOUCH (leaving your finger on the board) reports the location and the duration (in counts of 50ms). So touching the centre for a second, publishes messages from {TH_C:1} up to (approx.) {TH_C:20}. Touching for less than 1,25 seconds triggers a TAP-message in the moment of leaving the surface, so on the lower edge we will see: {TP_S:1} (plus some {TH_S:1...x} for the contact duration). Double Tap (like a double click on your mouse) works similar, but will (at the moment) always trigger a (single) TAP at the same position. Example for the upper edge: {DT_N:1} and before that: {TP_N:1} and some {TH_N:1...x}. Airwheel is a circular finger movement above the sensor, which will trigger a message {AW:0 ... 1023}. In position mode we get {X:0...1023,Y:0...1023,Z:0...511}, where X and Y are 0 in the lower left (west-south) corner. The z value is not published in close proximity to the surface in order to have a chance to switch to another mode with a TOUCH, TAP or DOUBLE-TAP. So the active sensing volume is in the upper z-half of the theoretical maximum sensing volume.","title":"MQTT-messages:"},{"location":"MGC3130/#examples","text":"A possible solution to cycle through the modes only with the sensor by double tapping the centre is using RULES: rule1 on Tele-MGC3130#DT_C do sensor91 0 endon or with a \"long\" touch of a second rule1 on Tele-MGC3130#TH_C > 20 do sensor91 0 endon","title":"EXAMPLES:"},{"location":"MGC3130/#considerations","text":"This is an extremely versatile sensor and the main problem is not to get it to work somehow in TASMOTA, but to make it usable in a sensible way. We can measure and publish all kinds of data in parallel, but this will likely end up in an unusable situation. It is important to have a basic understanding of the sensor, to not get confused with seemingly unreasonable messages (DOUBLE TAP triggers a TOUCH (or more than one), then a TAP (after the first lift of the finger) and then a DOUBLE TAP. The naming conventions of the gestures are according to the data sheets from Microchip, because if we only would have simple FLICKS, it would have made it easy to use: UP, DOWN, LEFT, RIGHT. But we have EDGE FLICKS and various TOUCHES too, and so the direction name could be ambiguous. That's why we (have to) use NORTH-SOUTH, EAST-WEST ... and NORTH, SOUTH, .... and CENTRE. To make the MQTT messages not too long, some useful abbreviations have to be found. This is definitely work in progress.","title":"CONSIDERATIONS:"},{"location":"MGC3130/#known-issues","text":"After the initial flashing the ESP8266/TASMOTA can freeze at startup with a connected sensor board. If this happens disconnect the wires from the MGC3130-board (I 2 C-wires should be enough), reboot and reconnect. Keep in mind, that in general many things will interfere with an electrical field. In certain places it can simply be impossible to use such kind of sensor. For testing reasons it is fine to connect the ESP8266-device to the USB-Port of a computer (for POWER and SERIAL), but this will likely lead to weird effects in some cases (i.e. reading of nonsense-location-data by simply touching the keyboard of a connected laptop). The chip can saturate the I 2 C-bus and additional I 2 C-devices can lead to problems. The driver was developed and tested on a SKYWRITER-board from PIMORONI. The behavior of other boards can not be guaranteed.","title":"KNOWN ISSUES:"},{"location":"MGC3130/#to-be-done","text":"Ideas are welcome and will be integrated if possible.","title":"TO-BE-DONE:"},{"location":"MH-Z19B/","text":"MH-Z19B CO 2 Sensor ~ This feature is included only in tasmota-sensors.bin The MH-Z19 sensor is manufactured by Winsen Lt., China and the measurement method used is based on the non-dispersive infrared ( NDIR ) principle to detect the existence of CO 2 in the air. Key features according to the manufacturer are: * good sensitivity * non-oxygen dependent * long life * built-in temperature compensation * UART serial interface and Pulse Width Modulation (PWM) output Principle of operation: The main components of an NDIR sensor are an infrared source (lamp), a sample chamber or light tube, a light filter and an infrared detector. The IR light is directed through the sample chamber towards the detector. In parallel there is another chamber with an enclosed reference gas, typically nitrogen. The gas in the sample chamber causes absorption of specific wavelengths according to the Beer\u00f1Lambert law, and the attenuation of these wavelengths is measured by the detector to determine the gas concentration. The detector has an optical filter in front of it that eliminates all light except the wavelength that the selected gas molecules can absorb. See also the datasheet . Buy example: AliExpress.com: MH-Z19B-Infrared-CO2-Sensor-for-CO2-Monitor-NDIR-Gas-Sensor-CO2-gas-sensor Operating current < 18mA average Connecting the MH-Z19B to a Wemos D1 mini ~ Wemos D1 Mini MH-Z19B VCC +5V Vin GND GND TX Rx RX Tx In some situations if you only get 0 ppm displayed it may be necessary to set \"TX GPIO1\" to \"MHZ Rx\" and \"RX GPIO3\" to \"MHZ Tx\" and correspondingly reverse the cabling for RX/TX. See here for more details. Tasmota Settings ~ In the Configuration -> Configure Module page, select the following for Wemos D1 mini: 1. Module Type: 18 Generic 2. TX GPIO1 Serial Out: 60 MHZ Tx 3. RX GPIO3 Serial In: 61 MHZ Rx For Sonoff Basic: 1. Module Type: 01 Sonoff Basic 2. GPIO01 60 MHZ Tx 3. GPIO03 61 MHZ Rx Tasmota Main ~ After reboot of the device the MHZ-19B measurements are shown. Measure range can be selected with command: sensor15 1000 for 1000 ppm range sensor15 2000 for 2000 ppm range sensor15 3000 for 3000 ppm range sensor15 5000 for 5000 ppm range Full commands list for the sensor","title":"MH-Z19B CO<sub>2</sub> Sensor"},{"location":"MH-Z19B/#mh-z19b-co2-sensor","text":"This feature is included only in tasmota-sensors.bin The MH-Z19 sensor is manufactured by Winsen Lt., China and the measurement method used is based on the non-dispersive infrared ( NDIR ) principle to detect the existence of CO 2 in the air. Key features according to the manufacturer are: * good sensitivity * non-oxygen dependent * long life * built-in temperature compensation * UART serial interface and Pulse Width Modulation (PWM) output Principle of operation: The main components of an NDIR sensor are an infrared source (lamp), a sample chamber or light tube, a light filter and an infrared detector. The IR light is directed through the sample chamber towards the detector. In parallel there is another chamber with an enclosed reference gas, typically nitrogen. The gas in the sample chamber causes absorption of specific wavelengths according to the Beer\u00f1Lambert law, and the attenuation of these wavelengths is measured by the detector to determine the gas concentration. The detector has an optical filter in front of it that eliminates all light except the wavelength that the selected gas molecules can absorb. See also the datasheet . Buy example: AliExpress.com: MH-Z19B-Infrared-CO2-Sensor-for-CO2-Monitor-NDIR-Gas-Sensor-CO2-gas-sensor Operating current < 18mA average","title":"MH-Z19B CO2 Sensor"},{"location":"MH-Z19B/#connecting-the-mh-z19b-to-a-wemos-d1-mini","text":"Wemos D1 Mini MH-Z19B VCC +5V Vin GND GND TX Rx RX Tx In some situations if you only get 0 ppm displayed it may be necessary to set \"TX GPIO1\" to \"MHZ Rx\" and \"RX GPIO3\" to \"MHZ Tx\" and correspondingly reverse the cabling for RX/TX. See here for more details.","title":"Connecting the MH-Z19B to a Wemos D1 mini"},{"location":"MH-Z19B/#tasmota-settings","text":"In the Configuration -> Configure Module page, select the following for Wemos D1 mini: 1. Module Type: 18 Generic 2. TX GPIO1 Serial Out: 60 MHZ Tx 3. RX GPIO3 Serial In: 61 MHZ Rx For Sonoff Basic: 1. Module Type: 01 Sonoff Basic 2. GPIO01 60 MHZ Tx 3. GPIO03 61 MHZ Rx","title":"Tasmota Settings"},{"location":"MH-Z19B/#tasmota-main","text":"After reboot of the device the MHZ-19B measurements are shown. Measure range can be selected with command: sensor15 1000 for 1000 ppm range sensor15 2000 for 2000 ppm range sensor15 3000 for 3000 ppm range sensor15 5000 for 5000 ppm range Full commands list for the sensor","title":"Tasmota Main"},{"location":"MLX90614/","text":"MLX90614 infrared thermometer ~ This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_MLX90614 #define USE_MLX90614 // [ I2cDriver32 ] Enable MLX90614 ir temp sensor ( I2C address 0x5a ) ( + 0.6 k code ) #endif The MLX90614 is an infrared thermometer for non-contact temperature measurements. Configuration ~ Wiring ~ MLX90614 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) After a reboot the driver will detect MLX90614 automatically and display Temperature measurements. Sensor sends a tele/%topic%/SENSOR JSON reponse: tele / tas mo ta /SENSOR = { \"Time\" : \"2019-11-11T00:03:30\" , \"MLX90614\" :{ \"OBJTMP\" : 23.8 , \"AMBTMP\" : 22.7 }} Breakout Boards ~ MLX90615 ~ This driver will also work with MLX90615 sensor with some code alterations. Change lines 26-30 # define I2_ADR_IRT 0 x5b # define MLX90614_RAWIR1 0 x05 # define MLX90614_TA 0 x26 # define MLX90614_TOBJ1 0 x27","title":"MLX90614 infrared thermometer"},{"location":"MLX90614/#mlx90614-infrared-thermometer","text":"This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_MLX90614 #define USE_MLX90614 // [ I2cDriver32 ] Enable MLX90614 ir temp sensor ( I2C address 0x5a ) ( + 0.6 k code ) #endif The MLX90614 is an infrared thermometer for non-contact temperature measurements.","title":"MLX90614 infrared thermometer"},{"location":"MLX90614/#configuration","text":"","title":"Configuration"},{"location":"MLX90614/#wiring","text":"MLX90614 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"MLX90614/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) After a reboot the driver will detect MLX90614 automatically and display Temperature measurements. Sensor sends a tele/%topic%/SENSOR JSON reponse: tele / tas mo ta /SENSOR = { \"Time\" : \"2019-11-11T00:03:30\" , \"MLX90614\" :{ \"OBJTMP\" : 23.8 , \"AMBTMP\" : 22.7 }}","title":"Tasmota Settings"},{"location":"MLX90614/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"MLX90614/#mlx90615","text":"This driver will also work with MLX90615 sensor with some code alterations. Change lines 26-30 # define I2_ADR_IRT 0 x5b # define MLX90614_RAWIR1 0 x05 # define MLX90614_TA 0 x26 # define MLX90614_TOBJ1 0 x27","title":"MLX90615"},{"location":"MLX90640/","text":"MLX90640 Far infrared thermal sensor array ~ This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_MLX90640 #define USE_MLX90640 // [ I2cDriver53 ] #endif The MLX90640 is a IR sensor array of 32x24 pixels, that is connected via an usual I2C-connection. Intended use case is to measure multiple points of interest of an object without the need to directly put a sensor on it, for instance if you are not allowed to apply hardware modifications to a heating. The update frequency of the measurements is approximately 1 per second. In the first driver version 6 POI\u2018s are freely selectable (POI1..6). POI-0 is reserved for the ambient temperature of the sensor (Ta). Data is published at Teleperiod as an array [POI-0...6]: { \"Time\": \"2020-09-11T09:18:08\", \"MLX90640\": { \"Temperature\": [30.8, 28.5, 24.2, 25.7, 24.5, 24.6, 24.9] }, \"TempUnit\": \"C\" } Configuration ~ Wiring ~ MLX90640 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) After a reboot the driver will detect MLX90614 automatically and display Temperature measurements. Commands ~ Command: MLXPOIn xxyy, n ist poi 1...6, xx 0...31, yy 0...23 Example: Point 2 at x:12 and y:08 results in mlxpoi2 1208 The configuration can be saved via RULES. Web-GUI ~ In order to find the correct coordinates a thermal view is provided via webGUI, where points can be validated and/or updated. A stable Wifi-setup is mandatory for reliable operation. Breakout Boards ~","title":"MLX90640 Far infrared thermal sensor array"},{"location":"MLX90640/#mlx90640-far-infrared-thermal-sensor-array","text":"This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_MLX90640 #define USE_MLX90640 // [ I2cDriver53 ] #endif The MLX90640 is a IR sensor array of 32x24 pixels, that is connected via an usual I2C-connection. Intended use case is to measure multiple points of interest of an object without the need to directly put a sensor on it, for instance if you are not allowed to apply hardware modifications to a heating. The update frequency of the measurements is approximately 1 per second. In the first driver version 6 POI\u2018s are freely selectable (POI1..6). POI-0 is reserved for the ambient temperature of the sensor (Ta). Data is published at Teleperiod as an array [POI-0...6]: { \"Time\": \"2020-09-11T09:18:08\", \"MLX90640\": { \"Temperature\": [30.8, 28.5, 24.2, 25.7, 24.5, 24.6, 24.9] }, \"TempUnit\": \"C\" }","title":"MLX90640 Far infrared thermal sensor array"},{"location":"MLX90640/#configuration","text":"","title":"Configuration"},{"location":"MLX90640/#wiring","text":"MLX90640 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"MLX90640/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) After a reboot the driver will detect MLX90614 automatically and display Temperature measurements.","title":"Tasmota Settings"},{"location":"MLX90640/#commands","text":"Command: MLXPOIn xxyy, n ist poi 1...6, xx 0...31, yy 0...23 Example: Point 2 at x:12 and y:08 results in mlxpoi2 1208 The configuration can be saved via RULES.","title":"Commands"},{"location":"MLX90640/#web-gui","text":"In order to find the correct coordinates a thermal view is provided via webGUI, where points can be validated and/or updated. A stable Wifi-setup is mandatory for reliable operation.","title":"Web-GUI"},{"location":"MLX90640/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"MPR121/","text":"MPR121 capacitive touch sensor ~ This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_MPR121 #define USE_MPR121 // [ I2cDriver23 ] Enable MPR121 controller ( I2C addresses 0x5A , 0x5B , 0x5C and 0x5D ) in input mode for touch buttons ( + 1 k3 code ) #endif 12-button or touch pad I 2 C controller Driver supports up to 4x MPR121 controllers (= 48 buttons per ESP8266) Electrodes can be covered with adhesive paper and adhesive plastic foil for labeling and symbols Break-out and touch button PCBs ~ 2\u20ac at AliExpress Break-out PCB ~ $8 at Adafruit Technical Data from the manufacturer ~ MPR121 Fact sheet MPR121 Data sheet AN3889 MPR121 capacitive sensing settings AN3890 MPR121 capacitive sensing filtering and timing AN3891 MPR121 touch sensing baseline system AN3892 MPR121 touch sensing jitter and false touch rejection AN3893 MPR121 proximity sensing AN3894 MPR121 LED driver system AN3895 MPR121 serial communication AN4600 MPR121 Designing a Touch Panel MPR121 Evaluation board schematics Wiring breakout boards ~ Breakout ESP8266 VCC/VIN +3.3VDC GND GND SCL GPIO I 2 SCL SDA GPIO I 2 SDA IRQ NC I 2 C address selection ~ Connect the ADD(R) pin/pad to one of the following pins/pads: Address ADD(R) 0x5A NC 0x5B +3.3VDC 0x5C GPIO I 2 SDA 0x5D GPIO I 2 SCL Tasmota SettingsCompile Tasmota with #define USE_MPR121 added in user_config_override.h ~ The driver will detect the I 2 C addresses of the MPR121s automatically. The MPR121 chip (or breakout board) must be connected to the ESP8266 and the I 2 C GPIO pins must be configured: Generally available types of breakout boards ~","title":"MPR121 capacitive touch sensor"},{"location":"MPR121/#mpr121-capacitive-touch-sensor","text":"This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_MPR121 #define USE_MPR121 // [ I2cDriver23 ] Enable MPR121 controller ( I2C addresses 0x5A , 0x5B , 0x5C and 0x5D ) in input mode for touch buttons ( + 1 k3 code ) #endif 12-button or touch pad I 2 C controller Driver supports up to 4x MPR121 controllers (= 48 buttons per ESP8266) Electrodes can be covered with adhesive paper and adhesive plastic foil for labeling and symbols Break-out and touch button PCBs ~ 2\u20ac at AliExpress Break-out PCB ~ $8 at Adafruit","title":"MPR121 capacitive touch sensor"},{"location":"MPR121/#technical-data-from-the-manufacturer","text":"MPR121 Fact sheet MPR121 Data sheet AN3889 MPR121 capacitive sensing settings AN3890 MPR121 capacitive sensing filtering and timing AN3891 MPR121 touch sensing baseline system AN3892 MPR121 touch sensing jitter and false touch rejection AN3893 MPR121 proximity sensing AN3894 MPR121 LED driver system AN3895 MPR121 serial communication AN4600 MPR121 Designing a Touch Panel MPR121 Evaluation board schematics","title":"Technical Data from the manufacturer"},{"location":"MPR121/#wiring-breakout-boards","text":"Breakout ESP8266 VCC/VIN +3.3VDC GND GND SCL GPIO I 2 SCL SDA GPIO I 2 SDA IRQ NC","title":"Wiring breakout boards"},{"location":"MPR121/#i2c-address-selection","text":"Connect the ADD(R) pin/pad to one of the following pins/pads: Address ADD(R) 0x5A NC 0x5B +3.3VDC 0x5C GPIO I 2 SDA 0x5D GPIO I 2 SCL","title":"I2C address selection"},{"location":"MPR121/#tasmota-settingscompile-tasmota-with-define-use_mpr121-added-in-user_config_overrideh","text":"The driver will detect the I 2 C addresses of the MPR121s automatically. The MPR121 chip (or breakout board) must be connected to the ESP8266 and the I 2 C GPIO pins must be configured:","title":"Tasmota SettingsCompile Tasmota with #define USE_MPR121 added in user_config_override.h"},{"location":"MPR121/#generally-available-types-of-breakout-boards","text":"","title":"Generally available types of breakout boards"},{"location":"MPU-6050/","text":"This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_MPU6050 #define USE_MPU6050 // [ I2cDriver25 ] Enable MPU6050 sensor ( I2C address 0x68 AD0 low or 0x69 AD0 high ) ( + 3 K3 of code and 188 Bytes of RAM ) #define USE_MPU6050_DMP // Enable in MPU6050 to use the DMP on the chip , should create better results ( + 8 k6 of code ) #endif The MPU-6050 combines a 3-axis gyroscope and a 3-axis accelerometer on the same silicon die, together with an onboard Digital Motion Processor\u2122 (DMP\u2122), which processes complex 6-axis MotionFusion algorithms. Datasheet Configuration ~ Wiring ~ MPU-6050 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy XDA XCL AD0 INT Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) After a reboot the driver will detect MCU-69050 automatically and display measurements. Sensor sends a tele/%topic%/SENSOR JSON reponse: tele / tas mo ta /SENSOR = { \"Time\" : \"2019-12-10T19:37:50\" , \"MPU6050\" :{ \"Temperature\" : 27.7 , \"AccelXAxis\" : -7568.00 , \"AccelYAxis\" : -776.00 , \"AccelZAxis\" : 12812.00 , \"GyroXAxis\" : 270.00 , \"GyroYAxis\" : -741.00 , \"GyroZAxis\" : 700.00 }, \"TempUnit\" : \"C\" } Digital Motion Processor Enabled If you define flag #define USE_MPU6050_DMP // Enable in MPU6050 to use the DMP on the chip, should create better results (+8k6 of code) enabling Digital Motion Processor\u2122 (DMP\u2122) you will get additional Yaw, Pitch and Roll measurements and more accurate measurements overall Sensor sends an expanded tele/%topic%/SENSOR JSON reponse: tele / tas mo ta /SENSOR = { \"Time\" : \"2019-12-10T19:24:55\" , \"MPU6050\" :{ \"Temperature\" : 25.0 , \"AccelXAxis\" : 756.00 , \"AccelYAxis\" : -1409.00 , \"AccelZAxis\" : 2152.00 , \"GyroXAxis\" : 0.00 , \"GyroYAxis\" : -1.00 , \"GyroZAxis\" : 10.00 , \"Yaw\" : 0.86 , \"Pitch\" : -1.45 , \"Roll\" : -10.76 }, \"TempUnit\" : \"C\" } Breakout Boards ~ Rule Triggers ~ The following trigger events are supported for use in Rules : ON MPU6050 # Temperature DO < command > ENDON ON MPU6050 # AccelXAxis DO < command > ENDON ON MPU6050 # AccelYAxis DO < command > ENDON ON MPU6050 # AccelZAxis DO < command > ENDON ON MPU6050 # GyroXAxis DO < command > ENDON ON MPU6050 # GyroYAxis DO < command > ENDON ON MPU6050 # GyroZAxis DO < command > ENDON ON MPU6050 # Yaw DO < command > ENDON ON MPU6050 # Roll DO < command > ENDON ON MPU6050 # Pitch DO < command > ENDON Example: ON MPU6050#Yaw DO publish espMotion/sensor/data/Yaw %value% ENDON","title":"MPU-6050 gyroscope and accelerometer"},{"location":"MPU-6050/#configuration","text":"","title":"Configuration"},{"location":"MPU-6050/#wiring","text":"MPU-6050 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy XDA XCL AD0 INT","title":"Wiring"},{"location":"MPU-6050/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) After a reboot the driver will detect MCU-69050 automatically and display measurements. Sensor sends a tele/%topic%/SENSOR JSON reponse: tele / tas mo ta /SENSOR = { \"Time\" : \"2019-12-10T19:37:50\" , \"MPU6050\" :{ \"Temperature\" : 27.7 , \"AccelXAxis\" : -7568.00 , \"AccelYAxis\" : -776.00 , \"AccelZAxis\" : 12812.00 , \"GyroXAxis\" : 270.00 , \"GyroYAxis\" : -741.00 , \"GyroZAxis\" : 700.00 }, \"TempUnit\" : \"C\" }","title":"Tasmota Settings"},{"location":"MPU-6050/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"MPU-6050/#rule-triggers","text":"The following trigger events are supported for use in Rules : ON MPU6050 # Temperature DO < command > ENDON ON MPU6050 # AccelXAxis DO < command > ENDON ON MPU6050 # AccelYAxis DO < command > ENDON ON MPU6050 # AccelZAxis DO < command > ENDON ON MPU6050 # GyroXAxis DO < command > ENDON ON MPU6050 # GyroYAxis DO < command > ENDON ON MPU6050 # GyroZAxis DO < command > ENDON ON MPU6050 # Yaw DO < command > ENDON ON MPU6050 # Roll DO < command > ENDON ON MPU6050 # Pitch DO < command > ENDON Example: ON MPU6050#Yaw DO publish espMotion/sensor/data/Yaw %value% ENDON","title":"Rule Triggers"},{"location":"MQTT/","text":"MQTT is the main protocol for controlling Tasmota devices After you have a working MQTT broker you need to configure Tasmota to communicate with it. If you have no knowledge of what MQTT is, you can learn about it from MQTT Essentials articles. Configure MQTT ~ If you flashed a precompiled .bin or didn't enter MQTT info in user_config_override.h before compiling you have to configure it on your device first. Configure MQTT using WebUI ~ Go to Configuration -> Configure Other and make sure \"MQTT Enable\" box is checked. Once MQTT is enabled you need to set it up using Configuration -> Configure MQTT . Tip While here, you might as well change the Friendly Name into something more descriptive than generic \"Tasmota\". This is a must for Home Assistant autodiscovery feature. For a basic setup you only need to set Host , User and Password but it is recommended to change Topic to avoid issues. Each device should have a unique Topic . Host = your MQTT broker address or IP ( mDNS is not available in the official Tasmota builds , means no .local domain!) Port = your MQTT broker port (default port is set to 1883) Client = device's unique identifier. In 99% of cases it's okay to leave it as is, however some Cloud-based MQTT brokers require a ClientID connected to your account. User = username for authenticating on your MQTT broker Password = password for authenticating on your MQTT broker Topic = unique identifying topic for your device (e.g. hallswitch , kitchen-light ). %topic% in wiki references to this. It is recommended to use a single word for the topic. FullTopic = full topic definition . Modify it if you want to use multi-level topics for your devices, for example lights/%prefix%/%topic%/ or %prefix%/top_floor/bathroom/%topic%/ etc. Configure MQTT using Backlog ~ Using a serial connection or the WebUI Console you can issue (or even better, paste a premade) Backlog command for quick and easy MQTT setup. Backlog mqtthost < mqtt_broker_address > ; mqttport < mqtt_broker_port > ; mqttuser < username > ; mqttpassword < password > ; topic < device_topic > After a reboot all necessary MQTT settings are configured. Don't forget, you can use Backlog for all commands! Commands over MQTT ~ To send commands and view responses you'll need an MQTT client . Commands over MQTT are issued to Tasmota by using cmnd/%topic%/<command> <parameter> . If there is no <parameter> (an empty MQTT message/payload), a query is sent for current status of the <command> . Tip If you are using mosquitto_pub , you can issue an empty payload using the -n command line option. If your MQTT client cannot issue an empty payload, you can use the single character ? instead. Command flow ~ The following example will go in depth on what happens when you send an MQTT command. A device was flashed and configured with the FullTopic as default %prefix%/%topic%/ and the Topic set to tasmota_switch . We want to see the current status of the switch and change it. By looking at the commands table we can learn about the POWER command and options associated with it. Ask the device for status cmnd / tasmota_switch / Power \u2190 // an empty message/payload sends a status query \u21b3 stat / tasmota_switch / RESULT \u2192 { \"POWER\" : \"OFF\" } \u21b3 stat / tasmota_switch / POWER \u2192 OFF We can see that the switch (device's relay) is turned off. Send a command to toggle the relay cmnd / tasmota_switch / Power \u2190 \"TOGGLE\" \u21b3 // Power for relay 1 is toggled \u21b3 stat / tasmota_switch / RESULT \u2192 { \"POWER\" : \"ON\" } \u21b3 stat / tasmota_switch / POWER \u2192 ON We've sent the toggle command and received confirmation that the switch is turned on. Tip By default, Tasmota replies to all commands through .../RESULT . This behavior can be changed using SetOption4 , which makes the commands reply on the endpoint matching the command name, ex. cmnd/tasmota/PowerOnState will send a response on cmnd/tasmota/POWERONSTATE . Examples ~ In the following examples %topic% is tasmota , FullTopic is %prefix%/%topic%/ , and prefixes are default cmnd/stat/tele : The relay can be controlled with cmnd/tasmota/POWER on , cmnd/tasmota/POWER off or cmnd/tasmota/POWER toggle . Tasmota will send a MQTT status message like stat/tasmota/POWER ON . Power state message can be sent with the retain flag set using PowerRetain 1 . Telemetry messages can also be sent with the retain flag using SensorRetain . For Sonoff Dual or Sonoff 4CH the relays need to be addressed with cmnd/tasmota/POWER<x> , where {x} is the relay number from 1 to 2 (Sonoff Dual) or from 1 to 4 (Sonoff 4CH). cmnd/tasmota/POWER4 off turns off the 4th relay on a Sonoff 4CH. MQTT topic can be changed with cmnd/tasmota/Topic tasmota1 which reboots Tasmota and changes the %topic% to tasmota1 . From that point on MQTT commands should look like cmnd/tasmota1/POWER on . The OTA firmware location can be made known to tasmota with cmnd/tasmota/OtaUrl http://ota.tasmota.com/tasmota/release/tasmota.bin . Reset to default with cmnd/tasmota/OtaUrl 1 . Upgrade OTA firmware from the OtaUrl server with cmnd/tasmota/Upgrade 1 . Show all status information with cmnd/tasmota/Status 0 . The button can send a MQTT message to the broker that in turn will switch the relay. To configure this you need to perform cmnd/tasmota/ButtonTopic tasmota where tasmota equals to Topic. The message can also be provided with the retain flag by cmnd/tasmota/ButtonRetain on . Sonoff Pow (and any device with sensors) status can be requested manually with cmnd/tasmota/status 8 . Additionally, Tasmota periodically sends telemetry every TelePeriod , which defaults to 300 seconds (5 minutes). When a Sonoff Pow (and any device with power metering sensors) threshold like PowerLow has been met a message tele/tasmota/POWER_LOW ON will be sent. When the error is corrected a message tele/tasmota/POWER_LOW OFF will be sent. While most MQTT commands will result in a message in JSON format the power status feedback will always be returned like stat/tasmota/POWER ON as well. Telemetry data will be sent by prefix tele like tele/tasmota/SENSOR {\"Time\":\"2017-02-16T10:13:52\", \"DS18B20\":{\"Temperature\":20.6}} MQTT Topic Definition ~ FullTopic ~ This is the MQTT topic used to communicate with Tasmota over MQTT. It is created using tokens placed within a user definable string (100 character limit). The tokens are substituted dynamically at run-time. Available substitution tokens are: %prefix% = one of three prefixes as defined by commands Prefix1 (default = cmnd ) , Prefix2 (default = stat ) and Prefix3 (default = tele ) . %topic% = one of five topics as defined by commands Topic , GroupTopic , ButtonTopic , SwitchTopic and MqttClient . %hostname% = the hostname of the device as defined through the web UI (default = %s-%04d ) or via Hostname command. %id% = MAC address of the device. Tip These substitution tokens will be used in examples across the documentation If FullTopic does not contain the %topic% token, the device will not subscribe to GroupTopic and FallbackTopic . Tip The order of %prefix% and %topic% doesn't matter, unless you have enabled Auto-discovery for Home Assistant ( SetOption19 ). Enabling this option re-formats the FullTopic to required order. Using the tokens the following example topics can be made: FullTopic %prefix%/%topic%/ default FullTopic tasmota/%topic%/%prefix%/ FullTopic tasmota/bedroom/%topic%/%prefix%/ FullTopic penthouse/bedroom1/bathroom2/%topic%/%prefix%/ FullTopic %prefix%/home/cellar/%topic%/ %prefix% Tasmota uses 3 prefixes for forming a FullTopic: cmnd - prefix to issue commands; ask for status stat - reports back status or configuration message tele - reports telemetry info at specified intervals Warning To solve possible MQTT topic loops it is strongly suggested that you use the %prefix% token in all of your FullTopics. Status and telemetry do not need a prefix. %topic% ~ All MQTT status messages will be sent using the configurable %topic% which must be made unique by the user. It can be called bedroom but it could also be called XP-TS_10 as long as the user knows what it is and where to find it. Default Topic is tasmota_XXXXXX where XXXXXX is unique and derives from the last 6 characters of the MAC address The use of the %topic% token is mandatory in case you want to use ButtonTopic and/or SwitchTopic . It also provides for GroupTopic and Fallback Topic functionality. Tip Use %prefix% and %topic% tokens at all time within your FullTopic definition! GroupTopic ~ Having two devices with the same topic allowed for MQTT commands to be sent once to make the devices act in conjunction. That inspired a third topic called GroupTopic. Devices with the same GroupTopic will all listen to that GroupTopic and react to the same MQTT command sent to it. You can use this to take global actions like updating firmware on all devices or split up devices into different groups using a unique GroupTopic for each group. Default GroupTopic is tasmotas FallBack Topic ~ Initially Tasmota had one MQTT configurable topic planned called Topic. It soon became apparent that when two devices come online with the same topic this would be a challenge, to say the least! Tasmota then introduced a unique, non-configurable \"FallBack Topic\" that allows MQTT communication regardless of the configurable topic. This fallback topic is just what it is meant to be: a fallback topic in case of emergency! By default the Fallback Topic is DVES_XXXXXX_fb where xxxxxx is derived from the last 6 charactes of the device's MAC address (excluding : ). It might look something like this: DVES_3D5E26_fb . You can find out the DVES code by looking at Information page in the webUI or issuing Status 6 : 12 : 36 : 17 MQT : s tat / tas mo ta /STATUS 6 = { \"StatusMQT\" :{ \"MqttHost\" : \"1.1.1.1\" , \"MqttPort\" : 1883 , \"MqttClientMask\" : \"DVES_%06X\" , \"MqttClient\" : \"DVES_3D5E26\" , \"MqttUser\" : \"tasmota\" , \"MqttCount\" : 1 , \"MAX_PACKET_SIZE\" : 1000 , \"KEEPALIVE\" : 30 }} Retained MQTT Messages ~ If MQTT is defined and PowerRetain is used the last state will be stored permanently in MQTT database. Command Description PowerRetain Show current MQTT power retain state. 0 / off = disable MQTT power retain on status update (default) 1 / on = enable MQTT power retain on status update BUT , a message in your MQTT broker flagged as 'retained' will always override the PowerOnState . This is usually the main cause for \"ghost switching\". Learn more in MQTT retained messages explained . Check out this tutorial for troubleshooting switch ghosting. Clearing Retained Messages ~ To check, if there is a retain flag set for the switch's power topic, monitor cmnd/+/power in a MQTT client (recommended MQTT.fx for Windows or Eclipse Mosquitto in linux). You can use Tasmota Device Manager to clear all retained messages for selected device with a single click. or use the following tutorials/forum threads: Clearing retained messages with mosquitto Remove retained messages in Home Assistant Remove retained messages in hass.io MQTT addon Return codes (rc) ~ Sometimes, something wrong can happen and you might need to check return codes. A return code can be found in the console, example output for Return Code = 5 : MQT: Connect failed to xxxx:1883, rc 5. Retry in 10 sec Below table provides more information about it. The original values are related to PubSubClient.h constants . Code Constant name Description -4 MQTT_CONNECTION_TIMEOUT the server didn't respond within the keepalive time -3 MQTT_CONNECTION_LOST the network connection was broken -2 MQTT_CONNECT_FAILED the network connection failed -1 MQTT_DISCONNECTED the client is disconnected cleanly 0 MQTT_CONNECTED the client is connected 1 MQTT_CONNECT_BAD_PROTOCOL the server doesn't support the requested version of MQTT 2 MQTT_CONNECT_BAD_CLIENT_ID the server rejected the client identifier 3 MQTT_CONNECT_UNAVAILABLE the server was unable to accept the connection 4 MQTT_CONNECT_BAD_CREDENTIALS the username/password were rejected 5 MQTT_CONNECT_UNAUTHORIZED the client was not authorized to connect","title":"MQTT"},{"location":"MQTT/#configure-mqtt","text":"If you flashed a precompiled .bin or didn't enter MQTT info in user_config_override.h before compiling you have to configure it on your device first.","title":"Configure MQTT"},{"location":"MQTT/#configure-mqtt-using-webui","text":"Go to Configuration -> Configure Other and make sure \"MQTT Enable\" box is checked. Once MQTT is enabled you need to set it up using Configuration -> Configure MQTT . Tip While here, you might as well change the Friendly Name into something more descriptive than generic \"Tasmota\". This is a must for Home Assistant autodiscovery feature. For a basic setup you only need to set Host , User and Password but it is recommended to change Topic to avoid issues. Each device should have a unique Topic . Host = your MQTT broker address or IP ( mDNS is not available in the official Tasmota builds , means no .local domain!) Port = your MQTT broker port (default port is set to 1883) Client = device's unique identifier. In 99% of cases it's okay to leave it as is, however some Cloud-based MQTT brokers require a ClientID connected to your account. User = username for authenticating on your MQTT broker Password = password for authenticating on your MQTT broker Topic = unique identifying topic for your device (e.g. hallswitch , kitchen-light ). %topic% in wiki references to this. It is recommended to use a single word for the topic. FullTopic = full topic definition . Modify it if you want to use multi-level topics for your devices, for example lights/%prefix%/%topic%/ or %prefix%/top_floor/bathroom/%topic%/ etc.","title":"Configure MQTT using WebUI"},{"location":"MQTT/#configure-mqtt-using-backlog","text":"Using a serial connection or the WebUI Console you can issue (or even better, paste a premade) Backlog command for quick and easy MQTT setup. Backlog mqtthost < mqtt_broker_address > ; mqttport < mqtt_broker_port > ; mqttuser < username > ; mqttpassword < password > ; topic < device_topic > After a reboot all necessary MQTT settings are configured. Don't forget, you can use Backlog for all commands!","title":"Configure MQTT using Backlog"},{"location":"MQTT/#commands-over-mqtt","text":"To send commands and view responses you'll need an MQTT client . Commands over MQTT are issued to Tasmota by using cmnd/%topic%/<command> <parameter> . If there is no <parameter> (an empty MQTT message/payload), a query is sent for current status of the <command> . Tip If you are using mosquitto_pub , you can issue an empty payload using the -n command line option. If your MQTT client cannot issue an empty payload, you can use the single character ? instead.","title":"Commands over MQTT"},{"location":"MQTT/#command-flow","text":"The following example will go in depth on what happens when you send an MQTT command. A device was flashed and configured with the FullTopic as default %prefix%/%topic%/ and the Topic set to tasmota_switch . We want to see the current status of the switch and change it. By looking at the commands table we can learn about the POWER command and options associated with it.","title":"Command flow"},{"location":"MQTT/#examples","text":"In the following examples %topic% is tasmota , FullTopic is %prefix%/%topic%/ , and prefixes are default cmnd/stat/tele : The relay can be controlled with cmnd/tasmota/POWER on , cmnd/tasmota/POWER off or cmnd/tasmota/POWER toggle . Tasmota will send a MQTT status message like stat/tasmota/POWER ON . Power state message can be sent with the retain flag set using PowerRetain 1 . Telemetry messages can also be sent with the retain flag using SensorRetain . For Sonoff Dual or Sonoff 4CH the relays need to be addressed with cmnd/tasmota/POWER<x> , where {x} is the relay number from 1 to 2 (Sonoff Dual) or from 1 to 4 (Sonoff 4CH). cmnd/tasmota/POWER4 off turns off the 4th relay on a Sonoff 4CH. MQTT topic can be changed with cmnd/tasmota/Topic tasmota1 which reboots Tasmota and changes the %topic% to tasmota1 . From that point on MQTT commands should look like cmnd/tasmota1/POWER on . The OTA firmware location can be made known to tasmota with cmnd/tasmota/OtaUrl http://ota.tasmota.com/tasmota/release/tasmota.bin . Reset to default with cmnd/tasmota/OtaUrl 1 . Upgrade OTA firmware from the OtaUrl server with cmnd/tasmota/Upgrade 1 . Show all status information with cmnd/tasmota/Status 0 . The button can send a MQTT message to the broker that in turn will switch the relay. To configure this you need to perform cmnd/tasmota/ButtonTopic tasmota where tasmota equals to Topic. The message can also be provided with the retain flag by cmnd/tasmota/ButtonRetain on . Sonoff Pow (and any device with sensors) status can be requested manually with cmnd/tasmota/status 8 . Additionally, Tasmota periodically sends telemetry every TelePeriod , which defaults to 300 seconds (5 minutes). When a Sonoff Pow (and any device with power metering sensors) threshold like PowerLow has been met a message tele/tasmota/POWER_LOW ON will be sent. When the error is corrected a message tele/tasmota/POWER_LOW OFF will be sent. While most MQTT commands will result in a message in JSON format the power status feedback will always be returned like stat/tasmota/POWER ON as well. Telemetry data will be sent by prefix tele like tele/tasmota/SENSOR {\"Time\":\"2017-02-16T10:13:52\", \"DS18B20\":{\"Temperature\":20.6}}","title":"Examples"},{"location":"MQTT/#mqtt-topic-definition","text":"","title":"MQTT Topic Definition"},{"location":"MQTT/#fulltopic","text":"This is the MQTT topic used to communicate with Tasmota over MQTT. It is created using tokens placed within a user definable string (100 character limit). The tokens are substituted dynamically at run-time. Available substitution tokens are: %prefix% = one of three prefixes as defined by commands Prefix1 (default = cmnd ) , Prefix2 (default = stat ) and Prefix3 (default = tele ) . %topic% = one of five topics as defined by commands Topic , GroupTopic , ButtonTopic , SwitchTopic and MqttClient . %hostname% = the hostname of the device as defined through the web UI (default = %s-%04d ) or via Hostname command. %id% = MAC address of the device. Tip These substitution tokens will be used in examples across the documentation If FullTopic does not contain the %topic% token, the device will not subscribe to GroupTopic and FallbackTopic . Tip The order of %prefix% and %topic% doesn't matter, unless you have enabled Auto-discovery for Home Assistant ( SetOption19 ). Enabling this option re-formats the FullTopic to required order. Using the tokens the following example topics can be made: FullTopic %prefix%/%topic%/ default FullTopic tasmota/%topic%/%prefix%/ FullTopic tasmota/bedroom/%topic%/%prefix%/ FullTopic penthouse/bedroom1/bathroom2/%topic%/%prefix%/ FullTopic %prefix%/home/cellar/%topic%/","title":"FullTopic"},{"location":"MQTT/#topic","text":"All MQTT status messages will be sent using the configurable %topic% which must be made unique by the user. It can be called bedroom but it could also be called XP-TS_10 as long as the user knows what it is and where to find it. Default Topic is tasmota_XXXXXX where XXXXXX is unique and derives from the last 6 characters of the MAC address The use of the %topic% token is mandatory in case you want to use ButtonTopic and/or SwitchTopic . It also provides for GroupTopic and Fallback Topic functionality. Tip Use %prefix% and %topic% tokens at all time within your FullTopic definition!","title":"%topic%"},{"location":"MQTT/#grouptopic","text":"Having two devices with the same topic allowed for MQTT commands to be sent once to make the devices act in conjunction. That inspired a third topic called GroupTopic. Devices with the same GroupTopic will all listen to that GroupTopic and react to the same MQTT command sent to it. You can use this to take global actions like updating firmware on all devices or split up devices into different groups using a unique GroupTopic for each group. Default GroupTopic is tasmotas","title":"GroupTopic"},{"location":"MQTT/#fallback-topic","text":"Initially Tasmota had one MQTT configurable topic planned called Topic. It soon became apparent that when two devices come online with the same topic this would be a challenge, to say the least! Tasmota then introduced a unique, non-configurable \"FallBack Topic\" that allows MQTT communication regardless of the configurable topic. This fallback topic is just what it is meant to be: a fallback topic in case of emergency! By default the Fallback Topic is DVES_XXXXXX_fb where xxxxxx is derived from the last 6 charactes of the device's MAC address (excluding : ). It might look something like this: DVES_3D5E26_fb . You can find out the DVES code by looking at Information page in the webUI or issuing Status 6 : 12 : 36 : 17 MQT : s tat / tas mo ta /STATUS 6 = { \"StatusMQT\" :{ \"MqttHost\" : \"1.1.1.1\" , \"MqttPort\" : 1883 , \"MqttClientMask\" : \"DVES_%06X\" , \"MqttClient\" : \"DVES_3D5E26\" , \"MqttUser\" : \"tasmota\" , \"MqttCount\" : 1 , \"MAX_PACKET_SIZE\" : 1000 , \"KEEPALIVE\" : 30 }}","title":"FallBack Topic"},{"location":"MQTT/#retained-mqtt-messages","text":"If MQTT is defined and PowerRetain is used the last state will be stored permanently in MQTT database. Command Description PowerRetain Show current MQTT power retain state. 0 / off = disable MQTT power retain on status update (default) 1 / on = enable MQTT power retain on status update BUT , a message in your MQTT broker flagged as 'retained' will always override the PowerOnState . This is usually the main cause for \"ghost switching\". Learn more in MQTT retained messages explained . Check out this tutorial for troubleshooting switch ghosting.","title":"Retained MQTT Messages"},{"location":"MQTT/#clearing-retained-messages","text":"To check, if there is a retain flag set for the switch's power topic, monitor cmnd/+/power in a MQTT client (recommended MQTT.fx for Windows or Eclipse Mosquitto in linux). You can use Tasmota Device Manager to clear all retained messages for selected device with a single click. or use the following tutorials/forum threads: Clearing retained messages with mosquitto Remove retained messages in Home Assistant Remove retained messages in hass.io MQTT addon","title":"Clearing Retained Messages"},{"location":"MQTT/#return-codes-rc","text":"Sometimes, something wrong can happen and you might need to check return codes. A return code can be found in the console, example output for Return Code = 5 : MQT: Connect failed to xxxx:1883, rc 5. Retry in 10 sec Below table provides more information about it. The original values are related to PubSubClient.h constants . Code Constant name Description -4 MQTT_CONNECTION_TIMEOUT the server didn't respond within the keepalive time -3 MQTT_CONNECTION_LOST the network connection was broken -2 MQTT_CONNECT_FAILED the network connection failed -1 MQTT_DISCONNECTED the client is disconnected cleanly 0 MQTT_CONNECTED the client is connected 1 MQTT_CONNECT_BAD_PROTOCOL the server doesn't support the requested version of MQTT 2 MQTT_CONNECT_BAD_CLIENT_ID the server rejected the client identifier 3 MQTT_CONNECT_UNAVAILABLE the server was unable to accept the connection 4 MQTT_CONNECT_BAD_CREDENTIALS the username/password were rejected 5 MQTT_CONNECT_UNAUTHORIZED the client was not authorized to connect","title":"Return codes (rc)"},{"location":"MacOSX-Server/","text":"Mac OSX comes with a built in web server, although it's not running by default. Starting the web server can be done by running: sudo apachectl start To start the server, you'll be asked for your user's password. Opening your localhost will show you 'it works!', which will tell you that much - it works. The folder to put files in is /Library/WebServer/Documents You may wish to create a subfolder for the firmware files. Use the IP address of this local web server to OTA flash Tasmota. You can determine your IP address here . For example, http://192.168.1.123/tasmota.bin Issue this command to stop the web server when your are done flashing: sudo apachectl stop Note: The MAMP web server does not seem to deliver the results as expected!","title":"MacOSX Server"},{"location":"Modules/","text":"Module is a firmware supported device which has specific code to enable its features. Configure Module page in the webUI is used to configure your device as one of the modules and to configure additional components connected to one of the free GPIO pins of the device. Warning New Modules are added to Tasmota only if a device requires additional code for new functions. Use Templates first to configure your device if it's not in the module list. Tip Use Generic module Module 18 to have almost all GPIO pins available. Each module is assigned a number which is used in Template configuration or when using Module command. # Name Module specifics 0 Template Module for currently active template. Named after the template NAME field. If a template is not active it will display Generic (0) . Do not use it until you configure a template , use Generic (18) instead 1 Sonoff Basic 2 Sonoff RF 3 Sonoff SV 4 Sonoff TH 5 Sonoff Dual Process relay and button via hardware serial interface using GPIO01 and GPIO03. Change the baud rate to 19200 bps. Process buttons as single press only 6 Sonoff POW 7 Sonoff 4Ch 8 Sonoff S2X 9 Slampher 10 Sonoff Touch Invert LedState 1 functionality 11 Sonoff LED Set light type to 2 PWM channels disregarding SetOption15. Fix device specific LED instabilities by disabling GPIO04, GPIO5 and GPIO14 12 1 Channel 13 4 Channel See Sonoff Dual 14 Motor C/AC Force all relays ON at power up and disable command PowerOnState 15 ElectroDragon 16 EXS Relay(s) Enable pulse latching using even/odd numbered relay pairs 17 WION 18 Generic Show Wemos specific pin information in GUI 19 Sonoff Dev 20 H801 Change hardware UART Tx from GPIO01 to GPIO02 21 Sonoff SC Enable and process data via hardware serial interface using GPIO01 and GPIO03. Change the baud rate to 19200 bps 22 Sonoff BN-SZ Set light type to 1 PWM channel disregarding SetOption15 23 Sonoff 4Ch Pro Button handling disregarding SetOption13 only allowing single press to enable RF learning while holding the button 24 Huafan SS 25 Sonoff Bridge Enable and Process data via hardware serial interface using GPIO01 and GPIO03. Change the baud rate to 19200 bps. Process 16 buttons in web GUI. Enable EFM8BB1 firmware upload 26 Sonoff B1 Set light type to RGBWC using MY92x1 27 Ailight Set light type to RGBW using MY92x1 28 Sonoff T1 1Ch See Sonoff Touch 29 Sonoff T1 2Ch See Sonoff Touch 30 Sonoff T1 3Ch See Sonoff Touch 31 Supla Espablo 32 Witty Cloud 33 Yunshan Relay 34 MagicHome 35 Luani HVIO 36 KMC 70011 37 Arilux LC01 38 Arilux LC11 39 Sonoff Dual R2 Process buttons as single press only 40 Arilux LC06 41 Sonoff S31 Selects component types for the CSE7766 (serial connected energy monitoring chip) with Rx and Tx hardware serial (even parity) on GPIO01 and GPIO03 respectively. Sets serial interface to 4800 baud and disables serial logging 42 Zengge WF017 43 Sonoff Pow R2 44 Sonoff IFan02 Enable command FanSpeed . Disable Interlock and PulseTime . Tune status information, MQTT data and GUI. Sync with microcontroller. Process Domoticz Fan state 45 Blitzwolf SHP Module specific power monitoring calibration 46 Shelly 1 47 Shelly 2 48 Xiaomi Philips Process color temperature using PWM2 and intensity using PWM1 49 Neo Coolcam 50 ESP SwitCh 51 Obi Socket 52 Teckin 53 APLIC WDP303075 54 TuyaMCU Enable and process data via software or hardware serial interface using component 107 and 108. Change the baud rate to 9600 bps. Process all buttons. Read more... 55 Gosund SP1 v23 56 Armtronix Dimmers Enable and process data via software or hardware serial interface using component 148 and 149. Change baudrate to 115200 bps. 57 SK03 Outdoor (Tuya) 58 PS-16-DZ Enable and process data via software or hardware serial interface using component 148 and 149. Change the baud rate to 19200 bps. 59 Teckin US 60 Manzoku Strip (EU 4) 61 Obi Socket 2 62 YTF IR Bridge Disable serial interface to stop loopback. 63 Digoo DG-SP202 64 KA10 65 Luminea ZX2820 66 Mi Desk Lamp Process rotary and Button1 data specific to this device 67 SP10 68 WAGA CHCZ02MB 69 SYF05 70 Sonoff L1 71 Sonoff iFan03 72 EX-Store Dimmer 73 PWM Dimmer For MJ-SD01/acenx/NTONPOWER PWM dimmers. Read more... 74 Sonoff D1 Dimmer 75 Sonoff ZBBridge Sonoff Zigbee bridge Serial logging is disabled by the Tasmota code for several modules and components (e.g., Sonoff POW, Sonoff S31, Sonoff Dual (v1), Tuya dimmers, PZEM components, etc.). Serial communication is used by these devices to transfer the data from the MCU chip to the ESP chip. Do not enable serial logging ( SerialLog 0 ) on these devices. It can cause the device software to crash. Supported Modules","title":"Modules"},{"location":"Moisture-Sensor-and-Chirp%21-Sensor/","text":"This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_CHIRP #define USE_CHIRP #endif Chirp! I 2 C moisture sensor is the sensor-only version of the original Chirp! sensor. The \"sensor mode only\" (without the chirp function) is the preferred sensor variant for Tasmota. It provides additional temperature readings. Chirp! is a plant watering alarm which uses capacitive sensing to measure moisture. It provides ambient light readings and works in Tasmota, but is not the recommended version. Additional References: - Catnip electronics - Plant Watering Alarm Connecting to an ESP82xx ~ Use a standard I 2 C connection plus 3.3V and GND. Device Configuration ~ In the Configuration -> Configure Other page, enter and activate the following template: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,0,0,0,6,5,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} BASE: Generic (18) GPIO4 : I2C SDA (06) GPIO5 : I2C SCL (05) At boot time the driver will scan the I 2 C bus for CHIRP moisture sensors and enumerate them starting with 0. The sensor has a default I 2 C address of 0x20 , which can be changed within the driver so that multiple sensors are possible. Write access to the sensor is potentially dangerous!! Only change the I 2 C address while only one is sensor connected, using a stable power supply, and if you are familiar with how to flash the sensor. Commands ~ Command Description CHIRPSCAN Re-scan the I 2 C bus and re-enumerate the sensors. CHIRPSELECT Select the active sensor, which can receive commands. To select the first sensor use CHIRPSELECT 0 . CHIRPSET Set the new I 2 C address for the selected sensor. Use decimal address. To change active sensor to 0x1f (=31) use CHIRPSET 31 . CHIRPSLEEP Put the selected sensor into sleep mode. CHIRPWAKE Wake the selected (sleeping) sensor. CHIRPRESET Reset the selected sensor. Sensor readings ~ The original explanation from the manufacturer can be found on this tindie page . It is important to understand, that the light sensor does not provide LUX but a relative reading ( 0..65535 ), where more light means a lower value! The term DARKNESS is used in Tasmota. !! \u26a0\ufe0f PLEASE USE TelePeriod OF 20 OR GREATER \u26a0\ufe0f !! The driver will sync with the TelePeriod and start the measure cycle about 17 seconds before the next telemetry message. You can issue a Status 8 and any time to output that last sensor readings. Known issues ~ The sensor is relatively slow and therefore the driver will (try to) slow down the I 2 C bus-speed and extend the CLOCKSTRETCHLIMIT. A long discussion about it can be found here . The problem seems to occur mostly when the sensor wakes up from sleep. That is why the implemented auto-sleep-wake function is currently deactivated in the driver. Typically when you get readings of 0 for all 3 measurements, then the I 2 C bus is likely \"frozen\". The expected result for I2CSCAN on the console is {\"I2CScan\":\"Error 4 at 0x01\"} . A restart ( Restart 1 ) of Tasmota should be enough, but you may need to power cycle the device. Different ESP Cores may lead to different behavior. It is possible to flash incorrect firmware to a sensor (chirp vs non-chirp). This will very likely lead to nonsense temperature readings. Multiple sensors on one I 2 C bus were tested successfully, but are not guaranteed to work due to multiple possible reasons (power, cabling, ...). Your mileage may vary.","title":"Chirp! moisture sensor"},{"location":"Moisture-Sensor-and-Chirp%21-Sensor/#connecting-to-an-esp82xx","text":"Use a standard I 2 C connection plus 3.3V and GND.","title":"Connecting to an ESP82xx"},{"location":"Moisture-Sensor-and-Chirp%21-Sensor/#device-configuration","text":"In the Configuration -> Configure Other page, enter and activate the following template: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,0,0,0,6,5,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} BASE: Generic (18) GPIO4 : I2C SDA (06) GPIO5 : I2C SCL (05) At boot time the driver will scan the I 2 C bus for CHIRP moisture sensors and enumerate them starting with 0. The sensor has a default I 2 C address of 0x20 , which can be changed within the driver so that multiple sensors are possible. Write access to the sensor is potentially dangerous!! Only change the I 2 C address while only one is sensor connected, using a stable power supply, and if you are familiar with how to flash the sensor.","title":"Device Configuration"},{"location":"Moisture-Sensor-and-Chirp%21-Sensor/#commands","text":"Command Description CHIRPSCAN Re-scan the I 2 C bus and re-enumerate the sensors. CHIRPSELECT Select the active sensor, which can receive commands. To select the first sensor use CHIRPSELECT 0 . CHIRPSET Set the new I 2 C address for the selected sensor. Use decimal address. To change active sensor to 0x1f (=31) use CHIRPSET 31 . CHIRPSLEEP Put the selected sensor into sleep mode. CHIRPWAKE Wake the selected (sleeping) sensor. CHIRPRESET Reset the selected sensor.","title":"Commands"},{"location":"Moisture-Sensor-and-Chirp%21-Sensor/#sensor-readings","text":"The original explanation from the manufacturer can be found on this tindie page . It is important to understand, that the light sensor does not provide LUX but a relative reading ( 0..65535 ), where more light means a lower value! The term DARKNESS is used in Tasmota. !! \u26a0\ufe0f PLEASE USE TelePeriod OF 20 OR GREATER \u26a0\ufe0f !! The driver will sync with the TelePeriod and start the measure cycle about 17 seconds before the next telemetry message. You can issue a Status 8 and any time to output that last sensor readings.","title":"Sensor readings"},{"location":"Moisture-Sensor-and-Chirp%21-Sensor/#known-issues","text":"The sensor is relatively slow and therefore the driver will (try to) slow down the I 2 C bus-speed and extend the CLOCKSTRETCHLIMIT. A long discussion about it can be found here . The problem seems to occur mostly when the sensor wakes up from sleep. That is why the implemented auto-sleep-wake function is currently deactivated in the driver. Typically when you get readings of 0 for all 3 measurements, then the I 2 C bus is likely \"frozen\". The expected result for I2CSCAN on the console is {\"I2CScan\":\"Error 4 at 0x01\"} . A restart ( Restart 1 ) of Tasmota should be enough, but you may need to power cycle the device. Different ESP Cores may lead to different behavior. It is possible to flash incorrect firmware to a sensor (chirp vs non-chirp). This will very likely lead to nonsense temperature readings. Multiple sensors on one I 2 C bus were tested successfully, but are not guaranteed to work due to multiple possible reasons (power, cabling, ...). Your mileage may vary.","title":"Known issues"},{"location":"NRF24L01/","text":"NRF24L01 module ~ This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #define USE_SPI // Hardware SPI using GPIO12(MISO), GPIO13(MOSI) and GPIO14(CLK) in addition to two user selectable GPIOs(CS and DC) #ifndef USE_NRF24 #define USE_NRF24 // Add SPI support for RF24L01(+) (+2k6 code) #define USE_MIBLE // BLE-bridge for some Mijia-BLE-sensors (+4k7 code) #endif This chip is manufactured by Nordic Semiconductors as a single chip transceiver in the 2,4 GHz band. There are many applications of this chip in many projects as a versatile very low cost wireless module. In recent years solutions were found to use this chip for limited Bluetooth-Low-Energy communication. One of the first articles about this topic can be found here . Subsequently, further work was done by several developers and a working bridge to read sensor data from a Xiaomi MJ_HT_V1 BLE sensor was created. The fundamental principle is, that some of these sensors send its data as a usual BLE-advertisement packet with a proprietary data format at the end of the payload. These packets had to fit into the 32 bytes of the FIFO-RX-buffer of the RF24L01, otherwise the \"later\" bytes were lost. A new solution was found for the Tasmota driver. The basic idea is to use some constant ID-bytes of the BLE-packets as the PDU-type for the NRF24l01. Thus, all bytes before these ID-bytes are lost and the size restriction for the payload is successfully circumvented. That way it is possible to read the sensor data from a Mi Flora sensor, which is positioned outside of the 32-byte-range. Of course there is still no bidirectional \"real\" BLE-communication, only advertisements can be read. Configuration ~ Wiring ~ Configure the pins for SPI_DC and SPI_CS while connecting the hardware SPI pins 12 - 14 (MOSI, MISO and CLOCK). Tip In order to simplify the code, the pin names from the SPI-display-drivers are used in the webUI! For nRF24L01 SPI_DC translates to CSN and SPI_CS to CE. Warning Even slightly loose cables can lead to malfunctions of the SPI-data-transfer. This can produce a Software WDT reset. Tasmota Settings ~ No additional steps are necessary. The initial log should like this: 00 : 00 : 00 NRF24L01 initialized 00 : 00 : 00 NRF24L01 + detected 00 : 00 : 00 MIBLE : started The driver will do the rest automatically and start to look for known \"special\" packets, which will be used to extract the sensor readings. webUI and TELE-messages will be populated with sensor data. This can take a while after start and may be influenced by the general traffic on the 2,4 GHz band. For a complete overview of supported devices, commands and features read the Bluetooth article .","title":"NRF24L01 module"},{"location":"NRF24L01/#nrf24l01-module","text":"This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #define USE_SPI // Hardware SPI using GPIO12(MISO), GPIO13(MOSI) and GPIO14(CLK) in addition to two user selectable GPIOs(CS and DC) #ifndef USE_NRF24 #define USE_NRF24 // Add SPI support for RF24L01(+) (+2k6 code) #define USE_MIBLE // BLE-bridge for some Mijia-BLE-sensors (+4k7 code) #endif This chip is manufactured by Nordic Semiconductors as a single chip transceiver in the 2,4 GHz band. There are many applications of this chip in many projects as a versatile very low cost wireless module. In recent years solutions were found to use this chip for limited Bluetooth-Low-Energy communication. One of the first articles about this topic can be found here . Subsequently, further work was done by several developers and a working bridge to read sensor data from a Xiaomi MJ_HT_V1 BLE sensor was created. The fundamental principle is, that some of these sensors send its data as a usual BLE-advertisement packet with a proprietary data format at the end of the payload. These packets had to fit into the 32 bytes of the FIFO-RX-buffer of the RF24L01, otherwise the \"later\" bytes were lost. A new solution was found for the Tasmota driver. The basic idea is to use some constant ID-bytes of the BLE-packets as the PDU-type for the NRF24l01. Thus, all bytes before these ID-bytes are lost and the size restriction for the payload is successfully circumvented. That way it is possible to read the sensor data from a Mi Flora sensor, which is positioned outside of the 32-byte-range. Of course there is still no bidirectional \"real\" BLE-communication, only advertisements can be read.","title":"NRF24L01 module"},{"location":"NRF24L01/#configuration","text":"","title":"Configuration"},{"location":"NRF24L01/#wiring","text":"Configure the pins for SPI_DC and SPI_CS while connecting the hardware SPI pins 12 - 14 (MOSI, MISO and CLOCK). Tip In order to simplify the code, the pin names from the SPI-display-drivers are used in the webUI! For nRF24L01 SPI_DC translates to CSN and SPI_CS to CE. Warning Even slightly loose cables can lead to malfunctions of the SPI-data-transfer. This can produce a Software WDT reset.","title":"Wiring"},{"location":"NRF24L01/#tasmota-settings","text":"No additional steps are necessary. The initial log should like this: 00 : 00 : 00 NRF24L01 initialized 00 : 00 : 00 NRF24L01 + detected 00 : 00 : 00 MIBLE : started The driver will do the rest automatically and start to look for known \"special\" packets, which will be used to extract the sensor readings. webUI and TELE-messages will be populated with sensor data. This can take a while after start and may be influenced by the general traffic on the 2,4 GHz band. For a complete overview of supported devices, commands and features read the Bluetooth article .","title":"Tasmota Settings"},{"location":"NodeRed/","text":"Home automation system examples with Pi, Tasmota and Node-Red Detailed setting up Node-Red and mosquitto on a Raspberry PI and initial control of a Sonoff Switch: https://www.instructables.com/id/Powerful-Standalone-Home-Automation-System-Pi-Sono/ Detailed setting up of sensors and LEDs using Tasmota: https://www.instructables.com/id/Home-Automation-Sonoff-Tasmota-Sensors-LEDs-Develo// Credits: @MikePRoberts ESP8266 OTA Firmware Upgrade Manager and Server https://flows.nodered.org/flow/888b4cd95250197eb429b2f40d188185 Dynamically Populate Dashboard with Buttons to Tasmota-Sonoff Devices https://flows.nodered.org/flow/1541bcbba48bb088ec1503dba109f63c","title":"NodeRed"},{"location":"OTA-over-SCP/","text":"How to setup and configure \"OTA over SCP\" upload for PlatformIO. The uploader pushes .bin files to remote OTA server using SCP (SSH connection). Images can be served to Tasmotas from there. Configuration ~ To upload .bin images to OTA server using SCP, edit the following lines under target environment: ; *** Upload file to OTA server using SCP upload_port = USER @ HOST : / path extra_scripts = pio / sftp - uploader . py upload_port should be modified to reflect user, host and path on the host where images should be uploaded. Requirements ~ SSH communication between the build server and OTA server should be pre-configured so that it doesn't require password (pre-shared keys). Add the pre-shared key ~ On a linux client machine type the following to generate the key. Press enter three times (without any input): ssh-keygen -t rsa -C \"YOUR OWN KEY DESCRIPTION\" Copy the key to your ssh server. You need to confirm this action. Use your server ssh password (one last time): ssh-copy-id -i ~/.ssh/id_rsa.pub USER@HOST Optionally, reload the ssh service: sudo /etc/init.d/ssh restart Upload Tasmota ~ Easy compilation and upload can be performed from the icons at the left side of the PlatformIO screen or use Ctrl + Alt + U to upload (will build if needed).","title":"OTA over SCP"},{"location":"OTA-over-SCP/#configuration","text":"To upload .bin images to OTA server using SCP, edit the following lines under target environment: ; *** Upload file to OTA server using SCP upload_port = USER @ HOST : / path extra_scripts = pio / sftp - uploader . py upload_port should be modified to reflect user, host and path on the host where images should be uploaded.","title":"Configuration"},{"location":"OTA-over-SCP/#requirements","text":"SSH communication between the build server and OTA server should be pre-configured so that it doesn't require password (pre-shared keys).","title":"Requirements"},{"location":"OTA-over-SCP/#add-the-pre-shared-key","text":"On a linux client machine type the following to generate the key. Press enter three times (without any input): ssh-keygen -t rsa -C \"YOUR OWN KEY DESCRIPTION\" Copy the key to your ssh server. You need to confirm this action. Use your server ssh password (one last time): ssh-copy-id -i ~/.ssh/id_rsa.pub USER@HOST Optionally, reload the ssh service: sudo /etc/init.d/ssh restart","title":"Add the pre-shared key"},{"location":"OTA-over-SCP/#upload-tasmota","text":"Easy compilation and upload can be performed from the icons at the left side of the PlatformIO screen or use Ctrl + Alt + U to upload (will build if needed).","title":"Upload Tasmota"},{"location":"Octoprint/","text":"OctoPrint ~ OctoPrint provides a snappy web interface for controlling consumer 3D printers. It is Free Software and released under the GNU Affero General Public License V3 by Gina H\u00e4u\u00dfge. Its website can be found at http://www.octoprint.org . OctoPrint-Tasmota ~ Jneilliii wrote a plugin to control your Sonoff device with tasmota firmware via OctoPrint, for example shutdown the printer after a print has finished. Repository: https://github.com/jneilliii/OctoPrint-Tasmota","title":"OctoPrint"},{"location":"Octoprint/#octoprint","text":"OctoPrint provides a snappy web interface for controlling consumer 3D printers. It is Free Software and released under the GNU Affero General Public License V3 by Gina H\u00e4u\u00dfge. Its website can be found at http://www.octoprint.org .","title":"OctoPrint"},{"location":"Octoprint/#octoprint-tasmota","text":"Jneilliii wrote a plugin to control your Sonoff device with tasmota firmware via OctoPrint, for example shutdown the printer after a print has finished. Repository: https://github.com/jneilliii/OctoPrint-Tasmota","title":"OctoPrint-Tasmota"},{"location":"OpenTherm/","text":"This feature is not included in precompiled binaries. To use it, you must compile your build . Add the following to user_config_override.h : #ifndef USE_OPENTHERM #define USE_OPENTHERM #endif Implementation of OpenTherm protocol OpenTherm integration is based on OpenTherm protocol specification v2.2 and works with all OpenTherm compatible boilers. OpenTherm protocol requires a simple low voltage two-wire connection to the boiler, but voltage levels (7..15V) still much higher than ESP8266 levels, which requires OpenTherm Adapter. Compatible Open Therm Adapters ~ Ihor Melnyk OpenTherm Adapter OpenTherm Gateway Arduino shield Both adapters have a fully isolated circuit from the boiler. However, please be aware that you can damage your boiler. You may also void your boiler warranty by installing this hardware. Please consult with your boiler manufacturer. Note For my home automation project, I used OpenTherm Gateway Arduino shield ; however, this project uses OpenTherm library from Ihor Melnyk . I assume both adapters will work. Please note, this integration does not work with the OTGW . You might want to take a look at the HA OpenTherm GW Connecting to the Boiler ~ Current integration acts as a master to the boiler. Note If OpenTherm master device is present, the boiler may disable it's front panel controls. Users may not be able to set a boiler and hot water temperature through the boiler. Now it's the responsibility of the master device. This behavior might vary across different boilers. You may disable this behavior by removing OpenTherm Slave Status command. However, the integration will not be able to read flame/heating/failure flags. OpenTherm Gateway Arduino shield support a gateway mode. As of now, this mode does not supported by the integration. As of now, gateway mode is not supported Setting Up Tasmota ~ Note You need to define USE_OPENTHERM and rebuild Tasmota to enable OpenTherm integration. Log into your Tasmota device Go to Configuration -> Configure Module Select Generic module type, save & restart In the Module parameters window, assign OpenTherm RX and OpenTherm TX to the corresponding pins Save settings and restart Note The integration attaches ISR to the RX GPIO to avoid pooling. That GPIO should support interrupts. Please consider this while working on the schematics. Troubleshooting ~ In order to troubleshoot you may need to enable Debug or More Debug logging level, After restart you might see the following in the logs: 00 : 00 : 00 CFG : Loaded from flash at 3 F7 , Count 72 00 : 00 : 00 QPC : Flag 0 E 00 : 00 : 00 CFG : CR 338 / 699 00 : 00 : 00 SRC : Restart 00 : 00 : 00 Project tasmota Tasmota Version 8.2.0 ( sensors ) - STAGE 00 : 00 : 01 [ OTH ] : perform handshake 00 : 00 : 01 [ OTH ] : Processing response . Status = SUCCESS , Response = 0x4003011B 00 : 00 : 01 [ OTH ] : getLastResponseStatus SUCCESS . Slave Cfg : 4003011 B 00 : 00 : 01 [ OTH ] : Processing response . Status = SUCCESS , Response = 0xC0000000 00 : 00 : 02 [ OTH ] : Setting Boiler Temp . Old : 0 , New : 85 00 : 00 : 02 [ OTH ] : Processing response . Status = SUCCESS , Response = 0xD0015500 00 : 00 : 02 [ OTH ] : Setting Hot Water Temp . Old : 0 , New : 37 12 : 34 : 58 [ OTH ] : Processing response . Status = INVALID , Response = 0x70730000 12 : 34 : 58 [ OTH ] : command OEMD is not supported by the boiler . Last status : INVALID 12 : 35 : 00 [ OTH ] : Processing response . Status = INVALID , Response = 0xF01B0000 12 : 35 : 00 [ OTH ] : command TOUT is not supported by the boiler . Last status : INVALID 12 : 35 : 00 [ OTH ] : Processing response . Status = INVALID , Response = 0x701C0000 12 : 35 : 00 [ OTH ] : command TRET is not supported by the boiler . Last status : INVALID 12 : 35 : 16 MQT : tele / boiler / SENSOR = { \"Time\" : \"2020-05-12T12:35:16\" , \"ANALOG\" :{ \"A0\" : 7 } , \"OPENTHERM\" :{ \"conn\" : \"BUSY\" , \"settings\" : 3 , \"SLAVE\" :{ \"FAULT\" : 0 , \"CH\" : 0 , \"DHW\" : 0 , \"FL\" : 0 , \"COOL\" : 0 , \"CH2\" : 0 , \"DIAG\" : 0 , \"RAW\" : 3221225472 } , \"BTMP\" :{ \"FAULT\" : 0 , \"REQ\" : 85.0 , \"ACT\" : 85.0 } , \"HWTMP\" :{ \"REQ\" : 37.0 , \"ACT\" : 37.0 } , \"ASFF\" :{ \"FC\" : 0 , \"OFC\" : 0 } , \"FLM\" : 0.0 , \"TB\" : 31.0 , \"TDHW\" : 30.0 , \"DHWS\" : 37.0 , \"TMAX\" : 0.0 }} In the example, perform handshake was successful, and the OpenTherm integration started to fetch various OpenTherm statuses. Note Your boiler may not respond to some of the OpenTherm commands. The integration made 3 attempts to execute the command. If the third attempt failed, the command marked as not supported and excluded from the rotation. External Thermostat Wiring and Safety ~ Central heating is the last thing you want to fail in your home. You might have significant damage to your property in case of the software bug or your custom hardware or wiring failure. As a last resort measure, you probably want to use some sort of mechanical thermostat, which turns on your boiler if the temperature drops below the safe threshold. In the worst-case scenario, your OpenTherm hardware stop communicating with the boiler. Proper boiler implementation will flag external panel error and take control back, following the external thermostat circuit state. The second issue can be with your thermostat logic, especially if your logic is running on some external device. To address this, OpenTherm integration is using Diagnostics Indication to enable central heating. That way, if your external thermostat report freezing condition, OpenTherm integration activates heating. To enable this option, set the CHOD flag. Note Another use case for the CHOD flag might be an external hot water tank storage using central heating to heat the hot water in the tank. Configuration ~ OpenTherm integration supports the following commands. ot_flags Get/Set OpenTherm flags ot_tboiler Get/Set central heating temperature ot_twater Get/Set domestic hot water temperature ot_save_setpoints Save central heating and domestic hot water temperatures ot_ch Activate/Deactivate central heating ot_flags command ~ OpenTherm integration supports the following flags: CHOD - Enable CH (central heating) on diagnostics flag. See External Thermostat section DHW - Enable Domestic Hot Water. If you have an on-demand gas heater, it won't start heating immediately, but enable heating when water is on CH - If set, activate central heating permanently, following the ot_tboiler setpoint value. If disabled and CHOD is set, it follows the Diagnostics flag. Otherwise, heating is controlled by the ot_ch status COOL - Enable cooling, if supported. Refer to your boiler manual. OTC - Enable external temperature compensation thermistor. Refer to your boiler manual. CH2 - Enable auxiliary central heating. Refer to your boiler manual. Note During the first run, ot_flags is set to the CHOD,DHW . Hot water setpoint set to 36-degree Celsius and central heating temperature set to 85 degree celsius To get OpenTherm flags, type ot_flags 13 : 49 : 48 CMD : ot_flags 13 : 49 : 48 MQT : stat /boiler/ RESULT = CHOD , DHW To set OpenTherm flags, type ot_flags DHW,CH,OTC 13 : 49 : 48 CMD : ot_flags DHW , CH , OTC 13 : 49 : 48 MQT : stat /boiler/ RESULT = DHW , CH , OTC ot_tboiler command ~ ot_tboiler set boiler (CH) desired temperature. The actual command to the boiler will be issued if your new temperature difference bigger than the OPENTHERM_BOILER_SETPOINT_TOLERANCE value which is 1-degree Celsius as of today. 14 : 12 : 04 CMD : ot_tboiler 14 : 12 : 04 MQT : stat /boiler/ RESULT = { \"ot_tboiler\" : 60.0 } 14 : 12 : 55 CMD : ot_tboiler 85 14 : 12 : 55 MQT : stat / boiler / RESULT = { \"ot_tboiler\" : 85.0 } 14 : 12 : 57 [ OTH ] : Setting Boiler Temp . Old : 60 , New : 85 Note Some boilers might write setpoint temperature into the Flash memory. Having PID controlled appliance may produce a lot of small fluctuations in the setpoint value, wearing out Boiler flash memory. Warning ot_tboiler do not write the value in the Tasmota settings, reducing Flash memory writes. To store it permanently, invoke ot_save_setpoints command after ot_tboiler command ot_twater command ~ ot_twater set domestic hot water temperature setpoint (DHW). Warning ot_twater do not write the value in the Tasmota settings. To store it permanently, invoke ot_save_setpoints command after ot_twater command. 14 : 13 : 55 CMD : ot_twater 14 : 13 : 55 MQT : stat /boiler/ RESULT = { \"ot_twater\" : 38.0 } 14 : 13 : 55 CMD : ot_twater 40 14 : 13 : 55 MQT : stat /boiler/ RESULT = { \"ot_twater\" : 40.0 } ot_save_setpoints command ~ ot_save_setpoints store boiler and domestic hot water setpoints into the flash memory of the Tasmota. ot_ch command ~ ot_ch enable or disable central heating (CH). The Boiler follows the ot_tboiler temperature setpoint. 14 : 14 : 57 CMD : ot_ch 14 : 14 : 57 MQT : stat /boiler/ RESULT = { \"ot_ch\" : 0 } 14 : 15 : 57 CMD : ot_ch 1 14 : 15 : 57 MQT : stat /boiler/ RESULT = { \"ot_ch\" : 1 } Warning ot_ch 0 won't turn the boiler off, if CHOD flag is set and external thermostat requires heat Setting Hot Water temperature ~ One of the drawbacks, at least with my boiler, is that the boiler disables all the external knobs, so I can not set up the desired hot water temperature from the boiler itself. You might come up with the automation, setting hot water temperature by some schedule. Another way is to use Home Assistant with the HomeKit integration. I created MQTT Hot Water Heater integration to the Home Assistant, so the Water Heater is exposed to the Home Kit. You should be able to install it through HACS You can add the following configuration into the configuration.yaml of your Home Assistant set up. water_heater : platform : mqtt_water_heater name : \"Water Heater\" state_topic : \"tele/boiler/SENSOR\" command_topic : \"cmnd/boiler/OT_TWATER\" value_template : \"{{ value_json.OPENTHERM.DHWS }}\" qos : 0 availability_topic : \"tele/boiler/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" target_temperature : 38 heater_min_temperature : 35 heater_max_temperature : 50 Automation Examples ~ This automation example turns on then Bathroom towel heater if someone is using hot water more than 5 minutes in the evening or more than 7 minutes in the evening. Bathroom towel heater has a coolant pump relay at 192.168.1.xx Also, it always turns on the heater on Clock#Timer3 event, working according to the schedule It publishes state to the st/boiler/rr_dry for the Home Assistant bookkeeping. Also, it set boiler temperature to the %var3% value if external heating is required during the bathroom Dry mode. Also, it syncs up the coolant pump state in case of the pump controller power outage. # var1 - hot water ON time to enable bathroom Dry mode # var2 - Bathroom Dry Mode boiler setpoint # var3 - Normal Mode boiler setpoint # var15 - a lock of the flame mode to avoid timer restart # var16 - sync power4 state # use VAR3 to set the actual boiler temperature setpoint # If heat demand is on during RR Dry Mode, the temperature should be set back to the normal Rule1 on system #boot do backlog TelePeriod 20; var1=540; var2=60; var3=85; var15 0; var16 0 endon on tele - OPENTHERM #SLAVE#FL do WebSend [192.168.1.xx] POWER4 %var16%; endon on Clock #Timer=1 do var1=300 endon on Clock #Timer=2 do var1=420 endon on Clock #Timer=3 do event dr=1 endon on var3 #state do ot_tboiler %value% endon Rule2 on tele - OPENTHERM #SLAVE#DHW>%var15% do backlog RuleTimer1 %var1%; var15 1 endon on tele - OPENTHERM #SLAVE#DHW=0 do backlog RuleTimer1 0; var15 0 endon on Rules #Timer=2 do backlog ot_ch 0; ot_tboiler %var3%; var16 0; WebSend [192.168.1.xx] POWER4 OFF; publish st/boiler/rr_dry 0 endon on Rules #Timer=1 do event dr=1 endon on event #dr do backlog RuleTimer2 7200; ot_ch 1; ot_tboiler %var2%; var16 1; WebSend [192.168.1.xx] POWER4 ON; publish st/boiler/rr_dry 1 endon Rule3 on tele - OPENTHERM #SLAVE#DIAG=1 do ot_tboiler %var3%; endon on tele - OPENTHERM #SLAVE#DIAG=0 do ot_tboiler %var2%; endon","title":"OpenTherm"},{"location":"OpenTherm/#compatible-open-therm-adapters","text":"Ihor Melnyk OpenTherm Adapter OpenTherm Gateway Arduino shield Both adapters have a fully isolated circuit from the boiler. However, please be aware that you can damage your boiler. You may also void your boiler warranty by installing this hardware. Please consult with your boiler manufacturer. Note For my home automation project, I used OpenTherm Gateway Arduino shield ; however, this project uses OpenTherm library from Ihor Melnyk . I assume both adapters will work. Please note, this integration does not work with the OTGW . You might want to take a look at the HA OpenTherm GW","title":"Compatible Open Therm Adapters"},{"location":"OpenTherm/#connecting-to-the-boiler","text":"Current integration acts as a master to the boiler. Note If OpenTherm master device is present, the boiler may disable it's front panel controls. Users may not be able to set a boiler and hot water temperature through the boiler. Now it's the responsibility of the master device. This behavior might vary across different boilers. You may disable this behavior by removing OpenTherm Slave Status command. However, the integration will not be able to read flame/heating/failure flags. OpenTherm Gateway Arduino shield support a gateway mode. As of now, this mode does not supported by the integration. As of now, gateway mode is not supported","title":"Connecting to the Boiler"},{"location":"OpenTherm/#setting-up-tasmota","text":"Note You need to define USE_OPENTHERM and rebuild Tasmota to enable OpenTherm integration. Log into your Tasmota device Go to Configuration -> Configure Module Select Generic module type, save & restart In the Module parameters window, assign OpenTherm RX and OpenTherm TX to the corresponding pins Save settings and restart Note The integration attaches ISR to the RX GPIO to avoid pooling. That GPIO should support interrupts. Please consider this while working on the schematics.","title":"Setting Up Tasmota"},{"location":"OpenTherm/#troubleshooting","text":"In order to troubleshoot you may need to enable Debug or More Debug logging level, After restart you might see the following in the logs: 00 : 00 : 00 CFG : Loaded from flash at 3 F7 , Count 72 00 : 00 : 00 QPC : Flag 0 E 00 : 00 : 00 CFG : CR 338 / 699 00 : 00 : 00 SRC : Restart 00 : 00 : 00 Project tasmota Tasmota Version 8.2.0 ( sensors ) - STAGE 00 : 00 : 01 [ OTH ] : perform handshake 00 : 00 : 01 [ OTH ] : Processing response . Status = SUCCESS , Response = 0x4003011B 00 : 00 : 01 [ OTH ] : getLastResponseStatus SUCCESS . Slave Cfg : 4003011 B 00 : 00 : 01 [ OTH ] : Processing response . Status = SUCCESS , Response = 0xC0000000 00 : 00 : 02 [ OTH ] : Setting Boiler Temp . Old : 0 , New : 85 00 : 00 : 02 [ OTH ] : Processing response . Status = SUCCESS , Response = 0xD0015500 00 : 00 : 02 [ OTH ] : Setting Hot Water Temp . Old : 0 , New : 37 12 : 34 : 58 [ OTH ] : Processing response . Status = INVALID , Response = 0x70730000 12 : 34 : 58 [ OTH ] : command OEMD is not supported by the boiler . Last status : INVALID 12 : 35 : 00 [ OTH ] : Processing response . Status = INVALID , Response = 0xF01B0000 12 : 35 : 00 [ OTH ] : command TOUT is not supported by the boiler . Last status : INVALID 12 : 35 : 00 [ OTH ] : Processing response . Status = INVALID , Response = 0x701C0000 12 : 35 : 00 [ OTH ] : command TRET is not supported by the boiler . Last status : INVALID 12 : 35 : 16 MQT : tele / boiler / SENSOR = { \"Time\" : \"2020-05-12T12:35:16\" , \"ANALOG\" :{ \"A0\" : 7 } , \"OPENTHERM\" :{ \"conn\" : \"BUSY\" , \"settings\" : 3 , \"SLAVE\" :{ \"FAULT\" : 0 , \"CH\" : 0 , \"DHW\" : 0 , \"FL\" : 0 , \"COOL\" : 0 , \"CH2\" : 0 , \"DIAG\" : 0 , \"RAW\" : 3221225472 } , \"BTMP\" :{ \"FAULT\" : 0 , \"REQ\" : 85.0 , \"ACT\" : 85.0 } , \"HWTMP\" :{ \"REQ\" : 37.0 , \"ACT\" : 37.0 } , \"ASFF\" :{ \"FC\" : 0 , \"OFC\" : 0 } , \"FLM\" : 0.0 , \"TB\" : 31.0 , \"TDHW\" : 30.0 , \"DHWS\" : 37.0 , \"TMAX\" : 0.0 }} In the example, perform handshake was successful, and the OpenTherm integration started to fetch various OpenTherm statuses. Note Your boiler may not respond to some of the OpenTherm commands. The integration made 3 attempts to execute the command. If the third attempt failed, the command marked as not supported and excluded from the rotation.","title":"Troubleshooting"},{"location":"OpenTherm/#external-thermostat-wiring-and-safety","text":"Central heating is the last thing you want to fail in your home. You might have significant damage to your property in case of the software bug or your custom hardware or wiring failure. As a last resort measure, you probably want to use some sort of mechanical thermostat, which turns on your boiler if the temperature drops below the safe threshold. In the worst-case scenario, your OpenTherm hardware stop communicating with the boiler. Proper boiler implementation will flag external panel error and take control back, following the external thermostat circuit state. The second issue can be with your thermostat logic, especially if your logic is running on some external device. To address this, OpenTherm integration is using Diagnostics Indication to enable central heating. That way, if your external thermostat report freezing condition, OpenTherm integration activates heating. To enable this option, set the CHOD flag. Note Another use case for the CHOD flag might be an external hot water tank storage using central heating to heat the hot water in the tank.","title":"External Thermostat Wiring and Safety"},{"location":"OpenTherm/#configuration","text":"OpenTherm integration supports the following commands. ot_flags Get/Set OpenTherm flags ot_tboiler Get/Set central heating temperature ot_twater Get/Set domestic hot water temperature ot_save_setpoints Save central heating and domestic hot water temperatures ot_ch Activate/Deactivate central heating","title":"Configuration"},{"location":"OpenTherm/#ot_flags-command","text":"OpenTherm integration supports the following flags: CHOD - Enable CH (central heating) on diagnostics flag. See External Thermostat section DHW - Enable Domestic Hot Water. If you have an on-demand gas heater, it won't start heating immediately, but enable heating when water is on CH - If set, activate central heating permanently, following the ot_tboiler setpoint value. If disabled and CHOD is set, it follows the Diagnostics flag. Otherwise, heating is controlled by the ot_ch status COOL - Enable cooling, if supported. Refer to your boiler manual. OTC - Enable external temperature compensation thermistor. Refer to your boiler manual. CH2 - Enable auxiliary central heating. Refer to your boiler manual. Note During the first run, ot_flags is set to the CHOD,DHW . Hot water setpoint set to 36-degree Celsius and central heating temperature set to 85 degree celsius To get OpenTherm flags, type ot_flags 13 : 49 : 48 CMD : ot_flags 13 : 49 : 48 MQT : stat /boiler/ RESULT = CHOD , DHW To set OpenTherm flags, type ot_flags DHW,CH,OTC 13 : 49 : 48 CMD : ot_flags DHW , CH , OTC 13 : 49 : 48 MQT : stat /boiler/ RESULT = DHW , CH , OTC","title":"ot_flags command"},{"location":"OpenTherm/#ot_tboiler-command","text":"ot_tboiler set boiler (CH) desired temperature. The actual command to the boiler will be issued if your new temperature difference bigger than the OPENTHERM_BOILER_SETPOINT_TOLERANCE value which is 1-degree Celsius as of today. 14 : 12 : 04 CMD : ot_tboiler 14 : 12 : 04 MQT : stat /boiler/ RESULT = { \"ot_tboiler\" : 60.0 } 14 : 12 : 55 CMD : ot_tboiler 85 14 : 12 : 55 MQT : stat / boiler / RESULT = { \"ot_tboiler\" : 85.0 } 14 : 12 : 57 [ OTH ] : Setting Boiler Temp . Old : 60 , New : 85 Note Some boilers might write setpoint temperature into the Flash memory. Having PID controlled appliance may produce a lot of small fluctuations in the setpoint value, wearing out Boiler flash memory. Warning ot_tboiler do not write the value in the Tasmota settings, reducing Flash memory writes. To store it permanently, invoke ot_save_setpoints command after ot_tboiler command","title":"ot_tboiler command"},{"location":"OpenTherm/#ot_twater-command","text":"ot_twater set domestic hot water temperature setpoint (DHW). Warning ot_twater do not write the value in the Tasmota settings. To store it permanently, invoke ot_save_setpoints command after ot_twater command. 14 : 13 : 55 CMD : ot_twater 14 : 13 : 55 MQT : stat /boiler/ RESULT = { \"ot_twater\" : 38.0 } 14 : 13 : 55 CMD : ot_twater 40 14 : 13 : 55 MQT : stat /boiler/ RESULT = { \"ot_twater\" : 40.0 }","title":"ot_twater command"},{"location":"OpenTherm/#ot_save_setpoints-command","text":"ot_save_setpoints store boiler and domestic hot water setpoints into the flash memory of the Tasmota.","title":"ot_save_setpoints command"},{"location":"OpenTherm/#ot_ch-command","text":"ot_ch enable or disable central heating (CH). The Boiler follows the ot_tboiler temperature setpoint. 14 : 14 : 57 CMD : ot_ch 14 : 14 : 57 MQT : stat /boiler/ RESULT = { \"ot_ch\" : 0 } 14 : 15 : 57 CMD : ot_ch 1 14 : 15 : 57 MQT : stat /boiler/ RESULT = { \"ot_ch\" : 1 } Warning ot_ch 0 won't turn the boiler off, if CHOD flag is set and external thermostat requires heat","title":"ot_ch command"},{"location":"OpenTherm/#setting-hot-water-temperature","text":"One of the drawbacks, at least with my boiler, is that the boiler disables all the external knobs, so I can not set up the desired hot water temperature from the boiler itself. You might come up with the automation, setting hot water temperature by some schedule. Another way is to use Home Assistant with the HomeKit integration. I created MQTT Hot Water Heater integration to the Home Assistant, so the Water Heater is exposed to the Home Kit. You should be able to install it through HACS You can add the following configuration into the configuration.yaml of your Home Assistant set up. water_heater : platform : mqtt_water_heater name : \"Water Heater\" state_topic : \"tele/boiler/SENSOR\" command_topic : \"cmnd/boiler/OT_TWATER\" value_template : \"{{ value_json.OPENTHERM.DHWS }}\" qos : 0 availability_topic : \"tele/boiler/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" target_temperature : 38 heater_min_temperature : 35 heater_max_temperature : 50","title":"Setting Hot Water temperature"},{"location":"OpenTherm/#automation-examples","text":"This automation example turns on then Bathroom towel heater if someone is using hot water more than 5 minutes in the evening or more than 7 minutes in the evening. Bathroom towel heater has a coolant pump relay at 192.168.1.xx Also, it always turns on the heater on Clock#Timer3 event, working according to the schedule It publishes state to the st/boiler/rr_dry for the Home Assistant bookkeeping. Also, it set boiler temperature to the %var3% value if external heating is required during the bathroom Dry mode. Also, it syncs up the coolant pump state in case of the pump controller power outage. # var1 - hot water ON time to enable bathroom Dry mode # var2 - Bathroom Dry Mode boiler setpoint # var3 - Normal Mode boiler setpoint # var15 - a lock of the flame mode to avoid timer restart # var16 - sync power4 state # use VAR3 to set the actual boiler temperature setpoint # If heat demand is on during RR Dry Mode, the temperature should be set back to the normal Rule1 on system #boot do backlog TelePeriod 20; var1=540; var2=60; var3=85; var15 0; var16 0 endon on tele - OPENTHERM #SLAVE#FL do WebSend [192.168.1.xx] POWER4 %var16%; endon on Clock #Timer=1 do var1=300 endon on Clock #Timer=2 do var1=420 endon on Clock #Timer=3 do event dr=1 endon on var3 #state do ot_tboiler %value% endon Rule2 on tele - OPENTHERM #SLAVE#DHW>%var15% do backlog RuleTimer1 %var1%; var15 1 endon on tele - OPENTHERM #SLAVE#DHW=0 do backlog RuleTimer1 0; var15 0 endon on Rules #Timer=2 do backlog ot_ch 0; ot_tboiler %var3%; var16 0; WebSend [192.168.1.xx] POWER4 OFF; publish st/boiler/rr_dry 0 endon on Rules #Timer=1 do event dr=1 endon on event #dr do backlog RuleTimer2 7200; ot_ch 1; ot_tboiler %var2%; var16 1; WebSend [192.168.1.xx] POWER4 ON; publish st/boiler/rr_dry 1 endon Rule3 on tele - OPENTHERM #SLAVE#DIAG=1 do ot_tboiler %var3%; endon on tele - OPENTHERM #SLAVE#DIAG=0 do ot_tboiler %var2%; endon","title":"Automation Examples"},{"location":"P1-Smart-Meter/","text":"P1 Smart Meter ~ Reading serial data from a P1 smart meter using a Wemos with Tasmota installed. Tested on the following smart meters: - Kaifa MA105C - De Landis + Gyr, E350 (ZCF110) Schematics ~ The transistor makes sure that the RxD signal is converted and inverted to 3.3v Tasmota Settings ~ In the Configuration -> Configure Module page, select module Generic (18) From the web console set the serial delimiter to 10 (newline). This makes Tasmota publish each line of the telegram separately to mqtt. SerialDelimiter 10 SerialSend 1 For more details see serial-bridge . Example output ~ Below an example of the telegram message published (per line) to mqtt. From here your HA system can process the data required for your needs. 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"/KFM5KAIFA-METER\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-3:0.2.8(42)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:1.0.0(200913101618S)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.1.1(4530303235303030303639363432393136)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:1.8.1(005779.835*kWh)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:1.8.2(005583.617*kWh)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:2.8.1(000000.000*kWh)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:2.8.2(000000.000*kWh)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.14.0(0001)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:1.7.0(00.498*kW)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:2.7.0(00.000*kW)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.7.21(00000)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.7.9(00000)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:99.97.0(1)(0-0:96.7.19)(000101000001W)(2147483647*s)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:32.32.0(00000)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:32.36.0(00000)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.13.1()\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.13.0()\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:31.7.0(002*A)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:21.7.0(00.496*kW)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:22.7.0(00.000*kW)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-1:24.1.0(003)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-1:96.1.0(4730303332353631323736373836373136)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-1:24.2.1(200913100000S)(04139.079*m3)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"!F798\\r\" } Description of each line ~ see also DSMR 5.0 - P1 Companion Standard Header information - { \"SerialReceived\" : \"/KFM5KAIFA-METER\" } Empty line - { \"SerialReceived\" : \"\" } Version information for P1 output - { \"SerialReceived\" : \"1-3:0.2.8(42)\" } Date - time stamp of the P1 message - { \"SerialReceived\" : \"0-0:1.0.0(181227093413W)\" } Equipment identifier - { \"SerialReceived\" : \"0-0:96.1.1(4530303235303030303639363432393136)\" } electricityUsedTariff1 >> Meter Reading electricity delivered to client ( Tariff 1 ) in 0 , 001 kWh - { \"SerialReceived\" : \"1-0:1.8.1(002293.192*kWh)\" } electricityUsedTariff2 >> Meter Reading electricity delivered to client ( Tariff 2 ) in 0 , 001 kWh - { \"SerialReceived\" : \"1-0:1.8.2(002523.640*kWh)\" } Meter Reading electricity delivered by client ( Tariff 1 ) in 0 , 001 kWh - { \"SerialReceived\" : \"1-0:2.8.1(000000.000*kWh)\" } Meter Reading electricity delivered by client ( Tariff 2 ) in 0 , 001 kWh - { \"SerialReceived\" : \"1-0:2.8.2(000000.000*kWh)\" } electricityActiveTariff >> Tariff indicator electricity . The tariff indicator can also be used to switch tariff dependent loads e . g boilers . This is the responsibility of the P1 user - { \"SerialReceived\" : \"0-0:96.14.0(0002)\" } Actual electricity power delivered ( + P ) in 1 Watt resolution - { \"SerialReceived\" : \"1-0:1.7.0(00.474*kW)\" } Actual electricity power received ( - P ) in 1 Watt resolution - { \"SerialReceived\" : \"1-0:2.7.0(00.000*kW)\" } Number of power failures in any phase - { \"SerialReceived\" : \"0-0:96.7.21(00000)\" } Number of long power failures in any phase - { \"SerialReceived\" : \"0-0:96.7.9(00000)\" } Power Failure Event Log ( long power failures ) - { \"SerialReceived\" : \"1-0:99.97.0(1)(0-0:96.7.19)(000101000001W)(2147483647*s)\" } Number of voltage sags in phase L1 - { \"SerialReceived\" : \"1-0:32.32.0(00000)\" } Number of voltage swells in phase L1 - { \"SerialReceived\" : \"1-0:32.36.0(00000)\" } Text message max 1024 characters . - { \"SerialReceived\" : \"0-0:96.13.1()\" } Text message max 1024 characters . - { \"SerialReceived\" : \"0-0:96.13.0()\" } Instantaneous current L1 in A resolution - { \"SerialReceived\" : \"1-0:31.7.0(002*A)\" } Instantaneous active power L1 ( + P ) in W resolution - { \"SerialReceived\" : \"1-0:21.7.0(00.474*kW)\" } Instantaneous active power L1 ( - P ) in W resolution - { \"SerialReceived\" : \"1-0:22.7.0(00.000*kW)\" } Device - Type - { \"SerialReceived\" : \"0-1:24.1.0(003)\" } Equipment identifier ( Gas ) - { \"SerialReceived\" : \"0-1:96.1.0(4730303332353631323736373836373136)\" } GasMeterReadingFiveMinutes >> Last 5 - minute value ( temperature converted ), gas delivered to client in m3 , including decimal values and capture time - { \"SerialReceived\" : \"0-1:24.2.1(181227090000W)(02910.491*m3)\" } { \"SerialReceived\" : \"!5E3E\" } Additional info * Kaifa Meters (Dutch) * DSMR 5.0 - P1 Companion Standard","title":"P1 Smart Meter"},{"location":"P1-Smart-Meter/#p1-smart-meter","text":"Reading serial data from a P1 smart meter using a Wemos with Tasmota installed. Tested on the following smart meters: - Kaifa MA105C - De Landis + Gyr, E350 (ZCF110)","title":"P1 Smart Meter"},{"location":"P1-Smart-Meter/#schematics","text":"The transistor makes sure that the RxD signal is converted and inverted to 3.3v","title":"Schematics"},{"location":"P1-Smart-Meter/#tasmota-settings","text":"In the Configuration -> Configure Module page, select module Generic (18) From the web console set the serial delimiter to 10 (newline). This makes Tasmota publish each line of the telegram separately to mqtt. SerialDelimiter 10 SerialSend 1 For more details see serial-bridge .","title":"Tasmota Settings"},{"location":"P1-Smart-Meter/#example-output","text":"Below an example of the telegram message published (per line) to mqtt. From here your HA system can process the data required for your needs. 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"/KFM5KAIFA-METER\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-3:0.2.8(42)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:1.0.0(200913101618S)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.1.1(4530303235303030303639363432393136)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:1.8.1(005779.835*kWh)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:1.8.2(005583.617*kWh)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:2.8.1(000000.000*kWh)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:2.8.2(000000.000*kWh)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.14.0(0001)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:1.7.0(00.498*kW)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:2.7.0(00.000*kW)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.7.21(00000)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.7.9(00000)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:99.97.0(1)(0-0:96.7.19)(000101000001W)(2147483647*s)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:32.32.0(00000)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:32.36.0(00000)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.13.1()\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.13.0()\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:31.7.0(002*A)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:21.7.0(00.496*kW)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:22.7.0(00.000*kW)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-1:24.1.0(003)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-1:96.1.0(4730303332353631323736373836373136)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-1:24.2.1(200913100000S)(04139.079*m3)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"!F798\\r\" }","title":"Example output"},{"location":"P1-Smart-Meter/#description-of-each-line","text":"see also DSMR 5.0 - P1 Companion Standard Header information - { \"SerialReceived\" : \"/KFM5KAIFA-METER\" } Empty line - { \"SerialReceived\" : \"\" } Version information for P1 output - { \"SerialReceived\" : \"1-3:0.2.8(42)\" } Date - time stamp of the P1 message - { \"SerialReceived\" : \"0-0:1.0.0(181227093413W)\" } Equipment identifier - { \"SerialReceived\" : \"0-0:96.1.1(4530303235303030303639363432393136)\" } electricityUsedTariff1 >> Meter Reading electricity delivered to client ( Tariff 1 ) in 0 , 001 kWh - { \"SerialReceived\" : \"1-0:1.8.1(002293.192*kWh)\" } electricityUsedTariff2 >> Meter Reading electricity delivered to client ( Tariff 2 ) in 0 , 001 kWh - { \"SerialReceived\" : \"1-0:1.8.2(002523.640*kWh)\" } Meter Reading electricity delivered by client ( Tariff 1 ) in 0 , 001 kWh - { \"SerialReceived\" : \"1-0:2.8.1(000000.000*kWh)\" } Meter Reading electricity delivered by client ( Tariff 2 ) in 0 , 001 kWh - { \"SerialReceived\" : \"1-0:2.8.2(000000.000*kWh)\" } electricityActiveTariff >> Tariff indicator electricity . The tariff indicator can also be used to switch tariff dependent loads e . g boilers . This is the responsibility of the P1 user - { \"SerialReceived\" : \"0-0:96.14.0(0002)\" } Actual electricity power delivered ( + P ) in 1 Watt resolution - { \"SerialReceived\" : \"1-0:1.7.0(00.474*kW)\" } Actual electricity power received ( - P ) in 1 Watt resolution - { \"SerialReceived\" : \"1-0:2.7.0(00.000*kW)\" } Number of power failures in any phase - { \"SerialReceived\" : \"0-0:96.7.21(00000)\" } Number of long power failures in any phase - { \"SerialReceived\" : \"0-0:96.7.9(00000)\" } Power Failure Event Log ( long power failures ) - { \"SerialReceived\" : \"1-0:99.97.0(1)(0-0:96.7.19)(000101000001W)(2147483647*s)\" } Number of voltage sags in phase L1 - { \"SerialReceived\" : \"1-0:32.32.0(00000)\" } Number of voltage swells in phase L1 - { \"SerialReceived\" : \"1-0:32.36.0(00000)\" } Text message max 1024 characters . - { \"SerialReceived\" : \"0-0:96.13.1()\" } Text message max 1024 characters . - { \"SerialReceived\" : \"0-0:96.13.0()\" } Instantaneous current L1 in A resolution - { \"SerialReceived\" : \"1-0:31.7.0(002*A)\" } Instantaneous active power L1 ( + P ) in W resolution - { \"SerialReceived\" : \"1-0:21.7.0(00.474*kW)\" } Instantaneous active power L1 ( - P ) in W resolution - { \"SerialReceived\" : \"1-0:22.7.0(00.000*kW)\" } Device - Type - { \"SerialReceived\" : \"0-1:24.1.0(003)\" } Equipment identifier ( Gas ) - { \"SerialReceived\" : \"0-1:96.1.0(4730303332353631323736373836373136)\" } GasMeterReadingFiveMinutes >> Last 5 - minute value ( temperature converted ), gas delivered to client in m3 , including decimal values and capture time - { \"SerialReceived\" : \"0-1:24.2.1(181227090000W)(02910.491*m3)\" } { \"SerialReceived\" : \"!5E3E\" } Additional info * Kaifa Meters (Dutch) * DSMR 5.0 - P1 Companion Standard","title":"Description of each line"},{"location":"PAJ7620/","text":"PAJ7620U2 gesture sensor ~ This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_PAJ7620 #define USE_PAJ7620 // PAJ7620 gesture sensor (I2C address 0x73) (+2.5k code) #endif PAJ7620U2 is an integrated gesture recognition I 2 C sensor from PixArt-Imaging Inc. based on infrared. It also has built-in proximity detection and can sense various properties like position (x,y,z) and speed. Gesture recognition seems to be more stable than with the APDS-9960 , which on the other hand is a lot cheaper. Configuration ~ Wiring ~ Breakout ESP8266 VCC/VIN +3.3VDC GND GND SCL GPIOy SDA GPIOx INT Not used Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) After a reboot the driver will detect the PAJ7620 automatically. After restart Tasmota needs some time to completely configure its state. In this time frame it is likely to miss some gestures. This should stabilize after a few moments. Commands ~ To use the sensor you need to switch to the desired mode of operation with Sensor50 <x> where <x> = 0\u20265 . It will not appear in the webUI but it can be observed via MQTT messages in console. 0 - Off Sensor muted, no readings in Tasmota. 1 - Gesture Mode Reports gesture movement with: \u2003 Up \u2003 Down \u2003 Left \u2003 Right \u2003 Near \u2003 Far \u2003 CW (clockwise rotation) \u2003 CCW (counter-clockwise rotation) As expected, \"Near\" and \"Far\" gestures are tricky and you have to train your movements to catch them. Sometimes the sensor reports \"Near\" and \"Far\" at once (which will be discarded). There is some postprocessing to allow the object (hand or finger) to move into the sensing area and delay the initial direction report (up, down, left, right) to give the chance to trigger (the intended) \"Near\" or \"Far\" movement. Especially \"Far\" is a bit harder to achieve. example: \u2026{Up:1} = up gesture once \u2026{Left:3} = left gesture 3 times in a row, without any other gesture in between 2 - Proximity Mode Arbitrary values between 0 (far away) and 255 (very near) are given. Exit from the sensor field will always give at least one \"zero message\". tele is only triggered, when the value has changed. example: \u2026{Proximity:255} = close proximity, almost touching the sensor \u2026{Proximity:0} = object has left the sensing area 3 - Corner Mode Sensing area is organised in quarters. An object in one of the corners will trigger the corresponding number. 1 2 3 4 example: \u2026{Corner:2} = object in upper right corner 4 - PIN Mode: A fluent movement of an object through a given sequence of corners (similar to unlocking a smartphone) will trigger a valid \"PIN\". The next corner must be reached in about 0.7 seconds. example: \u2026{PIN:1} = valid PIN 5 - Cursor Mode: Shows x- and y-coordinates. Mainly intended for debugging and \"seeing\" the sensing area. This reads only the upper 5-bit-values, which automatically removes much of the jitter, giving values between 0 and 15. example: \u2026{x:1, y:15} = upper left corner The sensor provides some more goodies, like velocity of an object, so if someone has a fancy use case for this, feel free to open a feature request. Of course it would be possible to mix the modes, but this can produce a lot of MQTT-messages. This could be added later upon user request (based on real world use cases). Breakout boards ~","title":"PAJ7620U2 gesture sensor"},{"location":"PAJ7620/#paj7620u2-gesture-sensor","text":"This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_PAJ7620 #define USE_PAJ7620 // PAJ7620 gesture sensor (I2C address 0x73) (+2.5k code) #endif PAJ7620U2 is an integrated gesture recognition I 2 C sensor from PixArt-Imaging Inc. based on infrared. It also has built-in proximity detection and can sense various properties like position (x,y,z) and speed. Gesture recognition seems to be more stable than with the APDS-9960 , which on the other hand is a lot cheaper.","title":"PAJ7620U2 gesture sensor"},{"location":"PAJ7620/#configuration","text":"","title":"Configuration"},{"location":"PAJ7620/#wiring","text":"Breakout ESP8266 VCC/VIN +3.3VDC GND GND SCL GPIOy SDA GPIOx INT Not used","title":"Wiring"},{"location":"PAJ7620/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) After a reboot the driver will detect the PAJ7620 automatically. After restart Tasmota needs some time to completely configure its state. In this time frame it is likely to miss some gestures. This should stabilize after a few moments.","title":"Tasmota Settings"},{"location":"PAJ7620/#commands","text":"To use the sensor you need to switch to the desired mode of operation with Sensor50 <x> where <x> = 0\u20265 . It will not appear in the webUI but it can be observed via MQTT messages in console.","title":"Commands"},{"location":"PAJ7620/#breakout-boards","text":"","title":"Breakout boards"},{"location":"PCA9685/","text":"PCA9685 12-bit PWM controller ~ Technical Data: Product Information from NXP IMPLEMENTATION STATUS IN TASMOTA ~ The PCA9685 driver is implemented in such a way that it may be used as standard individual OUTPUT pins, or as PWM capable OUTPUT pins - The latter offloads the PWM functionality from the ESP8266 insofar that the PCA9685 will continue to perform its configured output PWM/ON/OFF state without direct control or intervention from the Tasmota firmware. Support was added in line with the datasheet specification insofar that the PWM frequency can be set from 24hz all the way up to 1526hz. This driver does not currently have any perpetual settings so will revert to a base frequency of 50hz (usually suitable for most applications) and will be set in an OFF state for all pins during power-up and/or reset. The latter may change as the driver grows in cases where user requirements and development requirements are met. USAGE OF THE PCA9685 DRIVER IN TASMOTA ~ The driver needs to be connected to the I 2 C bus of your Tasmota powered device (note that most Sonoff devices will not have reachable I 2 C pins so it's applicable to a limited number, so most likely only applicable to bare ESP8266 or WeMos type users. If you modify a Sonoff or similar device to gain access to the I 2 C bus please be aware that other problems may persist and that for such use cases support in Tasmota chat or Issues is not guaranteed in any way whatsoever) The driver is not included during the compilation of the standard released binaries so in order to use this driver you will need to create a development environment for yourself and uncomment these two lines in my_user_config.h #define USE_PCA9685 #define USE_PCA9685_ADDR 0x40 #define USE_PCA9685_FREQ 50 // Support is for 24 to 1526 Hz For information on how to set up a development environment please check the wiki on PlatformIO Note that the I 2 C selection must correspond with how you have wired the module or chip as incorrect addressing will result in the PCA9685 not being detected. The valid I 2 C address range is 0x40 through 0x47 for the PCA9685 and most off-the-shelf modules would likely default to 0x40. If you are unsure please use I2CScan from Tasmota console to scan for devices on the I 2 C bus and you should find a device within the mentioned range. You may also get a discovery on 0x70 but please do not use this address as it is a broadcast address and the driver does not currently support its implementation. Also be aware of other I 2 C devices you have connected to the same Tasmota driven device in order to avoid I 2 C address conflicts. Once connected, correctly flashed, and configured Tasmota will detect the device automatically on startup. DRIVER USAGE ~ There is no web interface for this driver. The driver is used via MQTT or console command using the following available commands and their respective parameters driver15 pwmf,frequency // where frequency is the PWM frequency from 24 to 1526 in Hz driver15 pwm,pin,pwmvalue // where pin = LED pin 0 through 15 and pwmvalue is the pulse width between 0 and 4096 driver15 pwm,pin,ON // Fully turn a specific pin/LED ON driver15 pwm,pin,OFF // Fully turn a specific pin/LED OFF driver15 reset // Reset to power-up settings - i.e. F=50hz and all pins in OFF state driver15 status // Will return a JSON string containing all the current settings / parameters OTHER IMPORTANT INFORMATION ~ Please remember to consider the voltage and current limitations of the chip and per pin output current limitations as outlined in the datasheet. You may also get a discovery on 0x70 but please do not use this address as it is a broadcast address and the driver does not currently support its implementation. Also be aware of other I 2 C devices you have connected to the same Tasmota driven device in order to avoid I 2 C address conflicts. OUTSTANDING FEATURE REQUESTS ~ Dimming ON / OFF a dimming value in a certain time and fade on \"ON / OFF\" (Not yet scheduled for implementation) Allow usage of RGBW in pairs of 4 PWM outputs (i.e. drive 4 x 4pin RGBW LED's) (Not yet scheduled for implementation)","title":"PCA9685 12-bit PWM controller"},{"location":"PCA9685/#pca9685-12-bit-pwm-controller","text":"Technical Data: Product Information from NXP","title":"PCA9685 12-bit PWM controller"},{"location":"PCA9685/#implementation-status-in-tasmota","text":"The PCA9685 driver is implemented in such a way that it may be used as standard individual OUTPUT pins, or as PWM capable OUTPUT pins - The latter offloads the PWM functionality from the ESP8266 insofar that the PCA9685 will continue to perform its configured output PWM/ON/OFF state without direct control or intervention from the Tasmota firmware. Support was added in line with the datasheet specification insofar that the PWM frequency can be set from 24hz all the way up to 1526hz. This driver does not currently have any perpetual settings so will revert to a base frequency of 50hz (usually suitable for most applications) and will be set in an OFF state for all pins during power-up and/or reset. The latter may change as the driver grows in cases where user requirements and development requirements are met.","title":"IMPLEMENTATION STATUS IN TASMOTA"},{"location":"PCA9685/#usage-of-the-pca9685-driver-in-tasmota","text":"The driver needs to be connected to the I 2 C bus of your Tasmota powered device (note that most Sonoff devices will not have reachable I 2 C pins so it's applicable to a limited number, so most likely only applicable to bare ESP8266 or WeMos type users. If you modify a Sonoff or similar device to gain access to the I 2 C bus please be aware that other problems may persist and that for such use cases support in Tasmota chat or Issues is not guaranteed in any way whatsoever) The driver is not included during the compilation of the standard released binaries so in order to use this driver you will need to create a development environment for yourself and uncomment these two lines in my_user_config.h #define USE_PCA9685 #define USE_PCA9685_ADDR 0x40 #define USE_PCA9685_FREQ 50 // Support is for 24 to 1526 Hz For information on how to set up a development environment please check the wiki on PlatformIO Note that the I 2 C selection must correspond with how you have wired the module or chip as incorrect addressing will result in the PCA9685 not being detected. The valid I 2 C address range is 0x40 through 0x47 for the PCA9685 and most off-the-shelf modules would likely default to 0x40. If you are unsure please use I2CScan from Tasmota console to scan for devices on the I 2 C bus and you should find a device within the mentioned range. You may also get a discovery on 0x70 but please do not use this address as it is a broadcast address and the driver does not currently support its implementation. Also be aware of other I 2 C devices you have connected to the same Tasmota driven device in order to avoid I 2 C address conflicts. Once connected, correctly flashed, and configured Tasmota will detect the device automatically on startup.","title":"USAGE OF THE PCA9685 DRIVER IN TASMOTA"},{"location":"PCA9685/#driver-usage","text":"There is no web interface for this driver. The driver is used via MQTT or console command using the following available commands and their respective parameters driver15 pwmf,frequency // where frequency is the PWM frequency from 24 to 1526 in Hz driver15 pwm,pin,pwmvalue // where pin = LED pin 0 through 15 and pwmvalue is the pulse width between 0 and 4096 driver15 pwm,pin,ON // Fully turn a specific pin/LED ON driver15 pwm,pin,OFF // Fully turn a specific pin/LED OFF driver15 reset // Reset to power-up settings - i.e. F=50hz and all pins in OFF state driver15 status // Will return a JSON string containing all the current settings / parameters","title":"DRIVER USAGE"},{"location":"PCA9685/#other-important-information","text":"Please remember to consider the voltage and current limitations of the chip and per pin output current limitations as outlined in the datasheet. You may also get a discovery on 0x70 but please do not use this address as it is a broadcast address and the driver does not currently support its implementation. Also be aware of other I 2 C devices you have connected to the same Tasmota driven device in order to avoid I 2 C address conflicts.","title":"OTHER IMPORTANT INFORMATION"},{"location":"PCA9685/#outstanding-feature-requests","text":"Dimming ON / OFF a dimming value in a certain time and fade on \"ON / OFF\" (Not yet scheduled for implementation) Allow usage of RGBW in pairs of 4 PWM outputs (i.e. drive 4 x 4pin RGBW LED's) (Not yet scheduled for implementation)","title":"OUTSTANDING FEATURE REQUESTS"},{"location":"PID-Control/","text":"This extension adds a PID (Proportional Integral Derivative) feature into the Tasmota software. The PID algorithm is one designed to be used to control real-world processes that the users of Sonoff devices are likely to encounter. This includes room heating/cooling, temperature control when brewing, and a multitude of other processes. The PID tuning parameters are designed to be meaningful in the real world (rather than the abstract Ki Kd Kp that are often used which are completely meaningless to most). The algorithm is based on that in the node-red node node-red-contrib-pid which has been well received. In use it can either regularly be given the current process value via MQTT or if the device has a sensor attached then that sensor can be used to read the process value. So using a TH10 with a DS18B20 the complete PID loop control can be build into the device so that the process will continue to be controlled even if the wifi is down. This is a very cost effective way of achieving PID control. The algorithm allows the relay to be used in a time proportioned way using the Time Proportioned output extension. The loop tuning parameters can be set at build time and can be adjusted at run time via MQTT. To add the feature into the standard Tasmotta s/w (at least version 5.12.0 is required) then have a look at the pid_branch of the tasmota fork at https://github.com/colinl/Sonoff-Tasmota/tree/pid_branch. Pick up from there the files in the folder lib/ProcessControl (which are from this process-control repository ) and sonoff/xdrv_91_timeprop.ino and sonoff/xdrv_92_pid.ino and add them into your Tasmota sources. The PID code adds about 4.3k and the Timeprop code another 1.2k Instructions for setup are in the two xdrv files. The ESP8266 will run the PID algorithm at 1 cycle per second, which is much faster than is needed for the sort of processes Sonoff devices are usually associated with. It rather clobbers the Tasmota terminal output in the web browser at that rate so it is getting near to the limit. The maximum anyone is likely to need it running at is maybe once every 5 seconds, and the majority of home IoT applications probably nearer once per minute would be sufficient, so the device is well up to the task. Help with using the PID algorithm and with loop tuning can be found at http://blog.clanlaw.org.uk/2018/01/09/PID-tuning-with-node-red-contrib-pid.html This is directed towards using the algorithm in the node-red node node-red-contrib-pid but the algorithm here is based on the same code so the tuning technique described there should work just the same. Due to limited hardware availability this has so far only been tested in a Sonoff Basic and a TH10, if there are any issues running this on other hardware let me know. For any issues please submit an issue to the Tasmota fork on gitub or ask on the sonoff mailing list .","title":"PID Control"},{"location":"PIR-Motion-Sensors/","text":"PIR motion sensors, albeit called sensors, are configured as switches in Tasmota since they basically report motion ( 1 ) or no motion ( 0 ) to the device. Most PIR's are single wire and they require connecting to VCC, GND and one GPIO. In this guide we will use GPIO13 as the pin that the PIR output is connected to. See PIN Restrictions on which pins not to use Tasmota Settings ~ In Configuration -> Configure Module menu change GPIO13 to Switch1 . If there already is a Switch1 simply choose the next in line. Same applies if you're connecting more than 1 PIR on a single device. A configured PIR will not appear in the web UI in any form. To make it report like a sensor we need a rule that will send movement triggers to an MQTT topic. SwitchMode1 14 SwitchTopic 0 Rule1 on Switch1#state=1 do publish stat/%topic%/PIR1 ON endon on Switch1#state=0 do Publish stat/%topic%/PIR1 OFF endon Rule1 1 You can change ( PIR1 ) and the message ( ON / OFF ) to whatever suits your needs. %topic% is the configured device topic. Look in console for motion detection messages [20:24:03] stat/%topic%/PIR1 ON to verify everything is working optional: Before using rules configure any GPIO that doesn't have anything connected to it as Relay1 . This creates a dummy relay which is triggered by the PIR so you can see the changes in the web UI. This method is not recommended for daily use and should only be used for testing. A more advanced example of rules with PIRs. AM312 ~ AM312 works even on 3.3v instead of 5v (like HC-SR501) which makes it perfect for ESP8266 devices without a 5V line (like Sonoff Basic). It is also less prone to false triggers due to Wi-Fi interference. Pinout ~ Pin marked VOUT is connected to a free GPIO pin on the device. This PIR goes to off state after a few seconds so we need to use this rule instead of the one in the example. Rule1 on Switch1#state=1 do Backlog Publish stat/%topic%/PIR1 ON; RuleTimer1 30 endon on Rules#Timer=1 do Publish stat/%topic%/PIR1 OFF endon With this it will stay ON for 30 seconds then send OFF message and the timer restarts every time there's an ON trigger. Another use case as a hand wave switch . HC-SR501 ~ Pinout ~ MH-SR602 ~ This is a very small version of a PIR that is able to modify the sensitivity and delay by soldering resistors. With factory settings this PIR goes to off state after a few seconds so we need to use this rule instead of the one in the example. Rule1 on Switch1#state=1 do Backlog Publish stat/%topic%/PIR1 ON; RuleTimer1 30 endon on Rules#Timer=1 do Publish stat/%topic%/PIR1 OFF endon With this it will stay ON for 30 seconds then send OFF message and the timer restarts every time there's an ON trigger. Pinout ~","title":"PIR Motion Sensors"},{"location":"PIR-Motion-Sensors/#tasmota-settings","text":"In Configuration -> Configure Module menu change GPIO13 to Switch1 . If there already is a Switch1 simply choose the next in line. Same applies if you're connecting more than 1 PIR on a single device. A configured PIR will not appear in the web UI in any form. To make it report like a sensor we need a rule that will send movement triggers to an MQTT topic. SwitchMode1 14 SwitchTopic 0 Rule1 on Switch1#state=1 do publish stat/%topic%/PIR1 ON endon on Switch1#state=0 do Publish stat/%topic%/PIR1 OFF endon Rule1 1 You can change ( PIR1 ) and the message ( ON / OFF ) to whatever suits your needs. %topic% is the configured device topic. Look in console for motion detection messages [20:24:03] stat/%topic%/PIR1 ON to verify everything is working optional: Before using rules configure any GPIO that doesn't have anything connected to it as Relay1 . This creates a dummy relay which is triggered by the PIR so you can see the changes in the web UI. This method is not recommended for daily use and should only be used for testing. A more advanced example of rules with PIRs.","title":"Tasmota Settings"},{"location":"PIR-Motion-Sensors/#am312","text":"AM312 works even on 3.3v instead of 5v (like HC-SR501) which makes it perfect for ESP8266 devices without a 5V line (like Sonoff Basic). It is also less prone to false triggers due to Wi-Fi interference.","title":"AM312"},{"location":"PIR-Motion-Sensors/#pinout","text":"Pin marked VOUT is connected to a free GPIO pin on the device. This PIR goes to off state after a few seconds so we need to use this rule instead of the one in the example. Rule1 on Switch1#state=1 do Backlog Publish stat/%topic%/PIR1 ON; RuleTimer1 30 endon on Rules#Timer=1 do Publish stat/%topic%/PIR1 OFF endon With this it will stay ON for 30 seconds then send OFF message and the timer restarts every time there's an ON trigger. Another use case as a hand wave switch .","title":"Pinout"},{"location":"PIR-Motion-Sensors/#hc-sr501","text":"","title":"HC-SR501"},{"location":"PIR-Motion-Sensors/#pinout_1","text":"","title":"Pinout"},{"location":"PIR-Motion-Sensors/#mh-sr602","text":"This is a very small version of a PIR that is able to modify the sensitivity and delay by soldering resistors. With factory settings this PIR goes to off state after a few seconds so we need to use this rule instead of the one in the example. Rule1 on Switch1#state=1 do Backlog Publish stat/%topic%/PIR1 ON; RuleTimer1 30 endon on Rules#Timer=1 do Publish stat/%topic%/PIR1 OFF endon With this it will stay ON for 30 seconds then send OFF message and the timer restarts every time there's an ON trigger.","title":"MH-SR602"},{"location":"PIR-Motion-Sensors/#pinout_2","text":"","title":"Pinout"},{"location":"PN532/","text":"This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_PN532_HSU #define USE_PN532_HSU // Add support for PN532 using HSU (Serial) interface (+1k8 code, 140 bytes mem) // Optional defines, uncomment (remove //) as needed // #define USE_PN532_DATA_FUNCTION // Add sensor40 command support for erase, setting data block content (+1k7 code, 388 bytes mem) // #define USE_PN532_DATA_RAW // Allow DATA block to be used by non-alpha-numberic data (+ 80 bytes code, 48 bytes ram) #endif The PN532 is a highly integrated transceiver module for contactless communication at 13.56 MHz based on the 80C51 microcontroller core. The datasheet for the PN532 chip is available here . Please note that although the datasheet mentions that the PN532 can be used on SPI, I 2 C and HSUART that only the HSU interface is implemented in the Tasmota driver. Configuration ~ #define USE_PN532_CAUSE_EVENTS is replaced with generic rule trigger on pn532#uid= #define USE_PN532_DATA_FUNCTION This function is experimental. There are limitations because it seems not all cards are supported by this driver and/or the PN532 module. See issue 4941 for more information. We are still researching the Wiring ~ As mentioned earlier the PN532 breakout boards usually have pins broken out for all three protocols supported by the PN532 but we are only interested in the HSU interface as that is all the driver currently supports. For this reason breakout boards have either micro dip switches as shown in the image below, or they have pads on the PC board which you need to bridge out with solder to select which mode the PN532 will operate in. After selecting the correct protocol mode and connecting the HSU TX/RX pins of the PN532 to the pins you configured on your ESP8266 board you can power it up and the PN532 should be detected automatically. Wiring ~ PN532 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to PN532 Rx (139) GPIOy to PN532 Tx (138) The module will reboot when you save this configuration. During start-up the following information should be visible in your console output: 00 : 00 : 00 NFC : PN532 NFC Reader detected ( V1 . 6 ) If the device was not found please check your wiring and configuration and confirm that everything is as it should be. Example Configured using Wemos D1 mini on pins: D1 (connected to PN532 SCL) and D2 (connected to PN532 SDA) Usage ~ Tasmota will scan for a new card detect 4 times per second and if found will report it via immediate telemetry. The output on the console will look similar to the below when a new card is detected 18 : 23 : 24 MQT : tele /tasmota/ SENSOR = { \"Time\" : \"2019-01-10T18:23:24\" , \"PN532\" :{ \"UID\" : \"94D8FC5F\" , \"DATA\" : \"\" }} 18 : 23 : 24 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } 18 : 23 : 25 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } The UID of the card/tag is reported and any text stored in BLOCK 1 of a Mifare Classic card (up to 15 characters in length) is reported in the DATA field of the JSON sent via telemetry. Please note that the DATA field cannot contain spaces. The content of the DATA on BLOCK 1 of a Mifare Classic card can be set as follows Sensor40 S,ILOVETASMOTA Once executed the very next card/tag that is presented to the reader will be programmed accordingly and the data will be retained on the card/tag until either changed or erased. To erase the content of the DATA field the following command may be used Sensor40 E Once executed the very next card/tag that is presented to the reader will have its BLOCK 1 erased. Text logging of the above two actions are also presented during the process for information purposes. Using the UID and DATA of a presented card ~ When a card is presented to the PN532 under normal operating conditions up to 3 ways of using the data is possible. The first is the immediate telemetry generated which looks as follows 18 : 31 : 39 MQT : tele /tasmota/ SENSOR = { \"Time\" : \"2019-01-10T18:31:39\" , \"PN532\" :{ \"UID\" : \"94D8FC5F\" , \"DATA\" : \"ILOVETASMOTA\" }} Since this is an immediate telemetry generation as opposed to the sensor data you would normally be expected to be presented when the telemetry period occurs, this telemetry data is not directly usable on the device itself. It is generated and immediately transmitted over MQTT and the purpose of this is so that immediate action may be taken by any home automation software you are using with the data obtained from the card/tag as opposed to waiting for the telemetry period to expire and be sent with normal telemetry data. For the purpose of using card/tag data on the device itself you will need to use rules along with the events that are caused. Example Example rule for responding to a specific UID on the device when a card/tag matching a specific UID is presented rule1 on PN532#UID=94D8FC5F do power on endon Example Example rule for responding to a specific DATA content that was previously programmed to one or more cards using the Sensor40 S,xxxx command Rule 1on EVENT#PN532_DATA=ILOVETASMOTA do power on endon 18 : 41 : 12 MQT : tele /tasmota/ SENSOR = { \"Time\" : \"2019-01-10T18:41:12\" , \"PN532\" :{ \"UID\" : \"94D8FC5F\" , \"DATA\" : \"ILOVETASMOTA\" }} 18 : 41 : 13 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } 18 : 41 : 13 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } 18 : 41 : 13 RUL : EVENT # PN532_DATA = ILOVETASMOTA performs \"power on\" 18 : 41 : 13 MQT : stat /tasmota/ RESULT = { \"POWER\" : \"ON\" } 18 : 41 : 13 MQT : stat /tasmota/ POWER = ON Breakout Boards ~ Since the PN532 chip itself is surface mount and requires some external components to operate the best is probably to obtain a breakout board similar to the one below from your favourite online supplier. Please make sure the breakout board you order has the HSU pins (SCL=TX and SDA=RX) broken out as it will be very difficult to add them manually - Usually they have them but for good measure just make sure.","title":"PN532 NFC reader"},{"location":"PN532/#configuration","text":"#define USE_PN532_CAUSE_EVENTS is replaced with generic rule trigger on pn532#uid= #define USE_PN532_DATA_FUNCTION This function is experimental. There are limitations because it seems not all cards are supported by this driver and/or the PN532 module. See issue 4941 for more information. We are still researching the","title":"Configuration"},{"location":"PN532/#wiring","text":"As mentioned earlier the PN532 breakout boards usually have pins broken out for all three protocols supported by the PN532 but we are only interested in the HSU interface as that is all the driver currently supports. For this reason breakout boards have either micro dip switches as shown in the image below, or they have pads on the PC board which you need to bridge out with solder to select which mode the PN532 will operate in. After selecting the correct protocol mode and connecting the HSU TX/RX pins of the PN532 to the pins you configured on your ESP8266 board you can power it up and the PN532 should be detected automatically.","title":"Wiring"},{"location":"PN532/#wiring_1","text":"PN532 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"PN532/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to PN532 Rx (139) GPIOy to PN532 Tx (138) The module will reboot when you save this configuration. During start-up the following information should be visible in your console output: 00 : 00 : 00 NFC : PN532 NFC Reader detected ( V1 . 6 ) If the device was not found please check your wiring and configuration and confirm that everything is as it should be. Example Configured using Wemos D1 mini on pins: D1 (connected to PN532 SCL) and D2 (connected to PN532 SDA)","title":"Tasmota Settings"},{"location":"PN532/#usage","text":"Tasmota will scan for a new card detect 4 times per second and if found will report it via immediate telemetry. The output on the console will look similar to the below when a new card is detected 18 : 23 : 24 MQT : tele /tasmota/ SENSOR = { \"Time\" : \"2019-01-10T18:23:24\" , \"PN532\" :{ \"UID\" : \"94D8FC5F\" , \"DATA\" : \"\" }} 18 : 23 : 24 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } 18 : 23 : 25 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } The UID of the card/tag is reported and any text stored in BLOCK 1 of a Mifare Classic card (up to 15 characters in length) is reported in the DATA field of the JSON sent via telemetry. Please note that the DATA field cannot contain spaces. The content of the DATA on BLOCK 1 of a Mifare Classic card can be set as follows Sensor40 S,ILOVETASMOTA Once executed the very next card/tag that is presented to the reader will be programmed accordingly and the data will be retained on the card/tag until either changed or erased. To erase the content of the DATA field the following command may be used Sensor40 E Once executed the very next card/tag that is presented to the reader will have its BLOCK 1 erased. Text logging of the above two actions are also presented during the process for information purposes.","title":"Usage"},{"location":"PN532/#using-the-uid-and-data-of-a-presented-card","text":"When a card is presented to the PN532 under normal operating conditions up to 3 ways of using the data is possible. The first is the immediate telemetry generated which looks as follows 18 : 31 : 39 MQT : tele /tasmota/ SENSOR = { \"Time\" : \"2019-01-10T18:31:39\" , \"PN532\" :{ \"UID\" : \"94D8FC5F\" , \"DATA\" : \"ILOVETASMOTA\" }} Since this is an immediate telemetry generation as opposed to the sensor data you would normally be expected to be presented when the telemetry period occurs, this telemetry data is not directly usable on the device itself. It is generated and immediately transmitted over MQTT and the purpose of this is so that immediate action may be taken by any home automation software you are using with the data obtained from the card/tag as opposed to waiting for the telemetry period to expire and be sent with normal telemetry data. For the purpose of using card/tag data on the device itself you will need to use rules along with the events that are caused. Example Example rule for responding to a specific UID on the device when a card/tag matching a specific UID is presented rule1 on PN532#UID=94D8FC5F do power on endon Example Example rule for responding to a specific DATA content that was previously programmed to one or more cards using the Sensor40 S,xxxx command Rule 1on EVENT#PN532_DATA=ILOVETASMOTA do power on endon 18 : 41 : 12 MQT : tele /tasmota/ SENSOR = { \"Time\" : \"2019-01-10T18:41:12\" , \"PN532\" :{ \"UID\" : \"94D8FC5F\" , \"DATA\" : \"ILOVETASMOTA\" }} 18 : 41 : 13 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } 18 : 41 : 13 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } 18 : 41 : 13 RUL : EVENT # PN532_DATA = ILOVETASMOTA performs \"power on\" 18 : 41 : 13 MQT : stat /tasmota/ RESULT = { \"POWER\" : \"ON\" } 18 : 41 : 13 MQT : stat /tasmota/ POWER = ON","title":"Using the UID and DATA of a presented card"},{"location":"PN532/#breakout-boards","text":"Since the PN532 chip itself is surface mount and requires some external components to operate the best is probably to obtain a breakout board similar to the one below from your favourite online supplier. Please make sure the breakout board you order has the HSU pins (SCL=TX and SDA=RX) broken out as it will be very difficult to add them manually - Usually they have them but for good measure just make sure.","title":"Breakout Boards"},{"location":"PS-16-DZ-Dimmer/","text":"PS-16-DZ Dimmer ~ The PS-16-DZ dimmer uses eWeLink app same as Sonoff devices. It's available from Amazon and Aliexpress . It may under different name, but the model number is PS-16-DZ. Pics ~ Opened it up, found a ESP8285 and a Nuvoton N76E003. Flash and GPIO pins ~ Remove the ESP8285 daughter card DLX-MKCK01 from the main board and flash Tasmota. pin1 RST -> N76E003 P0.5/PWM2 pin2 TXD -> N76E003 P0.7/RXD pin3 RXD -> N76E003 P0.6/TXD pin4 GPIO13/MTCK -> LED pin5 3.3V pin6 GND Communication between ESP8285 and N76E003 ~ It uses AT command to communicate between ESP8285 and N76E003 over UART at 19200 baud. Turn on the switch from ESP8266 : Send from ESP8266 AT + UPDATE = \"sequence\" : \"1528335040032\" , \"switch\" : \"on\" Receive from MCU AT + RESULT = \"sequence\" : 1528335040032 \" Send from ESP8266 : AT + SEND = ok After 0.7 s Receive from MCU AT + UPDATE = \"switch\" : \"on\" , \"bright\" : 44 Send from ESP8266 : AT + SEND = ok Turn off the switch from ESP8266 : Send from ESP8266 AT + UPDATE = \"sequence\" : \"1528335118327\" , \"switch\" : \"off\" Receive from MCU AT + RESULT = \"sequence\" : 1528335118327 \" Send from ESP8266 : AT + SEND = ok After 0.7 s Receive from MCU AT + UPDATE = \"switch\" : \"on\" , \"bright\" : 44 Send from ESP8266 : AT + SEND = ok Change brightness to 44 from ESP8266 : Send from ESP8266 : AT + UPDATE = \"sequence\" : \"1528335181502\" , \"bright\" : 44 Receive from MCU AT + RESULT = \"sequence\" : 1528335181502 \" Send from ESP8266 : AT + SEND = ok After 0.7 s Receive from MCU AT + UPDATE = \"switch\" : \"on\" , \"bright\" : 44 Send from ESP8266 : AT + SEND = ok Turn on the switch with faceplate button : Received from MCU AT + UPDATE = \"switch\" : \"on\" , \"bright\" : 44 Send from ESP8266 : AT + SEND = ok Turn off the switch with faceplate button : Received from MCU AT + UPDATE = \"switch\" : \"off\" , \"bright\" : 44 Send from ESP8266 : AT + SEND = ok Change the brightness to 52 with faceplate button : Received from MCU AT + UPDATE = \"switch\" : \"on\" , \"bright\" : 52 Send from ESP8266 : AT + SEND = ok Holding the middle button on faceplate to reset the device : Received from MCU AT + SETTING = enterESPTOUCH Send from ESP8266 : AT + SETTING = enterESPTOUCH The sequence number is a 13 digits unix timestamp (in milliseconds). The data after \"bright\" is the brightness. The maximum of the brightness is 100 and the minimum is 10. There is one byte 0x1B at the end of each AT command.","title":"PS-16-DZ Dimmer"},{"location":"PS-16-DZ-Dimmer/#ps-16-dz-dimmer","text":"The PS-16-DZ dimmer uses eWeLink app same as Sonoff devices. It's available from Amazon and Aliexpress . It may under different name, but the model number is PS-16-DZ.","title":"PS-16-DZ Dimmer"},{"location":"PS-16-DZ-Dimmer/#pics","text":"Opened it up, found a ESP8285 and a Nuvoton N76E003.","title":"Pics"},{"location":"PS-16-DZ-Dimmer/#flash-and-gpio-pins","text":"Remove the ESP8285 daughter card DLX-MKCK01 from the main board and flash Tasmota. pin1 RST -> N76E003 P0.5/PWM2 pin2 TXD -> N76E003 P0.7/RXD pin3 RXD -> N76E003 P0.6/TXD pin4 GPIO13/MTCK -> LED pin5 3.3V pin6 GND","title":"Flash and GPIO pins"},{"location":"PS-16-DZ-Dimmer/#communication-between-esp8285-and-n76e003","text":"It uses AT command to communicate between ESP8285 and N76E003 over UART at 19200 baud. Turn on the switch from ESP8266 : Send from ESP8266 AT + UPDATE = \"sequence\" : \"1528335040032\" , \"switch\" : \"on\" Receive from MCU AT + RESULT = \"sequence\" : 1528335040032 \" Send from ESP8266 : AT + SEND = ok After 0.7 s Receive from MCU AT + UPDATE = \"switch\" : \"on\" , \"bright\" : 44 Send from ESP8266 : AT + SEND = ok Turn off the switch from ESP8266 : Send from ESP8266 AT + UPDATE = \"sequence\" : \"1528335118327\" , \"switch\" : \"off\" Receive from MCU AT + RESULT = \"sequence\" : 1528335118327 \" Send from ESP8266 : AT + SEND = ok After 0.7 s Receive from MCU AT + UPDATE = \"switch\" : \"on\" , \"bright\" : 44 Send from ESP8266 : AT + SEND = ok Change brightness to 44 from ESP8266 : Send from ESP8266 : AT + UPDATE = \"sequence\" : \"1528335181502\" , \"bright\" : 44 Receive from MCU AT + RESULT = \"sequence\" : 1528335181502 \" Send from ESP8266 : AT + SEND = ok After 0.7 s Receive from MCU AT + UPDATE = \"switch\" : \"on\" , \"bright\" : 44 Send from ESP8266 : AT + SEND = ok Turn on the switch with faceplate button : Received from MCU AT + UPDATE = \"switch\" : \"on\" , \"bright\" : 44 Send from ESP8266 : AT + SEND = ok Turn off the switch with faceplate button : Received from MCU AT + UPDATE = \"switch\" : \"off\" , \"bright\" : 44 Send from ESP8266 : AT + SEND = ok Change the brightness to 52 with faceplate button : Received from MCU AT + UPDATE = \"switch\" : \"on\" , \"bright\" : 52 Send from ESP8266 : AT + SEND = ok Holding the middle button on faceplate to reset the device : Received from MCU AT + SETTING = enterESPTOUCH Send from ESP8266 : AT + SETTING = enterESPTOUCH The sequence number is a 13 digits unix timestamp (in milliseconds). The data after \"bright\" is the brightness. The maximum of the brightness is 100 and the minimum is 10. There is one byte 0x1B at the end of each AT command.","title":"Communication between ESP8285 and N76E003"},{"location":"PWM-dimmer-switch/","text":"PWM Dimmer ~ PWM dimmer is supported in standard tasmota.bin To enable PWM dimmer operation, select the PWM Dimmer module. PWM Dimmer module adds support for PWM dimmer switches and devices with one or more buttons that control devices in a device group. The brightness of the load for PWM dimmers is controlled by a PWM GPIO pin. They typically have power, up and down buttons, a powered-on LED, five brightness LEDs and another status LED. Some of supported devices are switches model SD0x from Martin Jerry, Acenx, Tessan, NTONPOWER. Any other device with one or more buttons, such as any typical Tasmota-capable wall switch, can make use of the PWM Dimmer module to control the power, brightness and light channels of one or more device groups. For single-button devices or multi-button devices with remote device mode enabled, only the operations controlled by the power button in the instruction below apply. Examples include: PWM Dimmer Operation ~ Pressing and releasing the power button toggles the power on/off. If the toggle turns the power on, the load is returned to the last brightness it was adjusted to. If Fade is enabled, the load is faded on/off at the rate defined by the Speed setting. When the power is on, holding the down or up button decreases/increases the brightness. The brightness can also be changed using just the power button. When the power is on, holding the power button alternately increases or decreases the brightness. Initially, holding the power button increases the brightness. Releasing and then holding the power button again decreases the brightness. When the power is off, pressing and releasing the down or up button turns the power on at a temporary brightness of the low/high levels set by the BriPreset command. Turning the power on at the low preset can also be accomplished by holding the power button while the power is off. The brightness presets are intended to enable quickly turning on a light to a dim or bright level without changing the normal desired brightness. Turning the power on to a preset does not change the brightness the load will be set to when the switch is turned on the next time. For example, if the light is on and you adjust the brightness to 80 and then turn the light off, when you turn it back on, the brightness will return to 80. If you turn the power off again and then press the down button, the light will be turned on with a brightness of the low preset. If you then turn the light off and on again, the brightness will return to 80. If there are LED\u2019s defined in the template, they are turned on to indicate the current brightness. More LEDs are turned on at higher brightnesses. Option 86 enables/disables an LED timeout. If SetOption86 is enabled, the LED\u2019s turn off five seconds after the last change in brightness. Note that the lowest LED and the blue power LED are always on when the power is on. The LED timeout can also be enabled/disabled by holding the power button while tapping (pressing and releasing quickly) the down button. The LedLink LED can be used as a nightlight/powered-off indicator. SetOption 87 enables/disables turning the LedLink LED on when the power is off. The powered-off indicator can also be enabled/disabled by holding the power button and tapping the up button. Holding the power button and then holding the down or up button publishes an MQTT EVENT command. The topic follows the format of the Full Topic with a subtopic of EVENT (ex. cmnd/LightSwitch1/EVENT ). The MQTT payload is Trigger#, where # is 1 if the down button is held or 2 if the up button is held. These triggers can be used in rules on remote devices (ON Event#Trigger1 ) or by automation software to trigger automations such as scene changes. For example, the Event topic Trigger1 payload could trigger the automation software to turn on the previous scene in a list and the Trigger2 payload could trigger the automation software to turn on the next scene in a list. Holding the power button, tapping the down button and then tapping or holding the down or up button sends a device group message to set CW/RGB/RGBW/RGBCW lights in the device group to the previous/next fixed color. The command is sent/value is adjusted once every .75 seconds for as long as the button is held. The color sequence as is red, green, blue, orange, light green, light blue, amber, cyan, purple, yellow, pink, white using RGB channels, cold white using CT channels, warm white using CT channels. Holding the power button, tapping the up button and then tapping or holding the down or up button publishes an MQTT Event command. The command is sent once every .75 seconds for as long as the button is held. The MQTT topic is as described above. The MQTT payload is Trigger#, where # is 3 if the down button is held or 4 if the up button is held. Pressing and releasing the power button and then holding the power button publishes an MQTT Event command. The command is sent once every .75 seconds for as long as the button is held. The MQTT topic is as described above. The MQTT payload is Trigger#, where # is 5. Button presses and holds execute the normal ButtonTopic and Rule processing. If ButtonTopic is set and SetOption61 is 0 or a the button press/hold matches a rule, the button press/hold is ignored by PWM Dimmer. Operations invoked by holding the power button in combination with the up/dowm buttons can not be overidden by rules. Standard Tasmota multi-press button presses operate as normal. PWM Dimmer uses the Light module to control the PWM. Brightness levels are rescaled to PWM values between the dimmer_min and dimmer_max values specified with DimmerRange . Most LED bulbs do not show a significant difference between PWM value of 1 and PWM value of 100. This results in the lower 10% of the dimmer range having no effect. For best results, DimmerRange <dimmerMin> value should be set to the highest value that results in the lowest bulb brightness (Typically in the range of 8 - 18). When Device Groups are enabled, the PWM Dimmer brightness presets are kept in sync across all switches in the group. The powered-off LED and LED timeout settings are specific to each switch. Changing them does not replicate the change to the other switches in the group. When CW/RGB/RGBW/RGBCW lights are in the same device group as the PWM Dimmer device, use the PWMDimmerPWMs command to define the PWM (channel) count of the lights. This allows the PWM Dimmer module to correctly determine the brightness (dimmer) level and allows the color of all the lights in the device group to be controlled from the PWM Dimmer device. Commands ~ Command Parameters BriPreset <low>,<high> = set brightness low and high presets 1..255 = set brightness preset + = increase brightness preset - = decrease brightness preset LedMask Set a bitmask specifiying which LEDs are used to indicate the current brightness. LEDs not included in the bitmask can be controlled with LedPower . <bitmask> = bitwise value representing each LED. Values may be entered as either hexadecimal or decimal values (e.g., 0xFFFF = 65535). Note that LED 0 is tied to the relay and is always used to indicate the first level of brightness. 0xFFFF (= 1111 1111 1111 1111) All LEDs are used to indicate the brightness (default) Ex.: LedMask 3 = Use LEDs 0, 1 and 2 to indicate the brightness. PWMDimmerPWMs Set the PWM (channel) count of lights in the device group controlled by the module (CW=2, RGB=3, RGBW=4, RGBCW=5). SetOption86 Set brightness LED timeout 0 = disable timeout (default) 1 = enable timeout SetOption87 Set powered-off LED (nightlight) 0 = disable powered-off LED (default) 1 = enable powered-off LED SetOption88 Set remote device mode 0 = disable remote device mode(default) 1 = enable remote device mode Remote Device Mode ~ Remote device mode allows PWM Dimmer module based switches to control remote devices. With remote device mode enabled, each button controls a different device. Remote device mode is included in the default Tasmota binary. To include remote device mode support in other builds, define USE_PWM_DIMMER_REMOTE and USE_DEVICE_GROUPS in your user_config_override. Remote device mode support requires device group support. Remote device mode support adds 1K to the code size in addition to the code size required for device groups support. To enable remote device mode, execute SetOption88 1 (the device will restart). Each remote device must be running firmware with device group support and have remote device support enabled. Remote devices do not need to be built with PWM dimmer support nor do they need to be switches. If a remote device also uses the PWM Dimmer module, the device acts like a 3-way dimmer switch and may or may not have a load connected to it. All PWM dimmer switches in the device group can control the power, brightness and color of one or more smart lights with Tasmota with device group support loaded on them. With remote device mode is enabled, button 1 is the power button for the local device while buttons 2 and 3 are the power buttons for remote devices. Group names for buttons 2 and 3 are set by the DevGroupName2 and DevGroupName3 commands respectively. Note that the button numbers are defined by the module template and can be in any physical order on the switch (button 1 can be defined as the top button, the middle button or the bottom button). Button combinations that publish MQTT Event commands use a topic in the format cmnd/%group-topic%/EVENT . While holding a button, the other two buttons act like the down and up buttons for the remote device associated with the first button pressed. All the functions performed by the down and up buttons in non-remote device mode are available in remote device mode. While holding button 1, button 2 performs the functions of the down button and button 3 performs the functions of the up button. While holding button 2, button 1 performs the functions of the down button and button 3 performs the functions of the up button. While holding button 3, button 1 performs the functions of the down button and button 2 performs the functions of the up button.","title":"PWM Dimmer"},{"location":"PWM-dimmer-switch/#pwm-dimmer","text":"PWM dimmer is supported in standard tasmota.bin To enable PWM dimmer operation, select the PWM Dimmer module. PWM Dimmer module adds support for PWM dimmer switches and devices with one or more buttons that control devices in a device group. The brightness of the load for PWM dimmers is controlled by a PWM GPIO pin. They typically have power, up and down buttons, a powered-on LED, five brightness LEDs and another status LED. Some of supported devices are switches model SD0x from Martin Jerry, Acenx, Tessan, NTONPOWER. Any other device with one or more buttons, such as any typical Tasmota-capable wall switch, can make use of the PWM Dimmer module to control the power, brightness and light channels of one or more device groups. For single-button devices or multi-button devices with remote device mode enabled, only the operations controlled by the power button in the instruction below apply. Examples include:","title":"PWM Dimmer"},{"location":"PWM-dimmer-switch/#pwm-dimmer-operation","text":"Pressing and releasing the power button toggles the power on/off. If the toggle turns the power on, the load is returned to the last brightness it was adjusted to. If Fade is enabled, the load is faded on/off at the rate defined by the Speed setting. When the power is on, holding the down or up button decreases/increases the brightness. The brightness can also be changed using just the power button. When the power is on, holding the power button alternately increases or decreases the brightness. Initially, holding the power button increases the brightness. Releasing and then holding the power button again decreases the brightness. When the power is off, pressing and releasing the down or up button turns the power on at a temporary brightness of the low/high levels set by the BriPreset command. Turning the power on at the low preset can also be accomplished by holding the power button while the power is off. The brightness presets are intended to enable quickly turning on a light to a dim or bright level without changing the normal desired brightness. Turning the power on to a preset does not change the brightness the load will be set to when the switch is turned on the next time. For example, if the light is on and you adjust the brightness to 80 and then turn the light off, when you turn it back on, the brightness will return to 80. If you turn the power off again and then press the down button, the light will be turned on with a brightness of the low preset. If you then turn the light off and on again, the brightness will return to 80. If there are LED\u2019s defined in the template, they are turned on to indicate the current brightness. More LEDs are turned on at higher brightnesses. Option 86 enables/disables an LED timeout. If SetOption86 is enabled, the LED\u2019s turn off five seconds after the last change in brightness. Note that the lowest LED and the blue power LED are always on when the power is on. The LED timeout can also be enabled/disabled by holding the power button while tapping (pressing and releasing quickly) the down button. The LedLink LED can be used as a nightlight/powered-off indicator. SetOption 87 enables/disables turning the LedLink LED on when the power is off. The powered-off indicator can also be enabled/disabled by holding the power button and tapping the up button. Holding the power button and then holding the down or up button publishes an MQTT EVENT command. The topic follows the format of the Full Topic with a subtopic of EVENT (ex. cmnd/LightSwitch1/EVENT ). The MQTT payload is Trigger#, where # is 1 if the down button is held or 2 if the up button is held. These triggers can be used in rules on remote devices (ON Event#Trigger1 ) or by automation software to trigger automations such as scene changes. For example, the Event topic Trigger1 payload could trigger the automation software to turn on the previous scene in a list and the Trigger2 payload could trigger the automation software to turn on the next scene in a list. Holding the power button, tapping the down button and then tapping or holding the down or up button sends a device group message to set CW/RGB/RGBW/RGBCW lights in the device group to the previous/next fixed color. The command is sent/value is adjusted once every .75 seconds for as long as the button is held. The color sequence as is red, green, blue, orange, light green, light blue, amber, cyan, purple, yellow, pink, white using RGB channels, cold white using CT channels, warm white using CT channels. Holding the power button, tapping the up button and then tapping or holding the down or up button publishes an MQTT Event command. The command is sent once every .75 seconds for as long as the button is held. The MQTT topic is as described above. The MQTT payload is Trigger#, where # is 3 if the down button is held or 4 if the up button is held. Pressing and releasing the power button and then holding the power button publishes an MQTT Event command. The command is sent once every .75 seconds for as long as the button is held. The MQTT topic is as described above. The MQTT payload is Trigger#, where # is 5. Button presses and holds execute the normal ButtonTopic and Rule processing. If ButtonTopic is set and SetOption61 is 0 or a the button press/hold matches a rule, the button press/hold is ignored by PWM Dimmer. Operations invoked by holding the power button in combination with the up/dowm buttons can not be overidden by rules. Standard Tasmota multi-press button presses operate as normal. PWM Dimmer uses the Light module to control the PWM. Brightness levels are rescaled to PWM values between the dimmer_min and dimmer_max values specified with DimmerRange . Most LED bulbs do not show a significant difference between PWM value of 1 and PWM value of 100. This results in the lower 10% of the dimmer range having no effect. For best results, DimmerRange <dimmerMin> value should be set to the highest value that results in the lowest bulb brightness (Typically in the range of 8 - 18). When Device Groups are enabled, the PWM Dimmer brightness presets are kept in sync across all switches in the group. The powered-off LED and LED timeout settings are specific to each switch. Changing them does not replicate the change to the other switches in the group. When CW/RGB/RGBW/RGBCW lights are in the same device group as the PWM Dimmer device, use the PWMDimmerPWMs command to define the PWM (channel) count of the lights. This allows the PWM Dimmer module to correctly determine the brightness (dimmer) level and allows the color of all the lights in the device group to be controlled from the PWM Dimmer device.","title":"PWM Dimmer Operation"},{"location":"PWM-dimmer-switch/#commands","text":"Command Parameters BriPreset <low>,<high> = set brightness low and high presets 1..255 = set brightness preset + = increase brightness preset - = decrease brightness preset LedMask Set a bitmask specifiying which LEDs are used to indicate the current brightness. LEDs not included in the bitmask can be controlled with LedPower . <bitmask> = bitwise value representing each LED. Values may be entered as either hexadecimal or decimal values (e.g., 0xFFFF = 65535). Note that LED 0 is tied to the relay and is always used to indicate the first level of brightness. 0xFFFF (= 1111 1111 1111 1111) All LEDs are used to indicate the brightness (default) Ex.: LedMask 3 = Use LEDs 0, 1 and 2 to indicate the brightness. PWMDimmerPWMs Set the PWM (channel) count of lights in the device group controlled by the module (CW=2, RGB=3, RGBW=4, RGBCW=5). SetOption86 Set brightness LED timeout 0 = disable timeout (default) 1 = enable timeout SetOption87 Set powered-off LED (nightlight) 0 = disable powered-off LED (default) 1 = enable powered-off LED SetOption88 Set remote device mode 0 = disable remote device mode(default) 1 = enable remote device mode","title":"Commands"},{"location":"PWM-dimmer-switch/#remote-device-mode","text":"Remote device mode allows PWM Dimmer module based switches to control remote devices. With remote device mode enabled, each button controls a different device. Remote device mode is included in the default Tasmota binary. To include remote device mode support in other builds, define USE_PWM_DIMMER_REMOTE and USE_DEVICE_GROUPS in your user_config_override. Remote device mode support requires device group support. Remote device mode support adds 1K to the code size in addition to the code size required for device groups support. To enable remote device mode, execute SetOption88 1 (the device will restart). Each remote device must be running firmware with device group support and have remote device support enabled. Remote devices do not need to be built with PWM dimmer support nor do they need to be switches. If a remote device also uses the PWM Dimmer module, the device acts like a 3-way dimmer switch and may or may not have a load connected to it. All PWM dimmer switches in the device group can control the power, brightness and color of one or more smart lights with Tasmota with device group support loaded on them. With remote device mode is enabled, button 1 is the power button for the local device while buttons 2 and 3 are the power buttons for remote devices. Group names for buttons 2 and 3 are set by the DevGroupName2 and DevGroupName3 commands respectively. Note that the button numbers are defined by the module template and can be in any physical order on the switch (button 1 can be defined as the top button, the middle button or the bottom button). Button combinations that publish MQTT Event commands use a topic in the format cmnd/%group-topic%/EVENT . While holding a button, the other two buttons act like the down and up buttons for the remote device associated with the first button pressed. All the functions performed by the down and up buttons in non-remote device mode are available in remote device mode. While holding button 1, button 2 performs the functions of the down button and button 3 performs the functions of the up button. While holding button 2, button 1 performs the functions of the down button and button 3 performs the functions of the up button. While holding button 3, button 1 performs the functions of the down button and button 2 performs the functions of the up button.","title":"Remote Device Mode"},{"location":"PZEM-0XX/","text":"PZEM-0xx power monitor ~ PZEM is a dedicated separate energy monitor, device calibration in Tasmota is not supported. PZEM-004 ~ The PZEM-004T together with a Sonoff Basic provide a good clamp on energy monitor. Parts needed ~ Sonoff Basic PZEM-004T Resistor 1k Enclosure Power cable Preparation ~ Install Tasmota on the Sonoff Basic and confirm it is functional before connecting the PZEM-004T to its serial interface. Hardware connections ~ As the PZEM-004T RX optocoupler series resistor (1K ohm, R15 for v.1 .0 and R8 for v.3.0 ) is designed for 5V, that resistor value had to be reduced in order to achieve the current for driving the RX optocoupler diode. This can be accomplished by soldering a 1k resistor between the joints shown below (modification works for version v.1.0 and v.3.0). The resistor has to be connected between VDD (5V/3.3V) terminal and the RX opto terminal 1. PZEM-004T v.1.0 PZEM-004T v.3.0 It can be used a SMD resistor 102 or 1001 (1K) soldered near/parallel with R8 or a normal resistor (THT) similar to that used on the image of v.1.0 The resistor is placed in different place on v.3.0 because the optocouplers RX and TX are reversed compared to v.1.0 Connect the serial interface of the Sonoff Basic with the serial interface of the PZEM-004T. See pictures regarding used colors and connections. 3V3/5V Red Rx Yellow Tx Green Gnd Grey (Image re-used from https://www.instructables.com/id/Use-Homie-Firmware-to-Drive-Sonoff-Switch-Module-E/ Thanks @amayii0) If you need 5V you can use directly from Sonoff (for something else) but do not connect to PZEM logic because this will result in a big flash (kaboom!, the sonoff LIVE line may reach the PZEM NEUTRAL or viceversa). Using 5V from Sonoff for PZEM TTL port is safe but the resistor mod explained above must be undoed and another mod is needed for dropping the PZEM TX line from 5V to 3.3V. So, the simplest way is to use 3.3V from Sonoff to 5V TTL terminal of the PZEM and the resistor mod explained in the above images. Cut the power cable in two and connect the input wires to both Sonoff Basic and PZEM-004T. Route one of the power output wires through the PZEM-004T core and connect the output wires to the Sonoff Basic output. As most parts are connected to high voltage AC it is recommended to fit the hardware in a solid enclosure. Software configuration ~ Configure the GPIO's for hardware serial connection as shown below. IMPORTANT: If using the connections as following, the communication works in all cores due to TASMOTA using hardware serial. If the user wants to use other GPIOs for communication, TASMOTA will emulate a serial interface using software serial. This feature does not work using core 2.3.0 due to insufficient RAM. To use the software serial feature, you must use a core version of 2.4.2 or greater. Device Template PZEM-004T version prior to V3: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,62,0,63,0,0,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":1} PZEM-004T version V3 ~ {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,62,0,98,0,0,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":1} The PZEM-004T together with a HW-655 Relay provide a good clamp-on energy monitor for a 240V clothes dryer. Parts needed ~ Circuit Box 3-prong Dryer Electrical Cord (Note - some households use a 4-prong plug) 3-prong Dryer Receptacle (Note - some households use a 4-prong plug) PZEM-004T HW-655 w/ ESP-01 ESHION SPSD-5S AC-DC 5V Buck Converter 4-pin Serial Connector DuPont Connectors & 22 AWG wire Preparation ~ Install Tasmota on the ESP-01 and confirm it is functional before connecting the PZEM-004T to its serial interface. Use of pins other that the default hardware serial GPIO (01 & 03) in order for TASMOTA to emulate a serial interface using software serial. Hardware connections ~ Connect the serial interface of the HW-655 with the serial interface of the PZEM-004T. As most parts are connected to high voltage AC it is recommended to fit the hardware in a solid enclosure. Software configuration ~ Device Template PZEM-004T version prior to V3: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,63,0,62,0,0,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} PZEM-004T version V3 ~ {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,98,0,62,0,0,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} Use the module template to configure the GPIO's for hardware serial connection. IMPORTANT: If using the connections as following, the communication works in all cores due to TASMOTA using hardware serial. If the user wants to use other GPIOs for communication, TASMOTA will emulate a serial interface using software serial. This feature does not work using core 2.3.0 due to insufficient RAM. To use the software serial feature, you must use a core version of 2.4.2 or greater. Connected Power Meter using PZEM-004T, Wemos D1 Mini and a 1602 I 2 C display ~ Parts needed ~ Wemos D1 Mini PZEM-004T 1kOhm Resistor (optional - see alternate wiring) Enclosure 5V buck converter power supply (search for \"700ma 3.5w 5v\" on usual stores...) I 2 C 1602 LCD Display (I had issues with green one, I 2 C address 0x3F, while no problems with blue ones, address 0x27) Mains Power cable Mammuth Clamps Preparation ~ You need to compile your own Tasmota firmware as none of the pre-compiled binaries have support for display and PZEM module. Set up your preferred IDE as described in wiki Enable IDE to Use Custom Settings Create user_config_override.h in the tasmota folder and paste the contents of this sample configuration file . PlatformIO Rename platformio_override_sample.ini . to platformio_override.ini Enter platformio run -e <variant-name> Examples: platformio run -e tasmota-sensors platformio run -e tasmota-DE Arduino IDE Edit my_user_config.h . Uncomment the statement by removing the \"//\" in front of the line: #define USE_CONFIG_OVERRIDE Click compile Flash the binary on the Wemos D1 Mini and confirm it is functional before connecting the PZEM-004T to its serial interface. Tasmota Parameter Configuration ~ Device Template PZEM-004T version prior to V3: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,63,0,62,6,5,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} PZEM-004T version V3 ~ {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,98,0,62,6,5,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} use I2CScan to detect your device address use DeviceAddress XXX (where XXX is the decimal converted address found) to set the I 2 C address set TelePeriod 10 to have the display refresh every 10 seconds (you can't go under this value) set DisplayModel 1 , and DisplayMode 0 finally, add a Rule to display values (I choose these): Rule1 ON Tele - ENERGY#Power DO DisplayText [ z ] [ x1y0 ]% value % W ENDON ON Tele - ENERGY#Today DO DisplayText [ x8y0 ]% value % Wh ENDON ON Tele - ENERGY#Voltage DO DisplayText [ x1y1 ]% value % V ENDON ON Tele - ENERGY#Current DO DisplayText [ x8y1 ]% value % A ENDON remember to enable the rule, with Rule1 1 Images and Wiring diagram ~ DANGER - MAINS VOLTAGE . Be sure to crimp connectors and use heat-shrinking tube wherever possible/needed, and tightly secure any screw. How it looks, from web GUI: How it looks, from enclosure: You can set the contrast using the little trimmer/pot on back of the display. I cut a bit of the corners from the display to have it flush with border, and used two hexagonal plastic standoffs with nuts and bolts to secure it to transparent top. Mains IN, mains OUT, all sealed: Wiring Diagram: * Check images below for more information about the 1kOhm resistor needed to use 3.3V instead of 5V for the PZEM-004T serial connection. PZEM-004T v.1.0 PZEM-004T v.3.0 Calibration ~ Per Theo - As the PZEM is a dedicated energy monitor, device calibration in TASMOTA is currently not supported. PZEM-016 ~ DO NOT PERFORM THIS MODIFICATION WITHOUT REMOVING POWER FROM THE PZEM FIRST! Note : the PZEM-016 TTL output is at 5V signal levels. There are varying schools of thought on whether the ESP82xx has 5V tolerant GPIO. You may want to use a level shifter for the serial communications signals to bring them to the recommended 3.3V. PZEM-016 modules can be converted from RS485 to TTL serial level devices by simply removing the internal MAX485 chip and adding two internal jumper wires. This will bring the serial port connections out via the four-pin terminal block. Pin A is now TTL serial out (Tx) and pin B TTL serial in (Rx). The modification retains the optical isolation used by the PZEM for safety to ensure no high voltages on the outputs. You can use a voltage level shifter to power the ESP82xx from the PZEM-016 module's 5V power. This may also require a 470uf 35V capacitor across the 5V line to work reliably. Tasmota Configuration ~ It is recommended to use GPIO1/GPIO3 or GPIO13/GPIO15 for the most reliable serial communications. You can use any GPIO but anything else will use serial emulation (software). Software serial is not supported with the 2.3 Arduino Core. GPIO Component PZEM 1 PZEM0XX Tx (62) Pin B 3 PZEM016 Rx (98) Pin A","title":"PZEM-0xx power monitor"},{"location":"PZEM-0XX/#pzem-0xx-power-monitor","text":"PZEM is a dedicated separate energy monitor, device calibration in Tasmota is not supported.","title":"PZEM-0xx power monitor"},{"location":"PZEM-0XX/#pzem-004","text":"The PZEM-004T together with a Sonoff Basic provide a good clamp on energy monitor.","title":"PZEM-004"},{"location":"PZEM-0XX/#parts-needed","text":"Sonoff Basic PZEM-004T Resistor 1k Enclosure Power cable","title":"Parts needed"},{"location":"PZEM-0XX/#preparation","text":"Install Tasmota on the Sonoff Basic and confirm it is functional before connecting the PZEM-004T to its serial interface.","title":"Preparation"},{"location":"PZEM-0XX/#hardware-connections","text":"As the PZEM-004T RX optocoupler series resistor (1K ohm, R15 for v.1 .0 and R8 for v.3.0 ) is designed for 5V, that resistor value had to be reduced in order to achieve the current for driving the RX optocoupler diode. This can be accomplished by soldering a 1k resistor between the joints shown below (modification works for version v.1.0 and v.3.0). The resistor has to be connected between VDD (5V/3.3V) terminal and the RX opto terminal 1. PZEM-004T v.1.0 PZEM-004T v.3.0 It can be used a SMD resistor 102 or 1001 (1K) soldered near/parallel with R8 or a normal resistor (THT) similar to that used on the image of v.1.0 The resistor is placed in different place on v.3.0 because the optocouplers RX and TX are reversed compared to v.1.0 Connect the serial interface of the Sonoff Basic with the serial interface of the PZEM-004T. See pictures regarding used colors and connections. 3V3/5V Red Rx Yellow Tx Green Gnd Grey (Image re-used from https://www.instructables.com/id/Use-Homie-Firmware-to-Drive-Sonoff-Switch-Module-E/ Thanks @amayii0) If you need 5V you can use directly from Sonoff (for something else) but do not connect to PZEM logic because this will result in a big flash (kaboom!, the sonoff LIVE line may reach the PZEM NEUTRAL or viceversa). Using 5V from Sonoff for PZEM TTL port is safe but the resistor mod explained above must be undoed and another mod is needed for dropping the PZEM TX line from 5V to 3.3V. So, the simplest way is to use 3.3V from Sonoff to 5V TTL terminal of the PZEM and the resistor mod explained in the above images. Cut the power cable in two and connect the input wires to both Sonoff Basic and PZEM-004T. Route one of the power output wires through the PZEM-004T core and connect the output wires to the Sonoff Basic output. As most parts are connected to high voltage AC it is recommended to fit the hardware in a solid enclosure.","title":"Hardware connections"},{"location":"PZEM-0XX/#software-configuration","text":"Configure the GPIO's for hardware serial connection as shown below. IMPORTANT: If using the connections as following, the communication works in all cores due to TASMOTA using hardware serial. If the user wants to use other GPIOs for communication, TASMOTA will emulate a serial interface using software serial. This feature does not work using core 2.3.0 due to insufficient RAM. To use the software serial feature, you must use a core version of 2.4.2 or greater. Device Template PZEM-004T version prior to V3: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,62,0,63,0,0,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":1}","title":"Software configuration"},{"location":"PZEM-0XX/#pzem-004t-version-v3","text":"{\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,62,0,98,0,0,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":1} The PZEM-004T together with a HW-655 Relay provide a good clamp-on energy monitor for a 240V clothes dryer.","title":"PZEM-004T version V3"},{"location":"PZEM-0XX/#parts-needed_1","text":"Circuit Box 3-prong Dryer Electrical Cord (Note - some households use a 4-prong plug) 3-prong Dryer Receptacle (Note - some households use a 4-prong plug) PZEM-004T HW-655 w/ ESP-01 ESHION SPSD-5S AC-DC 5V Buck Converter 4-pin Serial Connector DuPont Connectors & 22 AWG wire","title":"Parts needed"},{"location":"PZEM-0XX/#preparation_1","text":"Install Tasmota on the ESP-01 and confirm it is functional before connecting the PZEM-004T to its serial interface. Use of pins other that the default hardware serial GPIO (01 & 03) in order for TASMOTA to emulate a serial interface using software serial.","title":"Preparation"},{"location":"PZEM-0XX/#hardware-connections_1","text":"Connect the serial interface of the HW-655 with the serial interface of the PZEM-004T. As most parts are connected to high voltage AC it is recommended to fit the hardware in a solid enclosure.","title":"Hardware connections"},{"location":"PZEM-0XX/#software-configuration_1","text":"Device Template PZEM-004T version prior to V3: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,63,0,62,0,0,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18}","title":"Software configuration"},{"location":"PZEM-0XX/#pzem-004t-version-v3_1","text":"{\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,98,0,62,0,0,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} Use the module template to configure the GPIO's for hardware serial connection. IMPORTANT: If using the connections as following, the communication works in all cores due to TASMOTA using hardware serial. If the user wants to use other GPIOs for communication, TASMOTA will emulate a serial interface using software serial. This feature does not work using core 2.3.0 due to insufficient RAM. To use the software serial feature, you must use a core version of 2.4.2 or greater.","title":"PZEM-004T version V3"},{"location":"PZEM-0XX/#connected-power-meter-using-pzem-004t-wemos-d1-mini-and-a-1602-i2c-display","text":"","title":"Connected Power Meter using PZEM-004T, Wemos D1 Mini and a 1602 I2C display"},{"location":"PZEM-0XX/#parts-needed_2","text":"Wemos D1 Mini PZEM-004T 1kOhm Resistor (optional - see alternate wiring) Enclosure 5V buck converter power supply (search for \"700ma 3.5w 5v\" on usual stores...) I 2 C 1602 LCD Display (I had issues with green one, I 2 C address 0x3F, while no problems with blue ones, address 0x27) Mains Power cable Mammuth Clamps","title":"Parts needed"},{"location":"PZEM-0XX/#preparation_2","text":"You need to compile your own Tasmota firmware as none of the pre-compiled binaries have support for display and PZEM module. Set up your preferred IDE as described in wiki","title":"Preparation"},{"location":"PZEM-0XX/#tasmota-parameter-configuration","text":"Device Template PZEM-004T version prior to V3: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,63,0,62,6,5,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18}","title":"Tasmota Parameter Configuration"},{"location":"PZEM-0XX/#pzem-004t-version-v3_2","text":"{\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,98,0,62,6,5,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} use I2CScan to detect your device address use DeviceAddress XXX (where XXX is the decimal converted address found) to set the I 2 C address set TelePeriod 10 to have the display refresh every 10 seconds (you can't go under this value) set DisplayModel 1 , and DisplayMode 0 finally, add a Rule to display values (I choose these): Rule1 ON Tele - ENERGY#Power DO DisplayText [ z ] [ x1y0 ]% value % W ENDON ON Tele - ENERGY#Today DO DisplayText [ x8y0 ]% value % Wh ENDON ON Tele - ENERGY#Voltage DO DisplayText [ x1y1 ]% value % V ENDON ON Tele - ENERGY#Current DO DisplayText [ x8y1 ]% value % A ENDON remember to enable the rule, with Rule1 1","title":"PZEM-004T version V3"},{"location":"PZEM-0XX/#images-and-wiring-diagram","text":"DANGER - MAINS VOLTAGE . Be sure to crimp connectors and use heat-shrinking tube wherever possible/needed, and tightly secure any screw. How it looks, from web GUI: How it looks, from enclosure: You can set the contrast using the little trimmer/pot on back of the display. I cut a bit of the corners from the display to have it flush with border, and used two hexagonal plastic standoffs with nuts and bolts to secure it to transparent top. Mains IN, mains OUT, all sealed: Wiring Diagram: * Check images below for more information about the 1kOhm resistor needed to use 3.3V instead of 5V for the PZEM-004T serial connection. PZEM-004T v.1.0 PZEM-004T v.3.0","title":"Images and Wiring diagram"},{"location":"PZEM-0XX/#calibration","text":"Per Theo - As the PZEM is a dedicated energy monitor, device calibration in TASMOTA is currently not supported.","title":"Calibration"},{"location":"PZEM-0XX/#pzem-016","text":"DO NOT PERFORM THIS MODIFICATION WITHOUT REMOVING POWER FROM THE PZEM FIRST! Note : the PZEM-016 TTL output is at 5V signal levels. There are varying schools of thought on whether the ESP82xx has 5V tolerant GPIO. You may want to use a level shifter for the serial communications signals to bring them to the recommended 3.3V. PZEM-016 modules can be converted from RS485 to TTL serial level devices by simply removing the internal MAX485 chip and adding two internal jumper wires. This will bring the serial port connections out via the four-pin terminal block. Pin A is now TTL serial out (Tx) and pin B TTL serial in (Rx). The modification retains the optical isolation used by the PZEM for safety to ensure no high voltages on the outputs. You can use a voltage level shifter to power the ESP82xx from the PZEM-016 module's 5V power. This may also require a 470uf 35V capacitor across the 5V line to work reliably.","title":"PZEM-016"},{"location":"PZEM-0XX/#tasmota-configuration","text":"It is recommended to use GPIO1/GPIO3 or GPIO13/GPIO15 for the most reliable serial communications. You can use any GPIO but anything else will use serial emulation (software). Software serial is not supported with the 2.3 Arduino Core. GPIO Component PZEM 1 PZEM0XX Tx (62) Pin B 3 PZEM016 Rx (98) Pin A","title":"Tasmota Configuration"},{"location":"Peripherals/","text":"Peripherals are sensors, displays, controllers, LEDs and other devices wired to available GPIO pins of your device Tip A peripheral must have correctly wired power, GND and data pins to the device prior to booting in order for Tasmota to detect it and initialize it properly. Supported peripherals list. Tasmota Settings ~ Tasmota allows for easy selection of peripherals and assignment to GPIO pins. Configuration is possible in the webUI Configuration - Configure Module page or by using commands: Module and GPIO , or Template . Module ~ First select desired module for the device (Wait for the restart). Depending on the type of Module , only certain GPIO pins are user configurable. Module Generic (18) has all the GPIOs configurable. Modules shows supported modules GPIO ~ Assign a component to a GPIO. GPIO14 2 configures sensor AM2301 to GPIO14_ Backlog GPIO14 5; GPIO4 6 sets I 2 C SCL to GPIO14 and I 2 C SDA to GPIO4 Tasmota will auto-detect all connected and supported I 2 C devices. If you have conflicting I 2 C addresses see I2CDevices GPIOs All shows list of all available components by name and index For a peripheral to show up you may need to power cycle your device instead of a soft restart. Template ~ Instead of using Module and GPIO you can define everything using Template . Read more... Additional Options ~ Measurement Units Temperature units can be set to Celsius or Fahrenheit with SetOption8 command. Pressure units can be set to hPa or mmHg with SetOption24 command. Update Interval To change the update interval (TelePeriod) of MQTT messages change the TelePeriod . Default interval is 300 seconds but can be set between 10 and 3600 seconds. TelePeriod 10 will set the update interval to 10 seconds, so the sensor will update 6 times a minute. Peripheral Specific Some peripherals offer, or even require, additional commands. See Sensor commands page for peripheral specific commands. Tip To make a link between the different naming schemes the Pin Definition overview in the ESP8266 wiki is quite helpful. Examples ~ Connect switch If you take a Sonoff Basic and connect a switch between pin4 (GND) and pin5 (GPIO14) of the 5 pin programming header you now have a second switch connected to the device. You can set this through the module config page as option Switch1 (9) or from the command line with gpio14 9 . See Buttons and Switches for more information. Connect jack Instead of connecting a switch, you could connect a 4-pin 2.5mm jack, with the pins wired: Jack Pin ESP8266 tip 5 GPIO14 R1 no connection R2 1 GND R3 4 3.3V You can then plug a sensor into the jack like you would to a Sonoff TH and define what sensor you have connected to GPIO14. Restrictions ~ Danger If you can avoid it, don't use GPIOs: 0, 1, 2, 6-11, 15 and 16 . That leaves 4, 5, 12, 13, 14 as GPIOs without any constraints. 3 being RX is also good to avoid (PWM is not working on this GPIO). Others can be used but you have to mind the constraints outlined in this document . Danger The ESP8266 is a 3.3V microcontroller, so its I/O operates at 3.3V as well. The pins are not 5V tolerant, applying more than 3.6V on any pin will release the magic smoke (fry the chip). The maximum current that can be drawn from a single GPIO pin is 12mA. It is important to have a reliable power supply The power supplied to the device is one of the most important elements for stable device operation. Many devices on the market have barely adequate power supplies for normal operation. Connected peripherals may strain the ability of the power supply on the device to deliver appropriate power to all the components, both on-board as well as externally connected. Voltage regulation issues typically result in fatal exception fault code 1 . You must ensure that the device receives sufficient power (current and appropriate voltage level). Take into account the current that each wired component (f.e. sensor) will draw from the device itself. Electrical Considerations ~ When you switch a GPIO pin to an input and hang a long wire off of it, that wire can pick up stray signals and cause the voltage on the GPIO pin to vary. This can cause the system to think the switch has changed. To fix this, there are several things you can do. add a pull-up resistor add a bypass capacitor shielding on the wire use twisted pair wiring A pull-up resistor is a resistor connected between the GPIO pin and 3.3v. The exact value of this is not critical, 4.7k is a common value to use, as is 10k. This ensures that when the switch it open, the GPIO pin will go high. A bypass capacitor is a small (pF range) capacitor that is connected between the GPIO and ground. This provides a path for any radio signals that are picked up by the wire to go to ground and not confuse the system. Shielding or using twisted pair wiring are other ways to reduce the effect of radio signals on the system. Example for 10K Resistor (issue #2708 ) ESP8266 In Depth ~ Complete document available from https://tttapa.github.io/ESP8266/Chap04%20-%20Microcontroller.html Digital I/O ~ Just like a normal Arduino, the ESP8266 has digital input/output pins (I/O or GPIO, General Purpose Input/Output pins). As the name implies, they can be used as digital inputs to read a digital voltage, or as digital outputs to output either 0V (sink current) or 3.3V (source current). Usable Pins ~ The ESP8266 and ESP8285 have 17 GPIO pins (0-16) but several are reserved or have constraints . Do not use any of the reserved pins. If you do, you might crash your program. On the ESP8266, six pins (GPIO 6 - 11) are used to interface the flash memory (the small 8-legged chip usually right next to the ESP8266). The ESP8285 has its flash memory integrated into the chip which frees up GPIO 9 and 10. GPIO 1 and 3 are used as TX and RX of the hardware Serial port (UART), so in most cases, you can\u2019t use them as normal I/O while sending/receiving serial data. GPIO 1, 2 and 3 will cause boot failure if LOW on boot - use with care. Boot Mode Pins Some I/O pins have a special function during boot: They select 1 of 3 boot modes: GPIO15 GPIO0 GPIO2 Mode 0V 0V 3.3V Uart Bootloader 0V 3.3V 3.3V Boot sketch (SPI flash) 3.3V x x SDIO mode (not used for Arduino) Note: you don\u2019t have to add an external pull-up resistor to GPIO2, the internal one is enabled at boot. We have to be sure that these conditions are met by adding external resistors, or the board manufacturer of your board has added them for you. This has some implications, however: GPIO15 is always pulled low, so you can\u2019t use the internal pull-up resistor. You have to keep this in mind when using GPIO15 as an input to read a switch or connect it to a device with an open-collector (or open-drain) output, like I\u00b2C. GPIO0 is pulled high during normal operation, so you can\u2019t use it as a Hi-Z input. GPIO2 can\u2019t be low at boot, so you can\u2019t connect a switch to it. Internal pull-up/-down resistors GPIO 0-15 all have a built-in pull-up resistor, just like in an Arduino. GPIO16 has a built-in pull-down resistor. PWM ~ Unlike most Atmel chips (Arduino), the ESP8266 doesn\u2019t support hardware PWM, however, software PWM is supported on all digital pins. The default PWM range is 10-bits @ 1kHz, but this can be changed (up to >14-bit@1kHz). Check Restrictions . Analog Input ~ The ESP8266 has a single analog input, with an input range of 0 - 1.0V. If you supply 3.3V, for example, you will damage the chip. Some boards like the NodeMCU have an on-board resistive voltage divider, to get an easier 0 - 3.3V range. You could also just use a trimpot as a voltage divider. The ADC (analog to digital converter) has a resolution of 10 bits. Communication ~ Serial ~ The ESP8266 has two hardware UARTS (Serial ports): UART0 on pins 1 and 3 (TX0 and RX0 resp.), and UART1 on pins 2 and 8 (TX1 and RX1 resp.), however, GPIO8 is used to connect the flash chip. This means that UART1 can only transmit data. UART0 also has hardware flow control on pins 15 and 13 (RTS0 and CTS0 resp.). These two pins can also be used as alternative TX0 and RX0 pins. I\u00b2C ~ ESP8266 doesn\u2019t have a hardware TWI (Two Wire Interface) but it is implemented in software. This means that you can use pretty much any two digital pins. By default, the I\u00b2C library uses pin 4 as SDA and pin 5 as SCL. (The data sheet specifies GPIO2 as SDA and GPIO14 as SCL.) The maximum speed is approximately 450kHz. SPI ~ The ESP8266 has one SPI connection available to the user, referred to as HSPI. It uses GPIO14 as CLK, 12 as MISO, 13 as MOSI and 15 as Slave Select (SS). It can be used in both Slave and Master mode (in software). GPIO Overview ~ NodeMCU Labelled Pin GPIO# Function State Restrictions D3 0 Boot mode select 3.3V No Hi-Z D10 1 TX0 - Not usable during Serial transmission - Boot will fail if LOW at boot D4 2 Boot mode select TX1 3.3V (boot only) Don\u2019t connect to ground at boot time - boot will fail. Sends debug data at boot time D9 3 RX0 - Not usable during Serial transmission D2 4 SDA (I\u00b2C) - - D1 5 SCL (I\u00b2C) - - x 6 - 8 Flash connection x Not usable, and not broken out x 9, 10 Flash connection * Only available on the ESP8285 x 11 Flash connection x Not usable, and not broken out D6 12 MISO (SPI) - - D7 13 MOSI (SPI) - - D5 14 SCK (SPI) - - D8 15 SS (SPI) 0V Pull-up resistor not usable (extern pull down resistor) D0 16 Wake up from sleep - No pull-up resistor, but pull-down instead Should be connected to RST to wake up","title":"Peripherals"},{"location":"Peripherals/#tasmota-settings","text":"Tasmota allows for easy selection of peripherals and assignment to GPIO pins. Configuration is possible in the webUI Configuration - Configure Module page or by using commands: Module and GPIO , or Template .","title":"Tasmota Settings"},{"location":"Peripherals/#module","text":"First select desired module for the device (Wait for the restart). Depending on the type of Module , only certain GPIO pins are user configurable. Module Generic (18) has all the GPIOs configurable. Modules shows supported modules","title":"Module"},{"location":"Peripherals/#gpio","text":"Assign a component to a GPIO. GPIO14 2 configures sensor AM2301 to GPIO14_ Backlog GPIO14 5; GPIO4 6 sets I 2 C SCL to GPIO14 and I 2 C SDA to GPIO4 Tasmota will auto-detect all connected and supported I 2 C devices. If you have conflicting I 2 C addresses see I2CDevices GPIOs All shows list of all available components by name and index For a peripheral to show up you may need to power cycle your device instead of a soft restart.","title":"GPIO"},{"location":"Peripherals/#template","text":"Instead of using Module and GPIO you can define everything using Template . Read more...","title":"Template"},{"location":"Peripherals/#additional-options","text":"","title":"Additional Options"},{"location":"Peripherals/#examples","text":"","title":"Examples"},{"location":"Peripherals/#restrictions","text":"Danger If you can avoid it, don't use GPIOs: 0, 1, 2, 6-11, 15 and 16 . That leaves 4, 5, 12, 13, 14 as GPIOs without any constraints. 3 being RX is also good to avoid (PWM is not working on this GPIO). Others can be used but you have to mind the constraints outlined in this document . Danger The ESP8266 is a 3.3V microcontroller, so its I/O operates at 3.3V as well. The pins are not 5V tolerant, applying more than 3.6V on any pin will release the magic smoke (fry the chip). The maximum current that can be drawn from a single GPIO pin is 12mA. It is important to have a reliable power supply The power supplied to the device is one of the most important elements for stable device operation. Many devices on the market have barely adequate power supplies for normal operation. Connected peripherals may strain the ability of the power supply on the device to deliver appropriate power to all the components, both on-board as well as externally connected. Voltage regulation issues typically result in fatal exception fault code 1 . You must ensure that the device receives sufficient power (current and appropriate voltage level). Take into account the current that each wired component (f.e. sensor) will draw from the device itself.","title":"Restrictions"},{"location":"Peripherals/#electrical-considerations","text":"When you switch a GPIO pin to an input and hang a long wire off of it, that wire can pick up stray signals and cause the voltage on the GPIO pin to vary. This can cause the system to think the switch has changed. To fix this, there are several things you can do. add a pull-up resistor add a bypass capacitor shielding on the wire use twisted pair wiring A pull-up resistor is a resistor connected between the GPIO pin and 3.3v. The exact value of this is not critical, 4.7k is a common value to use, as is 10k. This ensures that when the switch it open, the GPIO pin will go high. A bypass capacitor is a small (pF range) capacitor that is connected between the GPIO and ground. This provides a path for any radio signals that are picked up by the wire to go to ground and not confuse the system. Shielding or using twisted pair wiring are other ways to reduce the effect of radio signals on the system. Example for 10K Resistor (issue #2708 )","title":"Electrical Considerations"},{"location":"Peripherals/#esp8266-in-depth","text":"Complete document available from https://tttapa.github.io/ESP8266/Chap04%20-%20Microcontroller.html","title":"ESP8266 In Depth"},{"location":"Peripherals/#digital-io","text":"Just like a normal Arduino, the ESP8266 has digital input/output pins (I/O or GPIO, General Purpose Input/Output pins). As the name implies, they can be used as digital inputs to read a digital voltage, or as digital outputs to output either 0V (sink current) or 3.3V (source current).","title":"Digital I/O"},{"location":"Peripherals/#usable-pins","text":"The ESP8266 and ESP8285 have 17 GPIO pins (0-16) but several are reserved or have constraints . Do not use any of the reserved pins. If you do, you might crash your program. On the ESP8266, six pins (GPIO 6 - 11) are used to interface the flash memory (the small 8-legged chip usually right next to the ESP8266). The ESP8285 has its flash memory integrated into the chip which frees up GPIO 9 and 10. GPIO 1 and 3 are used as TX and RX of the hardware Serial port (UART), so in most cases, you can\u2019t use them as normal I/O while sending/receiving serial data. GPIO 1, 2 and 3 will cause boot failure if LOW on boot - use with care.","title":"Usable Pins"},{"location":"Peripherals/#pwm","text":"Unlike most Atmel chips (Arduino), the ESP8266 doesn\u2019t support hardware PWM, however, software PWM is supported on all digital pins. The default PWM range is 10-bits @ 1kHz, but this can be changed (up to >14-bit@1kHz). Check Restrictions .","title":"PWM"},{"location":"Peripherals/#analog-input","text":"The ESP8266 has a single analog input, with an input range of 0 - 1.0V. If you supply 3.3V, for example, you will damage the chip. Some boards like the NodeMCU have an on-board resistive voltage divider, to get an easier 0 - 3.3V range. You could also just use a trimpot as a voltage divider. The ADC (analog to digital converter) has a resolution of 10 bits.","title":"Analog Input"},{"location":"Peripherals/#communication","text":"","title":"Communication"},{"location":"Peripherals/#serial","text":"The ESP8266 has two hardware UARTS (Serial ports): UART0 on pins 1 and 3 (TX0 and RX0 resp.), and UART1 on pins 2 and 8 (TX1 and RX1 resp.), however, GPIO8 is used to connect the flash chip. This means that UART1 can only transmit data. UART0 also has hardware flow control on pins 15 and 13 (RTS0 and CTS0 resp.). These two pins can also be used as alternative TX0 and RX0 pins.","title":"Serial"},{"location":"Peripherals/#i2c","text":"ESP8266 doesn\u2019t have a hardware TWI (Two Wire Interface) but it is implemented in software. This means that you can use pretty much any two digital pins. By default, the I\u00b2C library uses pin 4 as SDA and pin 5 as SCL. (The data sheet specifies GPIO2 as SDA and GPIO14 as SCL.) The maximum speed is approximately 450kHz.","title":"I\u00b2C"},{"location":"Peripherals/#spi","text":"The ESP8266 has one SPI connection available to the user, referred to as HSPI. It uses GPIO14 as CLK, 12 as MISO, 13 as MOSI and 15 as Slave Select (SS). It can be used in both Slave and Master mode (in software).","title":"SPI"},{"location":"Peripherals/#gpio-overview","text":"NodeMCU Labelled Pin GPIO# Function State Restrictions D3 0 Boot mode select 3.3V No Hi-Z D10 1 TX0 - Not usable during Serial transmission - Boot will fail if LOW at boot D4 2 Boot mode select TX1 3.3V (boot only) Don\u2019t connect to ground at boot time - boot will fail. Sends debug data at boot time D9 3 RX0 - Not usable during Serial transmission D2 4 SDA (I\u00b2C) - - D1 5 SCL (I\u00b2C) - - x 6 - 8 Flash connection x Not usable, and not broken out x 9, 10 Flash connection * Only available on the ESP8285 x 11 Flash connection x Not usable, and not broken out D6 12 MISO (SPI) - - D7 13 MOSI (SPI) - - D5 14 SCK (SPI) - - D8 15 SS (SPI) 0V Pull-up resistor not usable (extern pull down resistor) D0 16 Wake up from sleep - No pull-up resistor, but pull-down instead Should be connected to RST to wake up","title":"GPIO Overview"},{"location":"Pinouts/","text":"Wi-Fi Module Pinouts ~ ESP82xx Based ~ ESP8266 and ESP8285 ~ ESP-12S ~ ESP-WROOM-02 ~ LM1 ~ TYWE1S ~ TYWE2S ~ TYWE2L ~ TYWE3S ~ TYWE3L ~ TYLC4 ~ TYWE5P ~ PSF-B85/PSF-B01/PSF-B04 ~ ESP32 Based ~ ESP32-WROVER ~ ESP32-ESP-WROOM-32 ~ Devices ~ Sonoff Mini ~ Sonoff TH ~ Sonoff Basic ~ Digoo DG-SP202 / OxaOxe NX-SP202 ~ (Found out by tracing the PCB copper tracks of the unknown ESP module. Not verified, except GPIO0, RX, TX, Vcc and GND which have successfully been used for flashing.)","title":"Wi-Fi Module Pinouts"},{"location":"Pinouts/#wi-fi-module-pinouts","text":"","title":"Wi-Fi Module Pinouts"},{"location":"Pinouts/#esp82xx-based","text":"","title":"ESP82xx Based"},{"location":"Pinouts/#esp8266-and-esp8285","text":"","title":"ESP8266 and ESP8285"},{"location":"Pinouts/#esp-12s","text":"","title":"ESP-12S"},{"location":"Pinouts/#esp-wroom-02","text":"","title":"ESP-WROOM-02"},{"location":"Pinouts/#lm1","text":"","title":"LM1"},{"location":"Pinouts/#tywe1s","text":"","title":"TYWE1S"},{"location":"Pinouts/#tywe2s","text":"","title":"TYWE2S"},{"location":"Pinouts/#tywe2l","text":"","title":"TYWE2L"},{"location":"Pinouts/#tywe3s","text":"","title":"TYWE3S"},{"location":"Pinouts/#tywe3l","text":"","title":"TYWE3L"},{"location":"Pinouts/#tylc4","text":"","title":"TYLC4"},{"location":"Pinouts/#tywe5p","text":"","title":"TYWE5P"},{"location":"Pinouts/#psf-b85psf-b01psf-b04","text":"","title":"PSF-B85/PSF-B01/PSF-B04"},{"location":"Pinouts/#esp32-based","text":"","title":"ESP32 Based"},{"location":"Pinouts/#esp32-wrover","text":"","title":"ESP32-WROVER"},{"location":"Pinouts/#esp32-esp-wroom-32","text":"","title":"ESP32-ESP-WROOM-32"},{"location":"Pinouts/#devices","text":"","title":"Devices"},{"location":"Pinouts/#sonoff-mini","text":"","title":"Sonoff Mini"},{"location":"Pinouts/#sonoff-th","text":"","title":"Sonoff TH"},{"location":"Pinouts/#sonoff-basic","text":"","title":"Sonoff Basic"},{"location":"Pinouts/#digoo-dg-sp202-oxaoxe-nx-sp202","text":"(Found out by tracing the PCB copper tracks of the unknown ESP module. Not verified, except GPIO0, RX, TX, Vcc and GND which have successfully been used for flashing.)","title":"Digoo DG-SP202 / OxaOxe NX-SP202"},{"location":"PlatformIO-CLI/","text":"How to flash the Tasmota firmware onto a device using the platformio command line interface. This manual was tested on Ubuntu 17.10. Prerequisites ~ Install Python and PIP ~ sudo apt-get install python-pip Install PlatformIO CLI ~ sudo pip install -U platformio Download the Tasmota source code ~ Either download the latest Tasmota Source code from https://github.com/arendst/Tasmota/ and extract it or clone the Git repository: git clone https://github.com/arendst/Tasmota.git Select the environment ~ The default environment configuration can be used to easily generate Tasmota firmware variants (sonoff, sensors, display, etc.). If you're not sure which binary is the right one for you, consult the builds table or just start with tasmota.bin . To build and/or flash exactly one of these, use the -e command line argument (e.g., -e tasmota-sensors ). Alternatively, uncomment (i.e., remove the leading ; ) the desired env_default line in the platformio.ini file and do not use the -e argument on the command. ; *** Uncomment one of the lines below to build / upload only one environment ; default_envs = tasmota ; default_envs = tasmota - ircustom ; alternative to 'tasmota' with full IR protocols activated , you will need to disable some features to keep code not too big ; default_envs = tasmota - minimal ; default_envs = tasmota - basic ; default_envs = tasmota - knx ; default_envs = tasmota - sensors ; default_envs = tasmota - display ; default_envs = tasmota - ir ; default_envs = tasmota - BG ; default_envs = tasmota - BR ; default_envs = tasmota - CN ; default_envs = tasmota - CZ ; default_envs = tasmota - DE ; default_envs = tasmota - ES ; default_envs = tasmota - FR ; default_envs = tasmota - GR ; default_envs = tasmota - HE ; default_envs = tasmota - HU ; default_envs = tasmota - IT ; default_envs = tasmota - KO ; default_envs = tasmota - NL ; default_envs = tasmota - PL ; default_envs = tasmota - PT ; default_envs = tasmota - RU ; default_envs = tasmota - SE ; default_envs = tasmota - SK ; default_envs = tasmota - TR ; default_envs = tasmota - TW ; default_envs = tasmota - UK Compile and upload ~ Once all the prerequisites are in place, compiling and uploading is one simple command. Execute this from within the Tasmota source code directory: platformio run -e <variant> --target upload --upload-port <port> Just make sure to replace <port> with the actual serial port your device is connected to. On Windows these interfaces are named COM ports (COM1, COM2, etc.). On Linux these interfaces are named TTY ports (e.g., /dev/ttyUSB0, /dev/ttyUSB1, etc.)]. Depending on your configuration your user account may need to be in the dialout group .","title":"PlatformIO CLI"},{"location":"PlatformIO-CLI/#prerequisites","text":"","title":"Prerequisites"},{"location":"PlatformIO-CLI/#install-python-and-pip","text":"sudo apt-get install python-pip","title":"Install Python and PIP"},{"location":"PlatformIO-CLI/#install-platformio-cli","text":"sudo pip install -U platformio","title":"Install PlatformIO CLI"},{"location":"PlatformIO-CLI/#download-the-tasmota-source-code","text":"Either download the latest Tasmota Source code from https://github.com/arendst/Tasmota/ and extract it or clone the Git repository: git clone https://github.com/arendst/Tasmota.git","title":"Download the Tasmota source code"},{"location":"PlatformIO-CLI/#select-the-environment","text":"The default environment configuration can be used to easily generate Tasmota firmware variants (sonoff, sensors, display, etc.). If you're not sure which binary is the right one for you, consult the builds table or just start with tasmota.bin . To build and/or flash exactly one of these, use the -e command line argument (e.g., -e tasmota-sensors ). Alternatively, uncomment (i.e., remove the leading ; ) the desired env_default line in the platformio.ini file and do not use the -e argument on the command. ; *** Uncomment one of the lines below to build / upload only one environment ; default_envs = tasmota ; default_envs = tasmota - ircustom ; alternative to 'tasmota' with full IR protocols activated , you will need to disable some features to keep code not too big ; default_envs = tasmota - minimal ; default_envs = tasmota - basic ; default_envs = tasmota - knx ; default_envs = tasmota - sensors ; default_envs = tasmota - display ; default_envs = tasmota - ir ; default_envs = tasmota - BG ; default_envs = tasmota - BR ; default_envs = tasmota - CN ; default_envs = tasmota - CZ ; default_envs = tasmota - DE ; default_envs = tasmota - ES ; default_envs = tasmota - FR ; default_envs = tasmota - GR ; default_envs = tasmota - HE ; default_envs = tasmota - HU ; default_envs = tasmota - IT ; default_envs = tasmota - KO ; default_envs = tasmota - NL ; default_envs = tasmota - PL ; default_envs = tasmota - PT ; default_envs = tasmota - RU ; default_envs = tasmota - SE ; default_envs = tasmota - SK ; default_envs = tasmota - TR ; default_envs = tasmota - TW ; default_envs = tasmota - UK","title":"Select the environment"},{"location":"PlatformIO-CLI/#compile-and-upload","text":"Once all the prerequisites are in place, compiling and uploading is one simple command. Execute this from within the Tasmota source code directory: platformio run -e <variant> --target upload --upload-port <port> Just make sure to replace <port> with the actual serial port your device is connected to. On Windows these interfaces are named COM ports (COM1, COM2, etc.). On Linux these interfaces are named TTY ports (e.g., /dev/ttyUSB0, /dev/ttyUSB1, etc.)]. Depending on your configuration your user account may need to be in the dialout group .","title":"Compile and upload"},{"location":"PlatformIO/","text":"How to setup and configure PlatformIO for Tasmota compilation and upload. Download PlatformIO ~ Download PlatformIO from http://platformio.org/ Install PlatformIO ~ Install PlatformIO to a known folder. Download Tasmota ~ Download the latest Tasmota Source code from https://github.com/arendst/Tasmota and unzip to another known folder. Configure PlatformIO ~ Copy files ~ Copy all files from the Tasmota Source code into your PlatformIO base folder. Change IDE parameters ~ The default environment configuration can be used to easily generate Tasmota firmware variants (sonoff, sensors, display, etc.). If you're not sure which binary is the right one for you, consult the builds table or just start with tasmota.bin . To build and/or flash exactly one of these, uncomment (i.e., remove the leading ; ) the env_default line for the variant you need. To compile more than one binary variant, uncomment all of the desired env_default lines in the platformio.ini file. Compile Tasmota ~ Select Build from the menu. Upload Tasmota ~ PlatformIO uses the serial interface to upload the firmware to your device. On Windows these interfaces are named COM ports (COM1, COM2, etc.). On Linux these interfaces are named TTY ports (e.g., /dev/ttyUSB0, /dev/ttyUSB1, etc.). Put device into programming mode ~ When performing a firmware upload do not connect the device to AC . Use a 3.3v DC power supply such as that provided by your serial programming adapter. Put the device in programming mode by grounding pin GPIO0 and then applying power (e.g., connecting your computer to the serial adapter). Grounding pin GPIO0 can often be achieved by pressing the button on the device or using a wire between GPIO0 and GND if the button is not available. Deviations may apply. Perform serial upload ~ Select Upload from the menu. NOTE: For a proper device initialization after first firmware upload power down and power up the device.","title":"PlatformIO"},{"location":"PlatformIO/#download-platformio","text":"Download PlatformIO from http://platformio.org/","title":"Download PlatformIO"},{"location":"PlatformIO/#install-platformio","text":"Install PlatformIO to a known folder.","title":"Install PlatformIO"},{"location":"PlatformIO/#download-tasmota","text":"Download the latest Tasmota Source code from https://github.com/arendst/Tasmota and unzip to another known folder.","title":"Download Tasmota"},{"location":"PlatformIO/#configure-platformio","text":"","title":"Configure PlatformIO"},{"location":"PlatformIO/#copy-files","text":"Copy all files from the Tasmota Source code into your PlatformIO base folder.","title":"Copy files"},{"location":"PlatformIO/#change-ide-parameters","text":"The default environment configuration can be used to easily generate Tasmota firmware variants (sonoff, sensors, display, etc.). If you're not sure which binary is the right one for you, consult the builds table or just start with tasmota.bin . To build and/or flash exactly one of these, uncomment (i.e., remove the leading ; ) the env_default line for the variant you need. To compile more than one binary variant, uncomment all of the desired env_default lines in the platformio.ini file.","title":"Change IDE parameters"},{"location":"PlatformIO/#compile-tasmota","text":"Select Build from the menu.","title":"Compile Tasmota"},{"location":"PlatformIO/#upload-tasmota","text":"PlatformIO uses the serial interface to upload the firmware to your device. On Windows these interfaces are named COM ports (COM1, COM2, etc.). On Linux these interfaces are named TTY ports (e.g., /dev/ttyUSB0, /dev/ttyUSB1, etc.).","title":"Upload Tasmota"},{"location":"PlatformIO/#put-device-into-programming-mode","text":"When performing a firmware upload do not connect the device to AC . Use a 3.3v DC power supply such as that provided by your serial programming adapter. Put the device in programming mode by grounding pin GPIO0 and then applying power (e.g., connecting your computer to the serial adapter). Grounding pin GPIO0 can often be achieved by pressing the button on the device or using a wire between GPIO0 and GND if the button is not available. Deviations may apply.","title":"Put device into programming mode"},{"location":"PlatformIO/#perform-serial-upload","text":"Select Upload from the menu. NOTE: For a proper device initialization after first firmware upload power down and power up the device.","title":"Perform serial upload"},{"location":"Power-Monitoring-Calibration/","text":"!> You need to calibrate your power monitoring device as correct measurements are influenced by hardware and timing differences. Your power monitoring capable device flashed with Tasmota and configured with the correct module/template that supports power monitoring An AC capable calibrated multi-meter A known wattage load with a power factor as close to 1 as possible (e.g., a resistive load) for best results Note A resistive load device is any device which draws a constant amount of power. For example, an incandescent or halogen light bulb (best choice since their power draw is declared on them). An electric kettle, heater, or blow dryer are also options but you will also need a power meter since the power draw could vary. Danger Do not use switch mode driven devices such as LED lamps, computer equipment, or inductive/capacitive devices such as motors! (optional) A calibrated power meter (a.k.a Kill-a-Watt) or AC multi-meter Setup ~ Connect the load (e.g., a 60W incandescent light bulb) to your device (optional) Plug your load into the Kill-a-Watt Open two Tasmota web UI browser windows for your power monitoring device: Click on Console in one browser window Keep the other on the main page to view the Power telemetry data Turn the power on to your device. Be sure to turn the output on so the load is powered on as well Wait a few seconds for the readings to stabilize Calibration Procedure ~ Verify the Power reading in the web UI (optionally with the power meter as well) for the expected wattage. Adjust the power offset if needed (in Watts): PowerSet 60.0 If you're using something other than a 60W bulb, enter your load's power rating Verify the Voltage reading. Adjust the voltage offset if needed (in Volts): VoltageSet <voltage> Replace <voltage> with your standard voltage or with reading on your multi-meter if you have one. Your voltage will vary depending on the electrical standards and your electrical grid Verify the Current reading by calculating current value (amperage) using this formula: P (W) /V (V) =I (A) . Adjust the current offset if needed (in milliAmps (mA=A*1000)): CurrentSet <current> Replace <current> with your calculated value (in milliAmps) CurrentSet calculation: P/V=I 1000 * Watts/Volts = milliAmperes Example 1000*(60.0/235.5) = 254.777 Confirm the validity of your calibration process checking Power Factor from the web UI which should be as close as possible to 1.00 . In theory resistive loads will always provide a power factor of 1.00. If that is not the case, we recommend you repeat the calibration process and make sure everything was done correctly. Fine Tuning ~ This procedure requires the use of a calibrated power meter or AC multi-meter. Commands CurrentCal , PowerCal and VoltageCal allow fine tuning of the power calibration. Repeat the procedure below for each of the readings: Current, Power, and Voltage using the corresponding calibration command ( CurrentCal , PowerCal , and VoltageCal respectively). Take note that the offset ranges vary for each command . Check the reading using a multi-meter Compare it with the reading on the Tasmota web UI If there is an observed difference, change the offset value by issuing the calibration command in the Console (e.g., PowerCal 10000 ) Adjust the offset value up or down until the readings on the multi-meter and the web page are as close as possible The CurrentCal , PowerCal , VoltageCal commands accept values up to 32000. If the offset values you would like to specify are larger, you may have configured an incorrect power monitoring chip in the template. For example: if you specify the BL0937 (134) while you actually have an HLW8012 (133). Change the template to proper power monitoring chip to fix. Known Issues ~ Power monitoring chips such as HLW8032 (Blitzwolf SHP5) and CSE7766 (Sonoff S31, Sonoff POW R2) occasionally report invalid power measurements for load values below 5W. During this situation it sometimes reports a valid load. By setting SetOption39 to 128 (default) it must read at least 128 invalid power readings before reporting there is no load. To discard all loads below 6W simply set SetOption39 1 ( 0 will reset to default on next restart) so it will report no load below 6W.","title":"Power Monitoring Calibration"},{"location":"Power-Monitoring-Calibration/#setup","text":"Connect the load (e.g., a 60W incandescent light bulb) to your device (optional) Plug your load into the Kill-a-Watt Open two Tasmota web UI browser windows for your power monitoring device: Click on Console in one browser window Keep the other on the main page to view the Power telemetry data Turn the power on to your device. Be sure to turn the output on so the load is powered on as well Wait a few seconds for the readings to stabilize","title":"Setup"},{"location":"Power-Monitoring-Calibration/#calibration-procedure","text":"Verify the Power reading in the web UI (optionally with the power meter as well) for the expected wattage. Adjust the power offset if needed (in Watts): PowerSet 60.0 If you're using something other than a 60W bulb, enter your load's power rating Verify the Voltage reading. Adjust the voltage offset if needed (in Volts): VoltageSet <voltage> Replace <voltage> with your standard voltage or with reading on your multi-meter if you have one. Your voltage will vary depending on the electrical standards and your electrical grid Verify the Current reading by calculating current value (amperage) using this formula: P (W) /V (V) =I (A) . Adjust the current offset if needed (in milliAmps (mA=A*1000)): CurrentSet <current> Replace <current> with your calculated value (in milliAmps) CurrentSet calculation: P/V=I 1000 * Watts/Volts = milliAmperes Example 1000*(60.0/235.5) = 254.777 Confirm the validity of your calibration process checking Power Factor from the web UI which should be as close as possible to 1.00 . In theory resistive loads will always provide a power factor of 1.00. If that is not the case, we recommend you repeat the calibration process and make sure everything was done correctly.","title":"Calibration Procedure"},{"location":"Power-Monitoring-Calibration/#fine-tuning","text":"This procedure requires the use of a calibrated power meter or AC multi-meter. Commands CurrentCal , PowerCal and VoltageCal allow fine tuning of the power calibration. Repeat the procedure below for each of the readings: Current, Power, and Voltage using the corresponding calibration command ( CurrentCal , PowerCal , and VoltageCal respectively). Take note that the offset ranges vary for each command . Check the reading using a multi-meter Compare it with the reading on the Tasmota web UI If there is an observed difference, change the offset value by issuing the calibration command in the Console (e.g., PowerCal 10000 ) Adjust the offset value up or down until the readings on the multi-meter and the web page are as close as possible The CurrentCal , PowerCal , VoltageCal commands accept values up to 32000. If the offset values you would like to specify are larger, you may have configured an incorrect power monitoring chip in the template. For example: if you specify the BL0937 (134) while you actually have an HLW8012 (133). Change the template to proper power monitoring chip to fix.","title":"Fine Tuning"},{"location":"Power-Monitoring-Calibration/#known-issues","text":"Power monitoring chips such as HLW8032 (Blitzwolf SHP5) and CSE7766 (Sonoff S31, Sonoff POW R2) occasionally report invalid power measurements for load values below 5W. During this situation it sometimes reports a valid load. By setting SetOption39 to 128 (default) it must read at least 128 invalid power readings before reporting there is no load. To discard all loads below 6W simply set SetOption39 1 ( 0 will reset to default on next restart) so it will report no load below 6W.","title":"Known Issues"},{"location":"PowerOnState/","text":"PowerOnState Functionality ~ Command Description PowerOnState Control relay state after powering up the device. 0 / OFF = keep relay(s) OFF after power up 1 / ON = turn relay(s) ON after power up 2 / TOGGLE = toggle relay(s) from last saved state 3 = switch relay(s) to their last saved state (default) 4 = turn relay(s) ON and disable further relay control 5 = after a PulseTime period turn relay(s) ON (acts as inverted PulseTime mode) The PowerOnState device configuration parameter is applied when the device is initially powered up. It does not apply to device warm restarts . Tasmota tracks the relays' state in a masked variable. A set bit ( 1 ) means the corresponding relay is turned ON. The associated GPIO state will be high or low according to whether the relay is configured as Relay<x> or Relay<x>i . Every command for setting the relay state is \"recorded\" in the variable and saved to flash (depending on SetOption0 ). The setting of the relay GPIO is then executed. After a warm restart , the mask variable is re-initialised with the saved state from flash and the relay(s) set to that state. PowerOnState is not executed. During any a device restart, the relay power feedback state is scanned according to the setting of SetOption63 . Scanning the relay state attempts to READ from GPIOs that are configured as relays, i.e., OUTPUTS! The result will not always be what is expected as it depends on how the device relays are wired to the GPIO. SetOption63 was introduced to make this scan optional. With SetOption63 set to 0 (the default), each GPIO assigned as a Relay<x> or Relay<x>i is scanned using 'digitalRead' . The mask variable will be updated with the detected values. The state of the relay(s) will not be changed. READING from an OUTPUT GPIO may result in the mask value being different from the state the relays are in. Thus, SetOption63 was introduced to disable the startup scan for devices where the scan leads to undefined results. SetOption63 is executed after PowerOnState or restart initialization.","title":"PowerOnState"},{"location":"PowerOnState/#poweronstate-functionality","text":"Command Description PowerOnState Control relay state after powering up the device. 0 / OFF = keep relay(s) OFF after power up 1 / ON = turn relay(s) ON after power up 2 / TOGGLE = toggle relay(s) from last saved state 3 = switch relay(s) to their last saved state (default) 4 = turn relay(s) ON and disable further relay control 5 = after a PulseTime period turn relay(s) ON (acts as inverted PulseTime mode) The PowerOnState device configuration parameter is applied when the device is initially powered up. It does not apply to device warm restarts . Tasmota tracks the relays' state in a masked variable. A set bit ( 1 ) means the corresponding relay is turned ON. The associated GPIO state will be high or low according to whether the relay is configured as Relay<x> or Relay<x>i . Every command for setting the relay state is \"recorded\" in the variable and saved to flash (depending on SetOption0 ). The setting of the relay GPIO is then executed. After a warm restart , the mask variable is re-initialised with the saved state from flash and the relay(s) set to that state. PowerOnState is not executed. During any a device restart, the relay power feedback state is scanned according to the setting of SetOption63 . Scanning the relay state attempts to READ from GPIOs that are configured as relays, i.e., OUTPUTS! The result will not always be what is expected as it depends on how the device relays are wired to the GPIO. SetOption63 was introduced to make this scan optional. With SetOption63 set to 0 (the default), each GPIO assigned as a Relay<x> or Relay<x>i is scanned using 'digitalRead' . The mask variable will be updated with the detected values. The state of the relay(s) will not be changed. READING from an OUTPUT GPIO may result in the mask value being different from the state the relays are in. Thus, SetOption63 was introduced to disable the startup scan for devices where the scan leads to undefined results. SetOption63 is executed after PowerOnState or restart initialization.","title":"PowerOnState Functionality"},{"location":"Project-AM312-and-Sonoff-R2/","text":"This use case represents a method to use AM312 as a \"wave hand toggle\" (for under-cabinet kitchen LED). Please note that this solution isn't working in 100% (this sensor has a detection range of a few meters, to decrease the range you can remove the lens from the sensor but still it will pick up movement from 50 cm. You can create the Tasmota rule that will disable AM312 toggle action when the light is on and turn off the power after a few minutes. The gesture sensor APDS-9960 should work better for \"hand-wave\" toggle. Wiring for Sonoff Basic R2 ~ As the R2 version doesn't have GPIO14 exposed you can use GPIO3 (RX) as the AM312 data pin. GPIO2 goes high during the boot (it would toggle the switch then). AM312 ESP8255 device VCC 3V3 or VCC VOUT GPIO3 (RX) GND GND Remember to remove the lens to lower the sensitivity of the sensor. Configuration Go to IP of the device, next Configuration --> Configure Module --> set \"GPIO3 Serial In\" to \"Switch1 (9)\" Go to Console and type \" SwitchMode 4 \" ( detailed description of SwitchModes ) to enable toggle switch type. Set rule to turn off light after X amount of seconds (mentioned workaround): rule1 on Switch1#State=2 do backlog Power1 1; RuleTimer1 180 endon on Rules#Timer=1 do backlog Power1 0 endon rule1 1 Rule explanation: Switch1#State=2 - fire the event when switch1 is toggled, Power1 1 - turn on power, RuleTimer1 180 - set Timer1 to 180 seconds and start counting, Rules#Timer=1 - fire the event when Timer1 has stopped, Power1 0 - turn off power. This rule will turn off the light after 3 minutes, if the movement will be detected prior, the timer will be restarted and will count the time from the beginning. Instead of point 3, you can set below rules in order to ignore the second and next movements. It will just turn off the power after 3 minutes. rule1 on Switch1#State=2 do backlog Power1 1; RuleTimer1 180; Rule1 0; Rule2 1 endon rule2 on Rules#Timer=1 do backlog Power1 0; Rule1 1; Rule2 0 endon on Switch1#State=2 do break backlog rule1 1; rule2 0 Rules explanation: rule1 on Switch1#State=2 do backlog Power1 1; RuleTimer1 180; Rule1 0; Rule2 1 endon : Switch1#State=2 - fire the event when switch1 is toggled, Power1 1 - turn on power, RuleTimer1 180 - set Timer1 to 180 seconds and start counting, Rule1 0 - disable Rule1, Rule2 1 - enable Rule2. rule2 on Rules#Timer=1 do backlog Power1 0; Rule1 1; Rule2 0 endon on Switch1#State=2 do break : Rules#Timer=1 - fire the event when Timer1 has stopped Power1 0 - turn off power Rule1 1 - enable Rule1 Rule2 0 - disable Rule2 Switch1#State=2 do break - ignore toggling","title":"Project AM312 and Sonoff R2"},{"location":"Project-AM312-and-Sonoff-R2/#wiring-for-sonoff-basic-r2","text":"As the R2 version doesn't have GPIO14 exposed you can use GPIO3 (RX) as the AM312 data pin. GPIO2 goes high during the boot (it would toggle the switch then). AM312 ESP8255 device VCC 3V3 or VCC VOUT GPIO3 (RX) GND GND Remember to remove the lens to lower the sensitivity of the sensor.","title":"Wiring for Sonoff Basic R2"},{"location":"Python-HTTP-OTA-Server/","text":"Introduction ~ Tasmota firmware can be upgraded using 'Firmware Upgrade' option on the main menu and selecting an OTA URL to fetch (and flash) a new firmware on the device. To use this feature, firmware files need to be hosted on an HTTP web server (e.g., http://ota.tasmota.com/tasmota). Alternatively, users can to deploy a local HTTP server with Apache, Nginx, or other software solutions. Python makes available the Flask (micro)framework that can be used at different levels of complexity due to its modular architecture. A simple HTTP server (hello-world) can be deployed with only six lines of Python code. A Flask application to offer Tasmota firmware images for OTA upgrades is available as part of the available tools . Requirements ~ Switching to superuser privileges and installing additional packages (and libraries) on a Linux/Windows box. Python3 (follow instruction related to your operating system) netifaces and Flask libraries - can be installed by 'pip' package manager: pip install netifaces flask Instructions ~ Copy Tasmota firmware binary files in 'tools/fw' directory. A set of pre-built firmware binary files can be downloaded from the Tasmota repository . Configure your Tasmota device with your firmware server URL: Firmware Upgrade -> Upgrade by web server: http://<ip_address>:5000/tasmota.bin or use the following command: Backlog OTAURL http://<ip_address>:5000/tasmota.bin; Upgrade 1 Usage ~ To start Python HTTP server: python fw-server.py -d <net_iface> (default: eth0) or python fw-server.py -i <ip_address> Example: python fw-server.py -d wlan0 or python fw-server.py -i 192.168.1.1 Note: On Windows it is advisable to use '-i' option because Windows uses UUID naming for network interfaces that are difficult to enter. Linux server: ~ If your MQTT broker is hosted on a local server, you may want your firmware web server used for Tasmota OTA updates to reside on the same server. Follow these steps to create it as a service: - Copy the python script on the Linux server: $ sudo su # mkdir /srv/tasmota/fw_server/fw # cd /srv/tasmota/fw_server # wget https://github.com/arendst/Tasmota/tree/development/tools/fw_server/fw-server.py - Create a new file named tasmota.service in /etc/systemd/system/ and paste these lines (replace XYZ by your username): ``` [Unit] Description=Local OTA server for Tasmota Requires=network.target After=network.target multi-user.target [Service] User=XYZ Type=idle ExecStart=/usr/bin/python /srv/tasmota/fw_server/fw-server.py -d wlan0 Restart=on-failure [Install] WantedBy=multi-user.target - User rights: The files and directories have been created as `root` but this is not desirable. Invoke the following commands (replace the four instances of `XYZ` by your username): # chown -hR XYZ:XYZ /srv/tasmota # chown XYZ:XYZ /etc/systemd/system/tasmota.service - Run the service: # systemctl daemon-reload # systemctl enable tasmota.service # systemctl start tasmota.service ``` If the server is rebooted, the service will automatically restart. - Check that the service is active and running: # systemctl status tasmota.service - Test the server: Copy new firmware files to the /srv/tasmota/fw_server/fw folder. Ensure that they have XYZ user rights in a similar fashion as shown above. You can use scp or a samba share. Copy the firmware files into the folder ( firmware.bin in the example below). The service can be tested from any browser by issuing the address http://<ip_address>:5000/firmware.bin were <ip_address> is the address of the Linux server. If the web server becomes unresponsive: After a power failure, your wlan0 IP may resolve to an invalid value like 169.254.5.153 because your LAN gateway was not ready when the web server restarted. If you notice that the OTA mechanism is broken, try to download the file from a browser. If you can't, then restart the service and check the status. Log in using a terminal session and enter: $ sudo su # systemctl restart tasmota.service # systemctl status tasmota.service If you recognize the IP address of your server on the last line of the status output, the web server should be OK. You can confirm that your OTA web server is restored by trying to download a file using your web browser. PlatformIO: If you want PlatformIO to be able to upload your compiled binaries to the local server, you'll still have to setup ssh with ssh-keygen in order to use the Tasmota script pio/sftp-uploader.py without a password.","title":"Python HTTP OTA Server"},{"location":"Python-HTTP-OTA-Server/#introduction","text":"Tasmota firmware can be upgraded using 'Firmware Upgrade' option on the main menu and selecting an OTA URL to fetch (and flash) a new firmware on the device. To use this feature, firmware files need to be hosted on an HTTP web server (e.g., http://ota.tasmota.com/tasmota). Alternatively, users can to deploy a local HTTP server with Apache, Nginx, or other software solutions. Python makes available the Flask (micro)framework that can be used at different levels of complexity due to its modular architecture. A simple HTTP server (hello-world) can be deployed with only six lines of Python code. A Flask application to offer Tasmota firmware images for OTA upgrades is available as part of the available tools .","title":"Introduction"},{"location":"Python-HTTP-OTA-Server/#requirements","text":"Switching to superuser privileges and installing additional packages (and libraries) on a Linux/Windows box. Python3 (follow instruction related to your operating system) netifaces and Flask libraries - can be installed by 'pip' package manager: pip install netifaces flask","title":"Requirements"},{"location":"Python-HTTP-OTA-Server/#instructions","text":"Copy Tasmota firmware binary files in 'tools/fw' directory. A set of pre-built firmware binary files can be downloaded from the Tasmota repository . Configure your Tasmota device with your firmware server URL: Firmware Upgrade -> Upgrade by web server: http://<ip_address>:5000/tasmota.bin or use the following command: Backlog OTAURL http://<ip_address>:5000/tasmota.bin; Upgrade 1","title":"Instructions"},{"location":"Python-HTTP-OTA-Server/#usage","text":"To start Python HTTP server: python fw-server.py -d <net_iface> (default: eth0) or python fw-server.py -i <ip_address> Example: python fw-server.py -d wlan0 or python fw-server.py -i 192.168.1.1 Note: On Windows it is advisable to use '-i' option because Windows uses UUID naming for network interfaces that are difficult to enter.","title":"Usage"},{"location":"Python-HTTP-OTA-Server/#linux-server","text":"If your MQTT broker is hosted on a local server, you may want your firmware web server used for Tasmota OTA updates to reside on the same server. Follow these steps to create it as a service: - Copy the python script on the Linux server: $ sudo su # mkdir /srv/tasmota/fw_server/fw # cd /srv/tasmota/fw_server # wget https://github.com/arendst/Tasmota/tree/development/tools/fw_server/fw-server.py - Create a new file named tasmota.service in /etc/systemd/system/ and paste these lines (replace XYZ by your username): ``` [Unit] Description=Local OTA server for Tasmota Requires=network.target After=network.target multi-user.target [Service] User=XYZ Type=idle ExecStart=/usr/bin/python /srv/tasmota/fw_server/fw-server.py -d wlan0 Restart=on-failure [Install] WantedBy=multi-user.target - User rights: The files and directories have been created as `root` but this is not desirable. Invoke the following commands (replace the four instances of `XYZ` by your username): # chown -hR XYZ:XYZ /srv/tasmota # chown XYZ:XYZ /etc/systemd/system/tasmota.service - Run the service: # systemctl daemon-reload # systemctl enable tasmota.service # systemctl start tasmota.service ``` If the server is rebooted, the service will automatically restart. - Check that the service is active and running: # systemctl status tasmota.service - Test the server: Copy new firmware files to the /srv/tasmota/fw_server/fw folder. Ensure that they have XYZ user rights in a similar fashion as shown above. You can use scp or a samba share. Copy the firmware files into the folder ( firmware.bin in the example below). The service can be tested from any browser by issuing the address http://<ip_address>:5000/firmware.bin were <ip_address> is the address of the Linux server. If the web server becomes unresponsive: After a power failure, your wlan0 IP may resolve to an invalid value like 169.254.5.153 because your LAN gateway was not ready when the web server restarted. If you notice that the OTA mechanism is broken, try to download the file from a browser. If you can't, then restart the service and check the status. Log in using a terminal session and enter: $ sudo su # systemctl restart tasmota.service # systemctl status tasmota.service If you recognize the IP address of your server on the last line of the status output, the web server should be OK. You can confirm that your OTA web server is restored by trying to download a file using your web browser. PlatformIO: If you want PlatformIO to be able to upload your compiled binaries to the local server, you'll still have to setup ssh with ssh-keygen in order to use the Tasmota script pio/sftp-uploader.py without a password.","title":"Linux server:"},{"location":"RCWL-0516/","text":"RCWL-0516 microwave radar motion sensor ~ module uses a \u201cmicrowave Doppler radar\u201d technique to detect moving objects. Its advantage over traditional PIRs is that it can detect presence through obstacles with a sensing distance of 3m average in real life conditions. Configuration ~ Wiring ~ RCWL-0516 ESP266 GND GND VIN 5V OUT GPIOx Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to Switch1 (9) A configured RCWL-0516 will not appear in the web UI, only the console displays the status of Switch1 as POWER . Continue to use RCWL-0516 just as any other PIR in Tasmota. Buy from AliExpress Features of RCWL-0516 RCWL-0516 Datasheet RCWL-0516 GitHub","title":"RCWL-0516 microwave radar motion sensor"},{"location":"RCWL-0516/#rcwl-0516-microwave-radar-motion-sensor","text":"module uses a \u201cmicrowave Doppler radar\u201d technique to detect moving objects. Its advantage over traditional PIRs is that it can detect presence through obstacles with a sensing distance of 3m average in real life conditions.","title":"RCWL-0516 microwave radar motion sensor"},{"location":"RCWL-0516/#configuration","text":"","title":"Configuration"},{"location":"RCWL-0516/#wiring","text":"RCWL-0516 ESP266 GND GND VIN 5V OUT GPIOx","title":"Wiring"},{"location":"RCWL-0516/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to Switch1 (9) A configured RCWL-0516 will not appear in the web UI, only the console displays the status of Switch1 as POWER . Continue to use RCWL-0516 just as any other PIR in Tasmota. Buy from AliExpress Features of RCWL-0516 RCWL-0516 Datasheet RCWL-0516 GitHub","title":"Tasmota Settings"},{"location":"RDM6300/","text":"RDM6300 RFID reader ~ RDM6300 125KHz cardreader mini-module is designed for reading code from 125KHz card compatible read-only tags and read/write card. Warning ~ There seems to be an issue with some card readers!(the cheap ones?) These output some fake/ghost readings that look like valid card numbers and validate thru the XOR method but are not real. This is confirmed by multiple users. Please see details in issue #9952 . There seem to not be issues yet with SeeedStudio Grove 125Khz Reader or RDM630 Configuration ~ Sensor uses serial interface for communication. Wiring ~ RDM6300 ESP8266 TX GPIOx RX GPIOy Pin3 unused GND GND VCC 5V Tasmota Settings ~ Update 12.10.2020: Seems there is a new driver and you can use RDM6300 RX instead of the SerBr Tx and SerBr Rx . This also seems to show the last card read in the management interface. As a note, the card number that comes from the SerBr was 12 chars and the RDM6300 one has only 8, being stripped by the first 2 and last 2 chars. In the Configuration -> Configure Module page assign: GPIOx to SerBr Tx (71) GPIOy to SerBr Rx (72) If the RFID Tag is held in front of the Antenna the reader starts sending the Tag ID. The Tag Id is prefaced with a 0x02 and the end is delimited with a 0x03. If the reader reads the tag multiple times you would get one line with multiple times the Tag ID. For this to seperate you can add a SerialDelimiter of 0x03. This will split the result from the serial into serveral single mqtt messages. But (probably) all the messages wil be prepended with a binary 0x02. Set SerialDelimiter to 3 SerialDelimiter 3 OpenHab ~ sonoff-rfid.items: // tele/sonoff-rfid-1/RESULT {\"SSerialReceived\":\"01020304FAFA\"} String RFID_1 \"RFID [%s]\" {mqtt=\"<[broker:tele/sonoff-rfid-1/RESULT:state:JSONPATH($.SSerialReceived)]\"} Breakout Boards ~","title":"RDM6300 RFID reader"},{"location":"RDM6300/#rdm6300-rfid-reader","text":"RDM6300 125KHz cardreader mini-module is designed for reading code from 125KHz card compatible read-only tags and read/write card.","title":"RDM6300 RFID reader"},{"location":"RDM6300/#warning","text":"There seems to be an issue with some card readers!(the cheap ones?) These output some fake/ghost readings that look like valid card numbers and validate thru the XOR method but are not real. This is confirmed by multiple users. Please see details in issue #9952 . There seem to not be issues yet with SeeedStudio Grove 125Khz Reader or RDM630","title":"Warning"},{"location":"RDM6300/#configuration","text":"Sensor uses serial interface for communication.","title":"Configuration"},{"location":"RDM6300/#wiring","text":"RDM6300 ESP8266 TX GPIOx RX GPIOy Pin3 unused GND GND VCC 5V","title":"Wiring"},{"location":"RDM6300/#tasmota-settings","text":"Update 12.10.2020: Seems there is a new driver and you can use RDM6300 RX instead of the SerBr Tx and SerBr Rx . This also seems to show the last card read in the management interface. As a note, the card number that comes from the SerBr was 12 chars and the RDM6300 one has only 8, being stripped by the first 2 and last 2 chars. In the Configuration -> Configure Module page assign: GPIOx to SerBr Tx (71) GPIOy to SerBr Rx (72) If the RFID Tag is held in front of the Antenna the reader starts sending the Tag ID. The Tag Id is prefaced with a 0x02 and the end is delimited with a 0x03. If the reader reads the tag multiple times you would get one line with multiple times the Tag ID. For this to seperate you can add a SerialDelimiter of 0x03. This will split the result from the serial into serveral single mqtt messages. But (probably) all the messages wil be prepended with a binary 0x02. Set SerialDelimiter to 3 SerialDelimiter 3","title":"Tasmota Settings"},{"location":"RDM6300/#openhab","text":"sonoff-rfid.items: // tele/sonoff-rfid-1/RESULT {\"SSerialReceived\":\"01020304FAFA\"} String RFID_1 \"RFID [%s]\" {mqtt=\"<[broker:tele/sonoff-rfid-1/RESULT:state:JSONPATH($.SSerialReceived)]\"}","title":"OpenHab"},{"location":"RDM6300/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"RF-Protocol/","text":"This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_RCSWITCH #define USE_RC_SWITCH // Add support for RF transceiver using library RcSwitch (+2k7 code, 460 iram) #endif This guide does not apply to Sonoff RF Bridge specific commands Tasmota uses the rc-switch library to decode RF codes. Supported hardware depends on rc-switch library support only. Sending RF Codes ~ Send an RF control code as a decimal or hexadecimal string in a JSON payload. An inexpensive RF receiver such as a STX882 can be connected to a device running Tasmota. In order to send RF data you need to configure the connected GPIO as RFSend (105) RF Transciever ~ Command Parameters RFsend <value> = code decimal or JSON. Data value is required and can be decimal or hexadecimal (using the 0x prefix), other values are optional. JSON {\"Data\":\"<value>\",\"Bits\":<value>,\"Protocol\":<value>,\"Pulse\":<value>} \"Data\":\"<value>\" = hexadecimal code \"Bits\":<value> = required number of data bits (default = 24 ) \"Protocol\":<value> = protocol number (default = 1 ) \"Repeat\":<value> = repeat value (default = 10 ) \"Pulse\":<value> = pulse value ( 350 = default for protocol 1) \u2003e.g., RFsend {\"Data\":\"0x7028DC\",\"Bits\":24,\"Protocol\":1,\"Pulse\":238} Decimal data, bits, protocol, repeat, pulse \u2003e.g., RFsend 7350492, 24, 1, 10, 238 or RFsend 0x7028DC, 24, 1, 10, 238 If you send only the \"Data\" value in decimal or hexadecimal other values will be sent as default. Example RfSend 123456 will be sent as {\"Data\":\"0x1E240\",\"Bits\":24,\"Protocol\":1,\"Pulse\":351} When sending decimal formatted command you need to follow the pattern otherwise a part of the command will be ignored. Example RfSend 123456, 24, 1, 238 is missing the repeat value so the last number intended as pulse value won't be sent Receiving RF Codes ~ An inexpensive RF receiver such as a SRX882 can be connected to a device running Tasmota. Configure the GPIO connected to Data pin on the RF receiver as 'RFrecv (106)'. If you have an RF receiver configured, a message will be logged each time an RF code is seen. RF driver will try to decode it against all protocols supported by rc-switch library. When Tasmota receives an RF message, the data portion of the payload has the same format as the RFSend JSON parameters. \"RfReceived\":{\"Data\":\"<hex-value>\",\"Bits\":<value>,\"Protocol\":<value>,\"Pulse\":<value>} This JSON payload data can be used in a rule such as: ON RfReceived#Data=<hex-value> DO <command> ENDON Examples: Sonoff RM433 Remote MQT: tele/tasmota/RESULT = {\"Time\":\"2020-05-27T18:59:06\",\"RfReceived\":{\"Data\":\"0x7028D2\",\"Bits\":24,\"Protocol\":1,\"Pulse\":238}}","title":"RF 433MHz Protocol"},{"location":"RF-Protocol/#sending-rf-codes","text":"Send an RF control code as a decimal or hexadecimal string in a JSON payload. An inexpensive RF receiver such as a STX882 can be connected to a device running Tasmota. In order to send RF data you need to configure the connected GPIO as RFSend (105)","title":"Sending RF Codes"},{"location":"RF-Protocol/#rf-transciever","text":"Command Parameters RFsend <value> = code decimal or JSON. Data value is required and can be decimal or hexadecimal (using the 0x prefix), other values are optional. JSON {\"Data\":\"<value>\",\"Bits\":<value>,\"Protocol\":<value>,\"Pulse\":<value>} \"Data\":\"<value>\" = hexadecimal code \"Bits\":<value> = required number of data bits (default = 24 ) \"Protocol\":<value> = protocol number (default = 1 ) \"Repeat\":<value> = repeat value (default = 10 ) \"Pulse\":<value> = pulse value ( 350 = default for protocol 1) \u2003e.g., RFsend {\"Data\":\"0x7028DC\",\"Bits\":24,\"Protocol\":1,\"Pulse\":238} Decimal data, bits, protocol, repeat, pulse \u2003e.g., RFsend 7350492, 24, 1, 10, 238 or RFsend 0x7028DC, 24, 1, 10, 238 If you send only the \"Data\" value in decimal or hexadecimal other values will be sent as default. Example RfSend 123456 will be sent as {\"Data\":\"0x1E240\",\"Bits\":24,\"Protocol\":1,\"Pulse\":351} When sending decimal formatted command you need to follow the pattern otherwise a part of the command will be ignored. Example RfSend 123456, 24, 1, 238 is missing the repeat value so the last number intended as pulse value won't be sent","title":"RF Transciever"},{"location":"RF-Protocol/#receiving-rf-codes","text":"An inexpensive RF receiver such as a SRX882 can be connected to a device running Tasmota. Configure the GPIO connected to Data pin on the RF receiver as 'RFrecv (106)'. If you have an RF receiver configured, a message will be logged each time an RF code is seen. RF driver will try to decode it against all protocols supported by rc-switch library. When Tasmota receives an RF message, the data portion of the payload has the same format as the RFSend JSON parameters. \"RfReceived\":{\"Data\":\"<hex-value>\",\"Bits\":<value>,\"Protocol\":<value>,\"Pulse\":<value>} This JSON payload data can be used in a rule such as: ON RfReceived#Data=<hex-value> DO <command> ENDON Examples: Sonoff RM433 Remote MQT: tele/tasmota/RESULT = {\"Time\":\"2020-05-27T18:59:06\",\"RfReceived\":{\"Data\":\"0x7028D2\",\"Bits\":24,\"Protocol\":1,\"Pulse\":238}}","title":"Receiving RF Codes"},{"location":"RF-Transciever/","text":"RC Switch driver enables sending RF codes through an RF transmitter and receiving them through an RF receiver via rc-switch library . RF Transmitter ~ Not all transmitter modules will work with the rc-switch library. Some of officially supported modules by rc-switch are: SC5262 / SC5272 HX2262 / HX2272 PT2262 / PT2272 EV1527 / RT1527 / FP1527 / HS1527 Intertechno outlets HT6P20X This guide was created using STX882 RF transmitter which also works without issues. Wiring ~ RF ESP266 data GPIOx + 3.3v/5v - GND Tasmota ~ In the Configuration -> Configure Module page assign: GPIOx to RFSend (105) See RF commands for use. RF Receiver ~ RF receiver is used to capture RF codes. Those codes can be sent using RFSend or used as a rule trigger. Not all transmitter modules will have sufficient power or range for normal use This guide is using SRX882 RF receiver module with a helical antenna. Wiring ~ SRX882 ESP266 Data GPIOx VCC 5v GND GND CS 3v3 or 5v CS pin needs to be pulled high to put the module in active mode Tasmota ~ In the Configuration -> Configure Module page assign: GPIOx to RFrecv (106) On a captured code RF receiver sends a tele/%topic%/RESULT JSON reponse visible in console: { \"Time\" : \"2019-01-01T00:00:00\" , \"RfReceived\" : { \"Data\" : \"0x7028D5\" , \"Bits\" : 24 , \"Protocol\" : 1 , \"Pulse\" : 238 } }","title":"RF Transciever"},{"location":"RF-Transciever/#rf-transmitter","text":"Not all transmitter modules will work with the rc-switch library. Some of officially supported modules by rc-switch are: SC5262 / SC5272 HX2262 / HX2272 PT2262 / PT2272 EV1527 / RT1527 / FP1527 / HS1527 Intertechno outlets HT6P20X This guide was created using STX882 RF transmitter which also works without issues.","title":"RF Transmitter"},{"location":"RF-Transciever/#wiring","text":"RF ESP266 data GPIOx + 3.3v/5v - GND","title":"Wiring"},{"location":"RF-Transciever/#tasmota","text":"In the Configuration -> Configure Module page assign: GPIOx to RFSend (105) See RF commands for use.","title":"Tasmota"},{"location":"RF-Transciever/#rf-receiver","text":"RF receiver is used to capture RF codes. Those codes can be sent using RFSend or used as a rule trigger. Not all transmitter modules will have sufficient power or range for normal use This guide is using SRX882 RF receiver module with a helical antenna.","title":"RF Receiver"},{"location":"RF-Transciever/#wiring_1","text":"SRX882 ESP266 Data GPIOx VCC 5v GND GND CS 3v3 or 5v CS pin needs to be pulled high to put the module in active mode","title":"Wiring"},{"location":"RF-Transciever/#tasmota_1","text":"In the Configuration -> Configure Module page assign: GPIOx to RFrecv (106) On a captured code RF receiver sends a tele/%topic%/RESULT JSON reponse visible in console: { \"Time\" : \"2019-01-01T00:00:00\" , \"RfReceived\" : { \"Data\" : \"0x7028D5\" , \"Bits\" : 24 , \"Protocol\" : 1 , \"Pulse\" : 238 } }","title":"Tasmota"},{"location":"Rule-Cookbook/","text":"","title":"Rule Cookbook"},{"location":"Rules/","text":"Rules expand the functionality of Tasmota with user configurable flexible logic Tasmota provides a Rule feature heavily inspired by the ESPEasy implementation while maintaining a small memory footprint. Automation solutions can be implemented without having to add dedicated code or use external solutions. Rules perform actions based on triggers (e.g., switch state change, temperature threshold, events like system boot, a defined timer elapsing, custom defined events, etc.) They are stored in flash and therefore will survive a reboot. Note Most pre-compiled builds have the Rules feature enabled. If you are >compiling your own firmware, in order to use rules, include #define USE_RULES in user_config_override.h . List of Rules Commands Rule Syntax ~ Rule definition syntax ON < trigger > DO < command > [ ENDON | BREAK ] ON - marks the beginning of a rule <trigger> - what condition needs to occur for the rule to trigger DO - statement marking end of trigger and beginning of command part <command> - command that is executed if the <trigger> condition is met ENDON - marks the end of a rule. It can be followed by another rule. BREAK - marks the end of a rule. BREAK will stop the execution of the remaining rules that follow this rule within the rule set. If a rule that ends with BREAK is triggered, the following rules in that rule set will not be executed. This allows the rules to somewhat simulate an \"IF/ELSE\" statement. Rule sets are defined by using the Rule<x> command. After defining a rule set, you have to enable it (turn it on) using Rule<x> 1 . Similarly you can disable the rule set using Rule<x> 0 . Note If bootloops are detected all rules will be disabled as a precaution. See SetOption36 . There are three separate rule sets called Rule1 , Rule2 and Rule3 . Each rule set can contain many rules which are dynamically compressed. Number of rules that can fit in a rule set varies. Expect at least 1000 characters available per rule set. Whenever a rule set is enabled all the rules in it will be active. If the character count of the rules in one set actually exceeds the limit, start using the next rule set. If you have a long list of rules, verify the rules have all fit by inspecting the resulting log. Rules inside a rule set Rule<x> are concatenated and entered as a single statement. Rule < x > ON < trigger1 > DO < command > ENDON ON < trigger2 > DO < command > ENDON ... Spaces after ON , around DO , and before ENDON or BREAK are mandatory. A rule is not case sensitive. Rule Trigger ~ Rule trigger names are derived from the JSON message displayed in the console. Each JSON level (all values enclosed in {...} ) is separated in the trigger with a # . A rule trigger can consist of: [TriggerName]#[ValueName] [TriggerName]#[ValueName][comparison][value] [SensorName]#[ValueName] [SensorName]#[ValueName][comparison][value] Tele-[SensorName]#[ValueName] [TriggerName1]#[TriggerName2]#[ValueName] [TriggerName1]#?#[ValueName] Use ? as a wildcard for a single trigger level. Rule will trigger on [TriggerName]#?#[Value] where ? is any value. Example Rule with a trigger of ZBReceived#?#Power=0 will trigger on {\"ZBReceived\":{\"0x4773\":{\"Power\":0}}} and on {\"ZBReceived\":{\"aqara_switch\":{\"Power\":0}}} both. Note Same trigger may be used in more than one rule. This may be required for some cases of using IF/ELSE since an IF statement cannot be used within a Backlog . Rule Trigger Comparison Operators Operator Function = equal to (used for string comparison) == equal to (used for numerical comparison) > greater than < lesser than != not equal to >= greater than or equal to <= lesser than or equal to | used for modulo operation with remainder = 0 (exact division) Examples of Available Triggers This is just a sampling of available triggers to showcase what is possible and not a definitive list Trigger When it occurs Analog#A0div10 when the A0 input changes by more than 1% it provides a value between 0 and 100 Button2#State when a button changes state: 0 = OFF 1 = ON 2 = TOGGLE 3 = HOLD Clock#Timer=3 when global Timer3 is activated Dimmer#Boot occurs after Tasmota starts Dimmer#State when the value for Dimmer is changed Event#eventName when command Event eventName is executed. You can define your own event values and trigger them with the Event command. FanSpeed#Data=3 when the fan speed is set to 3 Mem<x>#State when the value for Mem<x> is changed Http#Initialized Mqtt#Connected when MQTT is connected Mqtt#Disconnected when MQTT is disconnected Power1#Boot Relay1 state before Wi-Fi and MQTT are connected and before Time sync but after PowerOnState is executed. Power#Boot triggers before System#Boot. This trigger's value will be the last state of Relay1 if PowerOnState is set to its default value ( 3 ). Power1#State when a power output is changed use Power1#state=0 and Power1#state=1 for comparison, not =off or =on Power2 for Relay2, etc. Rotary1#Pos1 when rotary encoder change. See Use a rotary encoder . Rules#Timer=1 when countdown RuleTimer1 expires. Switch1#Boot occurs after Tasmota starts before it is initializated. Switch1#State when a switch changes to state. Will not trigger if SwitchTopic is set. use Switch1#state=0 and Switch1#state=1 for comparison, not =off or =on 0 = OFF 1 = ON 2 = TOGGLE 3 = HOLD ( SwitchTopic 0 must be set for this to trigger) 4 = INC_DEC (increment or decrement dimmer) 5 = INV (change from increment to decrement dimmer and vice versa) 6 = CLEAR (button released for the time set with SetOption32 ) System#Boot occurs once after Tasmota is fully intialized (after the INFO1, INFO2 and INFO3 console messages). System#Boot triggers after Wi-Fi and MQTT (if enabled) are connected. If you need a trigger prior to every service being initialized, use Power1#Boot System#Init occurs once after restart before Wi-Fi and MQTT are initialized System#Save executed just before a planned restart Time#Initialized once when NTP is initialized and time is in sync Time#Initialized>120 once, 120 seconds after NTP is initialized and time is in sync Time#Minute every minute Time#Minute|5 every five minutes Time#Minute=241 every day once at 04:01 (241 minutes after midnight) Time#Set every hour when NTP makes time in sync Var<x>#State when the value for Var<x> is changed (triggers whenever a value is written to Var<x> even if its the same value) Wifi#Connected when Wi-Fi is connected Wifi#Disconnected when Wi-Fi is disconnected Tele-Wifi1#AP when a teleperiod message is sent with the number of the used AP Tele-Wifi1#Ssid when a teleperiod message is sent with the name of the used AP Tele-Wifi1#Bssid when a teleperiod message is sent with the name of the bSSID Tele-Wifi1#Channel when a teleperiod message is sent with the number of the wifi channel used Tele-Wifi1#RSSI when a teleperiod message is sent with the RSSI LEVEL Tele-Wifi1#LinkCount when a teleperiod message is sent with the number of wifi disconnections Tele-Wifi1#Downtime when a teleperiod message is sent with the total seconds of wifi disconnections Every command with a JSON payload response has an associated rule trigger. Trigger When it occurs <command>#Data A one level JSON payload such as {\"Command\":\"value\"} . For example, for {\"Fanspeed\":3}, the trigger is Fanspeed#Data . <command>#level1#level2#levelN A multi-level JSON payload such as {\"TriggerLevel1\":{\"TriggerLevel2\":{\"ValueName\":\"value\"}}} does NOT have the #Data trigger. Instead, the trigger for these responses is TriggerLevel1#TriggerLevel2#ValueName . Example For {\"PulseTime2\":{\"Set\":0,\"Remaining\":0}} , the triggers are PulseTime2#Set and PulseTime2#Remaining .| For a 3 level JSON message such as {\"ZbReceived\":{\"test_switch\":{\"Device\":\"0x0C94\",\"Power\":1,\"Endpoint\":8,\"LinkQuality\":70}}} one possible trigger is ZbReceived#test_switch#Power or another ZbReceived#test_switch#LinkQuality Connected sensors can be a trigger in the form as they are represented in the TelePeriod and Status 8 JSON payloads. Trigger When it occurs DS18B20#Temperature whenever the temperature of sensor DS18B20 changes DS18B20#Temperature<20 whenever the temperature of sensor DS18B20 is below 20 degrees BME280#Humidity==55.5 whenever the humidity of sensor BEM280 equals 55.5% INA219#Current>0.100 whenever the current drawn is more than 0.1A Energy#Power>100 whenever the power used is more than 100W When the payload consists of an array of data eg: ENERGY\":{Current\":[1.320,2.100]} Trigger When it occurs Energy#Current[N] N = Number of the field. 1 for the first 1.320 , 2 for the second 2.100 etc. Energy#Current[1]>1.000 whenever the first value of Energy#Current is higher than 1.000. To trigger only at TelePeriod time, prefix the sensor with the word Tele- . Trigger When it occurs Tele-AM2301#Temperature sensor AM2301 Temperature value when the TelePeriod JSON payload is output Hardware and software serial interface, RF, IR and TuyaMCU are also supported based on their JSON status message: Trigger When it occurs TuyaReceived#Data=<hex_string> whenever <hex_string> is received with TuyaMCU component SerialReceived#Data=<string> whenever <string> is received via hardware serial SSerialReceived#Data=<string> whenever <string> is received via software serial IrReceived#Data=801 whenever an IR signal for a RC5 remote control button 1 is received IrReceived#Data=0x00FF9867 whenever an IR signal with hex code 0x00FF9867 is received RfReceived#RfKey=4 whenever the RF Bridge receives a recognized RfKey 4 signal RfReceived#Data=0xE8329E whenever an RF signal with hex code 0xE8329E is received Rule Command ~ A rule command can be any command listed in the Commands list . The command's <parameter> can be replaced with %value% which will use the value of the trigger. ON Switch1#State DO Power %value% ENDON To accomplish a rule with one trigger but several commands, you need to use Backlog : ON <trigger> DO Backlog <command1>; <command2>; <command3> ENDON Appending new rule onto an existing rule set Use the + character to append a new rule to the rule set. For example: Existing Rule1: ON Rules#Timer=1 DO Mem2 %time% ENDON Rule to append: ON Button1#state DO POWER TOGGLE ENDON Command: Rule1 + ON button1#state DO POWER TOGGLE ENDON Resulting in Rule1 ON Rules # Timer = 1 DO Mem2 % time % ENDON ON Button1 # state DO POWER TOGGLE ENDON You can repeate the same trigger in rules. Rule ON Power2 # state = 1 DO Power1 1 ENDON ON Power2 # state = 1 DO RuleTimer1 100 ENDON Rule Variables ~ There are thirty-two (32) available variables (single precision reals) in Tasmota: Var1..Var16 and Mem1..Mem16 . They provide a means to store the trigger %value% to be used in any rule. All Var will be empty strings when the program starts. The value of all Mem persists after a reboot. The value of a Var<x> and Mem<x> can be: any number any text %var1% to %var16% %mem1% to %mem16% %time% %timestamp% %uptime% %sunrise% %sunset% %utctime% %topic% To set the value for Var<x> and Mem<x> use the command Var<x> <value> Mem<x> <value> The <value> can also be the value of the trigger of the rule. Set Var2 to the temperature of the AM2301 sensor - ON AM2301#Temperature DO Var2 %value% ENDON Set Var4 to Var2's value - ON Event#temp DO Var4 %Var2% ENDON Set Mem2 to the current time (minutes elapsed since midnight) - ON Rules#Timer=1 DO Mem2 %time% ENDON After a Wi-Fi reconnect event, publish a payload containing timestamps of when Wi-Fi was disconnected in From: and when Wi-Fi re-connected in To: to stat/topic/BLACKOUT . Rule1 ON wifi # disconnected DO Var1 % timestamp % ENDON ON wifi # connected DO Var2 % timestamp % ENDON ON mqtt # connected DO Publish stat / topic / BLACKOUT { \"From\" : \"%Var1%\" , \"To\" : \"%Var2%\" } ENDON Delete rule To clear / delete use quote(s): Rule1 \" Conditional Rules ~ This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #define USE_EXPRESSION // Add support for expression evaluation in rules (+3k2 code, +64 bytes mem) #define SUPPORT_IF_STATEMENT // Add support for IF statement in rules (+4k2 code, -332 bytes mem) Major features Support IF, ELSEIF, ELSE Support for <comparison> and <logical expression> as condition Support for executing multiple commands Support for nested IF statements Available free RAM is the only limit for logical operators, parenthesis, and nested IF statements. Grammar <if-statement> IF (<logical-expression>) <statement-list> {ELSEIF (<logical-expression>) <statement-list>} [ELSE <statement-list>] ENDIF (<logical-expression>) Parentheses must enclose the expression. They can also be used to explicitly control the order of evaluation. <comparison-expression> ( <comparison-expression> | <logical-expression> ) {{ AND | OR } <logical-expression> } ( <logical-expression> ) { AND | OR } <logical expression> } <comparison-expression> <expression> { = | < | > | | | == | <= | >= | != } <expression> <statement-list> <statement> { ; <statement> } <statement> { <Tasmota-command> | <if-statement> } Syntax IF statement supports 3 formats: IF (<logical-expression>) <statement-list> ENDIF IF (<logical-expression>) <statement-list> ELSE <statement-list> ENDIF IF (<logical-expression>) <statement-list> [ELSEIF (<logical-expression>) <statement-list> ] ELSE <statement-list> ENDIF When the <if-statement> directly follows the trigger the standard 'Do' syntax applies, however, it is not necessary to use 'Backlog' within the chain Rule1 ON Power1#State DO IF (%value%==1) Backlog Power2 1;Power3 1 ENDIF ENDON is permitted Rule1 ON Power1#State DO IF (%value%==1) Power2 1;Power3 1 ENDIF ENDON is also permitted When the <if-statement> is preceded by other Tasmota commands you should use Backlog rather than Do , e.g. Rule1 ON ENERGY#Current>10 Backlog Power1 0; IF (%var1%==1) Power1 1 ENDIF;Power 2 0;Power3 1 ENDON and not Rule1 ON ENERGY#Current>10 DO Power1 0; IF (%var1%==1) Power1 1 ENDIF ENDON (<logical-expression>) example: (VAR1>=10) - Multiple comparison expressions with logical operator AND or OR between them. AND has higher priority than OR . For example: ((UPTIME>100) AND (MEM1==1) OR (MEM2==1)) - Parenthesis can be used to change the priority of the logical expression evaluation. For example: ((UPTIME>100) AND ((MEM1==1) OR (MEM2==1))) Following variables can be used in <condition> : Symbol Description VAR<x> variable (<x> = 1..MAX_RULE_VARS , e.g., VAR2 ) MEM<x> persistent variable (<x> = 1..MAX_RULE_MEMS , e.g., MEM3 ) TIME minutes past midnight UPTIME uptime minutes UTCTIME UTC time, UNIX timestamp, seconds since 01/01/1970 LOCALTIME local time, UNIX timestamp SUNRISE current sunrise time (minutes past midnight) SUNSET current sunset time (minutes past midnight) <statement-list> - A Tasmota command (e.g., LedPower on ) - Another IF statement ( IF ... ENDIF ) - Multiple Tasmota commands or IF statements separated by ; . For example: Power1 off; LedPower on; IF (Mem1==0) Var1 Var1+1; Mem1 1 ENDIF; Delay 10; Power1 on Backlog is implied and is not required (saves rule set buffer space). But not like this: Power1 off; LedPower on; IF (Mem1==0) Var1 Var1+1; Mem1 1 ENDIF; Delay 10; Power1 on You should split it in two lines like: ON Power2#state=1 DO Power1 off; LedPower on; ENDON ON Power2#state=1 DO IF (Mem1==0) Var1 Var1+1; Mem1 1 ENDIF; Delay 10; Power1 on ENDON Example Rule used to control pressure cooker with a Sonoff S31. Once it is finished cooking, shut off the power immediately. Rule1 ON system # boot DO var1 0 ENDON ON energy # power > 100 DO if ( var1 != 1 ) ruletimer1 0 ; var1 1 endif ENDON ON tele - energy # power < 50 DO if ( var1 == 1 ) var1 2 ; ruletimer1 600 endif ENDON ON rules # timer = 1 DO Backlog var1 0 ; power off ENDON Expressions in Rules ~ This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #define USE_EXPRESSION // Add support for expression evaluation in rules (+3k2 code, +64 bytes mem) #define SUPPORT_IF_STATEMENT // Add support for IF statement in rules (+4k2 code, -332 bytes mem) Beginning with Tasmota version 6.4.1.14, an optional feature for using mathematical expressions in rules was introduced. Supported Commands Once the feature is enabled, the use of expressions is supported in the following commands: Var Mem RuleTimer If conditional statement (requires #define SUPPORT_IF_STATEMENT ) Syntax Expressions can use of the following operators. They are listed by the order of operations priority, from higher to lower. ( ) (parentheses can be used to explicitly control the order of operations) ^ (power) % (modulo, division by zero returns modulo \"0\") * and / (multiplication and division; division by zero returns \"0\") + and - (addition and subtraction) Example 1+2*2 results in 5.0 as the multiplication is done first due to its higher priority (1+2)*2 results in 6.0 In addition to numeric constants, the following symbolic values can be used: Symbol Description VAR<x> variable (<x> = 1..MAX_RULE_VARS , e.g., VAR2 ) MEM<x> persistent variable (<x> = 1..MAX_RULE_MEMS , e.g., MEM3 ) TIME minutes past midnight UPTIME uptime minutes UTCTIME UTC time, UNIX timestamp, seconds since 01/01/1970 LOCALTIME local time, UNIX timestamp SUNRISE current sunrise time (minutes past midnight) SUNSET current sunset time (minutes past midnight) Example Mem1=((0.5*Var1)+10)*0.7 To use expressions in the Var , Mem and RuleTimer commands, an equal sign ( = ) character has to be used after the command. If not, the traditional syntax interpretation is used. Statement Var1 Result Var1=42 42 Var1 1+1 \"1+1\" (the literal string) Var1=1+1 2 Var1=sunset-sunrise duration of daylight in minutes Rule Cookbook ~ Long press on a switch ~ This example is for GPIOs defined as switches not buttons Activate long press action with Switchmode 5 and shorten long press time to 2 seconds ( Setoption32 20 ). Backlog SwitchMode 5 ; SetOption32 20 Rule ON switch1 # state = 3 DO publish cmnd / tasmota02 / POWER 2 ENDON Long pressing on switch1 sends POWER 2 (toggle action) command to the tasmota02 device Notice we use Rule which edits Rule1 rule set. They can be used interchangeably. If your rule does not trigger there could some constraints, in this case if SwitchTopic has a value it will override rules for switches and will need to be disabled: SwitchTopic 0 . Send MQTT message on button press ~ When a button is pressed the user has the possibility to send a MQTT message based on FullTopic and ButtonTopic. This MQTT message is going to be received by the MQTT broker and if there is any other device(s) subscribed to that Topic, it will receive also that message. So this approach can be used for sending messages/commands to MQTT Broker to Home Automation System, and/or sending messages/commands to MQTT Broker to other device(s). A problem with this solution is that on a Sonoff 4CH all four buttons will be sending the same MQTT topic using only a different Power index number like cmnd/ButtonTopic/Power3 toggle . By using a rule a single button can send any MQTT message allowing for more flexibility. Disable ButtonTopic as it overrides rules for buttons: ButtonTopic 0 Rule Rule1 ON button1 # state DO publish cmnd / ring2 / power % value % ENDON ON button2 # state DO publish cmnd / strip1 / power % value % ENDON You will need to enable this rule if it's the first time you've used rule with Rule1 1 Result When Button1 is pressed the rule kicks in and sends a MQTT message substituting variable %value% with the button state, f.e cmnd/ring2/Power 2 . When Button2 is pressed an MQTT message cmnd/strip1/Power 2 will be sent. Usage of one-shot (once) ~ The rule command once option provides the possibility to trigger only once ON a slow change while the change is still within the bounds of the test. Rule ON ENERGY # Current > 0.100 DO publish tool / tablesaw / power 1 ENDON ON ENERGY # Current < 0.100 DO publish tool / tablesaw / power 0 ENDON This creates a rule to publish MQTT commands whenever a Sonoff POW has current passing through it. Used as is, it will publish MQTT commands repeatedly, over and over, while current is >0.100 ... but, executing another command: Rule 5 Now the MQTT message will be sent once, and only once, while the condition is met. This is perfect for thermostat on/off depending on temperature, bathroom extractor fan on/off depending on humidity, workshop dust collector on/off depending on whether some dust-producing machine is running. It meets the 'hard thermostat' requests that have been common. Use a potentiometer ~ Connecting a potentiometer to the Analog A0 input and a rule can be used to control the dimmer state of any device. Hardware - Wemos D1 mini - Potentiometer of 2k2 connected to Gnd, A0 and 3V3 - WS2812 LED Rule ON analog # a0div10 DO dimmer % value % ENDON Result Turning the potentiometer the voltage on the analog input will change resulting in a value change of 0 (Off) to 100 for the trigger. Using this value to control the dimmer of the WS2812 will control the brightness of the led(s) Rule ON analog # a0div10 DO publish cmnd / grouplight / dimmer % value % ENDON Result This time all lights configured with GroupTopic grouplight will change their brightness according to the potentiometer position. NOTE: You might want to execute command SaveData 2 to reduce flash writes ;-) Use a rotary encoder ~ You can capture in rules the value of a rotary encoder connected to 2 GPIOs configured as Rotary_a|<n> and Rotary_b|<n> . Optionally the button of the rotary encoder can be connected to another GPIO configured as Button|<n> . <n> must be the same to allow the encoder to manage 2 absolute counters from the same rotary encoder. To get triggers from the rotary encoder into rules, you must enable SetOption98 1 . The rotary encoder <n> provides a JSON in the form of {'Rotary<n>': {'Pos1': value, 'Pos2': value}} . You can use the following rules triggers: SetOption98 1 Rule1 ON Rotary1 # Pos1 DO something_with % value % ENDON ON Rotary1 # Pos2 DO something_with % value % ENDON Result Pos1 is changed when the rotary encoder is turned while button is not pressed. Pos2 is changed while button is pressed. Both Pos1 and Pos2 are published whatever is the button position, so both trig at the same time. The button will still have it's default action (such as toggling power). If you want to avoid that, you need to capture the button into a dummy rule such as ON Button1#state DO Delay 0 ENDON . The range of the rotary encoder is hardcoded in #define ROTARY_MAX_STEPS 10 . If you want to change the range, you must change the value in your user_config_override.h and recompile . Use Zigbee to control Tasmota devices ~ This setup uses a Zigbee gateway with an Ikea remote switch paired. Ikea switch's name was set with ZbName to make it more user friendly. Rule Rule1 on zbreceived # ikea_switch # power = 1 do publish cmnd / backyard / POWER TOGGLE endon on zbreceived # ikea_switch # power = 0 do publish cmnd / hall_light / POWER TOGGLE endon Result Pressing I on the Ikea switch will toggle backyard device and pressing O toggles hall_light device. Button single press, double press and hold ~ This example show how to assign different behavior to a button other than Button1 . Button1 has special multi-press behaviors associated with it (see Note in Multi-Press Functions ), examples 1 and 2 cannot be applied to Button1. 1st example: [assuming Button2 (or >2) and Setoption73 0] single press: Toggle Power2 (or >2) double press: send a mqtt message hold 2 secs: send a different mqtt message Backlog ButtonTopic 0 ; SetOption1 1 ; SetOption11 0 ; SetOption32 20 Rule1 ON button2 # state = 3 DO publish cmnd / topicHOLD / power2 2 ENDON ON button2 # state = 2 DO publish cmnd / topicDOUBLEPRESS / power2 2 ENDON Rule1 1 2nd example with Setoption11 1 : [assuming Button2 (or >2) and Setoption73 0] single press: send MQTT message double press: Toggle Power2 (or >2) (SetOption11 swaps single and double press) hold 2 secs: send another mqtt message Backlog ButtonTopic 0 ; SetOption1 1 ; SetOption11 1 ; SetOption32 20 Rule1 ON button2 # state = 3 DO publish cmnd / topicHOLD / power2 2 ENDON ON button2 # state = 2 DO publish cmnd / topicSINGLEPRESS / power2 2 ENDON Rule1 1 3rd example for Button1: For assigning different actions to multi-press on Button1, it is mandatory to detach buttons from their default function using SetOption73 1 . With SetOption73 1 buttons only publish a MQTT message ( stat/tasmota/BUTTON<x> = {\"ACTION\":\"xxxx\"} ). To re-assign a specific action, rules must be used like below: single press: Toggle Power1 double press: send a mqtt message hold 2 secs: send a different mqtt message Backlog ButtonTopic 0 ; SetOption73 1 ; SetOption32 20 Rule1 ON button1 # state = 10 DO power1 2 ENDON ON button1 # state = 3 DO publish cmnd / topicHOLD / power 2 ENDON ON button1 # state = 11 DO publish cmnd / topicDOUBLEPRESS / power 2 ENDON Rule1 1 Note SetOption73 1 detaches ALL buttons. If you have more than 1 button, you must create rules for each buttons where you want an action (other than publishing stat/tasmota/BUTTON<x> = {\"ACTION\":\"xxxx\"} ) Disable switch single press and use long press ~ SetOption11 0 Switches do not have double press feature [assuming a connected pushbutton configured as Switch1] single press: Does nothing (empty Delay commands) hold 2 secs: Toggle Power1 Backlog SwitchTopic1 0 ; SwitchMode1 5 ; SetOption32 20 Rule1 ON Switch1 # State = 3 DO Power1 2 ENDON ON Switch1 # State = 2 DO Delay ENDON Rule1 1 Execute several commands when a Timer expires ~ The default Timer1..16 functionality allows for controlling one output to either off, on, toggle or blink. When rules are enabled the blink option will be replaced by rule functionality allowing much more flexibility. Configure timer5 for rule execution when activated: Timer5 { \"Arm\" : 1 , \"Mode\" : 0 , \"Time\" : \"16:00\" , \"Days\" : \"1111111\" , \"Repeat\" : 1 , \"Action\" : 3 } Rule Rule1 ON clock # Timer = 5 DO Backlog Power2 on ; Power1 off ; Power3 2 ENDON Result When the timer expires the rule kicks in and set Power1 to OFF, Power2 to ON and Power3 TOGGLE. If you want to have blink functionality define a rule like ON clock#Timer=5 DO power 3 ENDON Setting variables ~ Demonstrate the use of variables. Make sure to execute commands Rule 4 (Disable one-shot detection) first when trying the following example. Set a variable Rule ON event # setvar1 DO var1 % value % ENDON Command: event setvar1=1 View a variable rule ON event # getvar1 DO var1 ENDON Command: event getvar1 Toggle a variable Rule ON event # togglevar1 DO event toggling1 =% var1 % ENDON ON event # toggling1 < 1 DO event setvar1 = 1 ENDON ON event # toggling1 > 0 DO event setvar1 = 0 ENDON ON event # setvar1 DO var1 % value % ENDON Command: event togglevar1 Show Messages: Rule ON event # message DO publish stat / [ topic ] / log % value % ENDON Command: event message=INIT All event commands can be executed from: console: event anyname=number mqtt: cmnd/[topic]/event anyname=number Everything together: Rule1 ON event # togglevar1 DO event toggling1 =% var1 % ENDON ON event # toggling1 < 1 DO event setvar1 = 1 ENDON ON event # toggling1 > 0 DO event setvar1 = 0 ENDON ON event # setvar1 DO var1 % value % ENDON ON event # getvar1 DO var1 ENDON ON event # message DO publish stat / mqttTopic / log % value % ENDON The following won't work: Rule1 ON event#setvar1 DO Backlog var1 %value%; Power1 %var1% ENDON At least not as you probably would expect. The var1 value used by the Power1 command will be the value present before the Backlog command is executed. This is so, because the rule will replace %var1% BEFORE the Backlog commands are put in the Backlog command stream. Time-delayed Auto-off Switch ~ Rule Rule1 ON button1 # state DO Backlog Power1 % value % ; RuleTimer1 600 ENDON ON Rules # Timer = 1 DO Power1 off ENDON Result on button1#state do Backlog Power1 %value%; On Button press the Light will toggle on/off RuleTimer1 600 ENDON Additionally RuleTimer1 will begin to countdown 10 minutes ON Rules#Timer=1 DO Power1 off ENDON After the RuleTimer1 expires the light will be turned off (if you forgot to turn it off) Time-delay After Switch Off ~ Rule Backlog switchmode1 1 ; rule1 1 Rule1 ON switch1 # state = 1 DO Backlog Power1 on ; ruletimer1 0 ENDON ON switch1 # state = 0 DO ruletimer1 300 ENDON ON rules # timer = 1 DO Power1 0 ENDON Result ruletimer1 300 sets a 5 minute timer. After that time, fan will be switched off. If during the defined 5 minutes (or in general - when timer is counting) you the switch on, the timer will be canceled. switchmode1 1 sets the switch in follow mode (LOW=off, HIGH=on) If you have inverted switch (LOW=on, HIGH=off) then use switchmode1 2 Auto-off Motion Sense Switch ~ Example works fine on a Wemos D1 Mini. Used as night light with motion sensor or as ambient light on floor or kitchen. Connect an LED Strip WS2812 on D1 and the PIR on D2 and a LDR on A0 (voltage divider with 10k ohm resistor) SwitchMode1 1 Rule Rule1 ON analog # a0 < 400 DO Backlog Rule3 0 ; Rule2 1 ENDON ON analog # a0 > 500 DO Backlog Rule2 0 ; Rule3 1 ENDON Rule2 ON switch1 # state DO Backlog Power1 1 ; RuleTimer1 30 ENDON ON Rules # Timer = 1 DO Power1 off ENDON Rule3 ON switch1 # state DO Power1 off ENDON Activate Rule1 with one shot detection Backlog Rule1 1; Rule1 6 Optional Backlog Rule2 4; Rule3 4 Result on analog#a0>400 disable Rule3 and activate Rule2 on analog#a0>500 disable Rule2 and activate Rule3 Rule2 activates the LEDs for RuleTimer1 30 seconds on each trigger from PIR the RuleTimer start again. on Rules#Timer=1 do Power1 off The LEDs turn off after the RuleTimer expires Rule3 is active on daylight and pipe the PIR signal in a Power1 off signal. The LEDs stay off. Control Timers from a Switch ~ Assuming that your switch is on GPIO00 and configured as Switch1 : Switchmode1 1 will make Switch1#state be 1 when ON and 0 when OFF If you don't set Switchmode1 or it is equal 0, it will only have Switch1#state=2 (toggle) and the rule will not work. Rule Rule1 ON Switch1 # state = 1 DO Timers 0 ENDON ON Switch1 # state = 0 DO Timers 1 ENDON Toggle Relay when holding button for 2 seconds ~ The following example is to explain how to catch and use the HOLD feature for buttons. Behavior: Disable Button1 Short Press and Toggle Relay1 only when holding button1 for 2 Seconds. Backlog ButtonTopic 0 ; SetOption1 1 ; SetOption32 20 Rule1 ON button1 # state = 3 DO Power1 2 ENDON ON button1 # state = 2 DO delay ENDON Rule1 1 Commands Explanation ButtonTopic 0 : (default) To not use topics for buttons SetOption1 1 : Allow only single, double and hold press button actions SetOption32 20 : Set key hold time from 0.1 to 10 seconds (20 = 2 seconds) Rule ON button1#state=3 DO Power1 2 ENDON : When holding the button1 for 2 seconds it will toggle relay 1 (state = 3 means HOLD) ON button1#state=2 DO delay ENDON : Do nothing when short pressing the button1 (state = 2 means TOGGLE) Rule1 1 : To enable rules NOTE: There is no state value for \"double press\" for Buttons. It is designed that double press will toggle the relay. See Multi-Press Functions for more information. In the case you do not want the double press feature you can configure your button as switch and also set SwitchMode that fits your use case (such as SwitchMode 5 to make the switch behave like a pushbutton) [SWITCH does not support double press] Another example but using switch instead of button: Backlog SwitchTopic1 0 ; SwitchMode1 5 ; SetOption32 20 Rule1 ON switch1 # state = 3 DO Power1 2 ENDON ON switch1 # state = 2 DO delay ENDON Rule1 1 Make sure Light is on at night ~ Using Timers, you can set a light to turn on and off to illuminate a street/patio by night. But if the device has no power at the trigger time, then, when it powers up, the light will be off all night. So, as a fail-safe, implement a conditional control to be checked at Tasmota Startup. Set Timers to turn on your light at Sunset and Turn off at sunrise. Use poweronstate 0 in order to start with lights off when powering up your device. Set the following rules: Rule1 ON Time # Initialized DO Backlog event checksunrise =% time % ; event checksunset =% time % ENDON ON event # checksunset >% sunset % DO Power1 1 ENDON ON event # checksunrise <% sunrise % DO Power1 1 ENDON The previous rules are conditionals that represent the following logic: IF %time%>%sunset DO Power1 1 / IF %time%<%sunrise DO Power1 1 Turn On Light Before Dawn and At Dusk ~ Turn on light at dusk until your nighttime and again in the morning before dawn. What if the sun sets after your nighttime, as in during the summer? Then the timer will turn off the light at \"night\", but then the Sunset timer will turn it on again, so it stays on all night. Rule Rule1 ON Time # Initialized DO event chkSun ENDON ON Time # Minute =% sunset % DO event chkSun ENDON ON Time # Minute =% mem2 % DO event chkSun ENDON ON Time # Minute =% sunrise % DO event chkSun ENDON ON Time # Minute =% mem1 % DO event chkSun ENDON Rule2 ON event # chkSun DO Backlog var1 0 ; event chkSunrise =% time % ; event chkSunset =% time % ; event chkmorn =% time % ; event chknight =% time % ; event setPower ENDON ON event # chkSunrise <% sunrise % DO var1 1 ENDON ON event # chkSunset >=% sunset % DO var1 1 ENDON ON event # chkmorn <% mem1 % DO var1 0 ENDON ON event # chknight >=% mem2 % DO var1 0 ENDON ON event # setPower DO Power1 % var1 % ENDON Backlog mem1 360 ; mem2 1350 ; Rule1 1 ; Rule2 1 Result When device restarts, calculate if the light should be on or off ON Time#Initialized DO event chkSun ENDON Calculate if the light should be on or off ON Time#Minute=%sunset% DO event chkSun ENDON ON Time#Minute=%mem2% DO event chkSun ENDON ON Time#Minute=%sunrise% DO event chkSun ENDON ON Time#Minute=%mem1% DO event chkSun ENDON Calculate if the light should be on or off on event#chkSun do Backlog Assume off var1 0; Trigger each event with the current time event chkSunrise=%time%; event chkSunset=%time%; event chkmorn=%time%; event chknight=%time%; event setPower End rule ENDON If before sunrise, turn on ON event#chkSunrise<%sunrise% DO var1 1 ENDON If past sunset, turn on ON event#chkSunset>=%sunset% DO var1 1 ENDON But if before Morning time ( mem1 ), do not turn on ON event#chkmorn<%mem1% DO var1 0 ENDON Or if after Night time ( mem2 ), do not turn on ON event#chknight>=%mem2% DO var1 0 ENDON Perform on/off state ON event#setPower DO Power1 %var1% ENDON Set variables for Morning (06h00) and Night (22h30) times Backlog mem1 360; mem2 1350 Turn on the rule sets Backlog Rule1 1; Rule2 1 Enable a PIR Switch only at night ~ Latitude and Longitude need to be set in config. Use PulseTime to specify the duration the light should remains on. Every PIR trigger will restart for that amount of time. SwitchMode1 14 PulseTime 60 Rule1 ON Switch1 # state = 1 DO Backlog event checksunrise =% time % ; event checksunset =% time % ENDON ON event # checksunrise <% sunrise % DO Power1 1 ENDON ON event # checksunset >% sunset % DO Power1 1 ENDON Control luminance switch with Timer ~ Background: Tasmota powers a Sonoff Basic attached to a TS-2561 Luminance Sensor. This switch toggles a lamp ON or OFF. The switch should work as below: i) during daytime (sunrise-sunset): ON when it is too dark (<150 lx) and OFF when it gets brighter (>175 lx). ii) during evenings it ignores the sensor and turns on at sunset and turns off after about 5 hours Approach: Used a combination of Clock Timers and Rule to do this. Timer 1: Power ON switch at Sunset Powers on the switch at sunset with an offset of 20 minutes. Repeats every day. Timer1 { \"Arm\" : 1 , \"Mode\" : 2 , \"Time\" : \"-00:20\" , \"Window\" : 0 , \"Days\" : \"1111111\" , \"Repeat\" : 1 , \"Output\" : 1 , \"Action\" : 1 } Timer 2: Power OFF switch at Night. Turns power OFF at 23.00hrs. Repeats every day. Timer2 { \"Arm\" : 1 , \"Mode\" : 0 , \"Time\" : \"23:00\" , \"Window\" : 0 , \"Days\" : \"1111111\" , \"Repeat\" : 1 , \"Output\" : 1 , \"Action\" : 0 } Timer 3: Trigger Luminance Rule at Sunrise Start watching the Lux sensor 15 minutes after sunrise. Timer3 { \"Arm\" : 1 , \"Mode\" : 1 , \"Time\" : \"00:15\" , \"Window\" : 0 , \"Days\" : \"1111111\" , \"Repeat\" : 1 , \"Output\" : 1 , \"Action\" : 3 } Rule 1: Main Rule to check Luminance If Luminance is less than 150lx, power ON. If it goes beyond 175lx, power OFF. Rule1 ON tele - TSL2561 # Illuminance < 150 DO Power1 1 ENDON ON tele - TSL2561 # Illuminance > 175 DO Power1 0 ENDON Rule1 1 ``` haskell ** Rule 2 :** Trigger Rule1 only in the Mornings This ensures that Rule1 is triggered when Timer3 starts ( in the morning ) and stops when Timer1 starts ( in the evenings ) . ``` haskell Rule2 ON Clock # Timer = 3 DO Rule1 1 ENDON ON Clock # Timer = 1 DO Rule1 0 ENDON Rule2 1 Perform any action on single/double press (for switches AND buttons) ~ Rule SwitchMode 5 Rule1 ON switch1 # state == 2 DO add1 1 ENDON ON switch1 # state == 2 DO Power1 2 ENDON ON var1 # state != 0 DO Backlog delay 6 ; var1 0 ENDON ON var1 # state == 2 DO publish cmnd / othertasmota / POWER toggle ENDON Rule1 on Result each toggle of the switch triggers first condition and adds 1 to our variable (var1 in the example), each toggle of the switch toggles the associated relay ( Power1 2 - but can do anything else instead, Publish for example) when var1 changes to non zero, we set it back to 0 but after a Delay (arbitrarily chosen 6 here - 0.6 seconds) when var1 reaches 2 (i.e. the switch has been toggled twice within the last 0.6 seconds), desired action is triggered (here: Publish to othertasmota ) Every time you press the switch, your light toggles state (as it should). If you do press the switch twice in a rapid succession (i.e., double-click), you can trigger a different action (e.g., on a remote device). Enable or disable relay with a switch in Domoticz ~ When you want to send MQTT messages ( we use domoticz in this example ) and choose when you want the relay on or off, by simply sending HTTP commands to trigger an event. Initial Config: PushButton Doorbell (Sonoff Basic R1) GPIO14 - Switch4 (12) Connect the Switch to GND and the GPIO on your device. Be sure put a 4.7k resistor between VCC(3.3v) and the GPIO. This prevents ghost switching (capacitor is optional) See: YouTube Dont forget to change the IDX value Commands: Backlog SwitchTopic 0 ; SwitchMode4 2 ; SetOption0 0 ; PowerOnState 0 var1 1 Rule1 ON event # doorbell DO var1 % value % ENDON ON switch4 # state = 1 DO publish domoticz / in { \"idx\" : 11 , \"nvalue\" : 1 } ENDON ON switch4 # state = 1 DO Power1 % var1 % ENDON ON switch4 # state = 0 DO publish domoticz / in { \"idx\" : 11 , \"nvalue\" : 0 } ENDON ON switch4 # state = 0 DO Power1 0 ENDON Rule1 1 Usage: Turn off the relay by calling the event using HTTP: http://<tasmotaIP>/cm?cmnd=event%20doorbell=0 Turn on the relay by calling the event using HTTP: http://<tasmotaIP>/cm?cmnd=event%20doorbell=1 If your Tasmota device is password protected, which is most common, then use the following HTTP commands instead. Make sure you change <tasmotaUsername> and <tasmotaPassword> Off: http://<tasmotaIP>/cm?&user=<tasmotaUsername>&password=<tasmotaPassword>&cmnd=event%20doorbell=0 On: http://<tasmotaIP>/cm?&user=<tasmotaUsername>&password=<tasmotaPassword>&cmnd=event%20doorbell=1 Force automatic re-connection to MQTT server via SD DNS ~ In order to search for the MQTT server using SD-DNS service (a.k.a. Bonjour or Zero Network Configuration) the suggested configuration is to leave the MQTT Host field blank. The standard behavior of Tasmota is searches for _mqtt._tcp service resolve that to the proper IP address connect to it in case the connection is successful, retain the IP address and use that in the subsequent connections The above is not proper, though, in case you have a redundant MQTT (e.g., two MQTT server synchronized). In such case, when the active MQTT fails for any reason, the expected behavior is to achieve automatic re-connection to the other MQTT server. That can be easily configured defining the following rule on the device console: Rule1 ON Mqtt # Disconnected DO MqttHost 0 ENDON Rule1 1 If the MqttHost field already contains an IP, you have to delete it using the web interface or the following MQTT command: mosquitto_pub -h mqtt_server.local -t \"cmnd/mqttTopic/MqttHost\" -m '' Change distance to percentage ~ When measuring distance and you have the need to see it in percentage of distance. In the example 100% is everything below 69cm and 0% is everything above 128cm. This is used for showing fill percentage of a wood pellets storage. Rule1 ON tele - SR04 # distance DO Backlog var1 % value % ; event checklimit =% value % ; event senddistance ENDON ON event # checklimit > 128 DO var1 128 ENDON ON event # checklimit < 69 DO var1 68 ENDON ON event # senddistance DO Backlog SCALE1 % var1 % , 128 , 69 , 0 , 100 ; event pubdata ENDON ON event # pubdata DO publish tele / pannrum - temp / SENSOR % var1 % ENDON Rule1 1 Distinguish Switch1 and Switch2 (without the use of Relay1 and Relay2) ~ When two (or more) switches are defined as input and you want to distinguish these in the RESULT topic without the use of Relays, then consider the following rules. SwitchMode1 1 will make Switch1#state to be 1 when ON and 0 when OFF SwitchMode1 1 SwitchMode2 1 will make Switch2#state to be 1 when ON and 0 when OFF SwitchMode2 1 Publish json with key POWER1 and value %value% Rule1 ON switch1 # state DO publish stat / wemos - 4 / RESULT { \"POWER1\" : \"%value%\" } ENDON Publish json with key POWER2 and value %value% Rule2 ON switch2 # state DO publish stat / wemos - 4 / RESULT { \"POWER2\" : \"%value%\" } ENDON Enable Rules Backlog Rule1 1; Rule2 1 Output: RUL : SWITCH1 # STATE performs \"publish stat/wemos-4/RESULT {\" POWER1 \":\" 1 \"}\" MQT : stat /wemos-4/ RESULT = { \"POWER1\" : \"1\" } RUL : SWITCH2 # STATE performs \"publish stat/wemos-4/RESULT {\" POWER2 \":\" 1 \"}\" MQT : stat /wemos-4/ RESULT = { \"POWER2\" : \"1\" } RUL : SWITCH1 # STATE performs \"publish stat/wemos-4/RESULT {\" POWER1 \":\" 0 \"}\" MQT : stat /wemos-4/ RESULT = { \"POWER1\" : \"0\" } RUL : SWITCH2 # STATE performs \"publish stat/wemos-4/RESULT {\" POWER2 \":\" 0 \"}\" MQT : stat /wemos-4/ RESULT = { \"POWER2\" : \"0\" } RUL : SWITCH1 # STATE performs \"publish stat/wemos-4/RESULT {\" POWER1 \":\" 1 \"}\" MQT : stat /wemos-4/ RESULT = { \"POWER1\" : \"1\" } RUL : SWITCH1 # STATE performs \"publish stat/wemos-4/RESULT {\" POWER1 \":\" 0 \"}\" MQT : stat /wemos-4/ RESULT = { \"POWER1\" : \"0\" } Receiving state of anything that triggers SWITCH more than one time ~ With analog intercom doorbells you can take out info about ringing from speaker voltage. You can connect GPIO to it via opto-isolator and resistor to take out state. But even with those speaker voltage is dropping so it switches the device multiple times. MQT : cmnd /doorbell/ POWER2 = OFF ( retained ) MQT : cmnd /doorbell/ POWER2 = ON ( retained ) MQT : cmnd /doorbell/ POWER2 = OFF ( retained ) MQT : cmnd /doorbell/ POWER2 = ON ( retained ) MQT : cmnd /doorbell/ POWER2 = OFF ( retained ) To solve it we can use rules. SwitchTopic 0 Rule1 on System # Boot var1 0 ENDON ON Switch2 # State DO Backlog add1 1 ; event START ENDON ON event # START DO event BELL =% var1 % ENDON ON event # BELL = 1.000 DO Backlog publish cmnd / bell / power on ; RuleTimer1 60 ENDON ON event # BELL = 0 DO publish cmnd / bell / power off ENDON ON Rules # Timer = 1 DO Backlog var1 0 ; event BELL = 0 ENDON Rule1 1 description: Disable SwitchTopic as it overrides rules for switches: SwitchTopic 0 on system boot set var1 to 0 on switch2 click (person pushing doorbell) - var1 += 1; trigger event START on START - set event BELL equal to var1 if event#BELL=1 (triggered first time) publish mqtt message ON and trigger RulesTimer1 for 60 seconds if event#BELL=0 publish mqtt message OFF on RulesTimer1 - reset var1 to 0, and call event#BELL. enable rule 1 In this case we have lock for 60 seconds for multiple people calls or to be resistant for speaker voltage drops. Prevent Wemos D1 mini load overcurrent ~ As a WS2812 24 led ring draws approximately 24x3x20 mA = 1.44A and the Wemos D1 mini powered from a PC's USB port can only provide up to 0.5A it would be nice to have some kind of mechanism in place to limit the amount of current to the WS2812 LEDring to 0.1A. This is still enough to light all 24 leds up to color 202020. Hardware Wemos D1 mini INA219 I 2 C sensor WS2812 LEDring with 24 LEDs powered by the Wemos D1 mini 5V thru the INA219 sensor Rule1 ON INA219 # Current > 0.100 DO Backlog Dimmer 10 ; Color 10 , 0 , 0 ENDON Rule1 on Result - When a user raises brightness to a level using more than 0.1A the rule kicks in and lowers the current by executing command Dimmer 10 and changes the color to Red with command Color 10,0,0 . Using dummy GPIO to send Serial codes to an MCU ~ By having a device that controls all its features through an MCU and reports the states in serial codes to the ESP8266 we have to create some rules to control it using the Web UI or standard Power commands. Rule1 ON Power1 # state = 1 DO serialsend5 55 AA00060005020400010213 ENDON ON Power1 # state = 0 DO serialsend5 55 AA00060005020400010011 ENDON ON Power2 # state = 1 DO serialsend5 55 AA00060005060400010217 ENDON ON Power2 # state = 0 DO serialsend5 55 AA00060005060400010015 ENDON Power1 controls the device, Power2 turn on and off the light on the device. Another rule was created to issue commands on boot so the serial interface works every time and to control the built in fan using Event triggers and have its state retained in an MQTT message for Home Assistant. Rule2 ON system # boot DO Backlog baudrate 9600 ; seriallog 2 ; serialsend5 55 aa000300010306 ENDON ON event # high DO Backlog serialsend5 55 AA00060005650400010175 ; publish2 stat / diffuser / FAN high ENDON ON event # low DO Backlog serialsend5 55 AA00060005650400010074 ; publish2 stat / diffuser / FAN low ENDON Arithmetic commands used with VAR ~ ADD ADD1 to ADD5 : Add a value to VARx Syntax: ADDx value Usage: ADD1 15 Result: VAR1 = VAR1 + 15 SUBTRACT SUB1 to SUB5 : Subtract a value from VARx Syntax: SUBx value Usage: SUB1 15 Result: VAR1 = VAR1 - 15 MULTIPLY MULT1 to MULT5 : Multiply a value to VARx Syntax: MULTx value Usage: MULT1 15 Result: VAR1 = VAR1 * 15 SCALE A VALUE SCALE1 to SCALE5 : Scale a value from a low and high limit to another low and high limit and store it in VARx (directly equivalent to MAP arduino command) Syntax: SCALEx value, fromLow, fromHigh, toLow, toHigh where, value : the number to scale fromLow : the lower bound of the value\u2019s current range fromHigh : the upper bound of the value\u2019s current range toLow : the lower bound of the value\u2019s target range toHigh : the upper bound of the value\u2019s target range (omitted values are taken as zero) Usage: SCALE1 15, 0, 100, 0, 1000 Result: VAR1 = 150 Transmit sensor value only when a delta is reached ~ Send only when the sensor value changes by a certain amount. Rule1 ON SI7021 # temperature >% var1 % DO Backlog var1 % value % ; publish stat / mqttTopic / temp % value % ; var2 % value % ; add1 2 ; sub2 2 ENDON ON SI7021 # temperature <% var2 % DO Backlog var2 % value % ; publish stat / mqttTopic / temp % value % ; var1 % value % ; add1 2 ; sub2 2 ENDON Adjust a value and send it over MQTT ~ This example adds 2 degrees to the measured temperature and then sends that value to an MQTT topic. Rule1 ON tele - SI7021 # temperature DO Backlog var1 % value % ; add1 2 ; event sendtemp ENDON ON event # sendtemp DO publish stat / mqttTopic / temp % var1 % ENDON Control relays via serial ~ This example switches connected relays over the software serial on and off. Write the following rules: rule1 ON SSerialReceived # Data = on DO Power1 1 ENDON ON SSerialReceived # Data = off DO Power1 0 ENDON receiving on and off results in MQT : tele /mqttTopic/ RESULT = { \"SSerialReceived\" : \"on\" } RUL : SSERIALRECEIVED # DATA = ON performs \"Power1 1\" MQT : stat /mqttTopic/ RESULT = { \"POWER\" : \"ON\" } MQT : stat /mqttTopic/ POWER = ON MQT : tele /mqttTopic/ RESULT = { \"SSerialReceived\" : \"off\" } RUL : SSERIALRECEIVED # DATA = OFF performs \"Power1 0\" MQT : stat /mqttTopic/ RESULT = { \"POWER\" : \"OFF\" } MQT : stat /mqttTopic/ POWER = OFF Using BREAK to simulate IF..ELSEIF..ELSE..ENDIF ~ BREAK is an alternative to ENDON . BREAK will stop the execution for the triggers that follow. If a trigger that ends with BREAK fires, then the following triggers of that rule will not be executed. This allows to simulate IF..ELSEIF..ELSE..ENDIF Example: IF temp > 85 then VAR1 more85 ELSEIF temp > 83 then VAR1 more83 ELSEIF temp > 81 then VAR1 more81 ELSEIF temp = 81 then VAR1 equal81 ELSE VAR1 less81 ENDIF With the actual rules, if we use a set like the following: Rule1 ON event # temp > 85 DO VAR1 more85 ENDON ON event # temp > 83 DO VAR1 more83 ENDON ON event # temp > 81 DO VAR1 more81 ENDON ON event # temp = 81 DO VAR1 equal81 ENDON ON event # temp < 81 DO VAR1 less81 ENDON This is the output in the console: CMD : rule MQT : stat /living/ RESULT = { \"Rule1\" : \"ON\" , \"Once\" : \"ON\" , \"StopOnError\" : \"OFF\" , \"Free\" : 322 , \"Rules\" : \"ON event#temp>85 do VAR1 more85 ENDON ON event#temp>83 do VAR1 more83 ENDON on event#temp>81 do VAR1 more81 ENDON on event#temp=81 do VAR1 equal81 ENDON on event#temp<81 DO VAR1 less81 ENDON\" } CMD : event temp = 10 MQT : stat /living/ RESULT = { \"Event\" : \"Done\" } RUL : EVENT # TEMP < 81 performs \"VAR1 less81\" MQT : stat /living/ RESULT = { \"Var1\" : \"less81\" } CMD : event temp = 100 MQT : stat /living/ RESULT = { \"Event\" : \"Done\" } RUL : EVENT # TEMP > 85 performs \"VAR1 more85\" MQT : stat /living/ RESULT = { \"Var1\" : \"more85\" } RUL : EVENT # TEMP > 83 performs \"VAR1 more83\" MQT : stat /living/ RESULT = { \"Var1\" : \"more83\" } RUL : EVENT # TEMP > 81 performs \"VAR1 more81\" MQT : stat /living/ RESULT = { \"Var1\" : \"more81\" } So, all the triggers where TEMP>100, are firing. With the BREAK statement the rule set can be changed to: Rule on event # temp > 85 do VAR1 more85 break on event # temp > 83 do VAR1 more83 break ON event # temp > 81 DO VAR1 more81 ENDON ON event # temp = 81 DO VAR1 equal81 ENDON ON event # temp < 81 DO VAR1 less81 ENDON Which will result in the following output: CMD : rule RSL : RESULT = { \"Rule1\" : \"ON\" , \"Once\" : \"OFF\" , \"StopOnError\" : \"OFF\" , \"Free\" : 321 , \"Rules\" : \"ON event#temp>85 do VAR1 more85 break ON event#temp>83 do VAR1 more83 break on event#temp>81 do VAR1 more81 ENDON on event#temp=81 do VAR1 equal81 ENDON on event#temp<81 DO VAR1 less81 ENDON\" } CMD : event temp = 10 RSL : RESULT = { \"Event\" : \"Done\" } RUL : EVENT # TEMP < 81 performs \"VAR1 less81\" RSL : RESULT = { \"Var1\" : \"less81\" } CMD : event temp = 100 RSL : RESULT = { \"Event\" : \"Done\" } RUL : EVENT # TEMP > 85 performs \"VAR1 more85\" RSL : RESULT = { \"Var1\" : \"more85\" } CMD : event temp = 83 RSL : RESULT = { \"Event\" : \"Done\" } RUL : EVENT # TEMP > 81 performs \"VAR1 more81\" RSL : RESULT = { \"Var1\" : \"more81\" } Adjust PowerDelta according to current Power values ~ Power sensor reporting thresholds are set by a percentage change in the Power value by setting PowerDelta . Power changes from 10W to 11W (10%) may not be very interesting. But power changes from 1000W to 1100W (also 10%) could be very important. To avoid getting reports for small changes but ensuring that larger power swings are reported, a rule set can be used to create a gradient threshold based on the absolute power values. This rule also uses the one-shot feature of rules to avoid reporting of every small change within a threshold window. The rule (a ON/DO/ENDON rule in this the set) will trigger only once when a threshold is crossed. Backlog PowerDelta 0 ; Rule1 0 ; Rule1 5 Rule1 ON ENERGY # Power >= 35 DO Backlog PowerDelta 10 ; Status 8 BREAK ON ENERGY # Power >= 15 DO Backlog PowerDelta 25 ; Status 8 BREAK ON ENERGY # Power > 5 DO Backlog PowerDelta 35 ; Status 8 BREAK ON ENERGY # Power <= 5 DO PowerDelta 100 ENDON Rule1 1 Which translates (pseudo code): IF ENERGY # Power >= 35 // ENERGY # Power GE 35 DO Backlog PowerDelta 10 ; Status 8 ELSE IF ENERGY # Power >= 15 // ENERGY # Power GE 15 and LT 35 DO Backlog PowerDelta 25 ; Status 8 ELSE IF ENERGY # Power > 5 // ENERGY # Power GT 5 and LT 15 DO Backlog PowerDelta 35 ; Status 8 ELSE // ENERGY # Power changed ( i . e . LE 5 ) DO PowerDelta 100 Forward IR signals ~ Using one IR receiver and one sender (or both extender) you can simply forward signals from one to another using the following rule rule1 ON IRreceived # Data DO publish cmnd / irsideboard / irsend { Protocol:NEC , Bits: 32 , Data:% value % } ENDON Garage Door Opener ~ ( #3942 ) // Set the relay on time to signal the opener PulseTime 7 // Send ON and OFF as the switch is ON or OFF Backlog SwitchMode1 1 ; SwitchMode2 1 ; SwitchMode3 1 //No need to save changes on power cycle SetOption0 0 //Don\u2019t blindly run the door on power up PowerOnState 0 //One shot Detection off Backlog Rule1 0 ; Rule1 4 ; Rule2 0 ; Rule2 4 ; Rule2 0 ; Rule2 4 //Set Counter to measure the period between on and off, check if its blinking because of an obstruction Backlog CounterType 1 ; CounterDebounce 100 //So the door doesn't close if you send it an Open when it's already Opened, etc. // var1 = 1 Only When OPEN // var2 = 1 Only When CLOSED // var3 = 1 Only When OPENING // var4 = 1 Only When CLOSING Rule1 ON Switch1 # Boot = 1 DO Backlog delay 99 ; event Opened ENDON ON Switch2 # Boot = 1 DO Backlog delay 99 ; event Closed ENDON ON EVENT # OPEN DO Power1 % var2 % ENDON ON EVENT # CLOSE DO Power1 % var1 % ENDON ON EVENT # STOP DO Backlog Power1 % var3 % ; Power1 % var4 % ; event PState = STOP ENDON ON Switch1 # State = 1 DO event Opened ENDON ON Switch2 # State = 1 DO event Closed ENDON ON Switch1 # State = 0 DO event Closing ENDON ON Switch2 # State = 0 DO event Opening ENDON Rule2 ON event # Opened DO Backlog var 1 ; var2 0 ; var3 0 ; var4 0 ; ruletimer1 0 ; event PState = OPEN ENDON ON event # Closed DO Backlog var1 0 ; var2 1 ; var3 0 ; var4 0 ; ruletimer1 0 ; event PState = CLOSE ENDON ON event # Opening DO Backlog var1 0 ; var2 0 ; var3 1 ; var4 0 ; ruletimer1 15 ; event PState = OPENING ENDON ON event # Closing DO Backlog var1 0 ; var2 0 ; var3 0 ; var4 1 ; ruletimer1 15 ; event PState = CLOSING ENDON Rule3 ON counter # c1 > 1000 DO event PObstr = 0 ENDON ON counter # c1 < 1000 DO event PObstr = 1 ENDON ON event # PObstr DO publish stat / GarageDoor / OBSTR % value % ENDON ON event # PState DO publish stat / GarageDoor / STATE % value % ENDON ON rules # timer = 1 DO event PState = STOP ENDON //Turn on Rules Backlog Rule1 1 ; Rule2 1 ; Rule3 1 IR Remote Button Multi-press ~ For example, a remote control with one button to change speed. This rules simulates pressing the button three times to set the receiving device to the third speed setting. Specify the rule set The <trigger> can be a a condition or an event sent from another device or home automation hub. <topic> corresponds to the device transmitting the code (e.g., YTF IR Bridge ). This could also be modified to send an RF code from a Sonoff RF Bridge . The Delay may not be necessary in your environment or may need to be adjusted according to your device characteristics. Rule 1 ON Event # tora DO Backlog Publish cmnd /< topic >/ IRSend { \"Protocol\" : \"NEC\" , \"Bits\" : 32 , \"Data\" : \"0x00FF30CF\" }; Delay 10 ENDON ON < trigger > DO Backlog Event tora ; Event tora ; Event tora ENDON Enable the Rule set Rule1 1 Two-way light switches without MQTT ~ Two Sonoff T1 3-gang light switches can be used at either end of a room by setting up one the master and the other as the slave. The master performs the switching of the power to the lights, while the slave just asks the master to toggle the power state. The master also turns the slave's relays on and off so that the LED indicators follow the master's state. Using the WebSend command, the two switches can talk to each other without an MQTT broker. It remains to be seen how reliable this is. Starting with the slave, the rule to toggle the master is pretty simple: Rule1 ON Event # sendPower DO WebSend [ 192.168 . 0.74 ] POWER % value % TOGGLE ENDON ON Button1 # State DO Event sendPower = 1 ENDON ON Button2 # State DO Event sendPower = 2 ENDON ON Button3 # State DO Event sendPower = 3 ENDON Rule1 1 Note that having a rule for the Button#State disables the power toggling of the slave's relay(s). This is desirable because we want the master to control the slave's relay state(s) according to its own as follows: Rule1 ON Event # sendPower DO WebSend [ 192.168 . 0.144 ] POWER % Var1 % % value % ENDON ON Power1 # state DO Backlog Var1 1 ; Event sendPower =% value % ENDON ON Power2 # state DO Backlog Var1 2 ; Event sendPower =% value % ENDON ON Power3 # state DO Backlog Var1 3 ; Event sendPower =% value % ENDON Rule1 1 Roller shutter push-button toggle ~ With a two relay device (e.g., Shelly 2.5) configured for a roller shutter, you can also connect push-buttons (configured as switch components in this example) and set them for inverted toggle behavior. Pressing a push-button once makes the roller shutter move in one direction. Pressing it again stops it. These rules each use a variable to remember the shutter state where 0 == Stopped and 1 == Moving . Backlog SwitchTopic 0 ; SwitchMode1 4 ; SwitchMode2 4 Rule1 ON Switch1 # State == 1 DO Add1 1 ENDON ON Var1 # State == 0 DO ShutterStop1 ENDON ON Var1 # State == 1 DO ShutterClose1 ENDON ON Var1 # State >= 2 DO Var1 0 ENDON ON Shutter1 # Close DO Var1 0 ENDON ON Switch2 # State == 1 DO Add2 1 ENDON ON Var2 # State == 0 DO ShutterStop1 ENDON ON Var2 # State == 1 DO ShutterOpen1 ENDON ON Var2 # State >= 2 DO Var2 0 ENDON ON Shutter1 # Open DO Var2 0 ENDON Rule1 1 Control a dimmer with one switch ~ This example is for GPIOs defined as switches not buttons Activate dimmer mode with Switchmode 11 and shorten long press time to 1 second ( Setoption32 10 ). A short press of the switch sends a TOGGLE message to toggle the dimmer. A long press sends repeated INC_DEC messages to increment the dimmer. If a second press of the switch follows the first press a INV message is sent to invert the function from increment to decrement and repeatet INC_DEC messages are sent to decrement the dimmer. After releasing the switch a timeout message CLEAR resets the automation Backlog SwitchMode 11 ; SetOption32 10 Rule1 on system # boot mem1 + ENDON ON switch1 # state = 2 DO publish light / cmnd / POWER TOGGLE ENDON ON switch1 # state = 4 DO publish light / cmnd / DIMMER % mem1 % ENDON ON switch1 # state = 5 DO mem1 - ENDON ON switch1 # state = 6 DO mem1 + ENDON Rule1 1 Notice we use Rule which edits Rule1 rule set. They can be used interchangeably. Watchdog for Wi-Fi router ~ A Tasmota socket can ping a remote host (router itself or something else connected to the router) and power cycle the socket to reboot the router. In this example, ping interval of 3 minutes is used. The simplest watchdog rule does not use variables: Rule1 ON Time # Minute | 3 DO Ping4 192.168 . 1.10 ENDON ON Ping # 192.168 . 1.10 # Success == 0 DO Backlog Power1 0 ; Delay 10 ; Power1 1 ; ENDON Rule1 1 However, if the router becomes unreachable for a long time, the watchdog will keep cycling it every three minutes. This could reduce the watchdog's relay lifetime to months, at most years. Safer option would be to use an exponential backoff algorithm. Var1 contains the current ping interval in minutes, which is trippled after each failed ping, but limited to 1439 minutes (1 day). Rule1 ON system # boot do Var1 3 ENDON ON Var1 # State > 1439 DO Var1 1439 ENDON ON Time # Minute |% var1 % DO Ping4 192.168 . 1.10 ENDON ON Ping # 192.168 . 1.10 # Success == 0 DO backlog Mult1 3 ; Power1 0 ; Delay 10 ; Power1 1 ENDON ON Ping # 192.168 . 1.10 # Success > 0 DO Var1 3 ENDON This requires #define USE_PING and Tasmota version 8.2.0.3 or newer Simple Thermostat Example ~ As example, to be used on a Sonoff TH10 with Sensor Si7021 This example turn on and off an output based on the temperature value and the upper set point and the lower set point. It waits until is enabled by pressing the button or by mqtt message 1 to mem1. This value is remembered. So if power cycle occurs, will resume operation. The set point values can be changed on the fly by mqtt or console commands If the Temperature sensor disconnects, the outputs will shutdown until the sensor is back again and will resume operation. When the device is power up, the thermostat also waits until the sensor value to resume operation. Initial Config: Available physical button as Switch1 Relay1 will be used the controller Rules must be used to control Relay so the pushbutton must only control Switch1 and not directly control the relay - For this we use SwitchMode1 3 as described below and create the necessary rules because the pushbutton control of the relay is only disabled when the rules are in place. Initial config on console: SwitchMode1 3 <- Use the switch1 as pushbutton (It will allow us to disable the link between the button and the relay by inserting a rule to dictate what the pushbutton will do - NOTE: Until rules are created the pushbutton will still control the relay! ) Rule1 1 <- turn on rules Rule1 4 <- turn off one-shot rule TelePeriod 60 <- check temp every minute SetOption26 1 <- use Power1 on mqtt messages SetOption0 0 <- dont save relay status on eeprom PowerOnState 0 <- start all relays off Mem1 0 <- thermostat status: 0-off 1-enabled - View or set by MQTT cmnd/mqttTopic/mem1 Mem2 25 <- setpoint Temp upper limit - View or set by MQTT cmnd/mqttTopic/mem2 Mem3 23 <- setpoint Temp lower limit - View or set by MQTT cmnd/mqttTopic/mem3 Var1 0 <- thermostat actual status: 1-OK 0-NOT READY - View by MQTT cmnd/mqttTopic/var1 Rules On boot start a watchdog timer to check temp sensor connection. Rule ON system # boot DO RuleTimer1 70 ENDON An available button is configured as switch to set thermostat ON or OFF Rule1 ON switch1 # state DO Backlog event toggling1 =% mem1 % ENDON ON event # toggling1 = 0 DO mem1 1 ENDON ON event # toggling1 = 1 DO mem1 0 ENDON Check temp sensor connection. If fails, set to off and turn off thermostat. Also continue checking Rule ON Rules # Timer = 1 DO Backlog var1 0 ; RuleTimer1 70 ; Power1 0 ENDON Resets checking timer if temperature is connected Rule ON tele - SI7021 # temperature DO Backlog var1 1 ; RuleTimer1 30 ; event ctrl_ready = 1 ; event temp_demand =% value % ENDON Thermostat control - upper limit and lower limit and enabled Rule1 ON event # ctrl_ready >% mem1 % DO var1 0 ENDON ON event # temp_demand >% mem2 % DO Power1 0 ENDON ON event # temp_demand <% mem3 % DO Power1 % var1 % ENDON Thermostat can be turned On by: pushing button by command on local console: mem1 1 by command on any other console: publish cmnd/mqttTopic/mem1 1 or MQTT at: cmnd/mqttTopic/mem1 1 Thermostat can be turned Off by: pushing button by command on local console: mem1 0 by command on any other console: publish cmnd/mqttTopic/mem1 0 or MQTT at: cmnd/mqttTopic/mem1 0 To get the status: mem1 <- thermostat status: 0-off 1-enabled - View or set by MQTT cmnd/mqttTopic/mem1 mem2 <- setpoint Temp upper limit - View or set by MQTT cmnd/mqttTopic/mem2 mem3 <- setpoint Temp lower limit - View or set by MQTT cmnd/mqttTopic/mem3 var1 <- thermostat actual status: 1-OK 0-NOT READY - View by MQTT cmnd/mqttTopic/var1 Everything together: Initial config: RuleTimer1 must be greater that TelePeriod for expected results Backlog SwitchMode1 3 ; Rule 1 ; Rule 4 ; TelePeriod 60 ; SetOption26 1 ; SetOption0 0 ; poweronstate 0 ; mem1 0 ; mem2 25 ; mem3 23 ; var1 0 Rules Rule1 ON system # boot DO RuleTimer1 70 ENDON ON Switch1 # State DO event toggling1 =% mem1 % ENDON ON event # toggling1 = 0 DO mem1 1 ENDON ON event # toggling1 = 1 DO mem1 0 ENDON ON Rules # Timer = 1 DO Backlog var1 0 ; RuleTimer1 70 ; Power1 0 ENDON ON tele - SI7021 # temperature DO Backlog var1 1 ; RuleTimer1 70 ; event ctrl_ready = 1 ; event temp_demand =% value % ENDON ON event # ctrl_ready >% mem1 % DO var1 0 ENDON ON event # temp_demand >% mem2 % DO Power1 0 ENDON ON event # temp_demand <% mem3 % DO Power1 % var1 % ENDON Example rules without temp sensor to test the thermostat rules Rule1 ON system # boot DO RuleTimer1 70 ENDON ON Switch1 # State DO event toggling1 =% mem1 % ENDON ON event # toggling1 = 0 DO mem1 1 ENDON ON event # toggling1 = 1 DO mem1 0 ENDON ON Rules # Timer = 1 DO Backlog var1 0 ; RuleTimer1 70 ; Power1 0 ENDON ON event # temp DO Backlog var1 1 ; RuleTimer1 70 ; event ctrl_ready = 1 ; event temp_demand =% value % ENDON ON event # ctrl_ready >% mem1 % DO var1 0 ENDON ON event # temp_demand >% mem2 % DO Power1 0 ENDON ON event # temp_demand <% mem3 % DO Power1 % var1 % ENDON Tests: Push the button1. The thermostat changes to ENABLED (mem1=1) on console: event temp=20 (now the system receives like a tele message from temperature sensor) and will turn on the relay1 (to heat) on console: event temp=26 (the thermostat turn off the heater) on console: event temp=22 (the thermostat turn on the heater) wait more than a minute without using the event temp and the thermostat will turn off as there is no temperature value (like a sensor error or disconnection) will resume when using again the event temp console mem1 0, DISABLED, console mem1 1, ENABLED Timers: With the above the timers can be used to control mem1 and add a schedule to when the thermostat will be enabled Rule2 ON Clock#Timer=1 DO mem1 1 ENDON ON Clock#Timer=2 DO mem1 0 ENDON Solar heater control ~ In a swimming pool, a filter pump and a solar panel is installed. When the sun is shining, the pump should push water through the solar panel, to heat the pool. When it's night or cloudy, the pump should be off, to avoid cooling the pool water through the solar panel. The pump is controlled by a Sonoff TH10 with 2x DS18B20 sensors connected. 3 rules: Pump should start when solar panel is more than 2 deg warmer than the pool water Pump should stop when solar panel is less than 1 deg warmer than the pool water Pump should not start if the solar panel is below 25 deg Celsius. t1 : pool temp t2 : panel temp var1 : in valid panel temp range? var2 : off threshold temp for panel var3 : on threshold temp for panel mem3 : lowest valid panel temp mem3 25 rule1 ON DS18B20 - 1 # temperature DO event t1 =% value % ENDON ON DS18B20 - 2 # temperature DO event t2 =% value % ENDON ON event # t2 >% mem3 % DO var1 1 ENDON ON event # t2 <=% mem3 % DO var1 0 ENDON ON event # t1 DO Backlog var2 % value % ; add2 1 ENDON ON event # t1 DO Backlog var3 % value % ; add3 2 ENDON ON event # t2 >% var3 % DO Power1 % var1 % ENDON ON event # t2 <% var2 % DO Power1 0 ENDON To test the rule without having the sensors in place, simply enter the events for t1 and t2 in the console: Backlog event t1=21;event t2=30 And watch the relay turn on and off based on the values. Please note that this example does not support manual override or handles missing sensor data. Energy Saving Switch ~ Example of a switch controlling a light with a condition of a required amount of lux. When the switch is on, the light will turn on but only when you have less than 100 lux in that room. While if the switch is off the light will be off. Rule1 ON switch1 # state = 1 DO var1 100 ENDON ON switch1 # state = 0 DO Backlog var1 0 ; Power1 off ENDON ON APDS9960 # Ambient <% var1 % DO Power1 on ENDON Use of variables and tele- in Domoticz ~ Using variables allows for storing sensor results to be used in composing a single HA message like used with Domoticz. To prevent flooding Domoticz with messages we only want to send a message at TelePeriod time. This is achieved by prefixing the <SensorName> with the label tele- . This example will use a variable storing the temperature to be used together with humidity in one Domoticz MQTT message. Domoticz configured with a virtual sensor Temp+Hum using Idx 134 Rule Rule ON tele - am2301 - 12 # temperature DO var1 % value % ENDON ON tele - am2301 - 12 # humidity DO publish domoticz / in { \"idx\" : 134 , \"svalue\" : \"%var1%;%value%;1\" } ENDON Result - As a result of the tele- prefix the rules will be checked at TelePeriod time for sensor AM2301-12 Temperature and Humidity. The first rule will use the Temperature stored in %value% and save it in %var1% for future use. The second rule will use the Humidity stored in %value% and the Temperature stored in %var1% to compose a single MQTT message suitable for Domoticz. RF Repeater / IR Repeater ~ In some applications, an RF-Repeater may come in handy to increase the range of RF based devices. We need to use RF reciever and RF transmitter modules with tasmota powered controllers. The following rule looks for data received by the RF receiver and re transmits the same over the transmitter. Rule1 on RfReceived # data do Rfsend { \"Data\" :% value % , \"Bits\" : 24 , \"Protocol\" : 1 , \"Pulse\" : 454 } endon Enable it with Rule1 1 A similar concept can also work for IR- Repeater. Connect IR receiver module and IR trnasmitter to Tasmotized device and the following rule retransmits any data over IR Rule1 on IrReceived # Data do IRsend { \"Protocol\" : \"NEC\" , \"Bits\" : 32 , \"Data\" :% value % } endon Enable it with Rule1 1 The only catch is that the protocol needs to be setup in the rule. Most likely this can be taken care of by using a more complex rule maybe using variables. Would update in future","title":"Rules"},{"location":"Rules/#rule-syntax","text":"Rule definition syntax ON < trigger > DO < command > [ ENDON | BREAK ] ON - marks the beginning of a rule <trigger> - what condition needs to occur for the rule to trigger DO - statement marking end of trigger and beginning of command part <command> - command that is executed if the <trigger> condition is met ENDON - marks the end of a rule. It can be followed by another rule. BREAK - marks the end of a rule. BREAK will stop the execution of the remaining rules that follow this rule within the rule set. If a rule that ends with BREAK is triggered, the following rules in that rule set will not be executed. This allows the rules to somewhat simulate an \"IF/ELSE\" statement. Rule sets are defined by using the Rule<x> command. After defining a rule set, you have to enable it (turn it on) using Rule<x> 1 . Similarly you can disable the rule set using Rule<x> 0 . Note If bootloops are detected all rules will be disabled as a precaution. See SetOption36 . There are three separate rule sets called Rule1 , Rule2 and Rule3 . Each rule set can contain many rules which are dynamically compressed. Number of rules that can fit in a rule set varies. Expect at least 1000 characters available per rule set. Whenever a rule set is enabled all the rules in it will be active. If the character count of the rules in one set actually exceeds the limit, start using the next rule set. If you have a long list of rules, verify the rules have all fit by inspecting the resulting log. Rules inside a rule set Rule<x> are concatenated and entered as a single statement. Rule < x > ON < trigger1 > DO < command > ENDON ON < trigger2 > DO < command > ENDON ... Spaces after ON , around DO , and before ENDON or BREAK are mandatory. A rule is not case sensitive.","title":"Rule Syntax"},{"location":"Rules/#rule-trigger","text":"Rule trigger names are derived from the JSON message displayed in the console. Each JSON level (all values enclosed in {...} ) is separated in the trigger with a # . A rule trigger can consist of: [TriggerName]#[ValueName] [TriggerName]#[ValueName][comparison][value] [SensorName]#[ValueName] [SensorName]#[ValueName][comparison][value] Tele-[SensorName]#[ValueName] [TriggerName1]#[TriggerName2]#[ValueName] [TriggerName1]#?#[ValueName] Use ? as a wildcard for a single trigger level. Rule will trigger on [TriggerName]#?#[Value] where ? is any value. Example Rule with a trigger of ZBReceived#?#Power=0 will trigger on {\"ZBReceived\":{\"0x4773\":{\"Power\":0}}} and on {\"ZBReceived\":{\"aqara_switch\":{\"Power\":0}}} both. Note Same trigger may be used in more than one rule. This may be required for some cases of using IF/ELSE since an IF statement cannot be used within a Backlog .","title":"Rule Trigger"},{"location":"Rules/#rule-command","text":"A rule command can be any command listed in the Commands list . The command's <parameter> can be replaced with %value% which will use the value of the trigger. ON Switch1#State DO Power %value% ENDON To accomplish a rule with one trigger but several commands, you need to use Backlog : ON <trigger> DO Backlog <command1>; <command2>; <command3> ENDON Appending new rule onto an existing rule set Use the + character to append a new rule to the rule set. For example: Existing Rule1: ON Rules#Timer=1 DO Mem2 %time% ENDON Rule to append: ON Button1#state DO POWER TOGGLE ENDON Command: Rule1 + ON button1#state DO POWER TOGGLE ENDON Resulting in Rule1 ON Rules # Timer = 1 DO Mem2 % time % ENDON ON Button1 # state DO POWER TOGGLE ENDON You can repeate the same trigger in rules. Rule ON Power2 # state = 1 DO Power1 1 ENDON ON Power2 # state = 1 DO RuleTimer1 100 ENDON","title":"Rule Command"},{"location":"Rules/#rule-variables","text":"There are thirty-two (32) available variables (single precision reals) in Tasmota: Var1..Var16 and Mem1..Mem16 . They provide a means to store the trigger %value% to be used in any rule. All Var will be empty strings when the program starts. The value of all Mem persists after a reboot. The value of a Var<x> and Mem<x> can be: any number any text %var1% to %var16% %mem1% to %mem16% %time% %timestamp% %uptime% %sunrise% %sunset% %utctime% %topic% To set the value for Var<x> and Mem<x> use the command Var<x> <value> Mem<x> <value> The <value> can also be the value of the trigger of the rule. Set Var2 to the temperature of the AM2301 sensor - ON AM2301#Temperature DO Var2 %value% ENDON Set Var4 to Var2's value - ON Event#temp DO Var4 %Var2% ENDON Set Mem2 to the current time (minutes elapsed since midnight) - ON Rules#Timer=1 DO Mem2 %time% ENDON After a Wi-Fi reconnect event, publish a payload containing timestamps of when Wi-Fi was disconnected in From: and when Wi-Fi re-connected in To: to stat/topic/BLACKOUT . Rule1 ON wifi # disconnected DO Var1 % timestamp % ENDON ON wifi # connected DO Var2 % timestamp % ENDON ON mqtt # connected DO Publish stat / topic / BLACKOUT { \"From\" : \"%Var1%\" , \"To\" : \"%Var2%\" } ENDON","title":"Rule Variables"},{"location":"Rules/#conditional-rules","text":"This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #define USE_EXPRESSION // Add support for expression evaluation in rules (+3k2 code, +64 bytes mem) #define SUPPORT_IF_STATEMENT // Add support for IF statement in rules (+4k2 code, -332 bytes mem)","title":"Conditional Rules"},{"location":"Rules/#expressions-in-rules","text":"This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #define USE_EXPRESSION // Add support for expression evaluation in rules (+3k2 code, +64 bytes mem) #define SUPPORT_IF_STATEMENT // Add support for IF statement in rules (+4k2 code, -332 bytes mem) Beginning with Tasmota version 6.4.1.14, an optional feature for using mathematical expressions in rules was introduced.","title":"Expressions in Rules"},{"location":"Rules/#rule-cookbook","text":"","title":"Rule Cookbook"},{"location":"Rules/#long-press-on-a-switch","text":"This example is for GPIOs defined as switches not buttons Activate long press action with Switchmode 5 and shorten long press time to 2 seconds ( Setoption32 20 ). Backlog SwitchMode 5 ; SetOption32 20 Rule ON switch1 # state = 3 DO publish cmnd / tasmota02 / POWER 2 ENDON Long pressing on switch1 sends POWER 2 (toggle action) command to the tasmota02 device Notice we use Rule which edits Rule1 rule set. They can be used interchangeably. If your rule does not trigger there could some constraints, in this case if SwitchTopic has a value it will override rules for switches and will need to be disabled: SwitchTopic 0 .","title":"Long press on a switch"},{"location":"Rules/#send-mqtt-message-on-button-press","text":"When a button is pressed the user has the possibility to send a MQTT message based on FullTopic and ButtonTopic. This MQTT message is going to be received by the MQTT broker and if there is any other device(s) subscribed to that Topic, it will receive also that message. So this approach can be used for sending messages/commands to MQTT Broker to Home Automation System, and/or sending messages/commands to MQTT Broker to other device(s). A problem with this solution is that on a Sonoff 4CH all four buttons will be sending the same MQTT topic using only a different Power index number like cmnd/ButtonTopic/Power3 toggle . By using a rule a single button can send any MQTT message allowing for more flexibility. Disable ButtonTopic as it overrides rules for buttons: ButtonTopic 0","title":"Send MQTT message on button press"},{"location":"Rules/#usage-of-one-shot-once","text":"The rule command once option provides the possibility to trigger only once ON a slow change while the change is still within the bounds of the test. Rule ON ENERGY # Current > 0.100 DO publish tool / tablesaw / power 1 ENDON ON ENERGY # Current < 0.100 DO publish tool / tablesaw / power 0 ENDON This creates a rule to publish MQTT commands whenever a Sonoff POW has current passing through it. Used as is, it will publish MQTT commands repeatedly, over and over, while current is >0.100 ... but, executing another command: Rule 5 Now the MQTT message will be sent once, and only once, while the condition is met. This is perfect for thermostat on/off depending on temperature, bathroom extractor fan on/off depending on humidity, workshop dust collector on/off depending on whether some dust-producing machine is running. It meets the 'hard thermostat' requests that have been common.","title":"Usage of one-shot (once)"},{"location":"Rules/#use-a-potentiometer","text":"Connecting a potentiometer to the Analog A0 input and a rule can be used to control the dimmer state of any device. Hardware - Wemos D1 mini - Potentiometer of 2k2 connected to Gnd, A0 and 3V3 - WS2812 LED Rule ON analog # a0div10 DO dimmer % value % ENDON","title":"Use a potentiometer"},{"location":"Rules/#use-a-rotary-encoder","text":"You can capture in rules the value of a rotary encoder connected to 2 GPIOs configured as Rotary_a|<n> and Rotary_b|<n> . Optionally the button of the rotary encoder can be connected to another GPIO configured as Button|<n> . <n> must be the same to allow the encoder to manage 2 absolute counters from the same rotary encoder. To get triggers from the rotary encoder into rules, you must enable SetOption98 1 . The rotary encoder <n> provides a JSON in the form of {'Rotary<n>': {'Pos1': value, 'Pos2': value}} . You can use the following rules triggers: SetOption98 1 Rule1 ON Rotary1 # Pos1 DO something_with % value % ENDON ON Rotary1 # Pos2 DO something_with % value % ENDON","title":"Use a rotary encoder"},{"location":"Rules/#use-zigbee-to-control-tasmota-devices","text":"This setup uses a Zigbee gateway with an Ikea remote switch paired. Ikea switch's name was set with ZbName to make it more user friendly.","title":"Use Zigbee to control Tasmota devices"},{"location":"Rules/#button-single-press-double-press-and-hold","text":"This example show how to assign different behavior to a button other than Button1 . Button1 has special multi-press behaviors associated with it (see Note in Multi-Press Functions ), examples 1 and 2 cannot be applied to Button1.","title":"Button single press, double press and hold"},{"location":"Rules/#disable-switch-single-press-and-use-long-press","text":"SetOption11 0 Switches do not have double press feature [assuming a connected pushbutton configured as Switch1] single press: Does nothing (empty Delay commands) hold 2 secs: Toggle Power1 Backlog SwitchTopic1 0 ; SwitchMode1 5 ; SetOption32 20 Rule1 ON Switch1 # State = 3 DO Power1 2 ENDON ON Switch1 # State = 2 DO Delay ENDON Rule1 1","title":"Disable switch single press and use long press"},{"location":"Rules/#execute-several-commands-when-a-timer-expires","text":"The default Timer1..16 functionality allows for controlling one output to either off, on, toggle or blink. When rules are enabled the blink option will be replaced by rule functionality allowing much more flexibility. Configure timer5 for rule execution when activated: Timer5 { \"Arm\" : 1 , \"Mode\" : 0 , \"Time\" : \"16:00\" , \"Days\" : \"1111111\" , \"Repeat\" : 1 , \"Action\" : 3 }","title":"Execute several commands when a Timer expires"},{"location":"Rules/#setting-variables","text":"Demonstrate the use of variables. Make sure to execute commands Rule 4 (Disable one-shot detection) first when trying the following example. Set a variable Rule ON event # setvar1 DO var1 % value % ENDON Command: event setvar1=1 View a variable rule ON event # getvar1 DO var1 ENDON Command: event getvar1 Toggle a variable Rule ON event # togglevar1 DO event toggling1 =% var1 % ENDON ON event # toggling1 < 1 DO event setvar1 = 1 ENDON ON event # toggling1 > 0 DO event setvar1 = 0 ENDON ON event # setvar1 DO var1 % value % ENDON Command: event togglevar1 Show Messages: Rule ON event # message DO publish stat / [ topic ] / log % value % ENDON Command: event message=INIT All event commands can be executed from: console: event anyname=number mqtt: cmnd/[topic]/event anyname=number Everything together: Rule1 ON event # togglevar1 DO event toggling1 =% var1 % ENDON ON event # toggling1 < 1 DO event setvar1 = 1 ENDON ON event # toggling1 > 0 DO event setvar1 = 0 ENDON ON event # setvar1 DO var1 % value % ENDON ON event # getvar1 DO var1 ENDON ON event # message DO publish stat / mqttTopic / log % value % ENDON The following won't work: Rule1 ON event#setvar1 DO Backlog var1 %value%; Power1 %var1% ENDON At least not as you probably would expect. The var1 value used by the Power1 command will be the value present before the Backlog command is executed. This is so, because the rule will replace %var1% BEFORE the Backlog commands are put in the Backlog command stream.","title":"Setting variables"},{"location":"Rules/#time-delayed-auto-off-switch","text":"","title":"Time-delayed Auto-off Switch"},{"location":"Rules/#time-delay-after-switch-off","text":"","title":"Time-delay After Switch Off"},{"location":"Rules/#auto-off-motion-sense-switch","text":"Example works fine on a Wemos D1 Mini. Used as night light with motion sensor or as ambient light on floor or kitchen. Connect an LED Strip WS2812 on D1 and the PIR on D2 and a LDR on A0 (voltage divider with 10k ohm resistor) SwitchMode1 1","title":"Auto-off Motion Sense Switch"},{"location":"Rules/#control-timers-from-a-switch","text":"Assuming that your switch is on GPIO00 and configured as Switch1 : Switchmode1 1 will make Switch1#state be 1 when ON and 0 when OFF If you don't set Switchmode1 or it is equal 0, it will only have Switch1#state=2 (toggle) and the rule will not work.","title":"Control Timers from a Switch"},{"location":"Rules/#toggle-relay-when-holding-button-for-2-seconds","text":"The following example is to explain how to catch and use the HOLD feature for buttons. Behavior: Disable Button1 Short Press and Toggle Relay1 only when holding button1 for 2 Seconds. Backlog ButtonTopic 0 ; SetOption1 1 ; SetOption32 20 Rule1 ON button1 # state = 3 DO Power1 2 ENDON ON button1 # state = 2 DO delay ENDON Rule1 1 Commands Explanation ButtonTopic 0 : (default) To not use topics for buttons SetOption1 1 : Allow only single, double and hold press button actions SetOption32 20 : Set key hold time from 0.1 to 10 seconds (20 = 2 seconds) Rule ON button1#state=3 DO Power1 2 ENDON : When holding the button1 for 2 seconds it will toggle relay 1 (state = 3 means HOLD) ON button1#state=2 DO delay ENDON : Do nothing when short pressing the button1 (state = 2 means TOGGLE) Rule1 1 : To enable rules NOTE: There is no state value for \"double press\" for Buttons. It is designed that double press will toggle the relay. See Multi-Press Functions for more information. In the case you do not want the double press feature you can configure your button as switch and also set SwitchMode that fits your use case (such as SwitchMode 5 to make the switch behave like a pushbutton) [SWITCH does not support double press] Another example but using switch instead of button: Backlog SwitchTopic1 0 ; SwitchMode1 5 ; SetOption32 20 Rule1 ON switch1 # state = 3 DO Power1 2 ENDON ON switch1 # state = 2 DO delay ENDON Rule1 1","title":"Toggle Relay when holding button for 2 seconds"},{"location":"Rules/#make-sure-light-is-on-at-night","text":"Using Timers, you can set a light to turn on and off to illuminate a street/patio by night. But if the device has no power at the trigger time, then, when it powers up, the light will be off all night. So, as a fail-safe, implement a conditional control to be checked at Tasmota Startup. Set Timers to turn on your light at Sunset and Turn off at sunrise. Use poweronstate 0 in order to start with lights off when powering up your device. Set the following rules: Rule1 ON Time # Initialized DO Backlog event checksunrise =% time % ; event checksunset =% time % ENDON ON event # checksunset >% sunset % DO Power1 1 ENDON ON event # checksunrise <% sunrise % DO Power1 1 ENDON The previous rules are conditionals that represent the following logic: IF %time%>%sunset DO Power1 1 / IF %time%<%sunrise DO Power1 1","title":"Make sure Light is on at night"},{"location":"Rules/#turn-on-light-before-dawn-and-at-dusk","text":"Turn on light at dusk until your nighttime and again in the morning before dawn. What if the sun sets after your nighttime, as in during the summer? Then the timer will turn off the light at \"night\", but then the Sunset timer will turn it on again, so it stays on all night.","title":"Turn On Light Before Dawn and At Dusk"},{"location":"Rules/#enable-a-pir-switch-only-at-night","text":"Latitude and Longitude need to be set in config. Use PulseTime to specify the duration the light should remains on. Every PIR trigger will restart for that amount of time. SwitchMode1 14 PulseTime 60 Rule1 ON Switch1 # state = 1 DO Backlog event checksunrise =% time % ; event checksunset =% time % ENDON ON event # checksunrise <% sunrise % DO Power1 1 ENDON ON event # checksunset >% sunset % DO Power1 1 ENDON","title":"Enable a PIR Switch only at night"},{"location":"Rules/#control-luminance-switch-with-timer","text":"Background: Tasmota powers a Sonoff Basic attached to a TS-2561 Luminance Sensor. This switch toggles a lamp ON or OFF. The switch should work as below: i) during daytime (sunrise-sunset): ON when it is too dark (<150 lx) and OFF when it gets brighter (>175 lx). ii) during evenings it ignores the sensor and turns on at sunset and turns off after about 5 hours Approach: Used a combination of Clock Timers and Rule to do this. Timer 1: Power ON switch at Sunset Powers on the switch at sunset with an offset of 20 minutes. Repeats every day. Timer1 { \"Arm\" : 1 , \"Mode\" : 2 , \"Time\" : \"-00:20\" , \"Window\" : 0 , \"Days\" : \"1111111\" , \"Repeat\" : 1 , \"Output\" : 1 , \"Action\" : 1 } Timer 2: Power OFF switch at Night. Turns power OFF at 23.00hrs. Repeats every day. Timer2 { \"Arm\" : 1 , \"Mode\" : 0 , \"Time\" : \"23:00\" , \"Window\" : 0 , \"Days\" : \"1111111\" , \"Repeat\" : 1 , \"Output\" : 1 , \"Action\" : 0 } Timer 3: Trigger Luminance Rule at Sunrise Start watching the Lux sensor 15 minutes after sunrise. Timer3 { \"Arm\" : 1 , \"Mode\" : 1 , \"Time\" : \"00:15\" , \"Window\" : 0 , \"Days\" : \"1111111\" , \"Repeat\" : 1 , \"Output\" : 1 , \"Action\" : 3 } Rule 1: Main Rule to check Luminance If Luminance is less than 150lx, power ON. If it goes beyond 175lx, power OFF. Rule1 ON tele - TSL2561 # Illuminance < 150 DO Power1 1 ENDON ON tele - TSL2561 # Illuminance > 175 DO Power1 0 ENDON Rule1 1 ``` haskell ** Rule 2 :** Trigger Rule1 only in the Mornings This ensures that Rule1 is triggered when Timer3 starts ( in the morning ) and stops when Timer1 starts ( in the evenings ) . ``` haskell Rule2 ON Clock # Timer = 3 DO Rule1 1 ENDON ON Clock # Timer = 1 DO Rule1 0 ENDON Rule2 1","title":"Control luminance switch with Timer"},{"location":"Rules/#perform-any-action-on-singledouble-press-for-switches-and-buttons","text":"","title":"Perform any action on single/double press (for switches AND buttons)"},{"location":"Rules/#enable-or-disable-relay-with-a-switch-in-domoticz","text":"When you want to send MQTT messages ( we use domoticz in this example ) and choose when you want the relay on or off, by simply sending HTTP commands to trigger an event. Initial Config: PushButton Doorbell (Sonoff Basic R1) GPIO14 - Switch4 (12) Connect the Switch to GND and the GPIO on your device. Be sure put a 4.7k resistor between VCC(3.3v) and the GPIO. This prevents ghost switching (capacitor is optional) See: YouTube Dont forget to change the IDX value Commands: Backlog SwitchTopic 0 ; SwitchMode4 2 ; SetOption0 0 ; PowerOnState 0 var1 1 Rule1 ON event # doorbell DO var1 % value % ENDON ON switch4 # state = 1 DO publish domoticz / in { \"idx\" : 11 , \"nvalue\" : 1 } ENDON ON switch4 # state = 1 DO Power1 % var1 % ENDON ON switch4 # state = 0 DO publish domoticz / in { \"idx\" : 11 , \"nvalue\" : 0 } ENDON ON switch4 # state = 0 DO Power1 0 ENDON Rule1 1 Usage: Turn off the relay by calling the event using HTTP: http://<tasmotaIP>/cm?cmnd=event%20doorbell=0 Turn on the relay by calling the event using HTTP: http://<tasmotaIP>/cm?cmnd=event%20doorbell=1 If your Tasmota device is password protected, which is most common, then use the following HTTP commands instead. Make sure you change <tasmotaUsername> and <tasmotaPassword> Off: http://<tasmotaIP>/cm?&user=<tasmotaUsername>&password=<tasmotaPassword>&cmnd=event%20doorbell=0 On: http://<tasmotaIP>/cm?&user=<tasmotaUsername>&password=<tasmotaPassword>&cmnd=event%20doorbell=1","title":"Enable or disable relay with a switch in Domoticz"},{"location":"Rules/#force-automatic-re-connection-to-mqtt-server-via-sd-dns","text":"In order to search for the MQTT server using SD-DNS service (a.k.a. Bonjour or Zero Network Configuration) the suggested configuration is to leave the MQTT Host field blank. The standard behavior of Tasmota is searches for _mqtt._tcp service resolve that to the proper IP address connect to it in case the connection is successful, retain the IP address and use that in the subsequent connections The above is not proper, though, in case you have a redundant MQTT (e.g., two MQTT server synchronized). In such case, when the active MQTT fails for any reason, the expected behavior is to achieve automatic re-connection to the other MQTT server. That can be easily configured defining the following rule on the device console: Rule1 ON Mqtt # Disconnected DO MqttHost 0 ENDON Rule1 1 If the MqttHost field already contains an IP, you have to delete it using the web interface or the following MQTT command: mosquitto_pub -h mqtt_server.local -t \"cmnd/mqttTopic/MqttHost\" -m ''","title":"Force automatic re-connection to MQTT server via SD DNS"},{"location":"Rules/#change-distance-to-percentage","text":"When measuring distance and you have the need to see it in percentage of distance. In the example 100% is everything below 69cm and 0% is everything above 128cm. This is used for showing fill percentage of a wood pellets storage. Rule1 ON tele - SR04 # distance DO Backlog var1 % value % ; event checklimit =% value % ; event senddistance ENDON ON event # checklimit > 128 DO var1 128 ENDON ON event # checklimit < 69 DO var1 68 ENDON ON event # senddistance DO Backlog SCALE1 % var1 % , 128 , 69 , 0 , 100 ; event pubdata ENDON ON event # pubdata DO publish tele / pannrum - temp / SENSOR % var1 % ENDON Rule1 1","title":"Change distance to percentage"},{"location":"Rules/#distinguish-switch1-and-switch2-without-the-use-of-relay1-and-relay2","text":"When two (or more) switches are defined as input and you want to distinguish these in the RESULT topic without the use of Relays, then consider the following rules. SwitchMode1 1 will make Switch1#state to be 1 when ON and 0 when OFF SwitchMode1 1 SwitchMode2 1 will make Switch2#state to be 1 when ON and 0 when OFF SwitchMode2 1 Publish json with key POWER1 and value %value% Rule1 ON switch1 # state DO publish stat / wemos - 4 / RESULT { \"POWER1\" : \"%value%\" } ENDON Publish json with key POWER2 and value %value% Rule2 ON switch2 # state DO publish stat / wemos - 4 / RESULT { \"POWER2\" : \"%value%\" } ENDON Enable Rules Backlog Rule1 1; Rule2 1 Output: RUL : SWITCH1 # STATE performs \"publish stat/wemos-4/RESULT {\" POWER1 \":\" 1 \"}\" MQT : stat /wemos-4/ RESULT = { \"POWER1\" : \"1\" } RUL : SWITCH2 # STATE performs \"publish stat/wemos-4/RESULT {\" POWER2 \":\" 1 \"}\" MQT : stat /wemos-4/ RESULT = { \"POWER2\" : \"1\" } RUL : SWITCH1 # STATE performs \"publish stat/wemos-4/RESULT {\" POWER1 \":\" 0 \"}\" MQT : stat /wemos-4/ RESULT = { \"POWER1\" : \"0\" } RUL : SWITCH2 # STATE performs \"publish stat/wemos-4/RESULT {\" POWER2 \":\" 0 \"}\" MQT : stat /wemos-4/ RESULT = { \"POWER2\" : \"0\" } RUL : SWITCH1 # STATE performs \"publish stat/wemos-4/RESULT {\" POWER1 \":\" 1 \"}\" MQT : stat /wemos-4/ RESULT = { \"POWER1\" : \"1\" } RUL : SWITCH1 # STATE performs \"publish stat/wemos-4/RESULT {\" POWER1 \":\" 0 \"}\" MQT : stat /wemos-4/ RESULT = { \"POWER1\" : \"0\" }","title":"Distinguish Switch1 and Switch2 (without the use of Relay1 and Relay2)"},{"location":"Rules/#receiving-state-of-anything-that-triggers-switch-more-than-one-time","text":"With analog intercom doorbells you can take out info about ringing from speaker voltage. You can connect GPIO to it via opto-isolator and resistor to take out state. But even with those speaker voltage is dropping so it switches the device multiple times. MQT : cmnd /doorbell/ POWER2 = OFF ( retained ) MQT : cmnd /doorbell/ POWER2 = ON ( retained ) MQT : cmnd /doorbell/ POWER2 = OFF ( retained ) MQT : cmnd /doorbell/ POWER2 = ON ( retained ) MQT : cmnd /doorbell/ POWER2 = OFF ( retained ) To solve it we can use rules. SwitchTopic 0 Rule1 on System # Boot var1 0 ENDON ON Switch2 # State DO Backlog add1 1 ; event START ENDON ON event # START DO event BELL =% var1 % ENDON ON event # BELL = 1.000 DO Backlog publish cmnd / bell / power on ; RuleTimer1 60 ENDON ON event # BELL = 0 DO publish cmnd / bell / power off ENDON ON Rules # Timer = 1 DO Backlog var1 0 ; event BELL = 0 ENDON Rule1 1 description: Disable SwitchTopic as it overrides rules for switches: SwitchTopic 0 on system boot set var1 to 0 on switch2 click (person pushing doorbell) - var1 += 1; trigger event START on START - set event BELL equal to var1 if event#BELL=1 (triggered first time) publish mqtt message ON and trigger RulesTimer1 for 60 seconds if event#BELL=0 publish mqtt message OFF on RulesTimer1 - reset var1 to 0, and call event#BELL. enable rule 1 In this case we have lock for 60 seconds for multiple people calls or to be resistant for speaker voltage drops.","title":"Receiving state of anything that triggers SWITCH more than one time"},{"location":"Rules/#prevent-wemos-d1-mini-load-overcurrent","text":"As a WS2812 24 led ring draws approximately 24x3x20 mA = 1.44A and the Wemos D1 mini powered from a PC's USB port can only provide up to 0.5A it would be nice to have some kind of mechanism in place to limit the amount of current to the WS2812 LEDring to 0.1A. This is still enough to light all 24 leds up to color 202020. Hardware Wemos D1 mini INA219 I 2 C sensor WS2812 LEDring with 24 LEDs powered by the Wemos D1 mini 5V thru the INA219 sensor Rule1 ON INA219 # Current > 0.100 DO Backlog Dimmer 10 ; Color 10 , 0 , 0 ENDON Rule1 on Result - When a user raises brightness to a level using more than 0.1A the rule kicks in and lowers the current by executing command Dimmer 10 and changes the color to Red with command Color 10,0,0 .","title":"Prevent Wemos D1 mini load overcurrent"},{"location":"Rules/#using-dummy-gpio-to-send-serial-codes-to-an-mcu","text":"By having a device that controls all its features through an MCU and reports the states in serial codes to the ESP8266 we have to create some rules to control it using the Web UI or standard Power commands. Rule1 ON Power1 # state = 1 DO serialsend5 55 AA00060005020400010213 ENDON ON Power1 # state = 0 DO serialsend5 55 AA00060005020400010011 ENDON ON Power2 # state = 1 DO serialsend5 55 AA00060005060400010217 ENDON ON Power2 # state = 0 DO serialsend5 55 AA00060005060400010015 ENDON Power1 controls the device, Power2 turn on and off the light on the device. Another rule was created to issue commands on boot so the serial interface works every time and to control the built in fan using Event triggers and have its state retained in an MQTT message for Home Assistant. Rule2 ON system # boot DO Backlog baudrate 9600 ; seriallog 2 ; serialsend5 55 aa000300010306 ENDON ON event # high DO Backlog serialsend5 55 AA00060005650400010175 ; publish2 stat / diffuser / FAN high ENDON ON event # low DO Backlog serialsend5 55 AA00060005650400010074 ; publish2 stat / diffuser / FAN low ENDON","title":"Using dummy GPIO to send Serial codes to an MCU"},{"location":"Rules/#arithmetic-commands-used-with-var","text":"","title":"Arithmetic commands used with VAR"},{"location":"Rules/#transmit-sensor-value-only-when-a-delta-is-reached","text":"Send only when the sensor value changes by a certain amount. Rule1 ON SI7021 # temperature >% var1 % DO Backlog var1 % value % ; publish stat / mqttTopic / temp % value % ; var2 % value % ; add1 2 ; sub2 2 ENDON ON SI7021 # temperature <% var2 % DO Backlog var2 % value % ; publish stat / mqttTopic / temp % value % ; var1 % value % ; add1 2 ; sub2 2 ENDON","title":"Transmit sensor value only when a delta is reached"},{"location":"Rules/#adjust-a-value-and-send-it-over-mqtt","text":"This example adds 2 degrees to the measured temperature and then sends that value to an MQTT topic. Rule1 ON tele - SI7021 # temperature DO Backlog var1 % value % ; add1 2 ; event sendtemp ENDON ON event # sendtemp DO publish stat / mqttTopic / temp % var1 % ENDON","title":"Adjust a value and send it over MQTT"},{"location":"Rules/#control-relays-via-serial","text":"This example switches connected relays over the software serial on and off. Write the following rules: rule1 ON SSerialReceived # Data = on DO Power1 1 ENDON ON SSerialReceived # Data = off DO Power1 0 ENDON receiving on and off results in MQT : tele /mqttTopic/ RESULT = { \"SSerialReceived\" : \"on\" } RUL : SSERIALRECEIVED # DATA = ON performs \"Power1 1\" MQT : stat /mqttTopic/ RESULT = { \"POWER\" : \"ON\" } MQT : stat /mqttTopic/ POWER = ON MQT : tele /mqttTopic/ RESULT = { \"SSerialReceived\" : \"off\" } RUL : SSERIALRECEIVED # DATA = OFF performs \"Power1 0\" MQT : stat /mqttTopic/ RESULT = { \"POWER\" : \"OFF\" } MQT : stat /mqttTopic/ POWER = OFF","title":"Control relays via serial"},{"location":"Rules/#using-break-to-simulate-ifelseifelseendif","text":"BREAK is an alternative to ENDON . BREAK will stop the execution for the triggers that follow. If a trigger that ends with BREAK fires, then the following triggers of that rule will not be executed. This allows to simulate IF..ELSEIF..ELSE..ENDIF Example: IF temp > 85 then VAR1 more85 ELSEIF temp > 83 then VAR1 more83 ELSEIF temp > 81 then VAR1 more81 ELSEIF temp = 81 then VAR1 equal81 ELSE VAR1 less81 ENDIF With the actual rules, if we use a set like the following: Rule1 ON event # temp > 85 DO VAR1 more85 ENDON ON event # temp > 83 DO VAR1 more83 ENDON ON event # temp > 81 DO VAR1 more81 ENDON ON event # temp = 81 DO VAR1 equal81 ENDON ON event # temp < 81 DO VAR1 less81 ENDON This is the output in the console: CMD : rule MQT : stat /living/ RESULT = { \"Rule1\" : \"ON\" , \"Once\" : \"ON\" , \"StopOnError\" : \"OFF\" , \"Free\" : 322 , \"Rules\" : \"ON event#temp>85 do VAR1 more85 ENDON ON event#temp>83 do VAR1 more83 ENDON on event#temp>81 do VAR1 more81 ENDON on event#temp=81 do VAR1 equal81 ENDON on event#temp<81 DO VAR1 less81 ENDON\" } CMD : event temp = 10 MQT : stat /living/ RESULT = { \"Event\" : \"Done\" } RUL : EVENT # TEMP < 81 performs \"VAR1 less81\" MQT : stat /living/ RESULT = { \"Var1\" : \"less81\" } CMD : event temp = 100 MQT : stat /living/ RESULT = { \"Event\" : \"Done\" } RUL : EVENT # TEMP > 85 performs \"VAR1 more85\" MQT : stat /living/ RESULT = { \"Var1\" : \"more85\" } RUL : EVENT # TEMP > 83 performs \"VAR1 more83\" MQT : stat /living/ RESULT = { \"Var1\" : \"more83\" } RUL : EVENT # TEMP > 81 performs \"VAR1 more81\" MQT : stat /living/ RESULT = { \"Var1\" : \"more81\" } So, all the triggers where TEMP>100, are firing. With the BREAK statement the rule set can be changed to: Rule on event # temp > 85 do VAR1 more85 break on event # temp > 83 do VAR1 more83 break ON event # temp > 81 DO VAR1 more81 ENDON ON event # temp = 81 DO VAR1 equal81 ENDON ON event # temp < 81 DO VAR1 less81 ENDON Which will result in the following output: CMD : rule RSL : RESULT = { \"Rule1\" : \"ON\" , \"Once\" : \"OFF\" , \"StopOnError\" : \"OFF\" , \"Free\" : 321 , \"Rules\" : \"ON event#temp>85 do VAR1 more85 break ON event#temp>83 do VAR1 more83 break on event#temp>81 do VAR1 more81 ENDON on event#temp=81 do VAR1 equal81 ENDON on event#temp<81 DO VAR1 less81 ENDON\" } CMD : event temp = 10 RSL : RESULT = { \"Event\" : \"Done\" } RUL : EVENT # TEMP < 81 performs \"VAR1 less81\" RSL : RESULT = { \"Var1\" : \"less81\" } CMD : event temp = 100 RSL : RESULT = { \"Event\" : \"Done\" } RUL : EVENT # TEMP > 85 performs \"VAR1 more85\" RSL : RESULT = { \"Var1\" : \"more85\" } CMD : event temp = 83 RSL : RESULT = { \"Event\" : \"Done\" } RUL : EVENT # TEMP > 81 performs \"VAR1 more81\" RSL : RESULT = { \"Var1\" : \"more81\" }","title":"Using BREAK to simulate IF..ELSEIF..ELSE..ENDIF"},{"location":"Rules/#adjust-powerdelta-according-to-current-power-values","text":"Power sensor reporting thresholds are set by a percentage change in the Power value by setting PowerDelta . Power changes from 10W to 11W (10%) may not be very interesting. But power changes from 1000W to 1100W (also 10%) could be very important. To avoid getting reports for small changes but ensuring that larger power swings are reported, a rule set can be used to create a gradient threshold based on the absolute power values. This rule also uses the one-shot feature of rules to avoid reporting of every small change within a threshold window. The rule (a ON/DO/ENDON rule in this the set) will trigger only once when a threshold is crossed. Backlog PowerDelta 0 ; Rule1 0 ; Rule1 5 Rule1 ON ENERGY # Power >= 35 DO Backlog PowerDelta 10 ; Status 8 BREAK ON ENERGY # Power >= 15 DO Backlog PowerDelta 25 ; Status 8 BREAK ON ENERGY # Power > 5 DO Backlog PowerDelta 35 ; Status 8 BREAK ON ENERGY # Power <= 5 DO PowerDelta 100 ENDON Rule1 1 Which translates (pseudo code): IF ENERGY # Power >= 35 // ENERGY # Power GE 35 DO Backlog PowerDelta 10 ; Status 8 ELSE IF ENERGY # Power >= 15 // ENERGY # Power GE 15 and LT 35 DO Backlog PowerDelta 25 ; Status 8 ELSE IF ENERGY # Power > 5 // ENERGY # Power GT 5 and LT 15 DO Backlog PowerDelta 35 ; Status 8 ELSE // ENERGY # Power changed ( i . e . LE 5 ) DO PowerDelta 100","title":"Adjust PowerDelta according to current Power values"},{"location":"Rules/#forward-ir-signals","text":"Using one IR receiver and one sender (or both extender) you can simply forward signals from one to another using the following rule rule1 ON IRreceived # Data DO publish cmnd / irsideboard / irsend { Protocol:NEC , Bits: 32 , Data:% value % } ENDON","title":"Forward IR signals"},{"location":"Rules/#garage-door-opener","text":"( #3942 ) // Set the relay on time to signal the opener PulseTime 7 // Send ON and OFF as the switch is ON or OFF Backlog SwitchMode1 1 ; SwitchMode2 1 ; SwitchMode3 1 //No need to save changes on power cycle SetOption0 0 //Don\u2019t blindly run the door on power up PowerOnState 0 //One shot Detection off Backlog Rule1 0 ; Rule1 4 ; Rule2 0 ; Rule2 4 ; Rule2 0 ; Rule2 4 //Set Counter to measure the period between on and off, check if its blinking because of an obstruction Backlog CounterType 1 ; CounterDebounce 100 //So the door doesn't close if you send it an Open when it's already Opened, etc. // var1 = 1 Only When OPEN // var2 = 1 Only When CLOSED // var3 = 1 Only When OPENING // var4 = 1 Only When CLOSING Rule1 ON Switch1 # Boot = 1 DO Backlog delay 99 ; event Opened ENDON ON Switch2 # Boot = 1 DO Backlog delay 99 ; event Closed ENDON ON EVENT # OPEN DO Power1 % var2 % ENDON ON EVENT # CLOSE DO Power1 % var1 % ENDON ON EVENT # STOP DO Backlog Power1 % var3 % ; Power1 % var4 % ; event PState = STOP ENDON ON Switch1 # State = 1 DO event Opened ENDON ON Switch2 # State = 1 DO event Closed ENDON ON Switch1 # State = 0 DO event Closing ENDON ON Switch2 # State = 0 DO event Opening ENDON Rule2 ON event # Opened DO Backlog var 1 ; var2 0 ; var3 0 ; var4 0 ; ruletimer1 0 ; event PState = OPEN ENDON ON event # Closed DO Backlog var1 0 ; var2 1 ; var3 0 ; var4 0 ; ruletimer1 0 ; event PState = CLOSE ENDON ON event # Opening DO Backlog var1 0 ; var2 0 ; var3 1 ; var4 0 ; ruletimer1 15 ; event PState = OPENING ENDON ON event # Closing DO Backlog var1 0 ; var2 0 ; var3 0 ; var4 1 ; ruletimer1 15 ; event PState = CLOSING ENDON Rule3 ON counter # c1 > 1000 DO event PObstr = 0 ENDON ON counter # c1 < 1000 DO event PObstr = 1 ENDON ON event # PObstr DO publish stat / GarageDoor / OBSTR % value % ENDON ON event # PState DO publish stat / GarageDoor / STATE % value % ENDON ON rules # timer = 1 DO event PState = STOP ENDON //Turn on Rules Backlog Rule1 1 ; Rule2 1 ; Rule3 1","title":"Garage Door Opener"},{"location":"Rules/#ir-remote-button-multi-press","text":"For example, a remote control with one button to change speed. This rules simulates pressing the button three times to set the receiving device to the third speed setting. Specify the rule set The <trigger> can be a a condition or an event sent from another device or home automation hub. <topic> corresponds to the device transmitting the code (e.g., YTF IR Bridge ). This could also be modified to send an RF code from a Sonoff RF Bridge . The Delay may not be necessary in your environment or may need to be adjusted according to your device characteristics. Rule 1 ON Event # tora DO Backlog Publish cmnd /< topic >/ IRSend { \"Protocol\" : \"NEC\" , \"Bits\" : 32 , \"Data\" : \"0x00FF30CF\" }; Delay 10 ENDON ON < trigger > DO Backlog Event tora ; Event tora ; Event tora ENDON Enable the Rule set Rule1 1","title":"IR Remote Button Multi-press"},{"location":"Rules/#two-way-light-switches-without-mqtt","text":"Two Sonoff T1 3-gang light switches can be used at either end of a room by setting up one the master and the other as the slave. The master performs the switching of the power to the lights, while the slave just asks the master to toggle the power state. The master also turns the slave's relays on and off so that the LED indicators follow the master's state. Using the WebSend command, the two switches can talk to each other without an MQTT broker. It remains to be seen how reliable this is. Starting with the slave, the rule to toggle the master is pretty simple: Rule1 ON Event # sendPower DO WebSend [ 192.168 . 0.74 ] POWER % value % TOGGLE ENDON ON Button1 # State DO Event sendPower = 1 ENDON ON Button2 # State DO Event sendPower = 2 ENDON ON Button3 # State DO Event sendPower = 3 ENDON Rule1 1 Note that having a rule for the Button#State disables the power toggling of the slave's relay(s). This is desirable because we want the master to control the slave's relay state(s) according to its own as follows: Rule1 ON Event # sendPower DO WebSend [ 192.168 . 0.144 ] POWER % Var1 % % value % ENDON ON Power1 # state DO Backlog Var1 1 ; Event sendPower =% value % ENDON ON Power2 # state DO Backlog Var1 2 ; Event sendPower =% value % ENDON ON Power3 # state DO Backlog Var1 3 ; Event sendPower =% value % ENDON Rule1 1","title":"Two-way light switches without MQTT"},{"location":"Rules/#roller-shutter-push-button-toggle","text":"With a two relay device (e.g., Shelly 2.5) configured for a roller shutter, you can also connect push-buttons (configured as switch components in this example) and set them for inverted toggle behavior. Pressing a push-button once makes the roller shutter move in one direction. Pressing it again stops it. These rules each use a variable to remember the shutter state where 0 == Stopped and 1 == Moving . Backlog SwitchTopic 0 ; SwitchMode1 4 ; SwitchMode2 4 Rule1 ON Switch1 # State == 1 DO Add1 1 ENDON ON Var1 # State == 0 DO ShutterStop1 ENDON ON Var1 # State == 1 DO ShutterClose1 ENDON ON Var1 # State >= 2 DO Var1 0 ENDON ON Shutter1 # Close DO Var1 0 ENDON ON Switch2 # State == 1 DO Add2 1 ENDON ON Var2 # State == 0 DO ShutterStop1 ENDON ON Var2 # State == 1 DO ShutterOpen1 ENDON ON Var2 # State >= 2 DO Var2 0 ENDON ON Shutter1 # Open DO Var2 0 ENDON Rule1 1","title":"Roller shutter push-button toggle"},{"location":"Rules/#control-a-dimmer-with-one-switch","text":"This example is for GPIOs defined as switches not buttons Activate dimmer mode with Switchmode 11 and shorten long press time to 1 second ( Setoption32 10 ). A short press of the switch sends a TOGGLE message to toggle the dimmer. A long press sends repeated INC_DEC messages to increment the dimmer. If a second press of the switch follows the first press a INV message is sent to invert the function from increment to decrement and repeatet INC_DEC messages are sent to decrement the dimmer. After releasing the switch a timeout message CLEAR resets the automation Backlog SwitchMode 11 ; SetOption32 10 Rule1 on system # boot mem1 + ENDON ON switch1 # state = 2 DO publish light / cmnd / POWER TOGGLE ENDON ON switch1 # state = 4 DO publish light / cmnd / DIMMER % mem1 % ENDON ON switch1 # state = 5 DO mem1 - ENDON ON switch1 # state = 6 DO mem1 + ENDON Rule1 1 Notice we use Rule which edits Rule1 rule set. They can be used interchangeably.","title":"Control a dimmer with one switch"},{"location":"Rules/#watchdog-for-wi-fi-router","text":"A Tasmota socket can ping a remote host (router itself or something else connected to the router) and power cycle the socket to reboot the router. In this example, ping interval of 3 minutes is used. The simplest watchdog rule does not use variables: Rule1 ON Time # Minute | 3 DO Ping4 192.168 . 1.10 ENDON ON Ping # 192.168 . 1.10 # Success == 0 DO Backlog Power1 0 ; Delay 10 ; Power1 1 ; ENDON Rule1 1 However, if the router becomes unreachable for a long time, the watchdog will keep cycling it every three minutes. This could reduce the watchdog's relay lifetime to months, at most years. Safer option would be to use an exponential backoff algorithm. Var1 contains the current ping interval in minutes, which is trippled after each failed ping, but limited to 1439 minutes (1 day). Rule1 ON system # boot do Var1 3 ENDON ON Var1 # State > 1439 DO Var1 1439 ENDON ON Time # Minute |% var1 % DO Ping4 192.168 . 1.10 ENDON ON Ping # 192.168 . 1.10 # Success == 0 DO backlog Mult1 3 ; Power1 0 ; Delay 10 ; Power1 1 ENDON ON Ping # 192.168 . 1.10 # Success > 0 DO Var1 3 ENDON This requires #define USE_PING and Tasmota version 8.2.0.3 or newer","title":"Watchdog for Wi-Fi router"},{"location":"Rules/#simple-thermostat-example","text":"As example, to be used on a Sonoff TH10 with Sensor Si7021 This example turn on and off an output based on the temperature value and the upper set point and the lower set point. It waits until is enabled by pressing the button or by mqtt message 1 to mem1. This value is remembered. So if power cycle occurs, will resume operation. The set point values can be changed on the fly by mqtt or console commands If the Temperature sensor disconnects, the outputs will shutdown until the sensor is back again and will resume operation. When the device is power up, the thermostat also waits until the sensor value to resume operation. Initial Config: Available physical button as Switch1 Relay1 will be used the controller Rules must be used to control Relay so the pushbutton must only control Switch1 and not directly control the relay - For this we use SwitchMode1 3 as described below and create the necessary rules because the pushbutton control of the relay is only disabled when the rules are in place. Initial config on console: SwitchMode1 3 <- Use the switch1 as pushbutton (It will allow us to disable the link between the button and the relay by inserting a rule to dictate what the pushbutton will do - NOTE: Until rules are created the pushbutton will still control the relay! ) Rule1 1 <- turn on rules Rule1 4 <- turn off one-shot rule TelePeriod 60 <- check temp every minute SetOption26 1 <- use Power1 on mqtt messages SetOption0 0 <- dont save relay status on eeprom PowerOnState 0 <- start all relays off Mem1 0 <- thermostat status: 0-off 1-enabled - View or set by MQTT cmnd/mqttTopic/mem1 Mem2 25 <- setpoint Temp upper limit - View or set by MQTT cmnd/mqttTopic/mem2 Mem3 23 <- setpoint Temp lower limit - View or set by MQTT cmnd/mqttTopic/mem3 Var1 0 <- thermostat actual status: 1-OK 0-NOT READY - View by MQTT cmnd/mqttTopic/var1","title":"Simple Thermostat Example"},{"location":"Rules/#solar-heater-control","text":"In a swimming pool, a filter pump and a solar panel is installed. When the sun is shining, the pump should push water through the solar panel, to heat the pool. When it's night or cloudy, the pump should be off, to avoid cooling the pool water through the solar panel. The pump is controlled by a Sonoff TH10 with 2x DS18B20 sensors connected. 3 rules: Pump should start when solar panel is more than 2 deg warmer than the pool water Pump should stop when solar panel is less than 1 deg warmer than the pool water Pump should not start if the solar panel is below 25 deg Celsius. t1 : pool temp t2 : panel temp var1 : in valid panel temp range? var2 : off threshold temp for panel var3 : on threshold temp for panel mem3 : lowest valid panel temp mem3 25 rule1 ON DS18B20 - 1 # temperature DO event t1 =% value % ENDON ON DS18B20 - 2 # temperature DO event t2 =% value % ENDON ON event # t2 >% mem3 % DO var1 1 ENDON ON event # t2 <=% mem3 % DO var1 0 ENDON ON event # t1 DO Backlog var2 % value % ; add2 1 ENDON ON event # t1 DO Backlog var3 % value % ; add3 2 ENDON ON event # t2 >% var3 % DO Power1 % var1 % ENDON ON event # t2 <% var2 % DO Power1 0 ENDON To test the rule without having the sensors in place, simply enter the events for t1 and t2 in the console: Backlog event t1=21;event t2=30 And watch the relay turn on and off based on the values. Please note that this example does not support manual override or handles missing sensor data.","title":"Solar heater control"},{"location":"Rules/#energy-saving-switch","text":"Example of a switch controlling a light with a condition of a required amount of lux. When the switch is on, the light will turn on but only when you have less than 100 lux in that room. While if the switch is off the light will be off. Rule1 ON switch1 # state = 1 DO var1 100 ENDON ON switch1 # state = 0 DO Backlog var1 0 ; Power1 off ENDON ON APDS9960 # Ambient <% var1 % DO Power1 on ENDON","title":"Energy Saving Switch"},{"location":"Rules/#use-of-variables-and-tele-in-domoticz","text":"Using variables allows for storing sensor results to be used in composing a single HA message like used with Domoticz. To prevent flooding Domoticz with messages we only want to send a message at TelePeriod time. This is achieved by prefixing the <SensorName> with the label tele- . This example will use a variable storing the temperature to be used together with humidity in one Domoticz MQTT message. Domoticz configured with a virtual sensor Temp+Hum using Idx 134 Rule Rule ON tele - am2301 - 12 # temperature DO var1 % value % ENDON ON tele - am2301 - 12 # humidity DO publish domoticz / in { \"idx\" : 134 , \"svalue\" : \"%var1%;%value%;1\" } ENDON Result - As a result of the tele- prefix the rules will be checked at TelePeriod time for sensor AM2301-12 Temperature and Humidity. The first rule will use the Temperature stored in %value% and save it in %var1% for future use. The second rule will use the Humidity stored in %value% and the Temperature stored in %var1% to compose a single MQTT message suitable for Domoticz.","title":"Use of variables and tele- in Domoticz"},{"location":"Rules/#rf-repeater-ir-repeater","text":"In some applications, an RF-Repeater may come in handy to increase the range of RF based devices. We need to use RF reciever and RF transmitter modules with tasmota powered controllers. The following rule looks for data received by the RF receiver and re transmits the same over the transmitter. Rule1 on RfReceived # data do Rfsend { \"Data\" :% value % , \"Bits\" : 24 , \"Protocol\" : 1 , \"Pulse\" : 454 } endon Enable it with Rule1 1 A similar concept can also work for IR- Repeater. Connect IR receiver module and IR trnasmitter to Tasmotized device and the following rule retransmits any data over IR Rule1 on IrReceived # Data do IRsend { \"Protocol\" : \"NEC\" , \"Bits\" : 32 , \"Data\" :% value % } endon Enable it with Rule1 1 The only catch is that the protocol needs to be setup in the rule. Most likely this can be taken care of by using a more complex rule maybe using variables. Would update in future","title":"RF Repeater / IR Repeater"},{"location":"SDS011/","text":"SDS011 air quality sensor ~ This feature is included only in tasmota-sensors.bin Nova PM Sensor SDS011 can measure the air quality very accurately by measuring air particles or dust based on laser detection. Specifications: Voltage: 4.7 - 5.3V DC (5V DC with <20mV ripple advised) Power consumption: 70mA \u00b110mA (in operation), <4mA (laser and fan sleep mode) Measuring range: 0.0-999.9 \u03bcg/m3 PM2.5 and PM10 output See manufacturer site for more information. Configuration ~ Wiring ~ SDS011 ESP8266 GND GND 5V 5V TX GPIO RX RX GPIO TX Tasmota Settings ~ In the Configuration -> Configure Module page assign: 1. GPIO RX to SDS0X1 Tx (101) 2. GPIO TX to SDS0X1 Rx (70) Tasmota Main ~ After reboot of the device the displays the SDS011 measurements. OpenHab ~ Number Dust_Sensor_2_5 \"PM 2.5 [%.2f \u00b5g/m\u00b3]\" <door> (Dust) {mqtt=\"<[mosquitto:tele/dust/SENSOR:state:JSONPATH($.SDS0X1['PM2.5'])]\"} Number Dust_Sensor_10 \"PM 10 [%.2f \u00b5g/m\u00b3]\" <door> (Dust) {mqtt=\"<[mosquitto:tele/dust/SENSOR:state:JSONPATH($.SDS0X1['PM10'])]\"}","title":"SDS011 air quality sensor"},{"location":"SDS011/#sds011-air-quality-sensor","text":"This feature is included only in tasmota-sensors.bin Nova PM Sensor SDS011 can measure the air quality very accurately by measuring air particles or dust based on laser detection. Specifications: Voltage: 4.7 - 5.3V DC (5V DC with <20mV ripple advised) Power consumption: 70mA \u00b110mA (in operation), <4mA (laser and fan sleep mode) Measuring range: 0.0-999.9 \u03bcg/m3 PM2.5 and PM10 output See manufacturer site for more information.","title":"SDS011 air quality sensor"},{"location":"SDS011/#configuration","text":"","title":"Configuration"},{"location":"SDS011/#wiring","text":"SDS011 ESP8266 GND GND 5V 5V TX GPIO RX RX GPIO TX","title":"Wiring"},{"location":"SDS011/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: 1. GPIO RX to SDS0X1 Tx (101) 2. GPIO TX to SDS0X1 Rx (70)","title":"Tasmota Settings"},{"location":"SDS011/#tasmota-main","text":"After reboot of the device the displays the SDS011 measurements.","title":"Tasmota Main"},{"location":"SDS011/#openhab","text":"Number Dust_Sensor_2_5 \"PM 2.5 [%.2f \u00b5g/m\u00b3]\" <door> (Dust) {mqtt=\"<[mosquitto:tele/dust/SENSOR:state:JSONPATH($.SDS0X1['PM2.5'])]\"} Number Dust_Sensor_10 \"PM 10 [%.2f \u00b5g/m\u00b3]\" <door> (Dust) {mqtt=\"<[mosquitto:tele/dust/SENSOR:state:JSONPATH($.SDS0X1['PM10'])]\"}","title":"OpenHab"},{"location":"SHT30/","text":"This feature is included only in tasmota-sensors.bin Wemos SHT30 Shield High Precision Humidity & Temperature (I 2 C) sensor From the Wemos SHT30 shield specs the SDA pin on the SHT30 shield is connected to D2 and the SCL pin to D1. Note: v1.0.0 is retired, but v2.0.0 has the same pinout. Configuration ~ As a default the SHT30 uses I 2 C address 0x45 and is user changeable by short-circuiting the two soldering pads at the lower left-side of the sensor (see image below marked green). Also if no other I 2 C devices are connected to the Wemos it might be wise to short-circuit the three soldering pads at the upper left-side of the sensor (see image below marked red). This connects the pull-up resistors for I 2 C and biases the SCL and SDA pins to VCC. This is to avoid possible false detections of other sensors like VEML6070. Tasmota Settings ~ In the Configuration -> Configure Module page assign: 1. D2 GPIO4 to I2C SDA (6) 2. D1 GPIO5 to I2C SCL (5) After reboot of the device the temperature and humidity are displayed. Breakout Boards ~","title":"SHT30 temperature sensor"},{"location":"SHT30/#configuration","text":"As a default the SHT30 uses I 2 C address 0x45 and is user changeable by short-circuiting the two soldering pads at the lower left-side of the sensor (see image below marked green). Also if no other I 2 C devices are connected to the Wemos it might be wise to short-circuit the three soldering pads at the upper left-side of the sensor (see image below marked red). This connects the pull-up resistors for I 2 C and biases the SCL and SDA pins to VCC. This is to avoid possible false detections of other sensors like VEML6070.","title":"Configuration"},{"location":"SHT30/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: 1. D2 GPIO4 to I2C SDA (6) 2. D1 GPIO5 to I2C SCL (5) After reboot of the device the temperature and humidity are displayed.","title":"Tasmota Settings"},{"location":"SHT30/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"Scripting-Cookbook/","text":"","title":"Scripting Cookbook"},{"location":"Scripting-Language/","text":"This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_SCRIPT #define USE_SCRIPT // adds about 17k flash size, variable ram size #endif #ifdef USE_RULES #undef USE_RULES #endif Additional features are enabled by adding the following #define compiler directive parameters and then compiling the firmware. These parameters are explained further below in the article. Feature Description USE_BUTTON_EVENT enable >b section (detect button state changes) USE_SCRIPT_JSON_EXPORT enable >J section (publish JSON payload on TelePeriod ) USE_SCRIPT_SUB_COMMAND enables invoking named script subroutines via the Console or MQTT USE_SCRIPT_HUE enable >H section (Alexa Hue emulation) USE_SCRIPT_STATUS enable >U section (receive JSON payloads from cmd status) SCRIPT_POWER_SECTION enable >P section (execute on power changes) SUPPORT_MQTT_EVENT enables support for subscribe unsubscribe USE_SENDMAIL enable >m section and support for sending e-mail USE_SCRIPT_WEB_DISPLAY enable >W section (modify web UI) SCRIPT_FULL_WEBPAGE enable >w section (seperate full web page and webserver) USE_TOUCH_BUTTONS enable virtual touch button support with touch displays USE_WEBSEND_RESPONSE enable receiving the response of a WebSend command (received in section >E) SCRIPT_STRIP_COMMENTS enables stripping comments when attempting to paste a script that is too large to fit USE_ANGLE_FUNC add sin(x),acos(x) and sqrt(x) e.g. to allow calculation of horizontal cylinder volume USE_24C256 enables use of 24C256 I 2 C EEPROM to expand script buffer (defaults to 4k) USE_SCRIPT_FATFS enables SD card support (on SPI bus). Specify the CS pin number. Also enables 4k script buffer on ESP8266 if using device with 4 or more Mb can enable FS by specifying -1 (using linker files with enabled FS Buffer e.g. eagle.flash.4m1m.ld) USE_SCRIPT_FATFS_EXT enables additional FS commands SDCARD_DIR enables support for web UI for SD card directory upload and download USE_WEBCAM enables support ESP32 Webcam which is controlled by scripter cmds USE_FACE_DETECT enables face detecting in ESP32 Webcam USE_SCRIPT_TASK enables multitasking Task in ESP32 USE_SCRIPT_GLOBVARS enables global variables and >G section USE_SML_M enables Smart Meter Interface SML_REPLACE_VARS enables posibility to replace the lines from the (SML) descriptor with Vars USE_SML_SCRIPT_CMD enables SML script cmds USE_SCRIPT_TIMER enables up to 4 timers SCRIPT_GET_HTTPS_JP enables reading HTTPS JSON WEB Pages (e.g. Tesla Powerwall) LARGE_ARRAYS enables arrays of up to 1000 entries instead of max 127 SCRIPT_LARGE_VNBUFF enables to use 4096 in stead of 256 bytes buffer for variable names LITTLEFS_SCRIPT_SIZE S enables script buffer of size S (e.g.4096) USE_GOOGLE_CHARTS enables defintion of google charts within web section USE_DSIPLAY_DUMP enables to show epaper screen as BMP image in >w section ---- Scripting Language for Tasmota is an alternative to Tasmota Rules To enter a script, go to Configuration - Edit script in the Tasmota web UI menu The maximum script size is 1535 bytes (uses rule set buffers). If the pasted script is larger than 1535 characters, comments will be stripped to attempt to make the script fit. To save code space almost no error messages are provided. However it is taken care of that at least it should not crash on syntax errors. Features ~ Up to 50 variables (45 numeric and 5 strings - this may be changed by setting a compilation #define directive) Freely definable variable names (all variable names are intentionally case sensitive ) Nested if,then,else up to a level of 8 Math operators + , - , * , / , % , & , | , ^ All operators may be used in the op= form, e.g., += Comparison operators == , != , > , >= , < , <= and , or support Hexadecimal numbers with prefix 0x are supported Strings support + and += operators Support for \\n \\r regular expressions on strings String comparison == , != String size is 19 characters (default). This can be increased or decreased by the optional parameter on the D section definition Script Interpreter Execution is strictly sequential , line by line Evaluation is left to right with optional brackets All numbers are float , e.g., temp=hum*(100/37.5)+temp-(timer*hum%10) No spaces are allowed between math operators Comments start with ; Script buffer size the script language normally shares script buffer with rules buffer which is 1536 chars. with below options script buffer size may be expanded. PVARS is size for permanant vars. Feature ESP8266 ESP32 PVARS remarks fallback 1536 1536 50 compression (default) 2560 2560 50 actual compression rate may vary #define LITTLEFS_SCRIPT_SIZE S S<=4096 S<=16384 1536 ESP8266 must use 4M Flash with SPIFFS section use linker option -Wl,-Teagle.flash.4m2m.ld #define USE_SCRIPT_FATFS -1, #define FAT_SCRIPT_SIZE S S<=4096 S<=16384 1536 ESP8266 must use 4M Flash with SPIFFS section use linker option -Wl,-Teagle.flash.4m2m.ld, ESP32 must use linker file \"esp32_partition_app1572k_ffat983k.csv\"(4M chips) or \"esp32_partition_app1984k_ffat12M.csv\" (16M chips) #define USE_SCRIPT_FATFS CS, #define FAT_SCRIPT_SIZE S S<=4096 S<=16384 1536 requires SPI SD card, CS is chip select pin of SD card #define EEP_SCRIPT_SIZE S, #define USE_EEPROM, #define USE_24C256 S<=4096 S<=8192 1536 only hardware eeprom is usefull, because Flash EEPROM is also used by Tasmota #define EEP_SCRIPT_SIZE S, #define ALT_EEPROM S<=6500 1536 you must use setoption12 1 to disable flash rotation most usefull defintion for larger scripts would be ESP8266: with 1M flash only default compressed mode should be used a special mode can enable up to 6500 chars by defining #define ALT_EEPROM however this has some side effects. the script is deleted on OTA or serial update and has to be installed fresh after update. with 4M Flash best mode would be #define USE_SCRIPT_FATFS -1 with linker file \"eagle.flash.4m2m.ld\" ESP32: with standard linker file #define LITTLEFS_SCRIPT_SIZE 8192 or better: #define USE_SCRIPT_FATFS -1 #define FAT_SCRIPT_SIZE 8192 with linker file \"esp32_partition_app1572k_ffat983k.csv\" Optional external editor you may use a special external editor with syntax highlighting to edit the scripts. (mac and pc) you may use any number of comments and indents to make it better readable. then with cmd r the script is transfered to the ESP and immediately started. (all comments and indents are removed before transfering) see further info and download here Console Commands script <n> : 0 = switch script off; 1 = switch script on script ><cmdline> execute - Can be used to set variables, e.g., script >mintmp=15 - Multiple statements can be specified by separating each with a semicolon, e.g. script >mintmp=15;maxtemp=40 script?<var> queries a script variable var The script itself can't be specified because the size would not fit the MQTT buffers Script Sections ~ Section descriptors (e.g., >E ) are case sensitive a valid script must start with >D in the first line >D ssize ssize = optional max string size (default=19) define and init variables here, must be the first section, no other code allowed p:vname specifies permanent variables. The number of permanent variables is limited by Tasmota rules space (50 bytes) - numeric variables are 4 bytes; string variables are one byte longer than the length of string t:vname specifies countdown timers, if >0 they are decremented in seconds until zero is reached. see example below i:vname specifies auto increment counters if =0 (in seconds) g:vname specifies global variable which is linked to all global variables with the same defintion on all devices in the homenet. when a variable is updated in one device it is instantly updated in all other devices. if a section >G exists it is executed when a variable is updated from another device (this is done via UDP-multicast, so not always reliable) m:vname specifies a median filter variable with 5 entries (for elimination of outliers) M:vname specifies a moving average filter variable with 8 entries (for smoothing data) (max 5 filters in total m+M) optional another filter length (1..127) can be given after the definition. Filter vars can be accessed also in indexed mode vname[x] (x = 1..N , x = 0 returns current array index pointer, x = -1 returns arry lenght) Using this filter, vars can be used as arrays, #define LARGE_ARRAYS allows for arrays up to 1000 entries array may also be permanent by specifying an extra :p m:p:vname defines a permanent array. Keep in mind however that in 1M Flash standard configurations you only have 50 bytes permanent storage which stands for a maximum of 12 numbers. (see list above for permanent storage in other configurations) Tip Keep variable names as short as possible. The length of all variable names taken together may not exceed 256 characters. Memory is dynamically allocated as a result of the D section. Copying a string to a number or reverse is supported >B executed on BOOT time before sensors are initialized and on save script >BS executed on BOOT time after sensors are initialized >E Executed when a Tasmota MQTT RESULT message is received, e.g., on POWER change. Also Zigbee reports to this section. >F Executed every 100 ms >S Executed every second >R Executed on restart. p vars are saved automatically after this call >T Executed on TelePeriod time ( SENSOR and STATE ), only put tele- vars in this section Remark: json variable names (like all others) may not contain math operators like - , you should set SetOption64 1 to replace - ( dash ) with _ ( underscore ). Zigbee sensors will not report to this section, use E instead. >H Alexa Hue interface (up to 32 virtual hue devices) ( example ) device , type , onVars Remark: hue values have a range from 0-65535. Divide by 182 to assign HSBcolors hue values. device device name type device type - E = extended color; S = switch onVars assign Hue \"on\" extended color parameters for hue, saturation, brightness, and color temperature (hue,sat,bri,ct) to scripter variables Example lamp1,E,on=pwr1,hue=hue1,sat=sat1,bri=bri1,ct=ct1 >U JSON messages from cmd status arrive here >G global variable updated section >P any power change triggers here >jp https webpage json parse arrives here >ti1 >ti2 >ti3 >ti4 ticker callback after timer expiration >b (note lower case) executed on button state change bt[x] read button state (x = 1.. MAX_KEYS ) Example >D tmp=0 >b tmp=bt[1] if tmp==0 then print falling edge of button1 endif if tmp==1 then print rising edge of button1 endif >J The lines in this section are published via MQTT in a JSON payload on TelePeriod . Requires compiling with #define USE_SCRIPT_JSON_EXPORT . >W The lines in this section are displayed in the web UI main page. Requires compiling with #define USE_SCRIPT_WEB_DISPLAY . You may put any html code here. Variables may be substituted using %var% HTML statements are displayed in the sensor section of the main page HTML statements preceded with a @ are displayed at the top of the page USER IO elements are displayed at the top of the page for next loops are supported to repeat HTML code (precede with % char) %for var from to inc %next script subroutines may be called sub=name of subroutine, like normal subroutines %=#sub in this subroutine a web line may be sent by wcs (see below) thus allowing dynamic HTML pages A web user interface may be generated containing any of the following elements: Button: bu(vn txt1 txt2) (up to 4 buttons may be defined in one row) vn = name of variable to hold button state txt1 = text of ON state of button txt2 = text of OFF state of button Checkbox: ck(vn txt) vn = name of variable to hold checkbox state txt = label text Slider: sl(min max vn ltxt mtxt rtxt) min = slider minimum value max = slider maximum value vn = name of variable to hold slider value ltxt = label left of slider mtxt = label middle of slider rtxt = label right of slider Text Input: tx(vn lbl) vn = name of string variable to hold text state lbl = label text Number Input: nm(min max step vn txt) min = number minimum value max = number maximum value step = number step value for up/down arrows vn = name of number variable to hold number txt = label text Google Charts: draws a google chart with up to 4 data sets per chart gc( T array1 ... array4 \"name\" \"label1\" ... \"label4\" \"entrylabels\" \"header\" {\"maxy1\"} {\"maxy2\"}) T = type - b=barchart - c=columnchart - C=combochart - p=piechart - l=linechart up to 4 lines with same scaling - l2=linechart with exactly 2 lines and 2 y scales (must be given at end) - lf2 like above but with splined lines - h=histogram - t=data table - g=simple gauges (must give extra 3 vars after header, yellow start, red start, maxval) - T=Timeline (special type arrays contains start,stop pairs in minutes timeofday) b,l,h type may have the '2' option to specify exactly 2 arrays with 2 y scales given at the end of paramter list. a very individual chart may be specified by splitting the chart definition and inserting the chart options directly see example below array = up to 4 arrays of data name = name of chart label = label for up to the 4 datasets in chart entrylabel = labels of each x axis entry separated by '|' char (\"cntN\" starts numbering entries with the number N an optional /X generates numbers devided by X) (\"wdh: before a week defintion generates a week with full hours) header = visible header name of chart additionally you have to define the html frame to put the chart in (both lines must be preceded by a $ char) e.g. $<div id=\"chart1\"style=\"width:640px;height:480px;margin:0 auto\"></div> $gc(c array1 array2 \"wr\" \"pwr1\" \"pwr2\" \"mo|di|mi|do|fr|sa|so\" \"Solar feed\") you may define more then one chart. The charts id is chart1 ... chartN very customized chart definition: define a chart like above, but add a t to the definition this generates a google table from the arrays e.g.: &gc(lt array1 array2 \"wr\" \"pwr1\" \"pwr2\" \"mo|di|mi|do|fr|sa|so\") then define the options for the graph as from the doku of google e.g.: $var options = { $vAxes:{0:{maxValue:40,title:'Au\u00dfentemperatur'},1:{maxValue:60,title:'Solarspeicher'}}, $series:{0:{targetAxisIndex:0},1:{targetAxisIndex:1}}, $hAxis: {title: 'Wochenverlauf'}, $}; then gc(e) closes the definition $gc(e) >w ButtonLabel generates a button with the name \"ButtonLabel\" in Tasmota main menu. Clicking this button displays a web page with the HTML data of this section. all cmds like in >W apply here. these lines are refreshed frequently to show e.g. sensor values. lines preceeded by $ are static and not refreshed and display below lines without $. this option also enables a full webserver interface when USE_SCRIPT_FATFS is activ. you may display files from the flash or SD filesystem by specifying the url: IP/sdc/path . (supported files: *.jpg, *.html, *.txt) Requires compiling with #define SCRIPT_FULL_WEBPAGE . >M Smart Meter Interface If a variable does not exist, ??? is displayed for commands If a Tasmota SENSOR or STATUS or RESULT message is not generated or a Var does not exist the destination variable is NOT updated. Special Variables ~ (read only) upsecs = seconds since start uptime = minutes since start time = minutes since midnight sunrise = sunrise minutes since midnight sunset = sunset minutes since midnight tper = TelePeriod ( may be set also ) tstamp = timestamp (local date and time) topic = mqtt topic gtopic = mqtt group topic lip = local ip as string luip = udp ip as string (from updating device when USE_SCRIPT_GLOBVARS defined) prefixn = prefix n = 1-3 frnm = friendly name pwr[x] = power state (x = 1..N) pc[x] = pulse counter value (x = 1..4) tbut[x] = touch screen button state (x = 1..N) sw[x] = switch state (x = 0..N) (Switch1 = sw[0] ) bt[x] = button state (x = 1..N) only valid in section b (if defined USE_BUTTON_EVENT) pin[x] = GPIO pin level (x = 0..16) pn[x] = GPIO for sensor code x. 99 if none pd[x] = defined sensor for GPIO x. 999 if none pl[path] = plays the mp3 path (ESP32 and if I2S Device defined) say[svar] = text to speach (if I2S Device defined) adc(fac (pin)) = get adc value (on ESP32 can select pin) fac is number of averaged samples (power of 2: 0..7) sht[x] = shutter position (x = 1..N) (if defined USE_SHUTTER) gtmp = global temperature ghum = global humidity gprs = global pressure pow(x y) = calculates exponential powers x^y med(n x) = calculates a 5 value median filter of x (2 filters possible n=0,1) int(x) = gets the integer part of x (like floor) hn(x) = converts x (0..255) to a hex nibble string hx(x) = converts x (0..65535) to a hex string hd(\"hstr\") = converts hex number string to a decimal number st(svar c n) = string token - retrieve the n th element of svar delimited by c sl(svar) = gets the length of a string asc(svar) = gets the binary value of 1. char of a string sb(svar p n) = gets a substring from svar at position p (if p<0 counts from end) and length n is(num \"string1|string2|....|stringn|\") = defines a string array optionally preset with immediate strings separated by '|' (this immediate string may be up to 255 chars long) num = 0 read only string array, num > 0 number of elements in read write string array is[index] = gets string index from string array, if read-write also write string of index is1(..) , is2(...) string array see above is1[x] , is2[x] string array see above sin(x) = calculates the sinus(x) (if defined USE_ANGLE_FUNC) acos(x) = calculates the acos(x) (if defined USE_ANGLE_FUNC) sqrt(x) = calculates the sqrt(x) (if defined USE_ANGLE_FUNC) abs(x) = calculates the absolute value of x mpt(x) = measure pulse time, x>=0 defines pin to use, -1 returns low pulse time,-2 return high pulse time (if defined USE_ANGLE_FUNC) rnd(x) = return a random number between 0 and x, (seed may be set by rnd(-x)) sf(F) = sets the CPU Frequency (ESP32) to 80,160,240 Mhz, returns current Freq. s(x) = explicit conversion from number x to string mqtts = MQTT connection status: 0 = disconnected, >0 = connected wbut = button status of watch side button (if defined USE_TTGO_WATCH) wdclk = double tapped on display (if defined USE_TTGO_WATCH) wtch(sel) = gets state from touch panel sel=0 => touched, sel=1 => x position, sel=2 => y position (if defined USE_TTGO_WATCH) slp(time) = sleep time in seconds, pos values => light sleep, neg values => deep sleep (if defined USE_TTGO_WATCH) play(path) = play mp3 audio from filesystem (if defined USE_I2S_AUDIO or USE_TTGO_WATCH or USE_M5STACK_CORE2) say(\"text\") = plays specified text to speech (if defined USE_I2S_AUDIO or USE_TTGO_WATCH or USE_M5STACK_CORE2) c2ps(sel val) = gets, sets values on ESP32 CORE2 sel=0 green led, sel=1 vibration motor, sel=2,3,4 get touch button state 1,2,3 (if defined USE_M5STACK_CORE2) rec(path seconds) = rec n seconds wav audio file from i2s microphone to filesystem path (if defined USE_I2S_AUDIO or USE_M5STACK_CORE2) pwmN(-pin freq) = defines a pwm channel N (1..N) with pin Nr and frequency (pin 0 beeing -64, N=5 with esp8266 and N=8 with esp32) pwmN(val) = outputs a pwm signal on channel N (1..N) with val (0-1023) wifis = Wi-Fi connection status: 0 = disconnected, >0 = connected wcs = send this line to webpage (WebContentSend) wm = contains source of web request code e.g. 0 = Sensor display (FUNC_WEB_SENSOR) sml(m 0 bd) = set SML baudrate of Meter m to bd (baud) sml(m 1 htxt) = send SML Hexstring htxt as binary to Meter m (if defined USE_SML_SCRIPT_CMD) sml(m 2) = reads serial data received by Meter m into string (if m<0 reads hex values, else asci values)(if defined USE_SML_SCRIPT_CMD) sml[n] = get value of SML energy register n (if defined USE_SML_SCRIPT_CMD) enrg[n] = get value of energy register n 0=total, 1..3 voltage of phase 1..3, 4..6 current of phase 1..3, 7..9 power of phase 1..3 (if defined USE_ENERGY_SENSOR) gjp(\"host\" \"path\") = trigger HTTPS JSON page read as used by Tesla Powerwall (if defined SCRIPT_GET_HTTPS_JP) tsN(ms) = set up to 4 timers (N=1..4) to millisecond time on expiration triggers section >tiN (if defined USE_SCRIPT_TIMER) hours = hours mins = mins secs = seconds day = day of month wday = day of week (Sunday=1,Monday=2;Tuesday=3;Wednesday=4,Thursday=5,Friday=6,Saturday=7) month = month year = year epoch = epoch time (from 2019-1-1 00:00) eres = result of >E section set this var to 1 in section >E to tell Tasmota event is handled (prevents MQTT) The following variables are cleared after reading true: chg[var] = true if a variables value was changed (numeric vars only) upd[var] = true if a variable was updated boot = true on BOOT tinit = true on time init tset = true on time set mqttc = true on mqtt connect mqttd = true on mqtt disconnect wific = true on wifi connect wifid = true on wifi disconnect System variables (for debugging) stack = stack size heap = free heap size pheap = PSRAM free heap size (ESP32) core = current core (0 or 1) (ESP32) ram = used ram size slen = script length freq = cpu frequency micros = running microseconds millis = running milliseconds loglvl = loglevel of script cmds ( may be set also ) Remarks: If you define a variable with the same name as a special variable that special variable is discarded Commands ~ => <command> Execute recursion disabled +> <command> Execute recursion enabled -> <command> Execute - do not send MQTT or log messages (i.e., silent execute - useful to reduce traffic) Variable Substitution - A single percent sign must be given as %% - Variable replacement within commands is allowed using %varname% . Optionally, the decimal places precision for numeric values may be specified by placing a digit ( %Nvarname% , N = 0..9 ) in front of the substitution variable (e.g., Humidity: %3hum%%% will output Humidity: 43.271% ) - instead of variables arbitrary calculations my be inserted by bracketing %N(formula)% - Linefeed and carriage return may be defined by \\n and \\r Special commands: print or =>print prints to the log for debugging A Tasmota MQTT RESULT message invokes the script's E section. Add print statements to debug a script. Example >E slider=Dimmer power=POWER if upd [ slider ]> 0 then print slider updated % slider % endif if upd [ power ]> 0 then print power updated % power % endif break exits a section or terminates a for next loop dpx sets decimal precision to x (0-9) svars save permanent vars delay(x) pauses x milliseconds (should be as short as possible) beep(f l) (ESP32) beeps with a passive piezo beeper. beep(-f 0) attaches PIN f to the beeper, beep(f l) starts a sound with frequency f (Hz) and len l (ms). f=0 stops the sound. spin(x b) set GPIO x (0..16) to value b (0,1). Only bit 0 of b is used - even values set the GPIO to 0 and uneven values set the GPIO to 1 spinm(x m) set GPIO x (0..16) to mode m (input=0, output=1, input with pullup=2,alternatively b may be: O=out, I=in, P=in with pullup) ws2812(array dstoffset) copies an array (defined with m:vname ) to the WS2812 LED chain. The array length should be defined as long as the number of pixels. Color is coded as 24 bit RGB. optionally the destinationoffset in the LED chain may be given hsvrgb(h s v) converts hue (0..360), saturation (0..100) and value (0..100) to RGB color dt display text command (if #define USE_DISPLAY) #name names a subroutine. Subroutine is called with =#name #name(param) names a subroutine with a parameter. Subroutine is called with =#name(param) Subroutines end with the next # or > line or break. Subroutines may be nested Parameters can be numbers or strings and on type mismatch are converted If #define USE_SCRIPT_SUB_COMMAND is included in your user_config_override.h , a subroutine may be invoked via the Console or MQTT using the subroutine's name. For example, a declared subroutine #SETLED(num) may be invoked by typing SETLED 1 in the Console. The parameter 1 is passed into the num argument. This also works with string parameters. since Tasmota capitalizes all commands you must use upper case labels. It is possible to \"replace\" internal Tasmota commands. For example, if a #POWER1(num) subroutine is declared, the command POWER1 is processed in the scripter instead of in the main Tasmota code. =(svar) executes a routine whose name is passed as a string in a variable (dynamic or self modifying code). The string has to start with > or =# for the routine to be executed. D svar = \"=#subroutine\" S = ( svar ) #subroutine => print subroutine was executed For loop (loop count must not be less than 1, no direct nesting supported) for var < from > < to > < inc > next Switch selector (numeric or string) switch x case a case b ends Conditional Statements There are two syntax alternatives. You may NOT mix both formats. if a==b and x==y or k==i then = do this else = do that endif or if a==b and x==y or k==i { = do this } else { = do that } Remarks: The last closing bracket must be on a separate line Calculations are permitted in conditional expressions, e.g., if var1 - var2 == var3 * var4 Conditional expressions may be enclosed in parentheses. The statement must be on a single line. e.g., if ((a==b) and ((c==d) or (c==e)) and (s!=\"x\")) mapping function mp(x str1 str2 ... str ) It addresses a standard task with less code and much flexibility: mapping an arbitrary incoming numeric value into the allowed range. The numeric value x passed as the first parameter is compared to the rules in the order they are provided as subsequent sting parameters. If the value matches the criteria, the defined value is returned. Subsequent rules are skipped. If x matches none of the rules, x is returned unchanged. Rules consist of one of the comparison operators < > = followed by a numeric value v1, optionally followed by a colon and another numeric value v2. <|>|= v1 [: v2 ] Example 1 : \"<8:0\" - this rule reads : If x is less than 8 , return 0 . Example 2 : \">100\" - this rule reads : If x is greater than 100 , return 100 . Example 3 : y = mp ( x \"<8:0\" \">100\" ) Assigns 0 to y if x is less than 8 . Assigns 100 to y if x is greater than 100 . Assigns x to y for all values of x that do not meet the above criteria ( 8 to 100 ). The above code of example 3 does the same as the following code - with just one line of code and 15 characters less : y = x if x < 8 { y = 0 } if x > 100 { y = 100 } E-mail #define USE_SENDMAIL Enabling this feature also enables Tasmota TLS as sendmail uses SSL. sendmail [server:port:user:passwd:from:to:subject] msg Example sendmail [smtp.gmail.com:465:user:passwd:sender@gmail.com:<rec@gmail.com:alarm] %string% Remark: A number of e-mail servers (such as Gmail) require the receiver's e-mail address to be enclosed by < ... as in example above. Most other e-mail servers also accept this format. While ESP8266 sendmail needs brackets, ESP32 sendmail inserts brackets itself so you should not specify brackets here. The following parameters can be specified during compilation via #define directives in user_config_override.h : * EMAIL_SERVER * EMAIL_PORT * EMAIL_USER * EMAIL_PASSWORD * EMAIL_FROM To use any of these values, pass an * as its corresponding argument placeholder. sendmail [*:*:*:*:*:<rec@gmail.com:theSubject] theMessage Instead of passing the msg as a string constant, the body of the e-mail message may also be composed using the script m (note lower case) section. The specified text in this script section must end with an # character. sendmail will use the m section if * is passed as the msg parameter. in this >m section you may also specify email attachments. @/filename specifies a file to be attached (if file system is present) &arrayname specifies an array attachment (as tab delimeted text, no file system needed) See [Scripting Cookbook Example].(#send-e-mail) Subscribe, Unsubscribe #define SUPPORT_MQTT_EVENT subscribe and unsubscribe commands are supported. In contrast to rules, no event is generated but the event name specifies a variable defined in D section and this variable is automatically set on transmission of the subscribed item within a script the subscribe cmd must be send with +> instead of => the MQTT decoder may be configured for more space in user config overwrite by #define MQTT_EVENT_MSIZE xxx (default is 256) #define MQTT_EVENT_JSIZE xxx (default is 400) SD Card Support (+ 10k flash) #define USE_SCRIPT_FATFS CARD_CS CARD_CS = GPIO of card chip select SD card uses standard hardware SPI GPIO: mosi,miso,sclk with 4M flash on ESP8266 and special linker file you may specify -1 for CS and get a flash file system with the same functionality but but very low capacity (e.g. 2 MB) A maximum of four files may be open at a time e.g., allows for logging sensors to a tab delimited file and then downloading the file ( see Sensor Logging example ) The downloading of files may be executed in a kind of \"multitasking\" when bit 7 of loglvl is set (128+loglevel) Without multitasking 150kb/s (all processes are stopped during downloading), with multitasking 50kb/s (other Tasmota processes are running) The script itself is also stored on the SD card with a default size of 4096 characters SD card directory support (+ 1,2k flash) #define SDCARD_DIR Shows a web SD card directory (submenu of scripter) where you can upload and download files to/from sd card fr=fo(\"fname\" m) open file fname, mode 0=read, 1=write, 2=append (returns file reference (0-3) or -1 for error) (alternatively m may be: r=read, w=write, a=append) res=fw(\"text\" fr) writes text to (the end of) file fr, returns number of bytes written res=fr(svar fr) reads a string into svar, returns bytes read. String is read until delimiter (\\t \\n \\r) or eof fc(fr) close file ff(fr) flush file, writes cached data and updates directory fd(\"fname\") delete file fname flx(fname) create download link for file (x=1 or 2) fname = file name of file to download fsm return 1 if filesystem is mounted, (valid SD card found) res=fsi(sel) gets file system information, sel=0 returns total media size, sel=1 returns free space both in kB fra(array fr) reads array from open file with fr (assumes tab delimeted entries) fwa(array fr) writes array to open file with fr (writes tab delimited entries) Extended commands (+0,9k flash) #define USE_SCRIPT_FATFS_EXT fmd(\"fname\") make directory fname frd(\"fname\") remove directory fname fx(\"fname\") check if file fname exists fe(\"fname\") execute script fname (max 2048 bytes, script must start with the '>' character on the first line) ESP32 real Multitasking support #define USE_SCRIPT_TASK enables support for multitasking scripts res=ct(num timer core) creates a task num (1 or 2) which is executed every timer (ms) time on core 0 or 1 the sections are named >t1 for task 1 >t2 for task 2 Example > D > B ; create task 1 every 1000 ms on core 0 ct ( 1 1000 0 ) ; create task 2 every 3000 ms on core 1 ct ( 2 3000 1 ) > t1 print task1 on core % core % > t2 print task2 on core % core % Script compression #define USE_SCRIPT_COMPRESSION enables compression of script storage to about 40%. The script buffer is set to 2560 instead of 1535 chars. no backward compatibility. first save your old script before updating. ESP32 Webcam support #define USE_WEBCAM Template for AI THINKER CAM : {\"NAME\":\"AITHINKER CAM No SPI\",\"GPIO\":[4992,65504,65504,65504,65504,5088,65504,65504,65504,65504,65504,65504,65504,65504,5089,5090,0,5091,5184,5152,0,5120,5024,5056,0,0,0,0,4928,65504,5094,5095,5092,0,0,5093],\"FLAG\":0,\"BASE\":1} remarks: - GPIO0 zero must be disconnected from any wire after programming because this pin drives the cam clock and does not tolerate any capictive load - Only boards with PSRAM should be used. To enable PSRAM board should be se set to esp32cam in common32 of platform_override.ini board = esp32cam - To speed up cam processing cpu frequency should be better set to 240Mhz in common32 of platform_override.ini board_build.f_cpu = 240000000L file system extension: fwp(pnum fr) write picture from RAM buffer number pnum to sdcard file with file reference fr specific webcam commands: res=wc(sel p1 p2) controll webcam, sel = function selector p1 ... optional parameters res=wc(0 pres) init webcam with picture resolution pres, returns 0 when error, 2 when PSRAM found, else 1 pres * 0 = FRAMESIZE_QQVGA, // 160x120 * 1 = FRAMESIZE_QQVGA2, // 128x160 * 2 = FRAMESIZE_QCIF, // 176x144 * 3 = FRAMESIZE_HQVGA, // 240x176 * 4 = FRAMESIZE_QVGA, // 320x240 * 5 = FRAMESIZE_CIF, // 400x296 * 6 = FRAMESIZE_VGA, // 640x480 * 7 = FRAMESIZE_SVGA, // 800x600 * 8 = FRAMESIZE_XGA, // 1024x768 * 9 = FRAMESIZE_SXGA, // 1280x1024 * 10 = FRAMESIZE_UXGA, // 1600x1200 res=wc(1 bnum) capture picture to rambuffer bnum (1..4), returns framesize of picture or 0 when error res=wc(2 sel p1) execute various controls, details below. res=wc(3) gets picture width res=wc(4) gets picture height res=wc(5 p) start stop streaming 0=stop, 1=start res=wc(6 p) start stop motion detector, p=0 => stop detector, p=T start detector with picture every T ms, -1 get picture difference, -2 get picture brightness res=wc(7 p) start stop face detector, p=0 => stop detector, p=T start detector with picture every T ms, -1 get number of faces found in picture (USE_FACE_DETECT must be defined) control cmds sel = * 0 fs = set frame size (see above for constants) * 1 se = set special effect 0 = no effect 1 = negative 2 = black and white 3 = reddish 4 = greenish 5 = blue 6 = retro 2 fl = set horizontal flip 0,1 3 mi = set vertical mirror 0,1 to read a value without setting pass -1 extensions to the email system on ESP32 #define SEND_EMAIL and #define USE_ESP32MAIL enables specific ESP32 mail server this server can handle more mail servers by supporting START_TLS remark: mail adresses must not be enclosed with <> because the server inserts them automatically this server also supports email attachments in the >m section you may write &/file.txt to attach a file from SD card $N N=1..4 to attach a picture from picture RAM buffer number N displaying webcam pictures in WEBUI you may display a webcam picture by giving the name /wc.jpg?p=N (1..4) for RAM picturebuffer N \"<img src=\"/wc.jpg?p=1\" alt=\"webcam image\" >\" you may also provide the picture size (h and v have to be preset before) \"<img src=\"/wc.jpg?p=1\" alt=\"webcam image\" style=\"width:%w%px;height:%h%px;\">\" if you precede the line by & char the image is diplayed in the main section, else in the sensor tab section the webcam stream can be specified by the following line lip is a system variable containing the local device ip \"&<br>\" \"&<img src=\"http://%lip%:81/stream\" style=\"width:%w%px;height:%h%px\">\" \"&<br><center>webcam stream\" remark: the Flash illumination LED is connected to GPIO4 Example > D res = 0 w = 0 h = 0 mot = 0 bri = 0 > B ; init cam with QVGA res = wc ( 0 4 ) ; get pixel size w = wc ( 3 ) h = wc ( 4 ) ; start motion detector , picture every 1000 ms mot = wc ( 6 1000 ) > S if wific > 0 then ; when wifi up , start stream res = wc ( 5 1 ) endif ; get motion detect diff value mot = wc ( 6 -1 ) ; get picture brightnes bri = wc ( 6 -2 ) > W < center > motion diff = % mot %< br > < center > brightness = % bri %< br > ; show stream on WEBUI &< br > &< img src = \"http://%lip%:81/stream\" style = \"width:%w%px;height:%h%px\" > &< br >< center > webcam stream Scripting Cookbook ~ Scripting Language Example ~ a valid script must start with > D in the first line ! some samples still contain comment lines before > D . This is no longer valid ! ** Actually this code is too large ** . This is only meant to show some of the possibilities > D ; define all vars here p : mintmp = 10 ( p : means permanent ) p : maxtmp = 30 t : timer1 = 30 ( t : means countdown timer ) t : mt = 0 i : count = 0 ( i : means auto counter ) hello = \"hello world\" string = \"xxx\" url = \"[_IP_]\" ; hum = 0 temp = 0 zigbeetemp = 0 timer = 0 dimmer = 0 sw = 0 rssi = 0 param = 0 col = \"\" ocol = \"\" chan1 = 0 chan2 = 0 chan3 = 0 ahum = 0 atemp = 0 tcnt = 0 hour = 0 state = 1 m : med5 = 0 M : movav = 0 ; define array with 10 entries m : array = 0 10 > B string = hello + \"how are you?\" => print BOOT executed => print % hello % => mp3track 1 ; list gpio pin definitions for cnt 0 16 1 tmp = pd [ cnt ] => print % cnt % = % tmp % next ; get gpio pin for relais 1 tmp = pn [ 21 ] => print relais 1 is on pin % tmp % ; pulse relais over raw gpio spin ( tmp 1 ) delay ( 100 ) spin ( tmp 0 ) ; raw pin level => print level of gpio1 % pin [ 1 ]% ; pulse over tasmota cmd => power 1 delay ( 100 ) = power 0 > T hum = BME280#Humidity temp = BME280#Temperature rssi = Wifi#RSSI string = SleepMode ; add to median filter median = temp ; add to moving average filter movav = hum ; show filtered results => print % median % % movav % if chg [ rssi ]> 0 then => print rssi changed to % rssi % endif if temp > 30 and hum > 70 then => print damn hot ! endif = #siren ( 5 ) ; loop nesting workaround ; by using subroutine #siren ( num ) for cnt 1 num 1 = #stone next #stone for tone 2000 1000 - 20 beep ( tone 10 ); delay ( 12 ) next > S ; every second but not completely reliable time here ; use upsecs and uptime or best t : for reliable timers ; arrays array [ 1 ]= 4 array [ 2 ]= 5 tmp = array [ 1 ]+ array [ 2 ] ; call subrountines with parameters = #sub1 ( \"hallo\" ) = #sub2 ( 999 ) ; stop timer after expired if timer1 == 0 then timer1 =- 1 => print timer1 expired endif ; auto counter with restart if count = 10 then => print 10 seconds over count = 0 endif if upsecs % 5 == 0 then => print % upsecs % ( every 5 seconds ) endif ; not recommended for reliable timers timer += 1 if timer >= 5 then => print 5 seconds over ( may be ) timer = 0 endif dimmer += 1 if dimmer > 100 then dimmer = 0 endif => dimmer % dimmer % => WebSend % url % dimmer % dimmer % ; show on display dp0 dt [ c1l1f1s2p20 ] dimmer =% dimmer % => print % upsecs % % uptime % % time % % sunrise % % sunset % % tstamp % if time > sunset and time < sunrise then ; night time if pwr [ 1 ]== 0 then => power1 1 endif else ; day time if pwr [ 1 ]> 0 then => power1 0 endif endif ; clr display on boot if boot > 0 then dt [ z ] endif ; frost warning if (( temp < 0 or zigbeetemp < 0 ) and mt <= 0 ) then = #sendmail ( \"frost alert\" ) ; alarm only every 5 minutes mt = 300 = mp3track 2 endif ; var has been updated if upd [ hello ]> 0 then => print % hello % endif ; send to Thingspeak every 60 seconds ; average data in between if upsecs % 60 == 0 then ahum >= tcnt atemp >= tcnt = WebSend [ _IP_ ]/ update ? key = _token_ & field1 =% atemp %& field2 =% ahum % tcnt = 0 atemp = 0 ahum = 0 else ahum += hum atemp += temp tcnt += 1 endif hour = int ( time / 60 ) if chg [ hour ]> 0 then ; exactly every hour => print full hour reached endif if time5 { => print more then 5 minutes after midnight } else { = print less then 5 minutes after midnight } ; publish abs hum every teleperiod time if mqtts > 0 and upsecs % tper == 0 then ; calc abs humidity tmp = pow ( 2.718281828 ( 17.67 * temp ) / ( temp + 243.5 )) tmp = ( 6.112 * tmp * hum * 18.01534 ) / (( 273.15 + temp ) * 8.31447215 ) ; publish median filtered value => Publish tele /% topic %/ SENSOR { \"Script\" :{ \"abshum\" : % med ( 0 tmp ) % }} endif ; switch case state machine switch state case 1 => print state =% state % , start state += 1 case 2 => print state =% state % state += 1 case 3 => print state =% state % , reset state = 1 ends ; subroutines #sub1 ( string ) => print sub1 : % string % #sub2 ( param ) => print sub2 : % param % #sendmail ( string ) => sendmail [ smtp.gmail.com:465:user:passwd:<sender@gmail.de:<rec@gmail.de:alarm ] % string % > E => print event executed ! ; Assign temperature from a Zigbee sensor zigbeetemp = ZbReceived#0x2342#Temperature ; get HSBColor 1. component tmp = st ( HSBColor , 1 ) ; check if switch changed state sw = sw [ 1 ] if chg [ sw ]> 0 then => power1 % sw % endif hello = \"event occured\" ; check for Color change ( Color is a string ) col = Color ; color change needs 2 string vars if col != ocol then ocol = col => print color changed % col % endif ; or check change of color channels chan1 = Channel [ 1 ] chan2 = Channel [ 2 ] chan3 = Channel [ 3 ] if chg [ chan1 ]> 0 or chg [ chan2 ]> 0 or chg [ chan3 ]> 0 then = color has changed endif ; compose color string for red col = hn ( 255 ) + hn ( 0 ) + hn ( 0 ) = color % col % > R => print restarting now Sensor Logging ~ ; define all vars here ; reserve large strings > D 48 hum = 0 temp = 0 fr = 0 res = 0 ; moving average for 60 seconds M : mhum = 0 60 M : mtemp = 0 60 str = \"\" > B ; set sensor file download link fl1 ( \"slog.txt\" ) ; delete file in case we want to start fresh ; fd ( \"slog.txt\" ) ; list all files in root directory fr = fo ( \"/\" 0 ) for cnt 1 20 1 res = fr ( str fr ) if res > 0 then => print % cnt % : % str % else break endif next fc ( fr ) > T ; get sensor values temp = BME280 #Temperature hum = BME280 #Humidity > S ; average sensor values every second mhum = hum mtemp = temp ; write average to sensor log every minute if upsecs % 60 == 0 then ; open file for write fr = fo ( \"slog.txt\" 1 ) ; compose string for tab delimited file entry str = s ( upsecs ) + \" \\t \" + s ( mhum ) + \" \\t \" + s ( mtemp ) + \" \\n \" ; write string to log file res = fw ( str fr ) ; close file fc ( fr ) endif > R e-Paper 29 Display with SGP30 and BME280 ~ Some variables are set from ioBroker > D hum = 0 temp = 0 press = 0 ahum = 0 tvoc = 0 eco2 = 0 zwz = 0 wr1 = 0 wr2 = 0 wr3 = 0 otmp = 0 pwl = 0 tmp = 0 ; preset units in case they are not available punit = \"hPa\" tunit = \"C\" > B ; reset auto draw dt [ zD0 ] ; clr display and draw a frame dt [ x0y20h296x0y40h296 ] > T ; get telemetry sensor values temp = BME280#Temperature hum = BME280#Humidity press = BME280#Pressure tvoc = SGP30#TVOC eco2 = SGP30#eCO2 ahum = SGP30#aHumidity tunit = TempUnit punit = PressureUnit > S ; update display every [ `TelePeriod` ] ( Commands . md#teleperiod ) if upsecs % tper == 0 then dp2 dt [ f1p7x0y5 ]% temp % % tunit % dt [ p5x70y5 ]% hum % %%[ x250y5t ] dt [ p11x140y5 ]% press % % punit % dt [ p10x30y25 ] TVOC : % tvoc % ppb dt [ p10x160y25 ] eCO2 : % eco2 % ppm dt [ p10c26l5 ] ahum : % ahum % g ^ m3 dp0 dt [ p25c1l5 ] WR 1 ( Dach ) : % wr1 % W dt [ p25c1l6 ] WR 2 ( Garage ) : %- wr3 % W dt [ p25c1l7 ] WR 3 ( Garten ) : %- wr2 % W dt [ p25c1l8 ] Aussentemperatur : % otmp % C dt [ x170y95r120:30f2p6x185y100 ] % pwl % %% ; now update screen dt [ d ] endif > E > R e-Paper 42 Display with SHT31 and BME280 ~ This script shows 2 graphs on an 4.2 inch e-Paper display: 1. some local sensors, and 2. power statistics The first graph is the battery level of a solar battery (Tesla PowerWall 2) The second graph shows the solar yield of the roof panels in Watts Another special feature is that this script displays daily and weekly averages (via moving average) of all power IO of the house. it sends an email every sunday night with the weekly data it displays a google bar chart on the webui with values for each weekday of the last week ESP32 CPU with SD card Since the display is a full update panel it is updated only once a minute Some values (like power meters) are set remotely from ioBroker > D hum = 0 temp = 0 press = 0 zwz = 0 wr1 = 0 wr2 = 0 wr3 = 0 otmp = 0 pwl = 0 ez1 = 0 sez1 = 0 M :mez1 = 0 7 ezh = 0 sezh = 0 M :mezh = 0 7 vzh = 0 svzh = 0 M :mvzh = 0 7 wd = 0 res = 0 hr = 0 t1 = 0 res = 0 > B ->setoption64 1 tper = 30 dt [ IzD0 ] dt [ zG10352: 5 : 40 :- 350 : 80 : 10080 : 0 : 100 f3x360y40 ] 100 %%[x360y115]0 %% dt [ f1x100y25 ] Powerwall - 7 Tage [ f1x360y75 ] 0 %% dt [ G10353 : 5 : 140 :- 350 : 80 : 10080 : 0 : 5000 f3x360y140 ] + 5000 W [ x360y215 ] 0 W dt [ f1x70y125 ] Volleinspeisung - 7 Tage [ f1x360y180 ] 0 W dt [ p13x10y230 ] WR 1 , 2 , 3 : dt [ p13x10y245 ] H - Einsp . : dt [ p13x10y260 ] H - Verbr . : dt [ p13x10y275 ] D - Einsp . : dt [ d ] dt [ Gr0 :/g0_sav . txt :] dt [ Gr1 :/g1_sav . txt :] beep ( - 25 0 ) beep ( 1000 100 ) > T press = BMP280 # Pressure temp = SHT3X_0x44 # Temperature hum = SHT3X_0x44 # Humidity > S if upsecs %60==0 then dp2 dt [ f1p7x0y5 ] %temp% C dt [ x0y20h400x250y5T ][ x350t ][ f1p10x70y5 ] %hum% %% dt [ p10x140y5 ] %press% hPa dp0 dt [ p5x360y75 ] %pwl% %% dt [ p6x360y180 ] %wr1%W dt [ g0: %pwl%g1:%wr1%] dt [ p24x75y230 ] %wr1% W : %-wr2% W : %-wr3% W dt [ p - 10 x75y245 ] %ezh% kWh dt [ p - 10 x75y260 ] %vzh% kWh dt [ p - 10 x75y275 ] %ez1% kWh t1 = mezh * 7 dt [ p - 10 x150y245 ] : %t1% kWh t1 = mvzh * 7 dt [ p - 10 x150y260 ] : %t1% kWh t1 = mez1 * 7 dt [ p - 10 x150y275 ] : %t1% kWh dp1 t1 = ezh - sezh dt [ p12x250y245 ] : %t1% kWh t1 = vzh - svzh dt [ p12x250y260 ] : %t1% kWh t1 = ez1 - sez1 dt [ p12x250y275 ] : %t1% kWh dp0 dt [ f2p5x320y250 ] %otmp%C dt [ d ] print updating display endif hr = hours if chg [ hr ] > 0 and hr == 0 then mez1 = ez1 - sez1 sez1 = ez1 mezh = ezh - sezh sezh = ezh mvzh = vzh - svzh svzh = vzh endif if sezh == 0 then sez1 = ez1 sezh = ezh svzh = vzh endif wd = wday if chg [ wd ] > 0 and wd == 1 then =>sendmail [ *:*:*:*:*:user . tasmota@gmail . com : Wochenbericht ] * print sening email endif if upsecs %300==0 then =#savgraf print saving graph endif #savgraf dt [ Gs0 :/g0_sav . txt :] dt [ Gs1 :/g1_sav . txt :] > m Wochenbericht Einspeisung und Verbrauch < br><br > w1= %mez1[1]%,%mez1[2]%,%mez1[3]%,%mez1[4]%,%mez1[5]%,%mez1[6]%,%mez1[7]%,%mez1[8]%<br> w2= %mezh[1]%,%mezh[2]%,%mezh[3]%,%mezh[4]%,%mezh[5]%,%mezh[6]%,%mezh[7]%,%mezh[8]%<br> w3= %mvzh[1]%,%mvzh[2]%,%mvzh[3]%,%mvzh[4]%,%mvzh[5]%,%mvzh[6]%,%mvzh[7]%,%mvzh[8]%<br> # > W &<br>< div id= \"container\" style= \"width:640px;height:480px;margin:0 auto\" ></ div ><br > &<script type= \"text/javascript\" src= \"https://www.gstatic.com/charts/loader.js\" ></script > &<script type= \"text/javascript\" > google . charts . load ( 'current' ,{ packages :[ 'corechart' ]}); </script > &<script language= \"JavaScript\" > function drawChart (){ var data = &google . visualization . arrayToDataTable ([ & [ 'weekday' , 'Power' ],[ 'Mo' , %mvzh[1]%],['Di',%mvzh[2]%],['Mi',%mvzh[3]%],['Do',%mvzh[4]%], & [ 'Fr' , %mvzh[5]%],['Sa',%mvzh[6]%],['So',%mvzh[7]%]]); &var options= { title : 'daily solar feed' , isStacked:true }; &var chart = new &google . visualization . ColumnChart ( document . getElementById ( 'container' )); chart . draw ( data , options );} &google . charts . setOnLoadCallback ( drawChart ); </script > # ILI 9488 Color LCD Display with BMP280 and VL5310X ~ Shows various BMP280 energy graphs Turn display on and off using VL5310X proximity sensor to prevent burn-in Some variables are set from ioBroker > D temp = 0 press = 0 zwz = 0 wr1 = 0 wr2 = 0 wr3 = 0 otmp = 0 pwl = 0 tmp = 0 dist = 0 punit= \"hPa\" tunit= \"C\" hour = 0 > B dt [ z ] // define 2 graphs , 2. has 3 tracks dt [ zCi1G2656: 5 : 20 : 400 : 80 : 1440 :- 5000 : 5000 : 3 Ci7f3x410y20 ] + 5000 W [ x410y95 ] - 5000 W [ Ci7f1x70y3 ] Zweirichtungsz ~ 80 hler - 24 Stunden dt [ Ci1G2657 : 5 : 120 : 400 : 80 : 1440 : 0 : 5000 : 3 Ci7f3x410y120 ] + 5000 W [ x410y195 ] 0 W [ Ci7f1x70y103 ] Wechselrichter 1 - 3 - 24 Stunden dt [ Ci1G2658 : 5 : 120 : 400 : 80 : 1440 : 0 : 5000 : 16 ][ Ci1G2659 : 5 : 120 : 400 : 80 : 1440 : 0 : 5000 : 5 ] dt [ f1s1b0: 260 : 260 : 100 &# 8203 ; : 50 : 2 : 11 : 4 : 2 : Rel 1 :b1: 370 : 260 : 100 &# 8203 ; : 50 : 2 : 11 : 4 : 2 : Dsp off :] =>mp3volume 100 =>mp3track 4 > T ; get some telemetry values temp = BMP280 # Temperature press = BMP280 # Pressure tunit = TempUnit punit = PressureUnit dist = VL53L0X # Distance ; check proximity sensor to turn display on and off to prevent burn - in if dist > 300 then if pwr [ 2 ] > 0 then =>power2 0 endif else if pwr [ 2 ] == 0 then =>power2 1 endif endif > S ; update graph every teleperiod if upsecs %tper==0 then dp2 dt [ f1Ci3x40y260w30Ci1 ] dt [ Ci7x120y220t ] dt [ Ci7x180y220T ] dt [ Ci7p8x120y240 ] %temp% %tunit% dt [ Ci7x120y260 ] %press% %punit% dt [ Ci7x120y280 ] %dist% mm dp0 dt [ g0: %zwz%g1:%wr1%g2:%-wr2%g3:%-wr3%] if zwz0 then dt [ p - 8 x410y55Ci2Bi0 ] %zwz% W else dt [ p - 8 x410y55Ci3Bi0 ] %zwz% W endif dt [ p - 8 x410y140Ci3Bi0 ] %wr1% W dt [ p - 8 x410y155Ci16Bi0 ] %-wr2% W dt [ p - 8 x410y170Ci5Bi0 ] %-wr3% W endif ; chime every full hour hour = int ( time / 60 ) if chg [ hour ] > 0 then ->mp3track 4 endif > E > R LED Bar Display with WS2812 LED Chain ~ Used to display home's solar power input/output (+-5000 Watts) > D m : array = 0 60 ; defines array for 60 led pixels cnt = 0 val = 0 ind = 0 ; rgb values for grid colr1 = 0x050000 colr2 = 0x050100 colg1 = 0x000300 colg2 = 0x020300 ledbar = 0 blue = 64 pixels = 60 steps = 10 div = 0 tog = 0 max = 5000 min =- 5000 pos = 0 > B div = pixels / steps = #prep ws2812 ( array ) ; ledbar is set from broker > S if ledbar < min then ledbar = min endif if ledbar > max then ledbar = max endif pos = ( ledbar / max ) * ( pixels / 2 ) if ledbar > 0 then pos += ( pixels / 2 ) if pospixels - 1 then pos = pixels endif else pos += ( pixels / 2 ) + 1 if pospixels - 1 then pos = 1 endif endif if pos < 1 or pos > pixels then pos = 1 endif = #prep if ledbar == 0 then array [ pos ]= blue array [ pos-1 ]= blue else array [ pos ]= blue endif ; only used if power is off ; so lets may be used normally if on if pwr [ 1 ]== 0 then ws2812 ( array ) endif ; subroutine for grid #prep for cnt 1 pixels 1 ind += 1 if ind > div then ind = 1 tog ^= 1 endif if cnt <= pixels / 2 then if tog > 0 then val = colr1 else val = colr2 endif else if tog > 0 then val = colg1 else val = colg2 endif endif array [ cnt ]= val next > R Multiple IR Receiver Synchronization ~ Shows how a Magic Home with IR receiver works Synchronizes 2 Magic Home devices by also sending the commands to a second Magic Home via WebSend Script example using if then else ; expand default string length to be able to hold WebSend [xxx.xxx.xxx.xxx] > D 25 istr = \"\" ws = \"WebSend [_IP_]\" ; event section > E ; get ir data istr = IrReceived#Data ; on if istr == \"0x00F7C03F\" then -> wakeup ->% ws % wakeup endif ; off if istr == \"0x00F740BF\" then -> power1 0 ->% ws % power1 0 endif ; white if istr == \"0x00F7E01F\" then -> color 000000 ff ->% ws % color 000000 ff endif ; red if istr == \"0x00F720DF\" then -> color ff000000 ->% ws % color ff000000 endif ; green if istr == \"0x00F7A05F\" then -> color 00 ff0000 ->% ws % color 00 ff0000 endif ; blue if istr == \"0x00F7609F\" then -> color 0000 ff00 ->% ws % color 0000 ff00 endif ; dimmer up if istr == \"0x00F700FF\" then -> dimmer + ->% ws % dimmer + endif ; dimmer down if istr == \"0x00F7807F\" then -> dimmer - ->% ws % dimmer - endif istr = \"\" Script example using switch case ends ; expand default string length to be able to hold WebSend [xxx.xxx.xxx.xxx] > D 25 istr = \"\" ws = \"WebSend [_IP_]\" ; event section > E ; get ir data istr = IrReceived#Data switch istr ; on case \"0x00F7C03F\" -> wakeup ->% ws % wakeup ; off case \"0x00F740BF\" -> power1 0 ->% ws % power1 0 ; white case \"0x00F7E01F\" -> color 000000 ff ->% ws % color 000000 ff ; red case \"0x00F720DF\" -> color ff000000 ->% ws % color ff000000 ; green case \"0x00F7A05F\" -> color 00 ff0000 ->% ws % color 00 ff0000 ; blue case \"0x00F7609F\" -> color 0000 ff00 ->% ws % color 0000 ff00 ; dimmer up case \"0x00F700FF\" -> dimmer + ->% ws % dimmer + ; dimmer down case \"0x00F7807F\" -> dimmer - ->% ws % dimmer - ends istr = \"\" Fast Polling ~ ; expand default string length to be able to hold ` WebSend [ xxx.xxx.xxx.xxx ] ` > D 25 sw = 0 ws = \"WebSend [_IP_]\" timer = 0 hold = 0 toggle = 0 > B ; gpio 5 button input spinm ( 5 , 0 ) ; fast section 100 ms > F sw = pin [ 5 ] ; 100 ms timer timer += 1 ; 3 seconds long press ; below 0 , 5 short press if sw == 0 and timer5 and timer < 30 then ; short press ; => print short press toggle ^= 1 =>% ws % power1 % toggle % endif if sw > 0 then ; pressed if timer > 30 then ; hold hold = 1 ; => print hold =% timer % if toggle > 0 then =>% ws % dimmer + else =>% ws % dimmer - endif endif else timer = 0 hold = 0 endif Web UI ~ An example to show how to implement a web UI. This example controls a light via WebSend > D dimmer = 0 sw = 0 color = \"\" col1 = \"\" red = 0 green = 0 blue = 0 ww = 0 > F color = hn ( red ) + hn ( green ) + hn ( blue ) + hn ( ww ) if color != col1 then col1 = color => websend [ 192.168.178.75 ] color % color % endif if chg [ dimmer ]> 0 then => websend [ 192.168.178.75 ] dimmer % dimmer % endif if chg [ sw ]> 0 then => websend [ 192.168.178.75 ] power1 % sw % endif > W bu ( sw \"Light on\" \"Light off\" ) ck ( sw \"Light on/off \" ) sl ( 0 100 dimmer \"0\" \"Dimmer\" \"100\" ) sl ( 0 255 red \"0\" \"red\" \"255\" ) sl ( 0 255 green \"0\" \"green\" \"255\" ) sl ( 0 255 blue \"0\" \"blue\" \"255\" ) sl ( 0 255 ww \"0\" \"warm white\" \"255\" ) tx ( color \"color: \" ) Hue Emulation ~ An example to show how to respond to Alexa requests via Hue Emulation When Alexa sends on/off, dimmer, and color (via hsb), send commands to a MagicHome device > D pwr1 = 0 hue1 = 0 sat1 = 0 bri1 = 0 tmp = 0 > E if upd [ hue1 ]> 0 or upd [ sat1 ]> 0 or upd [ bri1 ]> 0 then tmp = hue1 / 182 -> websend [ 192.168.178.84 ] hsbcolor % tmp % , % sat1 % , % bri1 % endif if upd [ pwr1 ]> 0 then -> websend [ 192.168.178.84 ] power1 % pwr1 % endif > H ; on , hue , sat , bri , ct livingroom , E , on = pwr1 , hue = hue1 , sat = sat1 , bri = bri1 Alexa Controlled MCP230xx I 2 C GPIO Expander ~ Uses Tasmota's Hue Emulation capabilities for Alexa interface ; define vars > D p : p1 = 0 p : p2 = 0 p : p3 = 0 p : p4 = 0 ; init ports > B -> sensor29 0 , 5 , 0 -> sensor29 1 , 5 , 0 -> sensor29 2 , 5 , 0 -> sensor29 3 , 5 , 0 -> sensor29 0 , % 0 p1 % -> sensor29 1 , % 0 p2 % -> sensor29 2 , % 0 p3 % -> sensor29 3 , % 0 p4 % ; define Alexa virtual devices > H port1 , S , on = p1 port2 , S , on = p2 port3 , S , on = p3 port4 , S , on = p4 ; handle events > E print EVENT if upd [ p1 ]> 0 then -> sensor29 0 , % 0 p1 % endif if upd [ p2 ]> 0 then -> sensor29 1 , % 0 p2 % endif if upd [ p3 ]> 0 then -> sensor29 2 , % 0 p3 % endif if upd [ p4 ]> 0 then -> sensor29 3 , % 0 p4 % endif = #pub ; publish routine #pub => publish stat /% topic %/ RESULT { \"MCP23XX\" :{ \"p1\" : % 0 p1 % , \"p2\" : % 0 p2 % , \"p3\" : % 0 p3 % , \"p4\" : % 0 p4 % }} svars ; web interface > W bu ( p1 \"p1 on\" \"p1 off\" ) bu ( p2 \"p2 on\" \"p2 off\" ) bu ( p3 \"p3 on\" \"p3 off\" ) bu ( p4 \"p4 on\" \"p4 off\" ) Retrieve network gateway IP Address ~ > D gw = \"\" ; Request Status information . The response will trigger the `U` section > B +> status 5 ; Read the status JSON payload > U gw = StatusNET #Gateway print % gw % Send e-mail ~ > D 25 day1 = 0 et = 0 to = \"<mrx@gmail.com>\" > T et = ENERGY#Total > S ; send at midnight day1 = day if chg [ day1 ]> 0 then => sendmail [ *:*:*:*:*:%to%:energy report ]* endif > m email report at % tstamp % your power consumption today was % et % KWh # Switching and Dimming By Recognizing Mains Power Frequency ~ Switching in Tasmota is usually done by High/Low (+3.3V/GND) changes on a GPIO. However, for devices like the Moes QS-WiFi-D01 Dimmer , this is achieved by a pulse frequency when connected to the GPIO, and these pulses are captured by Counter1 in Tasmota. When the light is OFF and there is a short period of pulses - then turn the light ON at the previous dimmer level. When the light is ON and there is a short period of pulses - then turn the light OFF . When there is a longer period of pulses (i.e., HOLD ) - toggle dimming direction and then adjust the brightness level as long as the button is pressed or until the limits are reached. Issue 6085 In the Data Section D at the beginning of the Script the following initialization variables may be changed: dim multiplier = 0..2.55 set the dimming increment value dim lower limit = range for the dimmer value for push-button operation (set according to your bulb); min 0 dim upper limit = range for the dimmer value for push-button operation (set according to your bulb); max 100 start dim level = initial dimmer level after power-up or restart; max 100 > D sw = 0 tmp = 0 cnt = 0 tmr = 0 hold = 0 powert = 0 slider = 0 dim = \"\" shortprl = 2 ; short press lo limit shortpru = 10 ; short press up limit dimdir = 0 ; dim direction 0 / 1 dimstp = 2 ; dim step / speed 1 to 5 dimmlp = 2.2 ; dim multiplier dimll = 15 ; dim lower limit dimul = 95 ; dim upper limit dimval = 70 ; start dim level > B => print \"WiFi-Dimmer-Script-v0.2\" => Counter1 0 => Baudrate 9600 ; boot sequence = #senddim ( dimval ) delay ( 1000 ) = #senddim ( 0 ) > F cnt = pc [ 1 ] if chg [ cnt ]> 0 ; sw pressed then sw = 1 else sw = 0 ; sw not pressed endif ; 100 ms timer tmr += 1 ; short press if sw == 0 and tmr > shortprl and tmr < shortpru then powert ^= 1 ; change light on / off if powert == 1 then = #senddim ( dimval ) else = #senddim ( 0 ) endif endif ; long press if sw > 0 then if hold == 0 then ; change dim direction dimdir ^= 1 endif if tmr > shortpru then hold = 1 if powert > 0 ; dim when on & hold then if dimdir > 0 then ; increase dim level dimval += dimstp if dimval > dimul then ; upper limit dimval = dimul endif = #senddim ( dimval ) else ; decrease dim level dimval -= dimstp if dimval < dimll then ; lower limit dimval = dimll endif = #senddim ( dimval ) endif endif endif else tmr = 0 hold = 0 endif > E slider = Dimmer ; slider change if chg [ slider ]> 0 then ; dim according slider if slider > 0 then dimval = slider = #senddim ( dimval ) else powert = 0 = #senddim ( 0 ) endif endif if pwr [ 1 ]== 1 ; on / off webui then powert = 1 = #senddim ( dimval ) else powert = 0 = #senddim ( 0 ) endif ; subroutine dim #senddim ( tmp ) dim = \"FF55\" + hn ( tmp * dimmlp ) + \"05DC0A\" => SerialSend5 % dim % => Dimmer % tmp % #","title":"Scripting"},{"location":"Scripting-Language/#features","text":"Up to 50 variables (45 numeric and 5 strings - this may be changed by setting a compilation #define directive) Freely definable variable names (all variable names are intentionally case sensitive ) Nested if,then,else up to a level of 8 Math operators + , - , * , / , % , & , | , ^ All operators may be used in the op= form, e.g., += Comparison operators == , != , > , >= , < , <= and , or support Hexadecimal numbers with prefix 0x are supported Strings support + and += operators Support for \\n \\r regular expressions on strings String comparison == , != String size is 19 characters (default). This can be increased or decreased by the optional parameter on the D section definition Script Interpreter Execution is strictly sequential , line by line Evaluation is left to right with optional brackets All numbers are float , e.g., temp=hum*(100/37.5)+temp-(timer*hum%10) No spaces are allowed between math operators Comments start with ; Script buffer size the script language normally shares script buffer with rules buffer which is 1536 chars. with below options script buffer size may be expanded. PVARS is size for permanant vars. Feature ESP8266 ESP32 PVARS remarks fallback 1536 1536 50 compression (default) 2560 2560 50 actual compression rate may vary #define LITTLEFS_SCRIPT_SIZE S S<=4096 S<=16384 1536 ESP8266 must use 4M Flash with SPIFFS section use linker option -Wl,-Teagle.flash.4m2m.ld #define USE_SCRIPT_FATFS -1, #define FAT_SCRIPT_SIZE S S<=4096 S<=16384 1536 ESP8266 must use 4M Flash with SPIFFS section use linker option -Wl,-Teagle.flash.4m2m.ld, ESP32 must use linker file \"esp32_partition_app1572k_ffat983k.csv\"(4M chips) or \"esp32_partition_app1984k_ffat12M.csv\" (16M chips) #define USE_SCRIPT_FATFS CS, #define FAT_SCRIPT_SIZE S S<=4096 S<=16384 1536 requires SPI SD card, CS is chip select pin of SD card #define EEP_SCRIPT_SIZE S, #define USE_EEPROM, #define USE_24C256 S<=4096 S<=8192 1536 only hardware eeprom is usefull, because Flash EEPROM is also used by Tasmota #define EEP_SCRIPT_SIZE S, #define ALT_EEPROM S<=6500 1536 you must use setoption12 1 to disable flash rotation most usefull defintion for larger scripts would be ESP8266: with 1M flash only default compressed mode should be used a special mode can enable up to 6500 chars by defining #define ALT_EEPROM however this has some side effects. the script is deleted on OTA or serial update and has to be installed fresh after update. with 4M Flash best mode would be #define USE_SCRIPT_FATFS -1 with linker file \"eagle.flash.4m2m.ld\" ESP32: with standard linker file #define LITTLEFS_SCRIPT_SIZE 8192 or better: #define USE_SCRIPT_FATFS -1 #define FAT_SCRIPT_SIZE 8192 with linker file \"esp32_partition_app1572k_ffat983k.csv\" Optional external editor you may use a special external editor with syntax highlighting to edit the scripts. (mac and pc) you may use any number of comments and indents to make it better readable. then with cmd r the script is transfered to the ESP and immediately started. (all comments and indents are removed before transfering) see further info and download here Console Commands script <n> : 0 = switch script off; 1 = switch script on script ><cmdline> execute - Can be used to set variables, e.g., script >mintmp=15 - Multiple statements can be specified by separating each with a semicolon, e.g. script >mintmp=15;maxtemp=40 script?<var> queries a script variable var The script itself can't be specified because the size would not fit the MQTT buffers","title":"Features"},{"location":"Scripting-Language/#script-sections","text":"Section descriptors (e.g., >E ) are case sensitive a valid script must start with >D in the first line >D ssize ssize = optional max string size (default=19) define and init variables here, must be the first section, no other code allowed p:vname specifies permanent variables. The number of permanent variables is limited by Tasmota rules space (50 bytes) - numeric variables are 4 bytes; string variables are one byte longer than the length of string t:vname specifies countdown timers, if >0 they are decremented in seconds until zero is reached. see example below i:vname specifies auto increment counters if =0 (in seconds) g:vname specifies global variable which is linked to all global variables with the same defintion on all devices in the homenet. when a variable is updated in one device it is instantly updated in all other devices. if a section >G exists it is executed when a variable is updated from another device (this is done via UDP-multicast, so not always reliable) m:vname specifies a median filter variable with 5 entries (for elimination of outliers) M:vname specifies a moving average filter variable with 8 entries (for smoothing data) (max 5 filters in total m+M) optional another filter length (1..127) can be given after the definition. Filter vars can be accessed also in indexed mode vname[x] (x = 1..N , x = 0 returns current array index pointer, x = -1 returns arry lenght) Using this filter, vars can be used as arrays, #define LARGE_ARRAYS allows for arrays up to 1000 entries array may also be permanent by specifying an extra :p m:p:vname defines a permanent array. Keep in mind however that in 1M Flash standard configurations you only have 50 bytes permanent storage which stands for a maximum of 12 numbers. (see list above for permanent storage in other configurations) Tip Keep variable names as short as possible. The length of all variable names taken together may not exceed 256 characters. Memory is dynamically allocated as a result of the D section. Copying a string to a number or reverse is supported >B executed on BOOT time before sensors are initialized and on save script >BS executed on BOOT time after sensors are initialized >E Executed when a Tasmota MQTT RESULT message is received, e.g., on POWER change. Also Zigbee reports to this section. >F Executed every 100 ms >S Executed every second >R Executed on restart. p vars are saved automatically after this call >T Executed on TelePeriod time ( SENSOR and STATE ), only put tele- vars in this section Remark: json variable names (like all others) may not contain math operators like - , you should set SetOption64 1 to replace - ( dash ) with _ ( underscore ). Zigbee sensors will not report to this section, use E instead. >H Alexa Hue interface (up to 32 virtual hue devices) ( example ) device , type , onVars Remark: hue values have a range from 0-65535. Divide by 182 to assign HSBcolors hue values. device device name type device type - E = extended color; S = switch onVars assign Hue \"on\" extended color parameters for hue, saturation, brightness, and color temperature (hue,sat,bri,ct) to scripter variables Example lamp1,E,on=pwr1,hue=hue1,sat=sat1,bri=bri1,ct=ct1 >U JSON messages from cmd status arrive here >G global variable updated section >P any power change triggers here >jp https webpage json parse arrives here >ti1 >ti2 >ti3 >ti4 ticker callback after timer expiration >b (note lower case) executed on button state change bt[x] read button state (x = 1.. MAX_KEYS ) Example >D tmp=0 >b tmp=bt[1] if tmp==0 then print falling edge of button1 endif if tmp==1 then print rising edge of button1 endif >J The lines in this section are published via MQTT in a JSON payload on TelePeriod . Requires compiling with #define USE_SCRIPT_JSON_EXPORT . >W The lines in this section are displayed in the web UI main page. Requires compiling with #define USE_SCRIPT_WEB_DISPLAY . You may put any html code here. Variables may be substituted using %var% HTML statements are displayed in the sensor section of the main page HTML statements preceded with a @ are displayed at the top of the page USER IO elements are displayed at the top of the page for next loops are supported to repeat HTML code (precede with % char) %for var from to inc %next script subroutines may be called sub=name of subroutine, like normal subroutines %=#sub in this subroutine a web line may be sent by wcs (see below) thus allowing dynamic HTML pages A web user interface may be generated containing any of the following elements: Button: bu(vn txt1 txt2) (up to 4 buttons may be defined in one row) vn = name of variable to hold button state txt1 = text of ON state of button txt2 = text of OFF state of button Checkbox: ck(vn txt) vn = name of variable to hold checkbox state txt = label text Slider: sl(min max vn ltxt mtxt rtxt) min = slider minimum value max = slider maximum value vn = name of variable to hold slider value ltxt = label left of slider mtxt = label middle of slider rtxt = label right of slider Text Input: tx(vn lbl) vn = name of string variable to hold text state lbl = label text Number Input: nm(min max step vn txt) min = number minimum value max = number maximum value step = number step value for up/down arrows vn = name of number variable to hold number txt = label text Google Charts: draws a google chart with up to 4 data sets per chart gc( T array1 ... array4 \"name\" \"label1\" ... \"label4\" \"entrylabels\" \"header\" {\"maxy1\"} {\"maxy2\"}) T = type - b=barchart - c=columnchart - C=combochart - p=piechart - l=linechart up to 4 lines with same scaling - l2=linechart with exactly 2 lines and 2 y scales (must be given at end) - lf2 like above but with splined lines - h=histogram - t=data table - g=simple gauges (must give extra 3 vars after header, yellow start, red start, maxval) - T=Timeline (special type arrays contains start,stop pairs in minutes timeofday) b,l,h type may have the '2' option to specify exactly 2 arrays with 2 y scales given at the end of paramter list. a very individual chart may be specified by splitting the chart definition and inserting the chart options directly see example below array = up to 4 arrays of data name = name of chart label = label for up to the 4 datasets in chart entrylabel = labels of each x axis entry separated by '|' char (\"cntN\" starts numbering entries with the number N an optional /X generates numbers devided by X) (\"wdh: before a week defintion generates a week with full hours) header = visible header name of chart additionally you have to define the html frame to put the chart in (both lines must be preceded by a $ char) e.g. $<div id=\"chart1\"style=\"width:640px;height:480px;margin:0 auto\"></div> $gc(c array1 array2 \"wr\" \"pwr1\" \"pwr2\" \"mo|di|mi|do|fr|sa|so\" \"Solar feed\") you may define more then one chart. The charts id is chart1 ... chartN very customized chart definition: define a chart like above, but add a t to the definition this generates a google table from the arrays e.g.: &gc(lt array1 array2 \"wr\" \"pwr1\" \"pwr2\" \"mo|di|mi|do|fr|sa|so\") then define the options for the graph as from the doku of google e.g.: $var options = { $vAxes:{0:{maxValue:40,title:'Au\u00dfentemperatur'},1:{maxValue:60,title:'Solarspeicher'}}, $series:{0:{targetAxisIndex:0},1:{targetAxisIndex:1}}, $hAxis: {title: 'Wochenverlauf'}, $}; then gc(e) closes the definition $gc(e) >w ButtonLabel generates a button with the name \"ButtonLabel\" in Tasmota main menu. Clicking this button displays a web page with the HTML data of this section. all cmds like in >W apply here. these lines are refreshed frequently to show e.g. sensor values. lines preceeded by $ are static and not refreshed and display below lines without $. this option also enables a full webserver interface when USE_SCRIPT_FATFS is activ. you may display files from the flash or SD filesystem by specifying the url: IP/sdc/path . (supported files: *.jpg, *.html, *.txt) Requires compiling with #define SCRIPT_FULL_WEBPAGE . >M Smart Meter Interface If a variable does not exist, ??? is displayed for commands If a Tasmota SENSOR or STATUS or RESULT message is not generated or a Var does not exist the destination variable is NOT updated.","title":"Script Sections"},{"location":"Scripting-Language/#special-variables","text":"(read only) upsecs = seconds since start uptime = minutes since start time = minutes since midnight sunrise = sunrise minutes since midnight sunset = sunset minutes since midnight tper = TelePeriod ( may be set also ) tstamp = timestamp (local date and time) topic = mqtt topic gtopic = mqtt group topic lip = local ip as string luip = udp ip as string (from updating device when USE_SCRIPT_GLOBVARS defined) prefixn = prefix n = 1-3 frnm = friendly name pwr[x] = power state (x = 1..N) pc[x] = pulse counter value (x = 1..4) tbut[x] = touch screen button state (x = 1..N) sw[x] = switch state (x = 0..N) (Switch1 = sw[0] ) bt[x] = button state (x = 1..N) only valid in section b (if defined USE_BUTTON_EVENT) pin[x] = GPIO pin level (x = 0..16) pn[x] = GPIO for sensor code x. 99 if none pd[x] = defined sensor for GPIO x. 999 if none pl[path] = plays the mp3 path (ESP32 and if I2S Device defined) say[svar] = text to speach (if I2S Device defined) adc(fac (pin)) = get adc value (on ESP32 can select pin) fac is number of averaged samples (power of 2: 0..7) sht[x] = shutter position (x = 1..N) (if defined USE_SHUTTER) gtmp = global temperature ghum = global humidity gprs = global pressure pow(x y) = calculates exponential powers x^y med(n x) = calculates a 5 value median filter of x (2 filters possible n=0,1) int(x) = gets the integer part of x (like floor) hn(x) = converts x (0..255) to a hex nibble string hx(x) = converts x (0..65535) to a hex string hd(\"hstr\") = converts hex number string to a decimal number st(svar c n) = string token - retrieve the n th element of svar delimited by c sl(svar) = gets the length of a string asc(svar) = gets the binary value of 1. char of a string sb(svar p n) = gets a substring from svar at position p (if p<0 counts from end) and length n is(num \"string1|string2|....|stringn|\") = defines a string array optionally preset with immediate strings separated by '|' (this immediate string may be up to 255 chars long) num = 0 read only string array, num > 0 number of elements in read write string array is[index] = gets string index from string array, if read-write also write string of index is1(..) , is2(...) string array see above is1[x] , is2[x] string array see above sin(x) = calculates the sinus(x) (if defined USE_ANGLE_FUNC) acos(x) = calculates the acos(x) (if defined USE_ANGLE_FUNC) sqrt(x) = calculates the sqrt(x) (if defined USE_ANGLE_FUNC) abs(x) = calculates the absolute value of x mpt(x) = measure pulse time, x>=0 defines pin to use, -1 returns low pulse time,-2 return high pulse time (if defined USE_ANGLE_FUNC) rnd(x) = return a random number between 0 and x, (seed may be set by rnd(-x)) sf(F) = sets the CPU Frequency (ESP32) to 80,160,240 Mhz, returns current Freq. s(x) = explicit conversion from number x to string mqtts = MQTT connection status: 0 = disconnected, >0 = connected wbut = button status of watch side button (if defined USE_TTGO_WATCH) wdclk = double tapped on display (if defined USE_TTGO_WATCH) wtch(sel) = gets state from touch panel sel=0 => touched, sel=1 => x position, sel=2 => y position (if defined USE_TTGO_WATCH) slp(time) = sleep time in seconds, pos values => light sleep, neg values => deep sleep (if defined USE_TTGO_WATCH) play(path) = play mp3 audio from filesystem (if defined USE_I2S_AUDIO or USE_TTGO_WATCH or USE_M5STACK_CORE2) say(\"text\") = plays specified text to speech (if defined USE_I2S_AUDIO or USE_TTGO_WATCH or USE_M5STACK_CORE2) c2ps(sel val) = gets, sets values on ESP32 CORE2 sel=0 green led, sel=1 vibration motor, sel=2,3,4 get touch button state 1,2,3 (if defined USE_M5STACK_CORE2) rec(path seconds) = rec n seconds wav audio file from i2s microphone to filesystem path (if defined USE_I2S_AUDIO or USE_M5STACK_CORE2) pwmN(-pin freq) = defines a pwm channel N (1..N) with pin Nr and frequency (pin 0 beeing -64, N=5 with esp8266 and N=8 with esp32) pwmN(val) = outputs a pwm signal on channel N (1..N) with val (0-1023) wifis = Wi-Fi connection status: 0 = disconnected, >0 = connected wcs = send this line to webpage (WebContentSend) wm = contains source of web request code e.g. 0 = Sensor display (FUNC_WEB_SENSOR) sml(m 0 bd) = set SML baudrate of Meter m to bd (baud) sml(m 1 htxt) = send SML Hexstring htxt as binary to Meter m (if defined USE_SML_SCRIPT_CMD) sml(m 2) = reads serial data received by Meter m into string (if m<0 reads hex values, else asci values)(if defined USE_SML_SCRIPT_CMD) sml[n] = get value of SML energy register n (if defined USE_SML_SCRIPT_CMD) enrg[n] = get value of energy register n 0=total, 1..3 voltage of phase 1..3, 4..6 current of phase 1..3, 7..9 power of phase 1..3 (if defined USE_ENERGY_SENSOR) gjp(\"host\" \"path\") = trigger HTTPS JSON page read as used by Tesla Powerwall (if defined SCRIPT_GET_HTTPS_JP) tsN(ms) = set up to 4 timers (N=1..4) to millisecond time on expiration triggers section >tiN (if defined USE_SCRIPT_TIMER) hours = hours mins = mins secs = seconds day = day of month wday = day of week (Sunday=1,Monday=2;Tuesday=3;Wednesday=4,Thursday=5,Friday=6,Saturday=7) month = month year = year epoch = epoch time (from 2019-1-1 00:00) eres = result of >E section set this var to 1 in section >E to tell Tasmota event is handled (prevents MQTT) The following variables are cleared after reading true: chg[var] = true if a variables value was changed (numeric vars only) upd[var] = true if a variable was updated boot = true on BOOT tinit = true on time init tset = true on time set mqttc = true on mqtt connect mqttd = true on mqtt disconnect wific = true on wifi connect wifid = true on wifi disconnect System variables (for debugging) stack = stack size heap = free heap size pheap = PSRAM free heap size (ESP32) core = current core (0 or 1) (ESP32) ram = used ram size slen = script length freq = cpu frequency micros = running microseconds millis = running milliseconds loglvl = loglevel of script cmds ( may be set also ) Remarks: If you define a variable with the same name as a special variable that special variable is discarded","title":"Special Variables"},{"location":"Scripting-Language/#commands","text":"=> <command> Execute recursion disabled +> <command> Execute recursion enabled -> <command> Execute - do not send MQTT or log messages (i.e., silent execute - useful to reduce traffic) Variable Substitution - A single percent sign must be given as %% - Variable replacement within commands is allowed using %varname% . Optionally, the decimal places precision for numeric values may be specified by placing a digit ( %Nvarname% , N = 0..9 ) in front of the substitution variable (e.g., Humidity: %3hum%%% will output Humidity: 43.271% ) - instead of variables arbitrary calculations my be inserted by bracketing %N(formula)% - Linefeed and carriage return may be defined by \\n and \\r Special commands: print or =>print prints to the log for debugging A Tasmota MQTT RESULT message invokes the script's E section. Add print statements to debug a script. Example >E slider=Dimmer power=POWER if upd [ slider ]> 0 then print slider updated % slider % endif if upd [ power ]> 0 then print power updated % power % endif break exits a section or terminates a for next loop dpx sets decimal precision to x (0-9) svars save permanent vars delay(x) pauses x milliseconds (should be as short as possible) beep(f l) (ESP32) beeps with a passive piezo beeper. beep(-f 0) attaches PIN f to the beeper, beep(f l) starts a sound with frequency f (Hz) and len l (ms). f=0 stops the sound. spin(x b) set GPIO x (0..16) to value b (0,1). Only bit 0 of b is used - even values set the GPIO to 0 and uneven values set the GPIO to 1 spinm(x m) set GPIO x (0..16) to mode m (input=0, output=1, input with pullup=2,alternatively b may be: O=out, I=in, P=in with pullup) ws2812(array dstoffset) copies an array (defined with m:vname ) to the WS2812 LED chain. The array length should be defined as long as the number of pixels. Color is coded as 24 bit RGB. optionally the destinationoffset in the LED chain may be given hsvrgb(h s v) converts hue (0..360), saturation (0..100) and value (0..100) to RGB color dt display text command (if #define USE_DISPLAY) #name names a subroutine. Subroutine is called with =#name #name(param) names a subroutine with a parameter. Subroutine is called with =#name(param) Subroutines end with the next # or > line or break. Subroutines may be nested Parameters can be numbers or strings and on type mismatch are converted If #define USE_SCRIPT_SUB_COMMAND is included in your user_config_override.h , a subroutine may be invoked via the Console or MQTT using the subroutine's name. For example, a declared subroutine #SETLED(num) may be invoked by typing SETLED 1 in the Console. The parameter 1 is passed into the num argument. This also works with string parameters. since Tasmota capitalizes all commands you must use upper case labels. It is possible to \"replace\" internal Tasmota commands. For example, if a #POWER1(num) subroutine is declared, the command POWER1 is processed in the scripter instead of in the main Tasmota code. =(svar) executes a routine whose name is passed as a string in a variable (dynamic or self modifying code). The string has to start with > or =# for the routine to be executed. D svar = \"=#subroutine\" S = ( svar ) #subroutine => print subroutine was executed For loop (loop count must not be less than 1, no direct nesting supported) for var < from > < to > < inc > next Switch selector (numeric or string) switch x case a case b ends Conditional Statements There are two syntax alternatives. You may NOT mix both formats. if a==b and x==y or k==i then = do this else = do that endif or if a==b and x==y or k==i { = do this } else { = do that } Remarks: The last closing bracket must be on a separate line Calculations are permitted in conditional expressions, e.g., if var1 - var2 == var3 * var4 Conditional expressions may be enclosed in parentheses. The statement must be on a single line. e.g., if ((a==b) and ((c==d) or (c==e)) and (s!=\"x\")) mapping function mp(x str1 str2 ... str ) It addresses a standard task with less code and much flexibility: mapping an arbitrary incoming numeric value into the allowed range. The numeric value x passed as the first parameter is compared to the rules in the order they are provided as subsequent sting parameters. If the value matches the criteria, the defined value is returned. Subsequent rules are skipped. If x matches none of the rules, x is returned unchanged. Rules consist of one of the comparison operators < > = followed by a numeric value v1, optionally followed by a colon and another numeric value v2. <|>|= v1 [: v2 ] Example 1 : \"<8:0\" - this rule reads : If x is less than 8 , return 0 . Example 2 : \">100\" - this rule reads : If x is greater than 100 , return 100 . Example 3 : y = mp ( x \"<8:0\" \">100\" ) Assigns 0 to y if x is less than 8 . Assigns 100 to y if x is greater than 100 . Assigns x to y for all values of x that do not meet the above criteria ( 8 to 100 ). The above code of example 3 does the same as the following code - with just one line of code and 15 characters less : y = x if x < 8 { y = 0 } if x > 100 { y = 100 } E-mail #define USE_SENDMAIL Enabling this feature also enables Tasmota TLS as sendmail uses SSL. sendmail [server:port:user:passwd:from:to:subject] msg Example sendmail [smtp.gmail.com:465:user:passwd:sender@gmail.com:<rec@gmail.com:alarm] %string% Remark: A number of e-mail servers (such as Gmail) require the receiver's e-mail address to be enclosed by < ... as in example above. Most other e-mail servers also accept this format. While ESP8266 sendmail needs brackets, ESP32 sendmail inserts brackets itself so you should not specify brackets here. The following parameters can be specified during compilation via #define directives in user_config_override.h : * EMAIL_SERVER * EMAIL_PORT * EMAIL_USER * EMAIL_PASSWORD * EMAIL_FROM To use any of these values, pass an * as its corresponding argument placeholder. sendmail [*:*:*:*:*:<rec@gmail.com:theSubject] theMessage Instead of passing the msg as a string constant, the body of the e-mail message may also be composed using the script m (note lower case) section. The specified text in this script section must end with an # character. sendmail will use the m section if * is passed as the msg parameter. in this >m section you may also specify email attachments. @/filename specifies a file to be attached (if file system is present) &arrayname specifies an array attachment (as tab delimeted text, no file system needed) See [Scripting Cookbook Example].(#send-e-mail) Subscribe, Unsubscribe #define SUPPORT_MQTT_EVENT subscribe and unsubscribe commands are supported. In contrast to rules, no event is generated but the event name specifies a variable defined in D section and this variable is automatically set on transmission of the subscribed item within a script the subscribe cmd must be send with +> instead of => the MQTT decoder may be configured for more space in user config overwrite by #define MQTT_EVENT_MSIZE xxx (default is 256) #define MQTT_EVENT_JSIZE xxx (default is 400) SD Card Support (+ 10k flash) #define USE_SCRIPT_FATFS CARD_CS CARD_CS = GPIO of card chip select SD card uses standard hardware SPI GPIO: mosi,miso,sclk with 4M flash on ESP8266 and special linker file you may specify -1 for CS and get a flash file system with the same functionality but but very low capacity (e.g. 2 MB) A maximum of four files may be open at a time e.g., allows for logging sensors to a tab delimited file and then downloading the file ( see Sensor Logging example ) The downloading of files may be executed in a kind of \"multitasking\" when bit 7 of loglvl is set (128+loglevel) Without multitasking 150kb/s (all processes are stopped during downloading), with multitasking 50kb/s (other Tasmota processes are running) The script itself is also stored on the SD card with a default size of 4096 characters SD card directory support (+ 1,2k flash) #define SDCARD_DIR Shows a web SD card directory (submenu of scripter) where you can upload and download files to/from sd card fr=fo(\"fname\" m) open file fname, mode 0=read, 1=write, 2=append (returns file reference (0-3) or -1 for error) (alternatively m may be: r=read, w=write, a=append) res=fw(\"text\" fr) writes text to (the end of) file fr, returns number of bytes written res=fr(svar fr) reads a string into svar, returns bytes read. String is read until delimiter (\\t \\n \\r) or eof fc(fr) close file ff(fr) flush file, writes cached data and updates directory fd(\"fname\") delete file fname flx(fname) create download link for file (x=1 or 2) fname = file name of file to download fsm return 1 if filesystem is mounted, (valid SD card found) res=fsi(sel) gets file system information, sel=0 returns total media size, sel=1 returns free space both in kB fra(array fr) reads array from open file with fr (assumes tab delimeted entries) fwa(array fr) writes array to open file with fr (writes tab delimited entries) Extended commands (+0,9k flash) #define USE_SCRIPT_FATFS_EXT fmd(\"fname\") make directory fname frd(\"fname\") remove directory fname fx(\"fname\") check if file fname exists fe(\"fname\") execute script fname (max 2048 bytes, script must start with the '>' character on the first line) ESP32 real Multitasking support #define USE_SCRIPT_TASK enables support for multitasking scripts res=ct(num timer core) creates a task num (1 or 2) which is executed every timer (ms) time on core 0 or 1 the sections are named >t1 for task 1 >t2 for task 2 Example > D > B ; create task 1 every 1000 ms on core 0 ct ( 1 1000 0 ) ; create task 2 every 3000 ms on core 1 ct ( 2 3000 1 ) > t1 print task1 on core % core % > t2 print task2 on core % core % Script compression #define USE_SCRIPT_COMPRESSION enables compression of script storage to about 40%. The script buffer is set to 2560 instead of 1535 chars. no backward compatibility. first save your old script before updating. ESP32 Webcam support #define USE_WEBCAM Template for AI THINKER CAM : {\"NAME\":\"AITHINKER CAM No SPI\",\"GPIO\":[4992,65504,65504,65504,65504,5088,65504,65504,65504,65504,65504,65504,65504,65504,5089,5090,0,5091,5184,5152,0,5120,5024,5056,0,0,0,0,4928,65504,5094,5095,5092,0,0,5093],\"FLAG\":0,\"BASE\":1} remarks: - GPIO0 zero must be disconnected from any wire after programming because this pin drives the cam clock and does not tolerate any capictive load - Only boards with PSRAM should be used. To enable PSRAM board should be se set to esp32cam in common32 of platform_override.ini board = esp32cam - To speed up cam processing cpu frequency should be better set to 240Mhz in common32 of platform_override.ini board_build.f_cpu = 240000000L file system extension: fwp(pnum fr) write picture from RAM buffer number pnum to sdcard file with file reference fr specific webcam commands: res=wc(sel p1 p2) controll webcam, sel = function selector p1 ... optional parameters res=wc(0 pres) init webcam with picture resolution pres, returns 0 when error, 2 when PSRAM found, else 1 pres * 0 = FRAMESIZE_QQVGA, // 160x120 * 1 = FRAMESIZE_QQVGA2, // 128x160 * 2 = FRAMESIZE_QCIF, // 176x144 * 3 = FRAMESIZE_HQVGA, // 240x176 * 4 = FRAMESIZE_QVGA, // 320x240 * 5 = FRAMESIZE_CIF, // 400x296 * 6 = FRAMESIZE_VGA, // 640x480 * 7 = FRAMESIZE_SVGA, // 800x600 * 8 = FRAMESIZE_XGA, // 1024x768 * 9 = FRAMESIZE_SXGA, // 1280x1024 * 10 = FRAMESIZE_UXGA, // 1600x1200 res=wc(1 bnum) capture picture to rambuffer bnum (1..4), returns framesize of picture or 0 when error res=wc(2 sel p1) execute various controls, details below. res=wc(3) gets picture width res=wc(4) gets picture height res=wc(5 p) start stop streaming 0=stop, 1=start res=wc(6 p) start stop motion detector, p=0 => stop detector, p=T start detector with picture every T ms, -1 get picture difference, -2 get picture brightness res=wc(7 p) start stop face detector, p=0 => stop detector, p=T start detector with picture every T ms, -1 get number of faces found in picture (USE_FACE_DETECT must be defined) control cmds sel = * 0 fs = set frame size (see above for constants) * 1 se = set special effect 0 = no effect 1 = negative 2 = black and white 3 = reddish 4 = greenish 5 = blue 6 = retro 2 fl = set horizontal flip 0,1 3 mi = set vertical mirror 0,1 to read a value without setting pass -1 extensions to the email system on ESP32 #define SEND_EMAIL and #define USE_ESP32MAIL enables specific ESP32 mail server this server can handle more mail servers by supporting START_TLS remark: mail adresses must not be enclosed with <> because the server inserts them automatically this server also supports email attachments in the >m section you may write &/file.txt to attach a file from SD card $N N=1..4 to attach a picture from picture RAM buffer number N displaying webcam pictures in WEBUI you may display a webcam picture by giving the name /wc.jpg?p=N (1..4) for RAM picturebuffer N \"<img src=\"/wc.jpg?p=1\" alt=\"webcam image\" >\" you may also provide the picture size (h and v have to be preset before) \"<img src=\"/wc.jpg?p=1\" alt=\"webcam image\" style=\"width:%w%px;height:%h%px;\">\" if you precede the line by & char the image is diplayed in the main section, else in the sensor tab section the webcam stream can be specified by the following line lip is a system variable containing the local device ip \"&<br>\" \"&<img src=\"http://%lip%:81/stream\" style=\"width:%w%px;height:%h%px\">\" \"&<br><center>webcam stream\" remark: the Flash illumination LED is connected to GPIO4 Example > D res = 0 w = 0 h = 0 mot = 0 bri = 0 > B ; init cam with QVGA res = wc ( 0 4 ) ; get pixel size w = wc ( 3 ) h = wc ( 4 ) ; start motion detector , picture every 1000 ms mot = wc ( 6 1000 ) > S if wific > 0 then ; when wifi up , start stream res = wc ( 5 1 ) endif ; get motion detect diff value mot = wc ( 6 -1 ) ; get picture brightnes bri = wc ( 6 -2 ) > W < center > motion diff = % mot %< br > < center > brightness = % bri %< br > ; show stream on WEBUI &< br > &< img src = \"http://%lip%:81/stream\" style = \"width:%w%px;height:%h%px\" > &< br >< center > webcam stream","title":"Commands"},{"location":"Scripting-Language/#scripting-cookbook","text":"","title":"Scripting Cookbook"},{"location":"Scripting-Language/#scripting-language-example","text":"a valid script must start with > D in the first line ! some samples still contain comment lines before > D . This is no longer valid ! ** Actually this code is too large ** . This is only meant to show some of the possibilities > D ; define all vars here p : mintmp = 10 ( p : means permanent ) p : maxtmp = 30 t : timer1 = 30 ( t : means countdown timer ) t : mt = 0 i : count = 0 ( i : means auto counter ) hello = \"hello world\" string = \"xxx\" url = \"[_IP_]\" ; hum = 0 temp = 0 zigbeetemp = 0 timer = 0 dimmer = 0 sw = 0 rssi = 0 param = 0 col = \"\" ocol = \"\" chan1 = 0 chan2 = 0 chan3 = 0 ahum = 0 atemp = 0 tcnt = 0 hour = 0 state = 1 m : med5 = 0 M : movav = 0 ; define array with 10 entries m : array = 0 10 > B string = hello + \"how are you?\" => print BOOT executed => print % hello % => mp3track 1 ; list gpio pin definitions for cnt 0 16 1 tmp = pd [ cnt ] => print % cnt % = % tmp % next ; get gpio pin for relais 1 tmp = pn [ 21 ] => print relais 1 is on pin % tmp % ; pulse relais over raw gpio spin ( tmp 1 ) delay ( 100 ) spin ( tmp 0 ) ; raw pin level => print level of gpio1 % pin [ 1 ]% ; pulse over tasmota cmd => power 1 delay ( 100 ) = power 0 > T hum = BME280#Humidity temp = BME280#Temperature rssi = Wifi#RSSI string = SleepMode ; add to median filter median = temp ; add to moving average filter movav = hum ; show filtered results => print % median % % movav % if chg [ rssi ]> 0 then => print rssi changed to % rssi % endif if temp > 30 and hum > 70 then => print damn hot ! endif = #siren ( 5 ) ; loop nesting workaround ; by using subroutine #siren ( num ) for cnt 1 num 1 = #stone next #stone for tone 2000 1000 - 20 beep ( tone 10 ); delay ( 12 ) next > S ; every second but not completely reliable time here ; use upsecs and uptime or best t : for reliable timers ; arrays array [ 1 ]= 4 array [ 2 ]= 5 tmp = array [ 1 ]+ array [ 2 ] ; call subrountines with parameters = #sub1 ( \"hallo\" ) = #sub2 ( 999 ) ; stop timer after expired if timer1 == 0 then timer1 =- 1 => print timer1 expired endif ; auto counter with restart if count = 10 then => print 10 seconds over count = 0 endif if upsecs % 5 == 0 then => print % upsecs % ( every 5 seconds ) endif ; not recommended for reliable timers timer += 1 if timer >= 5 then => print 5 seconds over ( may be ) timer = 0 endif dimmer += 1 if dimmer > 100 then dimmer = 0 endif => dimmer % dimmer % => WebSend % url % dimmer % dimmer % ; show on display dp0 dt [ c1l1f1s2p20 ] dimmer =% dimmer % => print % upsecs % % uptime % % time % % sunrise % % sunset % % tstamp % if time > sunset and time < sunrise then ; night time if pwr [ 1 ]== 0 then => power1 1 endif else ; day time if pwr [ 1 ]> 0 then => power1 0 endif endif ; clr display on boot if boot > 0 then dt [ z ] endif ; frost warning if (( temp < 0 or zigbeetemp < 0 ) and mt <= 0 ) then = #sendmail ( \"frost alert\" ) ; alarm only every 5 minutes mt = 300 = mp3track 2 endif ; var has been updated if upd [ hello ]> 0 then => print % hello % endif ; send to Thingspeak every 60 seconds ; average data in between if upsecs % 60 == 0 then ahum >= tcnt atemp >= tcnt = WebSend [ _IP_ ]/ update ? key = _token_ & field1 =% atemp %& field2 =% ahum % tcnt = 0 atemp = 0 ahum = 0 else ahum += hum atemp += temp tcnt += 1 endif hour = int ( time / 60 ) if chg [ hour ]> 0 then ; exactly every hour => print full hour reached endif if time5 { => print more then 5 minutes after midnight } else { = print less then 5 minutes after midnight } ; publish abs hum every teleperiod time if mqtts > 0 and upsecs % tper == 0 then ; calc abs humidity tmp = pow ( 2.718281828 ( 17.67 * temp ) / ( temp + 243.5 )) tmp = ( 6.112 * tmp * hum * 18.01534 ) / (( 273.15 + temp ) * 8.31447215 ) ; publish median filtered value => Publish tele /% topic %/ SENSOR { \"Script\" :{ \"abshum\" : % med ( 0 tmp ) % }} endif ; switch case state machine switch state case 1 => print state =% state % , start state += 1 case 2 => print state =% state % state += 1 case 3 => print state =% state % , reset state = 1 ends ; subroutines #sub1 ( string ) => print sub1 : % string % #sub2 ( param ) => print sub2 : % param % #sendmail ( string ) => sendmail [ smtp.gmail.com:465:user:passwd:<sender@gmail.de:<rec@gmail.de:alarm ] % string % > E => print event executed ! ; Assign temperature from a Zigbee sensor zigbeetemp = ZbReceived#0x2342#Temperature ; get HSBColor 1. component tmp = st ( HSBColor , 1 ) ; check if switch changed state sw = sw [ 1 ] if chg [ sw ]> 0 then => power1 % sw % endif hello = \"event occured\" ; check for Color change ( Color is a string ) col = Color ; color change needs 2 string vars if col != ocol then ocol = col => print color changed % col % endif ; or check change of color channels chan1 = Channel [ 1 ] chan2 = Channel [ 2 ] chan3 = Channel [ 3 ] if chg [ chan1 ]> 0 or chg [ chan2 ]> 0 or chg [ chan3 ]> 0 then = color has changed endif ; compose color string for red col = hn ( 255 ) + hn ( 0 ) + hn ( 0 ) = color % col % > R => print restarting now","title":"Scripting Language Example"},{"location":"Scripting-Language/#sensor-logging","text":"; define all vars here ; reserve large strings > D 48 hum = 0 temp = 0 fr = 0 res = 0 ; moving average for 60 seconds M : mhum = 0 60 M : mtemp = 0 60 str = \"\" > B ; set sensor file download link fl1 ( \"slog.txt\" ) ; delete file in case we want to start fresh ; fd ( \"slog.txt\" ) ; list all files in root directory fr = fo ( \"/\" 0 ) for cnt 1 20 1 res = fr ( str fr ) if res > 0 then => print % cnt % : % str % else break endif next fc ( fr ) > T ; get sensor values temp = BME280 #Temperature hum = BME280 #Humidity > S ; average sensor values every second mhum = hum mtemp = temp ; write average to sensor log every minute if upsecs % 60 == 0 then ; open file for write fr = fo ( \"slog.txt\" 1 ) ; compose string for tab delimited file entry str = s ( upsecs ) + \" \\t \" + s ( mhum ) + \" \\t \" + s ( mtemp ) + \" \\n \" ; write string to log file res = fw ( str fr ) ; close file fc ( fr ) endif > R","title":"Sensor Logging"},{"location":"Scripting-Language/#e-paper-29-display-with-sgp30-and-bme280","text":"Some variables are set from ioBroker > D hum = 0 temp = 0 press = 0 ahum = 0 tvoc = 0 eco2 = 0 zwz = 0 wr1 = 0 wr2 = 0 wr3 = 0 otmp = 0 pwl = 0 tmp = 0 ; preset units in case they are not available punit = \"hPa\" tunit = \"C\" > B ; reset auto draw dt [ zD0 ] ; clr display and draw a frame dt [ x0y20h296x0y40h296 ] > T ; get telemetry sensor values temp = BME280#Temperature hum = BME280#Humidity press = BME280#Pressure tvoc = SGP30#TVOC eco2 = SGP30#eCO2 ahum = SGP30#aHumidity tunit = TempUnit punit = PressureUnit > S ; update display every [ `TelePeriod` ] ( Commands . md#teleperiod ) if upsecs % tper == 0 then dp2 dt [ f1p7x0y5 ]% temp % % tunit % dt [ p5x70y5 ]% hum % %%[ x250y5t ] dt [ p11x140y5 ]% press % % punit % dt [ p10x30y25 ] TVOC : % tvoc % ppb dt [ p10x160y25 ] eCO2 : % eco2 % ppm dt [ p10c26l5 ] ahum : % ahum % g ^ m3 dp0 dt [ p25c1l5 ] WR 1 ( Dach ) : % wr1 % W dt [ p25c1l6 ] WR 2 ( Garage ) : %- wr3 % W dt [ p25c1l7 ] WR 3 ( Garten ) : %- wr2 % W dt [ p25c1l8 ] Aussentemperatur : % otmp % C dt [ x170y95r120:30f2p6x185y100 ] % pwl % %% ; now update screen dt [ d ] endif > E > R","title":"e-Paper 29 Display with SGP30 and BME280"},{"location":"Scripting-Language/#e-paper-42-display-with-sht31-and-bme280","text":"This script shows 2 graphs on an 4.2 inch e-Paper display: 1. some local sensors, and 2. power statistics The first graph is the battery level of a solar battery (Tesla PowerWall 2) The second graph shows the solar yield of the roof panels in Watts Another special feature is that this script displays daily and weekly averages (via moving average) of all power IO of the house. it sends an email every sunday night with the weekly data it displays a google bar chart on the webui with values for each weekday of the last week ESP32 CPU with SD card Since the display is a full update panel it is updated only once a minute Some values (like power meters) are set remotely from ioBroker > D hum = 0 temp = 0 press = 0 zwz = 0 wr1 = 0 wr2 = 0 wr3 = 0 otmp = 0 pwl = 0 ez1 = 0 sez1 = 0 M :mez1 = 0 7 ezh = 0 sezh = 0 M :mezh = 0 7 vzh = 0 svzh = 0 M :mvzh = 0 7 wd = 0 res = 0 hr = 0 t1 = 0 res = 0 > B ->setoption64 1 tper = 30 dt [ IzD0 ] dt [ zG10352: 5 : 40 :- 350 : 80 : 10080 : 0 : 100 f3x360y40 ] 100 %%[x360y115]0 %% dt [ f1x100y25 ] Powerwall - 7 Tage [ f1x360y75 ] 0 %% dt [ G10353 : 5 : 140 :- 350 : 80 : 10080 : 0 : 5000 f3x360y140 ] + 5000 W [ x360y215 ] 0 W dt [ f1x70y125 ] Volleinspeisung - 7 Tage [ f1x360y180 ] 0 W dt [ p13x10y230 ] WR 1 , 2 , 3 : dt [ p13x10y245 ] H - Einsp . : dt [ p13x10y260 ] H - Verbr . : dt [ p13x10y275 ] D - Einsp . : dt [ d ] dt [ Gr0 :/g0_sav . txt :] dt [ Gr1 :/g1_sav . txt :] beep ( - 25 0 ) beep ( 1000 100 ) > T press = BMP280 # Pressure temp = SHT3X_0x44 # Temperature hum = SHT3X_0x44 # Humidity > S if upsecs %60==0 then dp2 dt [ f1p7x0y5 ] %temp% C dt [ x0y20h400x250y5T ][ x350t ][ f1p10x70y5 ] %hum% %% dt [ p10x140y5 ] %press% hPa dp0 dt [ p5x360y75 ] %pwl% %% dt [ p6x360y180 ] %wr1%W dt [ g0: %pwl%g1:%wr1%] dt [ p24x75y230 ] %wr1% W : %-wr2% W : %-wr3% W dt [ p - 10 x75y245 ] %ezh% kWh dt [ p - 10 x75y260 ] %vzh% kWh dt [ p - 10 x75y275 ] %ez1% kWh t1 = mezh * 7 dt [ p - 10 x150y245 ] : %t1% kWh t1 = mvzh * 7 dt [ p - 10 x150y260 ] : %t1% kWh t1 = mez1 * 7 dt [ p - 10 x150y275 ] : %t1% kWh dp1 t1 = ezh - sezh dt [ p12x250y245 ] : %t1% kWh t1 = vzh - svzh dt [ p12x250y260 ] : %t1% kWh t1 = ez1 - sez1 dt [ p12x250y275 ] : %t1% kWh dp0 dt [ f2p5x320y250 ] %otmp%C dt [ d ] print updating display endif hr = hours if chg [ hr ] > 0 and hr == 0 then mez1 = ez1 - sez1 sez1 = ez1 mezh = ezh - sezh sezh = ezh mvzh = vzh - svzh svzh = vzh endif if sezh == 0 then sez1 = ez1 sezh = ezh svzh = vzh endif wd = wday if chg [ wd ] > 0 and wd == 1 then =>sendmail [ *:*:*:*:*:user . tasmota@gmail . com : Wochenbericht ] * print sening email endif if upsecs %300==0 then =#savgraf print saving graph endif #savgraf dt [ Gs0 :/g0_sav . txt :] dt [ Gs1 :/g1_sav . txt :] > m Wochenbericht Einspeisung und Verbrauch < br><br > w1= %mez1[1]%,%mez1[2]%,%mez1[3]%,%mez1[4]%,%mez1[5]%,%mez1[6]%,%mez1[7]%,%mez1[8]%<br> w2= %mezh[1]%,%mezh[2]%,%mezh[3]%,%mezh[4]%,%mezh[5]%,%mezh[6]%,%mezh[7]%,%mezh[8]%<br> w3= %mvzh[1]%,%mvzh[2]%,%mvzh[3]%,%mvzh[4]%,%mvzh[5]%,%mvzh[6]%,%mvzh[7]%,%mvzh[8]%<br> # > W &<br>< div id= \"container\" style= \"width:640px;height:480px;margin:0 auto\" ></ div ><br > &<script type= \"text/javascript\" src= \"https://www.gstatic.com/charts/loader.js\" ></script > &<script type= \"text/javascript\" > google . charts . load ( 'current' ,{ packages :[ 'corechart' ]}); </script > &<script language= \"JavaScript\" > function drawChart (){ var data = &google . visualization . arrayToDataTable ([ & [ 'weekday' , 'Power' ],[ 'Mo' , %mvzh[1]%],['Di',%mvzh[2]%],['Mi',%mvzh[3]%],['Do',%mvzh[4]%], & [ 'Fr' , %mvzh[5]%],['Sa',%mvzh[6]%],['So',%mvzh[7]%]]); &var options= { title : 'daily solar feed' , isStacked:true }; &var chart = new &google . visualization . ColumnChart ( document . getElementById ( 'container' )); chart . draw ( data , options );} &google . charts . setOnLoadCallback ( drawChart ); </script > #","title":"e-Paper 42 Display with SHT31 and BME280"},{"location":"Scripting-Language/#ili-9488-color-lcd-display-with-bmp280-and-vl5310x","text":"Shows various BMP280 energy graphs Turn display on and off using VL5310X proximity sensor to prevent burn-in Some variables are set from ioBroker > D temp = 0 press = 0 zwz = 0 wr1 = 0 wr2 = 0 wr3 = 0 otmp = 0 pwl = 0 tmp = 0 dist = 0 punit= \"hPa\" tunit= \"C\" hour = 0 > B dt [ z ] // define 2 graphs , 2. has 3 tracks dt [ zCi1G2656: 5 : 20 : 400 : 80 : 1440 :- 5000 : 5000 : 3 Ci7f3x410y20 ] + 5000 W [ x410y95 ] - 5000 W [ Ci7f1x70y3 ] Zweirichtungsz ~ 80 hler - 24 Stunden dt [ Ci1G2657 : 5 : 120 : 400 : 80 : 1440 : 0 : 5000 : 3 Ci7f3x410y120 ] + 5000 W [ x410y195 ] 0 W [ Ci7f1x70y103 ] Wechselrichter 1 - 3 - 24 Stunden dt [ Ci1G2658 : 5 : 120 : 400 : 80 : 1440 : 0 : 5000 : 16 ][ Ci1G2659 : 5 : 120 : 400 : 80 : 1440 : 0 : 5000 : 5 ] dt [ f1s1b0: 260 : 260 : 100 &# 8203 ; : 50 : 2 : 11 : 4 : 2 : Rel 1 :b1: 370 : 260 : 100 &# 8203 ; : 50 : 2 : 11 : 4 : 2 : Dsp off :] =>mp3volume 100 =>mp3track 4 > T ; get some telemetry values temp = BMP280 # Temperature press = BMP280 # Pressure tunit = TempUnit punit = PressureUnit dist = VL53L0X # Distance ; check proximity sensor to turn display on and off to prevent burn - in if dist > 300 then if pwr [ 2 ] > 0 then =>power2 0 endif else if pwr [ 2 ] == 0 then =>power2 1 endif endif > S ; update graph every teleperiod if upsecs %tper==0 then dp2 dt [ f1Ci3x40y260w30Ci1 ] dt [ Ci7x120y220t ] dt [ Ci7x180y220T ] dt [ Ci7p8x120y240 ] %temp% %tunit% dt [ Ci7x120y260 ] %press% %punit% dt [ Ci7x120y280 ] %dist% mm dp0 dt [ g0: %zwz%g1:%wr1%g2:%-wr2%g3:%-wr3%] if zwz0 then dt [ p - 8 x410y55Ci2Bi0 ] %zwz% W else dt [ p - 8 x410y55Ci3Bi0 ] %zwz% W endif dt [ p - 8 x410y140Ci3Bi0 ] %wr1% W dt [ p - 8 x410y155Ci16Bi0 ] %-wr2% W dt [ p - 8 x410y170Ci5Bi0 ] %-wr3% W endif ; chime every full hour hour = int ( time / 60 ) if chg [ hour ] > 0 then ->mp3track 4 endif > E > R","title":"ILI 9488 Color LCD Display with BMP280 and VL5310X"},{"location":"Scripting-Language/#led-bar-display-with-ws2812-led-chain","text":"Used to display home's solar power input/output (+-5000 Watts) > D m : array = 0 60 ; defines array for 60 led pixels cnt = 0 val = 0 ind = 0 ; rgb values for grid colr1 = 0x050000 colr2 = 0x050100 colg1 = 0x000300 colg2 = 0x020300 ledbar = 0 blue = 64 pixels = 60 steps = 10 div = 0 tog = 0 max = 5000 min =- 5000 pos = 0 > B div = pixels / steps = #prep ws2812 ( array ) ; ledbar is set from broker > S if ledbar < min then ledbar = min endif if ledbar > max then ledbar = max endif pos = ( ledbar / max ) * ( pixels / 2 ) if ledbar > 0 then pos += ( pixels / 2 ) if pospixels - 1 then pos = pixels endif else pos += ( pixels / 2 ) + 1 if pospixels - 1 then pos = 1 endif endif if pos < 1 or pos > pixels then pos = 1 endif = #prep if ledbar == 0 then array [ pos ]= blue array [ pos-1 ]= blue else array [ pos ]= blue endif ; only used if power is off ; so lets may be used normally if on if pwr [ 1 ]== 0 then ws2812 ( array ) endif ; subroutine for grid #prep for cnt 1 pixels 1 ind += 1 if ind > div then ind = 1 tog ^= 1 endif if cnt <= pixels / 2 then if tog > 0 then val = colr1 else val = colr2 endif else if tog > 0 then val = colg1 else val = colg2 endif endif array [ cnt ]= val next > R","title":"LED Bar Display with WS2812 LED Chain"},{"location":"Scripting-Language/#multiple-ir-receiver-synchronization","text":"Shows how a Magic Home with IR receiver works Synchronizes 2 Magic Home devices by also sending the commands to a second Magic Home via WebSend Script example using if then else ; expand default string length to be able to hold WebSend [xxx.xxx.xxx.xxx] > D 25 istr = \"\" ws = \"WebSend [_IP_]\" ; event section > E ; get ir data istr = IrReceived#Data ; on if istr == \"0x00F7C03F\" then -> wakeup ->% ws % wakeup endif ; off if istr == \"0x00F740BF\" then -> power1 0 ->% ws % power1 0 endif ; white if istr == \"0x00F7E01F\" then -> color 000000 ff ->% ws % color 000000 ff endif ; red if istr == \"0x00F720DF\" then -> color ff000000 ->% ws % color ff000000 endif ; green if istr == \"0x00F7A05F\" then -> color 00 ff0000 ->% ws % color 00 ff0000 endif ; blue if istr == \"0x00F7609F\" then -> color 0000 ff00 ->% ws % color 0000 ff00 endif ; dimmer up if istr == \"0x00F700FF\" then -> dimmer + ->% ws % dimmer + endif ; dimmer down if istr == \"0x00F7807F\" then -> dimmer - ->% ws % dimmer - endif istr = \"\" Script example using switch case ends ; expand default string length to be able to hold WebSend [xxx.xxx.xxx.xxx] > D 25 istr = \"\" ws = \"WebSend [_IP_]\" ; event section > E ; get ir data istr = IrReceived#Data switch istr ; on case \"0x00F7C03F\" -> wakeup ->% ws % wakeup ; off case \"0x00F740BF\" -> power1 0 ->% ws % power1 0 ; white case \"0x00F7E01F\" -> color 000000 ff ->% ws % color 000000 ff ; red case \"0x00F720DF\" -> color ff000000 ->% ws % color ff000000 ; green case \"0x00F7A05F\" -> color 00 ff0000 ->% ws % color 00 ff0000 ; blue case \"0x00F7609F\" -> color 0000 ff00 ->% ws % color 0000 ff00 ; dimmer up case \"0x00F700FF\" -> dimmer + ->% ws % dimmer + ; dimmer down case \"0x00F7807F\" -> dimmer - ->% ws % dimmer - ends istr = \"\"","title":"Multiple IR Receiver Synchronization"},{"location":"Scripting-Language/#fast-polling","text":"; expand default string length to be able to hold ` WebSend [ xxx.xxx.xxx.xxx ] ` > D 25 sw = 0 ws = \"WebSend [_IP_]\" timer = 0 hold = 0 toggle = 0 > B ; gpio 5 button input spinm ( 5 , 0 ) ; fast section 100 ms > F sw = pin [ 5 ] ; 100 ms timer timer += 1 ; 3 seconds long press ; below 0 , 5 short press if sw == 0 and timer5 and timer < 30 then ; short press ; => print short press toggle ^= 1 =>% ws % power1 % toggle % endif if sw > 0 then ; pressed if timer > 30 then ; hold hold = 1 ; => print hold =% timer % if toggle > 0 then =>% ws % dimmer + else =>% ws % dimmer - endif endif else timer = 0 hold = 0 endif","title":"Fast Polling"},{"location":"Scripting-Language/#web-ui","text":"An example to show how to implement a web UI. This example controls a light via WebSend > D dimmer = 0 sw = 0 color = \"\" col1 = \"\" red = 0 green = 0 blue = 0 ww = 0 > F color = hn ( red ) + hn ( green ) + hn ( blue ) + hn ( ww ) if color != col1 then col1 = color => websend [ 192.168.178.75 ] color % color % endif if chg [ dimmer ]> 0 then => websend [ 192.168.178.75 ] dimmer % dimmer % endif if chg [ sw ]> 0 then => websend [ 192.168.178.75 ] power1 % sw % endif > W bu ( sw \"Light on\" \"Light off\" ) ck ( sw \"Light on/off \" ) sl ( 0 100 dimmer \"0\" \"Dimmer\" \"100\" ) sl ( 0 255 red \"0\" \"red\" \"255\" ) sl ( 0 255 green \"0\" \"green\" \"255\" ) sl ( 0 255 blue \"0\" \"blue\" \"255\" ) sl ( 0 255 ww \"0\" \"warm white\" \"255\" ) tx ( color \"color: \" )","title":"Web UI"},{"location":"Scripting-Language/#hue-emulation","text":"An example to show how to respond to Alexa requests via Hue Emulation When Alexa sends on/off, dimmer, and color (via hsb), send commands to a MagicHome device > D pwr1 = 0 hue1 = 0 sat1 = 0 bri1 = 0 tmp = 0 > E if upd [ hue1 ]> 0 or upd [ sat1 ]> 0 or upd [ bri1 ]> 0 then tmp = hue1 / 182 -> websend [ 192.168.178.84 ] hsbcolor % tmp % , % sat1 % , % bri1 % endif if upd [ pwr1 ]> 0 then -> websend [ 192.168.178.84 ] power1 % pwr1 % endif > H ; on , hue , sat , bri , ct livingroom , E , on = pwr1 , hue = hue1 , sat = sat1 , bri = bri1","title":"Hue Emulation"},{"location":"Scripting-Language/#alexa-controlled-mcp230xx-i2c-gpio-expander","text":"Uses Tasmota's Hue Emulation capabilities for Alexa interface ; define vars > D p : p1 = 0 p : p2 = 0 p : p3 = 0 p : p4 = 0 ; init ports > B -> sensor29 0 , 5 , 0 -> sensor29 1 , 5 , 0 -> sensor29 2 , 5 , 0 -> sensor29 3 , 5 , 0 -> sensor29 0 , % 0 p1 % -> sensor29 1 , % 0 p2 % -> sensor29 2 , % 0 p3 % -> sensor29 3 , % 0 p4 % ; define Alexa virtual devices > H port1 , S , on = p1 port2 , S , on = p2 port3 , S , on = p3 port4 , S , on = p4 ; handle events > E print EVENT if upd [ p1 ]> 0 then -> sensor29 0 , % 0 p1 % endif if upd [ p2 ]> 0 then -> sensor29 1 , % 0 p2 % endif if upd [ p3 ]> 0 then -> sensor29 2 , % 0 p3 % endif if upd [ p4 ]> 0 then -> sensor29 3 , % 0 p4 % endif = #pub ; publish routine #pub => publish stat /% topic %/ RESULT { \"MCP23XX\" :{ \"p1\" : % 0 p1 % , \"p2\" : % 0 p2 % , \"p3\" : % 0 p3 % , \"p4\" : % 0 p4 % }} svars ; web interface > W bu ( p1 \"p1 on\" \"p1 off\" ) bu ( p2 \"p2 on\" \"p2 off\" ) bu ( p3 \"p3 on\" \"p3 off\" ) bu ( p4 \"p4 on\" \"p4 off\" )","title":"Alexa Controlled MCP230xx I2C GPIO Expander"},{"location":"Scripting-Language/#retrieve-network-gateway-ip-address","text":"> D gw = \"\" ; Request Status information . The response will trigger the `U` section > B +> status 5 ; Read the status JSON payload > U gw = StatusNET #Gateway print % gw %","title":"Retrieve network gateway IP Address"},{"location":"Scripting-Language/#send-e-mail","text":"> D 25 day1 = 0 et = 0 to = \"<mrx@gmail.com>\" > T et = ENERGY#Total > S ; send at midnight day1 = day if chg [ day1 ]> 0 then => sendmail [ *:*:*:*:*:%to%:energy report ]* endif > m email report at % tstamp % your power consumption today was % et % KWh #","title":"Send e-mail"},{"location":"Scripting-Language/#switching-and-dimming-by-recognizing-mains-power-frequency","text":"Switching in Tasmota is usually done by High/Low (+3.3V/GND) changes on a GPIO. However, for devices like the Moes QS-WiFi-D01 Dimmer , this is achieved by a pulse frequency when connected to the GPIO, and these pulses are captured by Counter1 in Tasmota. When the light is OFF and there is a short period of pulses - then turn the light ON at the previous dimmer level. When the light is ON and there is a short period of pulses - then turn the light OFF . When there is a longer period of pulses (i.e., HOLD ) - toggle dimming direction and then adjust the brightness level as long as the button is pressed or until the limits are reached. Issue 6085 In the Data Section D at the beginning of the Script the following initialization variables may be changed: dim multiplier = 0..2.55 set the dimming increment value dim lower limit = range for the dimmer value for push-button operation (set according to your bulb); min 0 dim upper limit = range for the dimmer value for push-button operation (set according to your bulb); max 100 start dim level = initial dimmer level after power-up or restart; max 100 > D sw = 0 tmp = 0 cnt = 0 tmr = 0 hold = 0 powert = 0 slider = 0 dim = \"\" shortprl = 2 ; short press lo limit shortpru = 10 ; short press up limit dimdir = 0 ; dim direction 0 / 1 dimstp = 2 ; dim step / speed 1 to 5 dimmlp = 2.2 ; dim multiplier dimll = 15 ; dim lower limit dimul = 95 ; dim upper limit dimval = 70 ; start dim level > B => print \"WiFi-Dimmer-Script-v0.2\" => Counter1 0 => Baudrate 9600 ; boot sequence = #senddim ( dimval ) delay ( 1000 ) = #senddim ( 0 ) > F cnt = pc [ 1 ] if chg [ cnt ]> 0 ; sw pressed then sw = 1 else sw = 0 ; sw not pressed endif ; 100 ms timer tmr += 1 ; short press if sw == 0 and tmr > shortprl and tmr < shortpru then powert ^= 1 ; change light on / off if powert == 1 then = #senddim ( dimval ) else = #senddim ( 0 ) endif endif ; long press if sw > 0 then if hold == 0 then ; change dim direction dimdir ^= 1 endif if tmr > shortpru then hold = 1 if powert > 0 ; dim when on & hold then if dimdir > 0 then ; increase dim level dimval += dimstp if dimval > dimul then ; upper limit dimval = dimul endif = #senddim ( dimval ) else ; decrease dim level dimval -= dimstp if dimval < dimll then ; lower limit dimval = dimll endif = #senddim ( dimval ) endif endif endif else tmr = 0 hold = 0 endif > E slider = Dimmer ; slider change if chg [ slider ]> 0 then ; dim according slider if slider > 0 then dimval = slider = #senddim ( dimval ) else powert = 0 = #senddim ( 0 ) endif endif if pwr [ 1 ]== 1 ; on / off webui then powert = 1 = #senddim ( dimval ) else powert = 0 = #senddim ( 0 ) endif ; subroutine dim #senddim ( tmp ) dim = \"FF55\" + hn ( tmp * dimmlp ) + \"05DC0A\" => SerialSend5 % dim % => Dimmer % tmp % #","title":"Switching and Dimming By Recognizing Mains Power Frequency"},{"location":"Securing-your-IoT-from-hacking/","text":"General Weaknesses ~ Whenever you add devices to your network you generate additional points of potential intrusion. This is not only valid for your mobile phones and computers, but also for you Smart TV, you Alexa, or all of your SONOFF devices (ESP8266). There are following potential risks you have to mitigate: Someone hacks your device and is able to log in into your WLAN. (why is this a problem? 1 ) Someone hacks your device and is able to read and change any value on your MQTT server (why is this a problem? 2 ) Someone hacks your network and can interact with your devices (why is this a problem? 3 ) Someone hacks your device and use it for different things like mail bot or DOS (Denial of Service) device or WLAN jammer (why is this a problem? 4 ) Scenario 1 If someone is able to get your WLAN key, he can login into your network, if he is nearby and scan for any traffic and for any devices. Many communication is not encrypted in your WLAN by default. Therefore be part of your WLAN gives the attacker a great opportunity to screw-up the rest of your infrastructure. Also be part of your WLAN does mean, that the attacker can use your IP-Address and your traffic to do nasty things. Scenario 2 If you can hack an ESP82xx device, you might get access to the keys stored in the device. For example, the MQTT password allows you to read ALL of your devices and change any device at any time. With the information of the MQTT-Server user/password, it might be not required anymore to physically be in your WLAN. Maybe your MQTT Server is publicly accessible. Then the attacker can control your home from any place. Update: Beginning with version 6.0.0, passwords are not directly exposed through the serial connection or web interface in configuration mode. Therefore it is now less simple, however still possible to obtain the MQTT or WLAN password from a device. Such can be accomplished by downloading a configuration backup via the web UI of the device and decoding it using the decode-config.py script found in the Tasmota tools folder. Scenario 3 It might happen, that e.g. your Samsung SmartTV is not as secure as it should be and an attacker gets access to your network. Now he can listen to any traffic and maybe can make changes on all of your IoT devices. Scenario 4 If someone uses your device to spam mail or do a DOS attack the impact at your home is minimal. You might have more outbound traffic, but maybe you don't recognize this either. But thousands of hacked IoT devices can generate tremendous trouble even at the largest internet providers. I hope these four typical scenarios ( the list is not complete) give you some idea, why you should take care, even if you're not a terrorist and normally nobody is interested into hacking you personally. Securing your WLAN ~ That you should have a WLAN key and use WPA2 for encryption is a \"no brainer\". This is a minimum requirement. Now think about someone can extract the password from the device. E.g. because the device is in the garden and someone with a Laptop and some USB stuff can connect and extract information. The hacker will get the key. The ONLY possible preventive action to mitigate worst case scenario is to have a second WLAN, like the \"FritzBox Guest WLAN\". Many other routers offer similar things. This guest WLAN has no access to your private WLAN. Additionally, there are some interesting switched you can configure for the WLAN. At the FritzRouter you can configure \"network separation\" . At Fritz this is done by DISABLE \"The wireless devices connected with the guest access can communicate with each other\" . This does mean, that a device in the network can not interact with any other device in the WLAN. It can only communicate with the Internet. This simple configuration prevents any attacker to do nasty stuff on YOUR network. Now we have to take care, that the attacker is not creating a Bot-Net and sending e.g., Spam-Mails. Normally a device in the \"guest WLAN\" can use any internet service. For our IoT devices and for any new device we can create a Router rule, that ONLY MQTT is allowed to our server and any other traffic is blocked. This is a great configuration because it limits the options what a hacker can do. If you have a FritzBox following configuration has to be created to get this working: Create Profile to block all communication except MQTT and NTP Time services. Internet -> Filters -> List -> \"Add Network Application\" \"New Protocol\" (Add four rules, This will block all but UDP123 for Timeserver and 8883 for MQTT Server) TCP from any to Port 1 to 8882 TCP from any to Port 8884 to 65636 UDP from any to Port 1 to 122 UDP from any to Port 124 to 65636 Create a list of \"websites\" your IoT devices are allowed to access. Internet -> Filters -> List -> \"Permitted web sites\" -> EDIT yourserver 01.de.pool.ntp.org Replace with the full qualified name of your router in the Internet. NTP server - Use the one you have defined in Tasmota to be the timeserver. Create a profile you can attach to your IoT devices. Internet -> Filters -> Access profiles -> \"new Access profile\" \"Filter Web sites\" DISABLE \"Allow HTTPS queries\" SELECT \"Permit web sites (whitelist) Now you will probably ask two questions: How can I communicate with my MQTT Server in my personal WLAN if only traffic into the internet is allowed? How can I access the WebConsole of my devices to upload new Firmware and/or make investigations? The first topic will be solved by exposing your MQTT server to the Internet (no worries, can be done securely). The second topic has only a workaround. If you want access to your devices you need to change the configuration temporary on your router and ENABLE \"The wireless devices connected with the guest access can communicate with each other\" . Secondly, you must login with your Laptop into the GuestWLAN to be able to communicate. If the Webserver is running you should be able to connect and upload e.g. a new firmware. Securing your Communication ~ In the world of IoT devices and more and more devices in a network, it is essential to use encryption ALL the time. The Tasmota project is able to enable encryption for MQTT. This is great. But it cannot enable encryption on the WebServer. This is bad. As a conclusion, the Webserver must be switched OFF all the time and only be switched ON for administrative purpose. This also disables the feature to change the Relay Status with an HTTP REST call. But this option is insecure anyway and should be avoided. Now let's work on the MQTT configuration. Also here an attacker can get access to user and password. To minimize the impact EVERY and really EVERY device must have a unique USER and a unique password. If you don't follow this rule the attacker get one device he can control ALL devices. With the USER/PASSWORD he now can control the one device he already holds in his hands. ok, no big deal. How to configure Mosquitto? In general, Tasmota stores data in stat/ /+ and tele/ /+. or cmnd/ /+ to control something. If we use the as username we can make some quite nice and straight forward configuration. Example: Topic: ESP_123456 User: ESP_123456 (must be the same to Topic) password: 987654321 Configuration file: /etc/mosquitte/conf.d/jp.acl user root topic read # topic write # pattern read cmnd /% u /# pattern write stat /% u /# pattern write tele /% u /# My user root is allowed to do everything. This is used in my home-automation to control all devices and listen to all devices. The \"pattern\" is used for ALL other users and the %u is a substitute. The great thing is that the device can read its configuration but cannot write to it. And the status information it posts to the /status/ but is not able to read it afterward. With this minimal configuration, Tasmota devices are running. To add the different user to Mosquitte the following two commands work fine. There is also a re-read available, but a restart works better for me. sudo mosquitto_passwd -b /etc/mosquitto/conf.d/jp.pw ESP_123456 987654321 sudo /etc/init.d/mosquitto restart If this is running, we switch the Mosquitto to secure communication on Port 8883 and disable all insecure options. /etc/mosquitto/conf.d/user.conf # User Config password_file / etc / mosquitto / conf . d / jp . pw acl_file / etc / mosquitto / conf . d / jp . acl allow_anonymous false listener 8883 cafile / etc / mosquitto / certs / ca . crt certfile / etc / mosquitto / certs / server . crt keyfile / etc / mosquitto / certs / server . key require_certificate false How to generate the certificates in mosquitto please look at: Mosquitto SSL Configuration - MQTT TLS Security Adding TLS to connect to Mosquitto Internet of Things messaging MQTT with TLS Enable Secure Communication with TLS and the Mosquitto Broker SSL/TLS on Tasmota ~ TLS article explains how to set it up in Tasmota Disable unsecured fallback WiFi (WifiManager) ~ In case your Wifi SSID is not available (i.e. access point dies), the WiFiManager will jump into action and make your tasmota devices available using an unsecured access point. Type WifiConfig into the tasmota console. If this parameter is set to 2, you might want to change it after completing the setup of your device. Some less risky options would be: 0/4/5. (For details, see Wi-Fi commands ).","title":"Securing your IoT from hacking"},{"location":"Securing-your-IoT-from-hacking/#general-weaknesses","text":"Whenever you add devices to your network you generate additional points of potential intrusion. This is not only valid for your mobile phones and computers, but also for you Smart TV, you Alexa, or all of your SONOFF devices (ESP8266). There are following potential risks you have to mitigate: Someone hacks your device and is able to log in into your WLAN. (why is this a problem? 1 ) Someone hacks your device and is able to read and change any value on your MQTT server (why is this a problem? 2 ) Someone hacks your network and can interact with your devices (why is this a problem? 3 ) Someone hacks your device and use it for different things like mail bot or DOS (Denial of Service) device or WLAN jammer (why is this a problem? 4 )","title":"General Weaknesses"},{"location":"Securing-your-IoT-from-hacking/#securing-your-wlan","text":"That you should have a WLAN key and use WPA2 for encryption is a \"no brainer\". This is a minimum requirement. Now think about someone can extract the password from the device. E.g. because the device is in the garden and someone with a Laptop and some USB stuff can connect and extract information. The hacker will get the key. The ONLY possible preventive action to mitigate worst case scenario is to have a second WLAN, like the \"FritzBox Guest WLAN\". Many other routers offer similar things. This guest WLAN has no access to your private WLAN. Additionally, there are some interesting switched you can configure for the WLAN. At the FritzRouter you can configure \"network separation\" . At Fritz this is done by DISABLE \"The wireless devices connected with the guest access can communicate with each other\" . This does mean, that a device in the network can not interact with any other device in the WLAN. It can only communicate with the Internet. This simple configuration prevents any attacker to do nasty stuff on YOUR network. Now we have to take care, that the attacker is not creating a Bot-Net and sending e.g., Spam-Mails. Normally a device in the \"guest WLAN\" can use any internet service. For our IoT devices and for any new device we can create a Router rule, that ONLY MQTT is allowed to our server and any other traffic is blocked. This is a great configuration because it limits the options what a hacker can do. If you have a FritzBox following configuration has to be created to get this working: Create Profile to block all communication except MQTT and NTP Time services. Internet -> Filters -> List -> \"Add Network Application\" \"New Protocol\" (Add four rules, This will block all but UDP123 for Timeserver and 8883 for MQTT Server) TCP from any to Port 1 to 8882 TCP from any to Port 8884 to 65636 UDP from any to Port 1 to 122 UDP from any to Port 124 to 65636 Create a list of \"websites\" your IoT devices are allowed to access. Internet -> Filters -> List -> \"Permitted web sites\" -> EDIT yourserver 01.de.pool.ntp.org Replace with the full qualified name of your router in the Internet. NTP server - Use the one you have defined in Tasmota to be the timeserver. Create a profile you can attach to your IoT devices. Internet -> Filters -> Access profiles -> \"new Access profile\" \"Filter Web sites\" DISABLE \"Allow HTTPS queries\" SELECT \"Permit web sites (whitelist) Now you will probably ask two questions: How can I communicate with my MQTT Server in my personal WLAN if only traffic into the internet is allowed? How can I access the WebConsole of my devices to upload new Firmware and/or make investigations? The first topic will be solved by exposing your MQTT server to the Internet (no worries, can be done securely). The second topic has only a workaround. If you want access to your devices you need to change the configuration temporary on your router and ENABLE \"The wireless devices connected with the guest access can communicate with each other\" . Secondly, you must login with your Laptop into the GuestWLAN to be able to communicate. If the Webserver is running you should be able to connect and upload e.g. a new firmware.","title":"Securing your WLAN"},{"location":"Securing-your-IoT-from-hacking/#securing-your-communication","text":"In the world of IoT devices and more and more devices in a network, it is essential to use encryption ALL the time. The Tasmota project is able to enable encryption for MQTT. This is great. But it cannot enable encryption on the WebServer. This is bad. As a conclusion, the Webserver must be switched OFF all the time and only be switched ON for administrative purpose. This also disables the feature to change the Relay Status with an HTTP REST call. But this option is insecure anyway and should be avoided. Now let's work on the MQTT configuration. Also here an attacker can get access to user and password. To minimize the impact EVERY and really EVERY device must have a unique USER and a unique password. If you don't follow this rule the attacker get one device he can control ALL devices. With the USER/PASSWORD he now can control the one device he already holds in his hands. ok, no big deal. How to configure Mosquitto? In general, Tasmota stores data in stat/ /+ and tele/ /+. or cmnd/ /+ to control something. If we use the as username we can make some quite nice and straight forward configuration. Example: Topic: ESP_123456 User: ESP_123456 (must be the same to Topic) password: 987654321 Configuration file: /etc/mosquitte/conf.d/jp.acl user root topic read # topic write # pattern read cmnd /% u /# pattern write stat /% u /# pattern write tele /% u /# My user root is allowed to do everything. This is used in my home-automation to control all devices and listen to all devices. The \"pattern\" is used for ALL other users and the %u is a substitute. The great thing is that the device can read its configuration but cannot write to it. And the status information it posts to the /status/ but is not able to read it afterward. With this minimal configuration, Tasmota devices are running. To add the different user to Mosquitte the following two commands work fine. There is also a re-read available, but a restart works better for me. sudo mosquitto_passwd -b /etc/mosquitto/conf.d/jp.pw ESP_123456 987654321 sudo /etc/init.d/mosquitto restart If this is running, we switch the Mosquitto to secure communication on Port 8883 and disable all insecure options. /etc/mosquitto/conf.d/user.conf # User Config password_file / etc / mosquitto / conf . d / jp . pw acl_file / etc / mosquitto / conf . d / jp . acl allow_anonymous false listener 8883 cafile / etc / mosquitto / certs / ca . crt certfile / etc / mosquitto / certs / server . crt keyfile / etc / mosquitto / certs / server . key require_certificate false How to generate the certificates in mosquitto please look at: Mosquitto SSL Configuration - MQTT TLS Security Adding TLS to connect to Mosquitto Internet of Things messaging MQTT with TLS Enable Secure Communication with TLS and the Mosquitto Broker","title":"Securing your Communication"},{"location":"Securing-your-IoT-from-hacking/#ssltls-on-tasmota","text":"TLS article explains how to set it up in Tasmota","title":"SSL/TLS on Tasmota"},{"location":"Securing-your-IoT-from-hacking/#disable-unsecured-fallback-wifi-wifimanager","text":"In case your Wifi SSID is not available (i.e. access point dies), the WiFiManager will jump into action and make your tasmota devices available using an unsecured access point. Type WifiConfig into the tasmota console. If this parameter is set to 2, you might want to change it after completing the setup of your device. Some less risky options would be: 0/4/5. (For details, see Wi-Fi commands ).","title":"Disable unsecured fallback WiFi (WifiManager)"},{"location":"Sensor-API/","text":"Tasmota sensor API documentation for sensor driver development. Important things to consider ~ There are several I 2 C sensor examples you can take from the development codebase when writing your own and you are encouraged to do this as it is a quick and easy way to see how things fit together. The Tasmota firmware is essentially intended for ESP8266/ESP8285 Wi-Fi SoC based devices and commits to the main development branch will be subject to review based on whether or not what you intend to develop or add to the existing code is relevant to the general ESP device users. That being said, there is a lot of development going into the firmware which extends the functionality of standard off the shelf Sonoff devices. The firmware in itself is also useful for boards such as the WeMos ESP82xx boards. More technically inclined individuals who use generic ESP82xx modules in their own circuits to provide more access to pins and the ability to add more sensors and hardware external to the device or the generic ESP82xx module circuits can also take advantage of Tasmota. The resources on the ESP82xx are finite. Most devices ship with 1MByte SPI flash which means for the generic device users, the code generally needs to be less than 502KBytes to ensure that OTA (Over The Air) flash functionality (which is the main reason why people use this firmware) remains available. RAM is also limited to an absolute maximum of 80KBytes. This memory is divided into heap (used by global variables and Strings) and stack (used by local variables) where stack space is just 4KBytes. Given the above resource constraints its important to keep your code as small as possible, as fast running as possible, and use as little RAM as possible. You need to think about these resource constraints all the time whilst doing any development you wish to add to the firmware functionality - Face the fact that microcontroller development isn't as close a relative to standard computer programming as you'd expect. You will be adding code to an existing framework which requires you to adhere to some simple but strict rules such as not having any infinite loops like you would have in your generic Arduino code and try to avoid using the delay() functions when writing your code as this will cause the entire firmware to be subjected to the delays you have added - Infinite loops will cause the firmware to lock up completely! If your sensor has configuration options please make these available by using the SensorXX framework which is already incorporated in the base code - This may not stop you from using a web-based configuration interface but since web-based configuration takes up a lot of code space in flash it is very important to make this optional by means of a compiler directive or a #define in the configuration file and as such something you need to keep in mind during your development and debugging - The more progressively optional additional features are in your driver the smaller the basic codebase can be for minimalist implementations. Whilst developing drivers for devices that use the I 2 C bus always consider other devices already supported in the codebase which may use the same address range. This could mean you need to find a unique way of differentiating your device detection from other devices on the same address range (e.g. querying a model-specific register) and/or disabling by #undef existing devices if yours is selected with a #define statement and in such cases always provide a warning to the user during compile time using the #warning pragma such as including #warning **** Turned off conflicting drivers SHT and VEML6070 **** in your code. DO NOT ADD WEB INTERFACE FOR SENSOR CONFIGURATION if your sensor requires additional user configuration. The reason for this is the additional program memory required but most importantly the amount of RAM required to even create minimal user interfaces. Running out of RAM during runtime will lead to abnormal behaviour of your driver and/or other drivers or the entire firmware! See sensors such as the MCP23008/MCP23017 driver on more information on how to implement SensorXX commands instead! While developing you might want to enable additional debugging provided by file xdrv_99_debug.ino using #define USE_DEBUG_DRIVER which provides some commands for managing configuration settings and CPU timing. In addition you can enable define PROFILE_XSNS_SENSOR_EVERY_SECOND to profile your drivers duration. Do not assume others will know immediately how to use your addition and know that you will need to write a Wiki for it in the end. Managing a Forked Branch ~ If you plan to submit a PR bigger than a simple change in one file, here is a short intro about how to do a clean PR. fork the Tasmota repository in Github git clone https://github.com/<github_user>/Tasmota.git and work on your local copy git remote add upstream https://github.com/arendst/Tasmota.git git checkout development git checkout -b <temp_branch> to create a working branch where you can push commits git push --set-upstream origin <temp_branch> work on your local version and push as many commits as you want When you think it is ready to merge and submit a PR: git checkout development to go back to the main branch git pull upstream development to update all the latest changes git push to update your fork git checkout -b <pr_branch> to create a new branch for the final PR git push --set-upstream origin <pr_branch> Merge the edits but be sure to remove the history of your local commits git merge --squash <temp_branch> git commit -m \"Message\" Now you have a clean single commit from which you can create the PR on the Tasmota Github. Directory/file structure ~ Sensor libraries are located in the lib/ directory. Sensor drivers are located in the tasmota/ directory. The filename of the sensor driver is xsns_<driver_ID>_<driver_name>.ino , e.g. xsns_05_ds18b20.ino where <driver_ID> is a unique number between 01 and 90 and <driver_name> is a human-readable name of the driver. Using generic libraries from external sources for sensors should be avoided as far as possible as they usually include code for other platforms and are not always written in an optimized way. API structure ~ Pre-processor directives ~ Conditional compiling of a sensor driver is achieved by adding a pre-processor directive of the scheme USE_<driver_name> in my_user_config.h . Accordingly the driver code has to be wrapped in #ifdef USE_<driver_name> ... #endif // USE_<driver_name> . Any Sensor driver must contain a pre-processor directive defining the driver ID by the scheme #define XSNS_<driver_ID> . Callback function ~ Any sensor driver needs a callback function following the scheme // Conditional compilation of driver #ifdef USE_<driver_name> // Define driver ID #define XSNS_<driver_ID> <driver_ID> /** * The callback function Xsns<driver_ID>() interfaces Tasmota with the sensor driver. * * It provides the Tasmota callback IDs. * * @param byte callback_id Tasmota function ID. * @return boolean Return value. * @pre None. * @post None. * */ boolean Xsns < driverID > ( byte callback_id ) { // Set return value to `false` boolean result = false ; // Check if I2C interface mode // if(i2c_flg) { // Check which callback ID is called by Tasmota switch ( callback_id ) { case FUNC_INIT : break ; case FUNC_EVERY_50_MSECOND : break ; case FUNC_EVERY_SECOND : break ; case FUNC_JSON_APPEND : break ; #ifdef USE_WEBSERVER case FUNC_WEB_APPEND : break ; #endif // USE_WEBSERVER case FUNC_SAVE_BEFORE_RESTART : break ; case FUNC_COMMAND : break ; } // } // if(i2c_flg) // Return boolean result return result ; } #endif // USE_<driver_name> Callback IDs ~ FUNC_INIT This callback ID is called when sensor drivers should be initialized. FUNC_EVERY_50_MSECOND This callback ID is called every 50 milliseconds, e.g. for near real-time operation FUNC_EVERY_SECOND This callback ID is called every second. It can be useful for anything that you need to do on a per second basis and is commonly used as an entry point to detect a driver or initialize an externally driven device such as a sensor, relay board or other forms of input/output required by your driver. You would normally want to make sure you've detected and initialised before it is used by JSON_APPEND , etc. so that its ready to serve data. The generally accepted way to use this would be to detect your sensor and once this is done set a sensor value accordingly so that the function does not use unnecessary resources during future calls, for example: void MySensorDetect () { if ( MySensorDetected ) { return ; } /* * Perform the code which needs to be completed to * detect your sensor and then set MySensorDetected to * a non-zero value which will prevent this section * of your code to re-run every time the function is * called. * * Under normal circumstances you'd not need to do * re-detect or initialise your sensor once it has been * done */ } Setting a flag that the driver was successful in detecting the attached chip/board via I 2 C or SPI will prevent it from continuously trying to initialize an already initialized device. When writing your function responsible for detecting an externally connected I 2 C device try to create a method by which you read or write to specific registers that would be applicable to that specific I 2 C device only as to confirm a positive detect for the device. If this is not done extensively it will lead to some drivers getting false detects for a different device type simply because it shares the same I 2 C address. Unless your driver is specifically going to use the entire array of addresses provisioned by the manufacturer please consider using a #define USE_MYCHIPNAME_ADDR in the my_user_config.h so that the user may specify the address on which to expect the device. This is of course only applicable to drivers that are not enabled by default in any of the pre-built binaries. I 2 C address auto-detection example #define MPR121_I2C_ADDR_1ST 0x5A /** 1st I2C address of sensor model **/ #define MPR121_I2C_ADDR_NUM 4 /** Number of sensors/I2C addresses **/ #define MPR121_I2C_ID_REG 0x5D /** Sensor model specific ID register **/ #define MPR121_I2C_ID_VAL 0x24 /** Sensor model specific ID register value **/ /* Sensor data struct type declaration/default definition */ typedef struct { bool connected = false ; /** Status if sensor is connected at I2C address */ bool running = false ; /** Running state of sensor */ . . . } mpr121 ; // Declare array of sensor data structs mpr121 mpr121 [ MPR121_I2C_ADDR_NUM ]; // Sensor specific init function void mpr121_init () { // Loop through I2C addresses for ( uint8_t i = 0 ; i < MPR121_I2C_ADDR_NUM ); i ++ ) { // Check if sensor is connected on I2C address mpr121 [ i ]. connected = ( MPR121_I2C_ID_VAL == I2cRead8 ( MPR121_I2C_ADDR_1ST + i , MPR121_I2C_ID_REG ); if ( mpr121 [ i ]. connected ) { // Log sensor found snprintf_P ( log_data , sizeof ( log_data ), PSTR ( D_LOG_I2C \"MPR121-%d \" D_FOUND_AT \" 0x%X\" ), i , MPR121_I2C_ADDR_1ST + i ); AddLog ( LOG_LEVEL_INFO ); // Initialize sensor . . . // Set running to true mpr121 [ i ]. running = true ; } } if ( ! ( mpr121 [ 0 ]. connected || mpr121 [ 1 ]. connected || mpr121 [ 2 ]. connected || mpr121 [ 3 ]. connected )){ snprintf_P ( log_data , sizeof ( log_data ), PSTR ( D_LOG_I2C \"MPR121: No sensors found\" )); AddLog ( LOG_LEVEL_INFO ); } } Four advanced methods to use FUNC_EVERY_SECOND (Food for thought) : * If a sensor needs an action which takes a long time, like more than 100mS, the action will be started here for a future follow-up. Using the uptime variable for testing like (uptime &1) will happen every 2 seconds. An example is the DS18B20 driver where readings (conversions they call it) can take up to 800mS from the initial request. * If a sensor needed the previous action it is now time to gather the information and store it in a safe place to be used by FUNC_JSON_APPEND and/or FUNC_WEB_APPEND . Using the else function of the previous test (uptime &1) will happen every 2 seconds too but just 1 second later than the previous action. * If a sensor does not respond for 10 times the sensor detection flag could be reset which will stop further processing until the sensor is re-detected. This is currently not being used actively as some users complain about disappearing sensors for whatever reason - Could be hardware related but easier to make Tasmota a little more flexible. * Making re-detection of a sensor possible by executing this once every 100 seconds (94 == (uptime %100)) a re-attached sensor can be detected without a restart of Tasmota. The 94 given in this example should be different for every sensor driver to make sure not all sensors start detection at the same time. Using the drivers index number should be a good starting point. FUNC_PREP_BEFORE_TELEPERIOD NOTE: This callback ID is deprecated as sensors should prepare for more regular updates due to \"realtime\" rule execution. Use FUNC_EVERY_SECOND instead. See examples used in xsns_05_ds18x20.ino and xsns_09_bmp.ino where updated sensor data is stored in preparation to calls to FUNC_JSON_APPEND and FUNC_WEB_APPEND. FUNC_JSON_APPEND This callback ID is called when TelePeriod is due to append telemetry data to the MQTT JSON string or at approximately every 2 seconds when a rule is checked, e.g. snprintf_P ( mqtt_data , sizeof ( mqtt_data ), PSTR ( \"{ \\\" MPR121%c \\\" :{ \\\" Button%i \\\" :%i}}\" ), pS -> id [ i ], j , BITC ( i , j )); FUNC_WEB_APPEND This callback ID is called every millisecond when HTML code should be added to the Tasmota web-interface main page, e.g., snprintf_P ( mqtt_data , sizeof ( mqtt_data ), PSTR ( \"%s{s}MPR121%c Button%d{m}%d{e}\" ), mqtt_data , pS -> id [ i ], j , BITC ( i , j )); It should be wrapped in #ifdef USE_WEBSERVER ... #endif // USE_WEBSERVER FUNC_SAVE_BEFORE_RESTART This callback ID is called to allow a sensor to prepare for saving configuration changes. To be used to save volatile data just before a restart. Variables can be appended to struct SYSCFG {} Settings in file tasmota/settings.h . FUNC_COMMAND This callback ID is called when a sensor specific command Sensor<xx> or Driver<xx> is executed where xx is the sensor index. case FUNC_COMMAND : if ( XSNS_ < driver_ID > == XdrvMailbox . index ) { result = < driver_name > Command () { ... }; // Return true on success } break ; // Data struct of FUNC_COMMAND ID struct XDRVMAILBOX { uint16_t valid ; // ??? uint16_t index ; // Sensor index uint16_t data_len ; // Length of command string uint16_t payload16 ; // 16 bit unsigned int of payload if it could be converted, otherwise 0 int16_t payload ; // 16 bit signed int of payload if it could be converted, otherwise 0 uint8_t grpflg ; // ??? uint8_t notused ; // ??? char * topic ; // Command topic char * data ; // Command string/value - length of which is defined by data_len } XdrvMailbox ; If your driver needs to accept multiple parameters for SensorXX and/or DriverXX please consider using comma delimited formatting and use the already written subStr() function declared in support.ino to parse through the parameters you need. An example of those could be SensorXX reset // The reset parameter may be intercepted using: if ( ! strcmp ( subStr ( sub_string , XdrvMailbox . data , \",\" , 1 ), \"RESET\" )) { // Note 1 used for param number MyDriverName_Reset (); return serviced ; } Or in the case of multiple parameters SensorXX mode , 1 if ( ! strcmp ( subStr ( sub_string , XdrvMailbox . data , \",\" , 1 ), \"MODE\" )) { // Note 1 used for param number uint8_t mode = atoi ( subStr ( sub_string , XdrvMailbox . data , \",\" , 2 ); // Note 2 used for param number } Useful functions ~ MQTT ~ void MqttPublishPrefixTopic_P ( uint8_t prefix , const char * subtopic , boolean retained ) This function publishes MQTT messages immediately, e.g., snprintf_P ( mqtt_data , sizeof ( mqtt_data ), PSTR ( \"{ \\\" MPR121%c \\\" :{ \\\" Button%i \\\" :%i}}\" ), pS -> id [ i ], j , BITC ( i , j )); MqttPublishPrefixTopic_P ( RESULT_OR_STAT , mqtt_data ); Logging ~ void AddLog ( byte loglevel ) This function adds log messages stored in log_data to the local logging system, e.g. snprintf_P ( log_data , sizeof ( log_data ), PSTR ( D_LOG_I2C \"MPR121(%c) \" D_FOUND_AT \" 0x%X\" ), pS -> id [ i ], pS -> i2c_addr [ i ]); AddLog ( LOG_LEVEL_INFO ); void AddLogSerial ( byte loglevel ) This function adds a log message to the local logging system dumping the serial buffer as hex information, e.g. AddLogSerial ( LOG_LEVEL_INFO ); void AddLogMissed ( char * sensor , uint8_t misses ) This function adds a log message to the local logging system about missed sensor reads. I 2 C Interface ~ bool I2cValidRead8 ( uint8_t * data , uint8_t addr , uint8_t reg ) bool I2cValidRead16 ( uint16_t * data , uint8_t addr , uint8_t reg ) bool I2cValidReadS16 ( int16_t * data , uint8_t addr , uint8_t reg ) bool I2cValidRead16LE ( uint16_t * data , uint8_t addr , uint8_t reg ) bool I2cValidReadS16_LE ( int16_t * data , uint8_t addr , uint8_t reg ) bool I2cValidRead24 ( int32_t * data , uint8_t addr , uint8_t reg ) bool I2cValidRead ( uint8_t addr , uint8_t reg , uint8_t size ) These functions return true if 1, 2, 3 or size bytes can be read from the I 2 C address addr and register reg into *data . Functions with a S read signed data types while functions without a S read unsigned data types. Functions with LE read little-endian byte order while functions without LE read machine byte order. uint8_t I2cRead8 ( uint8_t addr , uint8_t reg ) uint16_t I2cRead16 ( uint8_t addr , uint8_t reg ) int16_t I2cReadS16 ( uint8_t addr , uint8_t reg ) uint16_t I2cRead16LE ( uint8_t addr , uint8_t reg ) int16_t I2cReadS16_LE ( uint8_t addr , uint8_t reg ) int32_t I2cRead24 ( uint8_t addr , uint8_t reg ) These functions return 1, 2 or 3 bytes from the I 2 C address addr and register reg . Functions with a S read signed data types while functions without a S read unsigned data types. Functions with LE read little endian byte order while functions without LE read machine byte order. bool I2cWrite8 ( uint8_t addr , uint8_t reg , uint8_t val ) bool I2cWrite16 ( uint8_t addr , uint8_t reg , uint16_t val ) bool I2cWrite ( uint8_t addr , uint8_t reg , uint32_t val , uint8_t size ) These functions return true after successfully writing 1, 2 or size bytes to the I 2 C address addr and register reg . int8_t I2cReadBuffer ( uint8_t addr , uint8_t reg , uint8_t * reg_data , uint16_t len ) int8_t I2cWriteBuffer ( uint8_t addr , uint8_t reg , uint8_t * reg_data , uint16_t len ) These functions copy len bytes from/to *reg_data starting at I 2 C address addr and register reg . void I2cScan ( char * devs , unsigned int devs_len ) This functions writes a list of I 2 C addresses in use into the string *dev with maximum length devs_len . bool I2cDevice ( byte addr ) This functions checks if the I 2 C address addr is in use. Useful pre-processor directives ~ PSTR(\"string\") This pre-processor directive saves RAM by storing strings in flash instead of RAM. const char MyTextStaticVariable [] PROGMEM = \"string\" ; This pre-processor directive saves RAM by storing strings in flash instead of RAM. You may then reference them directly (if the type matches the parameter required) or force it to 4 byte alignment by using the variable as FPSTR(MyTextStaticVariable) Keeping ESP8266 code compact ~ Below are various tips and tricks to keep ESP8266 code compact and save both Flash and Memory. Flash code is limited to 1024k but keep in mind that to allow OTA upgrade, you need Flash memory to contain two firmwares at the same time. To go beyond 512k, you typically use tasmota-minimal as an intermediate firmware. tasmota-minimal takes roughly 360k, so it's safe not to go uint32_t beyond 620k of Flash. Memory is even more limited: 80k. With Arduino Core and basic Tasmota, there are 25k-30k left of heap space. Heap memory is very precious, running out of memory will generally cause a crash. About ESP8266 ~ ESP8266 is based on Xtensa instruction set . Xtensa is a 32 bits RISC processor core, containing 16 x 32 bits registers. ESP8266 supports integer operations, including 32x32 multiplication. It does not contain an FPU for floating point operations, nor integer divisions. Contrary to classical RISC processors, all instructions are 24 bits wide instead of 32 bits. To increase code compactness, some instructions have a 16 bits version used whenever possible by gcc. If you want to see what assembly is generated by gcc, in file platform.ini , at the section used to compile (ex: [core_2_6_1] ) in section build_flags add: -save-temps=obj -fverbose-asm Gcc will store <file>.s in the same folder as the .o file, typically in .pioenvs/ . First example ~ Let's take a basic function: uint32_t Example ( uint32_t a , uint32_t b ) { return a + b ; } Below is the generated assembly. Function names are mangled using standard C++, i.e. their name derive from their arguments and return types: _Z7Examplejj: add.n a2 , a2 , a3 #, a, b ret.n As you can see, this is the simplest function we can think of. Register A2 holds the first argument and is used for return value. A3 holds the second argument. uint8_t or uint32_t ? ~ uint32_t Example ( uint32_t a , uint32_t b ) { uint8_t c = a + b ; return c ; } Assembly: _Z7Examplejj: add.n a2 , a2 , a3 # tmp52, a, b extui a2 , a2 , 0 , 8 #, tmp52 ret.n Whenever gcc needs to convert from uin32_t to uint8_t , it uses an extra instruction extui <reg>, <reg>, 0, 8 . Whenever you allocate uint8_t as a local variable, it will anyways allocate 32 bits on the stack. In conclusion you can easily use uint32_t in many places in the code. The main reason to force uint8_t are: in structures, to save memory. This is the only place where uint8_t will take 1 byte and the compiler will try to pack as much as 4 uint8_t in 32 bits when you want to ensure that the value can never exceed 255. Beware though that the compiler will just chunk the last 8 bits of a 32 bits value and will not report any overflow. Loops ~ Should you use uint8_t or uint32_t for loops? Let's try: uint32_t Example ( uint32_t a , uint32_t b ) { for ( uint8_t i = 0 ; i < 10 ; i ++ ) { a += b ; } for ( uint32_t j = 0 ; j < 10 ; j ++ ) { a += b ; } return a ; } Assembly: _Z7Examplejj: movi.n a3 , 0 # ivtmp$7334, <- loop 1 .L2031: add.n a2 , a2 , a3 # a, a, ivtmp$7334 addi.n a3 , a3 , 1 # ivtmp$7334, ivtmp$7334, bnei a3 , 10 , .L2031 # ivtmp$7334,, movi.n a3 , 0 # j, <- loop 2 .L2033: add.n a2 , a2 , a3 # a, a, j addi.n a3 , a3 , 1 # j, j, bnei a3 , 10 , .L2033 # j,, ret.n As you can see here, both loops generate the same assembly for fixed size loops. Let's now see for variable size loops. uint32_t Example ( uint32_t a , uint32_t b ) { for ( uint8_t i = 0 ; i < b ; i ++ ) { a += i ; } for ( uint32_t j = 0 ; j < b ; j ++ ) { a += j ; } return a ; } Assembly: _Z7Examplejj: movi.n a4 , 0 # i, <- loop 1 j .L2030 # .L2031: add.n a2 , a2 , a4 # a, a, i addi.n a4 , a4 , 1 # tmp48, i, extui a4 , a4 , 0 , 8 # i, tmp48 <- extra 32 to 8 bits conversion .L2030: bltu a4 , a3 , .L2031 # i, b, movi.n a4 , 0 # j, <- loop 2 j .L2032 # .L2033: add.n a2 , a2 , a4 # a, a, j addi.n a4 , a4 , 1 # j, j, .L2032: bne a4 , a3 , .L2033 # j, b, ret.n In the first loop, the register a4 needs to be converted from 32 bits to 8 bits in each iteration. Again, there is no definitive rule, but keep in mind that using uint8_t can sometimes increase code size compared to uint32_t . Floats, not doubles! ~ ESP8266 does not have a FPU (Floating Point Unit), all floating point operations are emulated in software and provided in libm.a . The linker removes any unused functions, so we need to limit the number of floating point function calls. Rule 1 : use ints where you can, avoid floating point operations. Rule 2 : if you really need floating point, always use float , never ever use double . Let's now see why. float fits in 32 bits, with a mantissa of 20 bits, exponent of TODO. The mantissa is 20 bits wide, which provides enough precision for most of our needs. float is 32 bits wide and fits in a single register, whereas double is 64 bits and requires 2 registers. float Examplef ( float a , float b ) { return sinf ( a ) * ( b + 0.4f ) - 3.5f ; } Assembly: .literal .LC1012 , 0x3ecccccd < - 0 .4f .literal .LC1013 , 0x40600000 < - 3 .5f _Z8Examplefff: addi sp , sp , -16 #,, <- reserve 16 bytes on stack s32i.n a0 , sp , 12 #, <- save a0 (return address) on stack s32i.n a12 , sp , 8 #, <- save a12 on stack, to free for local var s32i.n a13 , sp , 4 #, <- save a13 on stack, to free for local var mov.n a13 , a3 # b, b <- a3 holds 'b', save to a13 call0 sinf # <- calc sin of a2 (a) l32r a3 , .LC1012 #, <- load 0.4f in a3 mov.n a12 , a2 # D.171139, <- save result 'sin(a)' to a12 mov.n a2 , a13 #, b <- move a13 (second arg: b) to a2 call0 __addsf3 # <- add floats a2 and a3, result to a2 mov.n a3 , a2 # D.171139, <- copy result to a3 mov.n a2 , a12 #, D.171139 <- load a2 with a12: sin(a) call0 __mulsf3 # <- multiply 'sin(a)*(b+0.4f)' l32r a3 , .LC1013 #, <- load a3 with 3.5f call0 __subsf3 # <- substract l32i.n a0 , sp , 12 #, <- restore a0 (return address) l32i.n a12 , sp , 8 #, <- restore a12 l32i.n a13 , sp , 4 #, <- restore a13 addi sp , sp , 16 #,, <- free stack ret.n < - return Now with double : double Exampled ( double a , double b ) { return sin ( a ) * ( b + 0.4 ) - 3.5 ; } Assembly: .literal .LC1014 , 0x9999999a , 0x3fd99999 < - 0 .4 .literal .LC1015 , 0x00000000 , 0x400c0000 < - 3 .5 _Z8Exampleddd: addi sp , sp , -32 #,, s32i.n a0 , sp , 28 #, s32i.n a12 , sp , 24 #, s32i.n a13 , sp , 20 #, s32i.n a14 , sp , 16 #, s32i.n a15 , sp , 12 #, mov.n a14 , a4 #, mov.n a15 , a5 #, call0 sin # l32r a4 , .LC1014 #, l32r a5 , .LC1014 + 4 #, mov.n a12 , a2 #, mov.n a13 , a3 #, mov.n a2 , a14 #, mov.n a3 , a15 #, call0 __adddf3 # mov.n a4 , a2 #, mov.n a5 , a3 #, mov.n a2 , a12 #, mov.n a3 , a13 #, call0 __muldf3 # l32r a4 , .LC1015 #, l32r a5 , .LC1015 + 4 #, call0 __subdf3 # l32i.n a0 , sp , 28 #, l32i.n a12 , sp , 24 #, l32i.n a13 , sp , 20 #, l32i.n a14 , sp , 16 #, l32i.n a15 , sp , 12 #, addi sp , sp , 32 #,, ret.n As you can see the double needs to move many more registers around. Examplef (float) is 84 bytes, Exampled (double) is 119 bytes (+42% code size). Actually it's even worse, sin is larger than float version sinf . Also, never forget to explicitly tag literals as float: always put 1.5f and not 1.5 . Let's see the impact: float Examplef2 ( float a , float b ) { return sinf ( a ) * ( b + 0.4 ) - 3.5 ; // same as above with double literals } Assembly: .literal .LC1014 , 0x9999999a , 0x3fd99999 .literal .LC1015 , 0x00000000 , 0x400c0000 .align 4 .global _Z9Examplef2ff .type _Z9Examplef2ff , @function _Z9Examplef2ff: addi sp , sp , -16 #,, s32i.n a0 , sp , 12 #, s32i.n a12 , sp , 8 #, s32i.n a13 , sp , 4 #, s32i.n a14 , sp , 0 #, mov.n a14 , a3 # b, b call0 sinf # call0 __extendsfdf2 # <- extend float to double mov.n a12 , a2 #, mov.n a2 , a14 #, b mov.n a13 , a3 #, call0 __extendsfdf2 # <- extend float to double l32r a4 , .LC1014 #, l32r a5 , .LC1014 + 4 #, call0 __adddf3 # <- add double mov.n a4 , a2 #, mov.n a5 , a3 #, mov.n a2 , a12 #, mov.n a3 , a13 #, call0 __muldf3 # <- multiply double l32r a4 , .LC1015 #, l32r a5 , .LC1015 + 4 #, call0 __subdf3 # <- substract double call0 __truncdfsf2 # <- truncate double to float l32i.n a0 , sp , 12 #, l32i.n a12 , sp , 8 #, l32i.n a13 , sp , 4 #, l32i.n a14 , sp , 0 #, addi sp , sp , 16 #,, ret.n The last example takes 143 bytes, which is even worse than the double version, because of conversions from float to double and back. Internally, if you don't force float literals, gcc will make all intermediate compute in double and convert to float in the end. This is usually what is wanted: compute with maximum precision and truncate at the last moment. But for ESP8266 we want the opposite: most compact code. String concatenation ~ Let's start with an easy example: void ExampleStringConcat ( String & s ) { s += \"suffix\" ; } Assembly (25 bytes): .LC1024: .string \"suffix\" .literal .LC1025 , .LC1024 _Z19ExampleStringConcatR6String: l32r a3 , .LC1025 #, addi sp , sp , -16 #,, s32i.n a0 , sp , 12 #, call0 _ZN6String6concatEPKc # l32i.n a0 , sp , 12 #, addi sp , sp , 16 #,, ret.n If you need to add more complex strings, do not concatenate using native c++ concat: void ExampleStringConcat2 ( String & s , uint8_t a , uint8_t b ) { s += \"[\" + String ( a ) + \",\" + String ( b ) + \"]\" ; } Assembly (122 bytes!): .LC231: .string \",\" .LC1026: .string \"[\" .LC1029: .string \"]\" .literal .LC1027 , .LC1026 .literal .LC1028 , .LC231 .literal .LC1030 , .LC1029 _Z20ExampleStringConcat2R6Stringhh: addi sp , sp , -64 #,, s32i.n a13 , sp , 52 #, extui a13 , a3 , 0 , 8 # a, a l32r a3 , .LC1027 #, s32i.n a12 , sp , 56 #, mov.n a12 , a2 # s, s addi.n a2 , sp , 12 #,, s32i.n a0 , sp , 60 #, s32i.n a14 , sp , 48 #, extui a14 , a4 , 0 , 8 # b, b call0 _ZN6StringC2EPKc # . <- allocate String movi.n a4 , 0xa #, addi a2 , sp , 24 #,, mov.n a3 , a13 #, a call0 _ZN6StringC1Ehh # <- allocate String addi a3 , sp , 24 #,, addi.n a2 , sp , 12 #,, call0 _ZplRK15StringSumHelperRK6String # l32r a3 , .LC1028 #, call0 _ZplRK15StringSumHelperPKc # movi.n a4 , 0xa #, mov.n a13 , a2 # D.171315, mov.n a3 , a14 #, b mov.n a2 , sp #, call0 _ZN6StringC1Ehh # <- allocate String mov.n a3 , sp #, mov.n a2 , a13 #, D.171315 call0 _ZplRK15StringSumHelperRK6String # l32r a3 , .LC1030 #, call0 _ZplRK15StringSumHelperPKc # mov.n a3 , a2 # D.171315, mov.n a2 , a12 #, s call0 _ZN6String6concatERKS_ # mov.n a2 , sp #, call0 _ZN6StringD1Ev # <- destructor addi a2 , sp , 24 #,, call0 _ZN6StringD1Ev # <- destructor addi.n a2 , sp , 12 #,, call0 _ZN6StringD2Ev # <- destructor l32i.n a0 , sp , 60 #, l32i.n a12 , sp , 56 #, l32i.n a13 , sp , 52 #, l32i.n a14 , sp , 48 #, addi sp , sp , 64 #,, ret.n Instead use native String concat: void ExampleStringConcat3 ( String & s , uint8_t a , uint8_t b ) { s += \"[\" ; s += a ; s += \",\" ; s += b ; s += \"]\" ; } Assembly (69 bytes, -43%): .LC231: .string \",\" .LC1026: .string \"[\" .LC1029: .string \"]\" .literal .LC1031 , .LC1026 .literal .LC1032 , .LC231 .literal .LC1033 , .LC1029 _Z20ExampleStringConcat3R6Stringhh: addi sp , sp , -16 #,, s32i.n a13 , sp , 4 #, extui a13 , a3 , 0 , 8 # a, a l32r a3 , .LC1031 #, s32i.n a0 , sp , 12 #, s32i.n a12 , sp , 8 #, s32i.n a14 , sp , 0 #, mov.n a12 , a2 # s, s extui a14 , a4 , 0 , 8 # b, b call0 _ZN6String6concatEPKc # <- native char* add mov.n a3 , a13 #, a mov.n a2 , a12 #, s call0 _ZN6String6concatEh # <- native int add l32r a3 , .LC1032 #, mov.n a2 , a12 #, s call0 _ZN6String6concatEPKc # <- native char* add mov.n a3 , a14 #, b mov.n a2 , a12 #, s call0 _ZN6String6concatEh # <- native int add l32r a3 , .LC1033 #, mov.n a2 , a12 #, s call0 _ZN6String6concatEPKc # <- native char* add l32i.n a0 , sp , 12 #, l32i.n a12 , sp , 8 #, l32i.n a13 , sp , 4 #, l32i.n a14 , sp , 0 #, addi sp , sp , 16 #,, ret.n","title":"Sensor API"},{"location":"Sensor-API/#important-things-to-consider","text":"There are several I 2 C sensor examples you can take from the development codebase when writing your own and you are encouraged to do this as it is a quick and easy way to see how things fit together. The Tasmota firmware is essentially intended for ESP8266/ESP8285 Wi-Fi SoC based devices and commits to the main development branch will be subject to review based on whether or not what you intend to develop or add to the existing code is relevant to the general ESP device users. That being said, there is a lot of development going into the firmware which extends the functionality of standard off the shelf Sonoff devices. The firmware in itself is also useful for boards such as the WeMos ESP82xx boards. More technically inclined individuals who use generic ESP82xx modules in their own circuits to provide more access to pins and the ability to add more sensors and hardware external to the device or the generic ESP82xx module circuits can also take advantage of Tasmota. The resources on the ESP82xx are finite. Most devices ship with 1MByte SPI flash which means for the generic device users, the code generally needs to be less than 502KBytes to ensure that OTA (Over The Air) flash functionality (which is the main reason why people use this firmware) remains available. RAM is also limited to an absolute maximum of 80KBytes. This memory is divided into heap (used by global variables and Strings) and stack (used by local variables) where stack space is just 4KBytes. Given the above resource constraints its important to keep your code as small as possible, as fast running as possible, and use as little RAM as possible. You need to think about these resource constraints all the time whilst doing any development you wish to add to the firmware functionality - Face the fact that microcontroller development isn't as close a relative to standard computer programming as you'd expect. You will be adding code to an existing framework which requires you to adhere to some simple but strict rules such as not having any infinite loops like you would have in your generic Arduino code and try to avoid using the delay() functions when writing your code as this will cause the entire firmware to be subjected to the delays you have added - Infinite loops will cause the firmware to lock up completely! If your sensor has configuration options please make these available by using the SensorXX framework which is already incorporated in the base code - This may not stop you from using a web-based configuration interface but since web-based configuration takes up a lot of code space in flash it is very important to make this optional by means of a compiler directive or a #define in the configuration file and as such something you need to keep in mind during your development and debugging - The more progressively optional additional features are in your driver the smaller the basic codebase can be for minimalist implementations. Whilst developing drivers for devices that use the I 2 C bus always consider other devices already supported in the codebase which may use the same address range. This could mean you need to find a unique way of differentiating your device detection from other devices on the same address range (e.g. querying a model-specific register) and/or disabling by #undef existing devices if yours is selected with a #define statement and in such cases always provide a warning to the user during compile time using the #warning pragma such as including #warning **** Turned off conflicting drivers SHT and VEML6070 **** in your code. DO NOT ADD WEB INTERFACE FOR SENSOR CONFIGURATION if your sensor requires additional user configuration. The reason for this is the additional program memory required but most importantly the amount of RAM required to even create minimal user interfaces. Running out of RAM during runtime will lead to abnormal behaviour of your driver and/or other drivers or the entire firmware! See sensors such as the MCP23008/MCP23017 driver on more information on how to implement SensorXX commands instead! While developing you might want to enable additional debugging provided by file xdrv_99_debug.ino using #define USE_DEBUG_DRIVER which provides some commands for managing configuration settings and CPU timing. In addition you can enable define PROFILE_XSNS_SENSOR_EVERY_SECOND to profile your drivers duration. Do not assume others will know immediately how to use your addition and know that you will need to write a Wiki for it in the end.","title":"Important things to consider"},{"location":"Sensor-API/#managing-a-forked-branch","text":"If you plan to submit a PR bigger than a simple change in one file, here is a short intro about how to do a clean PR. fork the Tasmota repository in Github git clone https://github.com/<github_user>/Tasmota.git and work on your local copy git remote add upstream https://github.com/arendst/Tasmota.git git checkout development git checkout -b <temp_branch> to create a working branch where you can push commits git push --set-upstream origin <temp_branch> work on your local version and push as many commits as you want When you think it is ready to merge and submit a PR: git checkout development to go back to the main branch git pull upstream development to update all the latest changes git push to update your fork git checkout -b <pr_branch> to create a new branch for the final PR git push --set-upstream origin <pr_branch> Merge the edits but be sure to remove the history of your local commits git merge --squash <temp_branch> git commit -m \"Message\" Now you have a clean single commit from which you can create the PR on the Tasmota Github.","title":"Managing a Forked Branch"},{"location":"Sensor-API/#directoryfile-structure","text":"Sensor libraries are located in the lib/ directory. Sensor drivers are located in the tasmota/ directory. The filename of the sensor driver is xsns_<driver_ID>_<driver_name>.ino , e.g. xsns_05_ds18b20.ino where <driver_ID> is a unique number between 01 and 90 and <driver_name> is a human-readable name of the driver. Using generic libraries from external sources for sensors should be avoided as far as possible as they usually include code for other platforms and are not always written in an optimized way.","title":"Directory/file structure"},{"location":"Sensor-API/#api-structure","text":"","title":"API structure"},{"location":"Sensor-API/#pre-processor-directives","text":"Conditional compiling of a sensor driver is achieved by adding a pre-processor directive of the scheme USE_<driver_name> in my_user_config.h . Accordingly the driver code has to be wrapped in #ifdef USE_<driver_name> ... #endif // USE_<driver_name> . Any Sensor driver must contain a pre-processor directive defining the driver ID by the scheme #define XSNS_<driver_ID> .","title":"Pre-processor directives"},{"location":"Sensor-API/#callback-function","text":"Any sensor driver needs a callback function following the scheme // Conditional compilation of driver #ifdef USE_<driver_name> // Define driver ID #define XSNS_<driver_ID> <driver_ID> /** * The callback function Xsns<driver_ID>() interfaces Tasmota with the sensor driver. * * It provides the Tasmota callback IDs. * * @param byte callback_id Tasmota function ID. * @return boolean Return value. * @pre None. * @post None. * */ boolean Xsns < driverID > ( byte callback_id ) { // Set return value to `false` boolean result = false ; // Check if I2C interface mode // if(i2c_flg) { // Check which callback ID is called by Tasmota switch ( callback_id ) { case FUNC_INIT : break ; case FUNC_EVERY_50_MSECOND : break ; case FUNC_EVERY_SECOND : break ; case FUNC_JSON_APPEND : break ; #ifdef USE_WEBSERVER case FUNC_WEB_APPEND : break ; #endif // USE_WEBSERVER case FUNC_SAVE_BEFORE_RESTART : break ; case FUNC_COMMAND : break ; } // } // if(i2c_flg) // Return boolean result return result ; } #endif // USE_<driver_name>","title":"Callback function"},{"location":"Sensor-API/#callback-ids","text":"FUNC_INIT This callback ID is called when sensor drivers should be initialized. FUNC_EVERY_50_MSECOND This callback ID is called every 50 milliseconds, e.g. for near real-time operation FUNC_EVERY_SECOND This callback ID is called every second. It can be useful for anything that you need to do on a per second basis and is commonly used as an entry point to detect a driver or initialize an externally driven device such as a sensor, relay board or other forms of input/output required by your driver. You would normally want to make sure you've detected and initialised before it is used by JSON_APPEND , etc. so that its ready to serve data. The generally accepted way to use this would be to detect your sensor and once this is done set a sensor value accordingly so that the function does not use unnecessary resources during future calls, for example: void MySensorDetect () { if ( MySensorDetected ) { return ; } /* * Perform the code which needs to be completed to * detect your sensor and then set MySensorDetected to * a non-zero value which will prevent this section * of your code to re-run every time the function is * called. * * Under normal circumstances you'd not need to do * re-detect or initialise your sensor once it has been * done */ } Setting a flag that the driver was successful in detecting the attached chip/board via I 2 C or SPI will prevent it from continuously trying to initialize an already initialized device. When writing your function responsible for detecting an externally connected I 2 C device try to create a method by which you read or write to specific registers that would be applicable to that specific I 2 C device only as to confirm a positive detect for the device. If this is not done extensively it will lead to some drivers getting false detects for a different device type simply because it shares the same I 2 C address. Unless your driver is specifically going to use the entire array of addresses provisioned by the manufacturer please consider using a #define USE_MYCHIPNAME_ADDR in the my_user_config.h so that the user may specify the address on which to expect the device. This is of course only applicable to drivers that are not enabled by default in any of the pre-built binaries. I 2 C address auto-detection example #define MPR121_I2C_ADDR_1ST 0x5A /** 1st I2C address of sensor model **/ #define MPR121_I2C_ADDR_NUM 4 /** Number of sensors/I2C addresses **/ #define MPR121_I2C_ID_REG 0x5D /** Sensor model specific ID register **/ #define MPR121_I2C_ID_VAL 0x24 /** Sensor model specific ID register value **/ /* Sensor data struct type declaration/default definition */ typedef struct { bool connected = false ; /** Status if sensor is connected at I2C address */ bool running = false ; /** Running state of sensor */ . . . } mpr121 ; // Declare array of sensor data structs mpr121 mpr121 [ MPR121_I2C_ADDR_NUM ]; // Sensor specific init function void mpr121_init () { // Loop through I2C addresses for ( uint8_t i = 0 ; i < MPR121_I2C_ADDR_NUM ); i ++ ) { // Check if sensor is connected on I2C address mpr121 [ i ]. connected = ( MPR121_I2C_ID_VAL == I2cRead8 ( MPR121_I2C_ADDR_1ST + i , MPR121_I2C_ID_REG ); if ( mpr121 [ i ]. connected ) { // Log sensor found snprintf_P ( log_data , sizeof ( log_data ), PSTR ( D_LOG_I2C \"MPR121-%d \" D_FOUND_AT \" 0x%X\" ), i , MPR121_I2C_ADDR_1ST + i ); AddLog ( LOG_LEVEL_INFO ); // Initialize sensor . . . // Set running to true mpr121 [ i ]. running = true ; } } if ( ! ( mpr121 [ 0 ]. connected || mpr121 [ 1 ]. connected || mpr121 [ 2 ]. connected || mpr121 [ 3 ]. connected )){ snprintf_P ( log_data , sizeof ( log_data ), PSTR ( D_LOG_I2C \"MPR121: No sensors found\" )); AddLog ( LOG_LEVEL_INFO ); } } Four advanced methods to use FUNC_EVERY_SECOND (Food for thought) : * If a sensor needs an action which takes a long time, like more than 100mS, the action will be started here for a future follow-up. Using the uptime variable for testing like (uptime &1) will happen every 2 seconds. An example is the DS18B20 driver where readings (conversions they call it) can take up to 800mS from the initial request. * If a sensor needed the previous action it is now time to gather the information and store it in a safe place to be used by FUNC_JSON_APPEND and/or FUNC_WEB_APPEND . Using the else function of the previous test (uptime &1) will happen every 2 seconds too but just 1 second later than the previous action. * If a sensor does not respond for 10 times the sensor detection flag could be reset which will stop further processing until the sensor is re-detected. This is currently not being used actively as some users complain about disappearing sensors for whatever reason - Could be hardware related but easier to make Tasmota a little more flexible. * Making re-detection of a sensor possible by executing this once every 100 seconds (94 == (uptime %100)) a re-attached sensor can be detected without a restart of Tasmota. The 94 given in this example should be different for every sensor driver to make sure not all sensors start detection at the same time. Using the drivers index number should be a good starting point. FUNC_PREP_BEFORE_TELEPERIOD NOTE: This callback ID is deprecated as sensors should prepare for more regular updates due to \"realtime\" rule execution. Use FUNC_EVERY_SECOND instead. See examples used in xsns_05_ds18x20.ino and xsns_09_bmp.ino where updated sensor data is stored in preparation to calls to FUNC_JSON_APPEND and FUNC_WEB_APPEND. FUNC_JSON_APPEND This callback ID is called when TelePeriod is due to append telemetry data to the MQTT JSON string or at approximately every 2 seconds when a rule is checked, e.g. snprintf_P ( mqtt_data , sizeof ( mqtt_data ), PSTR ( \"{ \\\" MPR121%c \\\" :{ \\\" Button%i \\\" :%i}}\" ), pS -> id [ i ], j , BITC ( i , j )); FUNC_WEB_APPEND This callback ID is called every millisecond when HTML code should be added to the Tasmota web-interface main page, e.g., snprintf_P ( mqtt_data , sizeof ( mqtt_data ), PSTR ( \"%s{s}MPR121%c Button%d{m}%d{e}\" ), mqtt_data , pS -> id [ i ], j , BITC ( i , j )); It should be wrapped in #ifdef USE_WEBSERVER ... #endif // USE_WEBSERVER FUNC_SAVE_BEFORE_RESTART This callback ID is called to allow a sensor to prepare for saving configuration changes. To be used to save volatile data just before a restart. Variables can be appended to struct SYSCFG {} Settings in file tasmota/settings.h . FUNC_COMMAND This callback ID is called when a sensor specific command Sensor<xx> or Driver<xx> is executed where xx is the sensor index. case FUNC_COMMAND : if ( XSNS_ < driver_ID > == XdrvMailbox . index ) { result = < driver_name > Command () { ... }; // Return true on success } break ; // Data struct of FUNC_COMMAND ID struct XDRVMAILBOX { uint16_t valid ; // ??? uint16_t index ; // Sensor index uint16_t data_len ; // Length of command string uint16_t payload16 ; // 16 bit unsigned int of payload if it could be converted, otherwise 0 int16_t payload ; // 16 bit signed int of payload if it could be converted, otherwise 0 uint8_t grpflg ; // ??? uint8_t notused ; // ??? char * topic ; // Command topic char * data ; // Command string/value - length of which is defined by data_len } XdrvMailbox ; If your driver needs to accept multiple parameters for SensorXX and/or DriverXX please consider using comma delimited formatting and use the already written subStr() function declared in support.ino to parse through the parameters you need. An example of those could be SensorXX reset // The reset parameter may be intercepted using: if ( ! strcmp ( subStr ( sub_string , XdrvMailbox . data , \",\" , 1 ), \"RESET\" )) { // Note 1 used for param number MyDriverName_Reset (); return serviced ; } Or in the case of multiple parameters SensorXX mode , 1 if ( ! strcmp ( subStr ( sub_string , XdrvMailbox . data , \",\" , 1 ), \"MODE\" )) { // Note 1 used for param number uint8_t mode = atoi ( subStr ( sub_string , XdrvMailbox . data , \",\" , 2 ); // Note 2 used for param number }","title":"Callback IDs"},{"location":"Sensor-API/#useful-functions","text":"","title":"Useful functions"},{"location":"Sensor-API/#mqtt","text":"void MqttPublishPrefixTopic_P ( uint8_t prefix , const char * subtopic , boolean retained ) This function publishes MQTT messages immediately, e.g., snprintf_P ( mqtt_data , sizeof ( mqtt_data ), PSTR ( \"{ \\\" MPR121%c \\\" :{ \\\" Button%i \\\" :%i}}\" ), pS -> id [ i ], j , BITC ( i , j )); MqttPublishPrefixTopic_P ( RESULT_OR_STAT , mqtt_data );","title":"MQTT"},{"location":"Sensor-API/#logging","text":"void AddLog ( byte loglevel ) This function adds log messages stored in log_data to the local logging system, e.g. snprintf_P ( log_data , sizeof ( log_data ), PSTR ( D_LOG_I2C \"MPR121(%c) \" D_FOUND_AT \" 0x%X\" ), pS -> id [ i ], pS -> i2c_addr [ i ]); AddLog ( LOG_LEVEL_INFO ); void AddLogSerial ( byte loglevel ) This function adds a log message to the local logging system dumping the serial buffer as hex information, e.g. AddLogSerial ( LOG_LEVEL_INFO ); void AddLogMissed ( char * sensor , uint8_t misses ) This function adds a log message to the local logging system about missed sensor reads.","title":"Logging"},{"location":"Sensor-API/#i2c-interface","text":"bool I2cValidRead8 ( uint8_t * data , uint8_t addr , uint8_t reg ) bool I2cValidRead16 ( uint16_t * data , uint8_t addr , uint8_t reg ) bool I2cValidReadS16 ( int16_t * data , uint8_t addr , uint8_t reg ) bool I2cValidRead16LE ( uint16_t * data , uint8_t addr , uint8_t reg ) bool I2cValidReadS16_LE ( int16_t * data , uint8_t addr , uint8_t reg ) bool I2cValidRead24 ( int32_t * data , uint8_t addr , uint8_t reg ) bool I2cValidRead ( uint8_t addr , uint8_t reg , uint8_t size ) These functions return true if 1, 2, 3 or size bytes can be read from the I 2 C address addr and register reg into *data . Functions with a S read signed data types while functions without a S read unsigned data types. Functions with LE read little-endian byte order while functions without LE read machine byte order. uint8_t I2cRead8 ( uint8_t addr , uint8_t reg ) uint16_t I2cRead16 ( uint8_t addr , uint8_t reg ) int16_t I2cReadS16 ( uint8_t addr , uint8_t reg ) uint16_t I2cRead16LE ( uint8_t addr , uint8_t reg ) int16_t I2cReadS16_LE ( uint8_t addr , uint8_t reg ) int32_t I2cRead24 ( uint8_t addr , uint8_t reg ) These functions return 1, 2 or 3 bytes from the I 2 C address addr and register reg . Functions with a S read signed data types while functions without a S read unsigned data types. Functions with LE read little endian byte order while functions without LE read machine byte order. bool I2cWrite8 ( uint8_t addr , uint8_t reg , uint8_t val ) bool I2cWrite16 ( uint8_t addr , uint8_t reg , uint16_t val ) bool I2cWrite ( uint8_t addr , uint8_t reg , uint32_t val , uint8_t size ) These functions return true after successfully writing 1, 2 or size bytes to the I 2 C address addr and register reg . int8_t I2cReadBuffer ( uint8_t addr , uint8_t reg , uint8_t * reg_data , uint16_t len ) int8_t I2cWriteBuffer ( uint8_t addr , uint8_t reg , uint8_t * reg_data , uint16_t len ) These functions copy len bytes from/to *reg_data starting at I 2 C address addr and register reg . void I2cScan ( char * devs , unsigned int devs_len ) This functions writes a list of I 2 C addresses in use into the string *dev with maximum length devs_len . bool I2cDevice ( byte addr ) This functions checks if the I 2 C address addr is in use.","title":"I2C Interface"},{"location":"Sensor-API/#useful-pre-processor-directives","text":"PSTR(\"string\") This pre-processor directive saves RAM by storing strings in flash instead of RAM. const char MyTextStaticVariable [] PROGMEM = \"string\" ; This pre-processor directive saves RAM by storing strings in flash instead of RAM. You may then reference them directly (if the type matches the parameter required) or force it to 4 byte alignment by using the variable as FPSTR(MyTextStaticVariable)","title":"Useful pre-processor directives"},{"location":"Sensor-API/#keeping-esp8266-code-compact","text":"Below are various tips and tricks to keep ESP8266 code compact and save both Flash and Memory. Flash code is limited to 1024k but keep in mind that to allow OTA upgrade, you need Flash memory to contain two firmwares at the same time. To go beyond 512k, you typically use tasmota-minimal as an intermediate firmware. tasmota-minimal takes roughly 360k, so it's safe not to go uint32_t beyond 620k of Flash. Memory is even more limited: 80k. With Arduino Core and basic Tasmota, there are 25k-30k left of heap space. Heap memory is very precious, running out of memory will generally cause a crash.","title":"Keeping ESP8266 code compact"},{"location":"Sensor-API/#about-esp8266","text":"ESP8266 is based on Xtensa instruction set . Xtensa is a 32 bits RISC processor core, containing 16 x 32 bits registers. ESP8266 supports integer operations, including 32x32 multiplication. It does not contain an FPU for floating point operations, nor integer divisions. Contrary to classical RISC processors, all instructions are 24 bits wide instead of 32 bits. To increase code compactness, some instructions have a 16 bits version used whenever possible by gcc. If you want to see what assembly is generated by gcc, in file platform.ini , at the section used to compile (ex: [core_2_6_1] ) in section build_flags add: -save-temps=obj -fverbose-asm Gcc will store <file>.s in the same folder as the .o file, typically in .pioenvs/ .","title":"About ESP8266"},{"location":"Sensor-API/#first-example","text":"Let's take a basic function: uint32_t Example ( uint32_t a , uint32_t b ) { return a + b ; } Below is the generated assembly. Function names are mangled using standard C++, i.e. their name derive from their arguments and return types: _Z7Examplejj: add.n a2 , a2 , a3 #, a, b ret.n As you can see, this is the simplest function we can think of. Register A2 holds the first argument and is used for return value. A3 holds the second argument.","title":"First example"},{"location":"Sensor-API/#uint8_t-or-uint32_t","text":"uint32_t Example ( uint32_t a , uint32_t b ) { uint8_t c = a + b ; return c ; } Assembly: _Z7Examplejj: add.n a2 , a2 , a3 # tmp52, a, b extui a2 , a2 , 0 , 8 #, tmp52 ret.n Whenever gcc needs to convert from uin32_t to uint8_t , it uses an extra instruction extui <reg>, <reg>, 0, 8 . Whenever you allocate uint8_t as a local variable, it will anyways allocate 32 bits on the stack. In conclusion you can easily use uint32_t in many places in the code. The main reason to force uint8_t are: in structures, to save memory. This is the only place where uint8_t will take 1 byte and the compiler will try to pack as much as 4 uint8_t in 32 bits when you want to ensure that the value can never exceed 255. Beware though that the compiler will just chunk the last 8 bits of a 32 bits value and will not report any overflow.","title":"uint8_t or uint32_t ?"},{"location":"Sensor-API/#loops","text":"Should you use uint8_t or uint32_t for loops? Let's try: uint32_t Example ( uint32_t a , uint32_t b ) { for ( uint8_t i = 0 ; i < 10 ; i ++ ) { a += b ; } for ( uint32_t j = 0 ; j < 10 ; j ++ ) { a += b ; } return a ; } Assembly: _Z7Examplejj: movi.n a3 , 0 # ivtmp$7334, <- loop 1 .L2031: add.n a2 , a2 , a3 # a, a, ivtmp$7334 addi.n a3 , a3 , 1 # ivtmp$7334, ivtmp$7334, bnei a3 , 10 , .L2031 # ivtmp$7334,, movi.n a3 , 0 # j, <- loop 2 .L2033: add.n a2 , a2 , a3 # a, a, j addi.n a3 , a3 , 1 # j, j, bnei a3 , 10 , .L2033 # j,, ret.n As you can see here, both loops generate the same assembly for fixed size loops. Let's now see for variable size loops. uint32_t Example ( uint32_t a , uint32_t b ) { for ( uint8_t i = 0 ; i < b ; i ++ ) { a += i ; } for ( uint32_t j = 0 ; j < b ; j ++ ) { a += j ; } return a ; } Assembly: _Z7Examplejj: movi.n a4 , 0 # i, <- loop 1 j .L2030 # .L2031: add.n a2 , a2 , a4 # a, a, i addi.n a4 , a4 , 1 # tmp48, i, extui a4 , a4 , 0 , 8 # i, tmp48 <- extra 32 to 8 bits conversion .L2030: bltu a4 , a3 , .L2031 # i, b, movi.n a4 , 0 # j, <- loop 2 j .L2032 # .L2033: add.n a2 , a2 , a4 # a, a, j addi.n a4 , a4 , 1 # j, j, .L2032: bne a4 , a3 , .L2033 # j, b, ret.n In the first loop, the register a4 needs to be converted from 32 bits to 8 bits in each iteration. Again, there is no definitive rule, but keep in mind that using uint8_t can sometimes increase code size compared to uint32_t .","title":"Loops"},{"location":"Sensor-API/#floats-not-doubles","text":"ESP8266 does not have a FPU (Floating Point Unit), all floating point operations are emulated in software and provided in libm.a . The linker removes any unused functions, so we need to limit the number of floating point function calls. Rule 1 : use ints where you can, avoid floating point operations. Rule 2 : if you really need floating point, always use float , never ever use double . Let's now see why. float fits in 32 bits, with a mantissa of 20 bits, exponent of TODO. The mantissa is 20 bits wide, which provides enough precision for most of our needs. float is 32 bits wide and fits in a single register, whereas double is 64 bits and requires 2 registers. float Examplef ( float a , float b ) { return sinf ( a ) * ( b + 0.4f ) - 3.5f ; } Assembly: .literal .LC1012 , 0x3ecccccd < - 0 .4f .literal .LC1013 , 0x40600000 < - 3 .5f _Z8Examplefff: addi sp , sp , -16 #,, <- reserve 16 bytes on stack s32i.n a0 , sp , 12 #, <- save a0 (return address) on stack s32i.n a12 , sp , 8 #, <- save a12 on stack, to free for local var s32i.n a13 , sp , 4 #, <- save a13 on stack, to free for local var mov.n a13 , a3 # b, b <- a3 holds 'b', save to a13 call0 sinf # <- calc sin of a2 (a) l32r a3 , .LC1012 #, <- load 0.4f in a3 mov.n a12 , a2 # D.171139, <- save result 'sin(a)' to a12 mov.n a2 , a13 #, b <- move a13 (second arg: b) to a2 call0 __addsf3 # <- add floats a2 and a3, result to a2 mov.n a3 , a2 # D.171139, <- copy result to a3 mov.n a2 , a12 #, D.171139 <- load a2 with a12: sin(a) call0 __mulsf3 # <- multiply 'sin(a)*(b+0.4f)' l32r a3 , .LC1013 #, <- load a3 with 3.5f call0 __subsf3 # <- substract l32i.n a0 , sp , 12 #, <- restore a0 (return address) l32i.n a12 , sp , 8 #, <- restore a12 l32i.n a13 , sp , 4 #, <- restore a13 addi sp , sp , 16 #,, <- free stack ret.n < - return Now with double : double Exampled ( double a , double b ) { return sin ( a ) * ( b + 0.4 ) - 3.5 ; } Assembly: .literal .LC1014 , 0x9999999a , 0x3fd99999 < - 0 .4 .literal .LC1015 , 0x00000000 , 0x400c0000 < - 3 .5 _Z8Exampleddd: addi sp , sp , -32 #,, s32i.n a0 , sp , 28 #, s32i.n a12 , sp , 24 #, s32i.n a13 , sp , 20 #, s32i.n a14 , sp , 16 #, s32i.n a15 , sp , 12 #, mov.n a14 , a4 #, mov.n a15 , a5 #, call0 sin # l32r a4 , .LC1014 #, l32r a5 , .LC1014 + 4 #, mov.n a12 , a2 #, mov.n a13 , a3 #, mov.n a2 , a14 #, mov.n a3 , a15 #, call0 __adddf3 # mov.n a4 , a2 #, mov.n a5 , a3 #, mov.n a2 , a12 #, mov.n a3 , a13 #, call0 __muldf3 # l32r a4 , .LC1015 #, l32r a5 , .LC1015 + 4 #, call0 __subdf3 # l32i.n a0 , sp , 28 #, l32i.n a12 , sp , 24 #, l32i.n a13 , sp , 20 #, l32i.n a14 , sp , 16 #, l32i.n a15 , sp , 12 #, addi sp , sp , 32 #,, ret.n As you can see the double needs to move many more registers around. Examplef (float) is 84 bytes, Exampled (double) is 119 bytes (+42% code size). Actually it's even worse, sin is larger than float version sinf . Also, never forget to explicitly tag literals as float: always put 1.5f and not 1.5 . Let's see the impact: float Examplef2 ( float a , float b ) { return sinf ( a ) * ( b + 0.4 ) - 3.5 ; // same as above with double literals } Assembly: .literal .LC1014 , 0x9999999a , 0x3fd99999 .literal .LC1015 , 0x00000000 , 0x400c0000 .align 4 .global _Z9Examplef2ff .type _Z9Examplef2ff , @function _Z9Examplef2ff: addi sp , sp , -16 #,, s32i.n a0 , sp , 12 #, s32i.n a12 , sp , 8 #, s32i.n a13 , sp , 4 #, s32i.n a14 , sp , 0 #, mov.n a14 , a3 # b, b call0 sinf # call0 __extendsfdf2 # <- extend float to double mov.n a12 , a2 #, mov.n a2 , a14 #, b mov.n a13 , a3 #, call0 __extendsfdf2 # <- extend float to double l32r a4 , .LC1014 #, l32r a5 , .LC1014 + 4 #, call0 __adddf3 # <- add double mov.n a4 , a2 #, mov.n a5 , a3 #, mov.n a2 , a12 #, mov.n a3 , a13 #, call0 __muldf3 # <- multiply double l32r a4 , .LC1015 #, l32r a5 , .LC1015 + 4 #, call0 __subdf3 # <- substract double call0 __truncdfsf2 # <- truncate double to float l32i.n a0 , sp , 12 #, l32i.n a12 , sp , 8 #, l32i.n a13 , sp , 4 #, l32i.n a14 , sp , 0 #, addi sp , sp , 16 #,, ret.n The last example takes 143 bytes, which is even worse than the double version, because of conversions from float to double and back. Internally, if you don't force float literals, gcc will make all intermediate compute in double and convert to float in the end. This is usually what is wanted: compute with maximum precision and truncate at the last moment. But for ESP8266 we want the opposite: most compact code.","title":"Floats, not doubles!"},{"location":"Sensor-API/#string-concatenation","text":"Let's start with an easy example: void ExampleStringConcat ( String & s ) { s += \"suffix\" ; } Assembly (25 bytes): .LC1024: .string \"suffix\" .literal .LC1025 , .LC1024 _Z19ExampleStringConcatR6String: l32r a3 , .LC1025 #, addi sp , sp , -16 #,, s32i.n a0 , sp , 12 #, call0 _ZN6String6concatEPKc # l32i.n a0 , sp , 12 #, addi sp , sp , 16 #,, ret.n If you need to add more complex strings, do not concatenate using native c++ concat: void ExampleStringConcat2 ( String & s , uint8_t a , uint8_t b ) { s += \"[\" + String ( a ) + \",\" + String ( b ) + \"]\" ; } Assembly (122 bytes!): .LC231: .string \",\" .LC1026: .string \"[\" .LC1029: .string \"]\" .literal .LC1027 , .LC1026 .literal .LC1028 , .LC231 .literal .LC1030 , .LC1029 _Z20ExampleStringConcat2R6Stringhh: addi sp , sp , -64 #,, s32i.n a13 , sp , 52 #, extui a13 , a3 , 0 , 8 # a, a l32r a3 , .LC1027 #, s32i.n a12 , sp , 56 #, mov.n a12 , a2 # s, s addi.n a2 , sp , 12 #,, s32i.n a0 , sp , 60 #, s32i.n a14 , sp , 48 #, extui a14 , a4 , 0 , 8 # b, b call0 _ZN6StringC2EPKc # . <- allocate String movi.n a4 , 0xa #, addi a2 , sp , 24 #,, mov.n a3 , a13 #, a call0 _ZN6StringC1Ehh # <- allocate String addi a3 , sp , 24 #,, addi.n a2 , sp , 12 #,, call0 _ZplRK15StringSumHelperRK6String # l32r a3 , .LC1028 #, call0 _ZplRK15StringSumHelperPKc # movi.n a4 , 0xa #, mov.n a13 , a2 # D.171315, mov.n a3 , a14 #, b mov.n a2 , sp #, call0 _ZN6StringC1Ehh # <- allocate String mov.n a3 , sp #, mov.n a2 , a13 #, D.171315 call0 _ZplRK15StringSumHelperRK6String # l32r a3 , .LC1030 #, call0 _ZplRK15StringSumHelperPKc # mov.n a3 , a2 # D.171315, mov.n a2 , a12 #, s call0 _ZN6String6concatERKS_ # mov.n a2 , sp #, call0 _ZN6StringD1Ev # <- destructor addi a2 , sp , 24 #,, call0 _ZN6StringD1Ev # <- destructor addi.n a2 , sp , 12 #,, call0 _ZN6StringD2Ev # <- destructor l32i.n a0 , sp , 60 #, l32i.n a12 , sp , 56 #, l32i.n a13 , sp , 52 #, l32i.n a14 , sp , 48 #, addi sp , sp , 64 #,, ret.n Instead use native String concat: void ExampleStringConcat3 ( String & s , uint8_t a , uint8_t b ) { s += \"[\" ; s += a ; s += \",\" ; s += b ; s += \"]\" ; } Assembly (69 bytes, -43%): .LC231: .string \",\" .LC1026: .string \"[\" .LC1029: .string \"]\" .literal .LC1031 , .LC1026 .literal .LC1032 , .LC231 .literal .LC1033 , .LC1029 _Z20ExampleStringConcat3R6Stringhh: addi sp , sp , -16 #,, s32i.n a13 , sp , 4 #, extui a13 , a3 , 0 , 8 # a, a l32r a3 , .LC1031 #, s32i.n a0 , sp , 12 #, s32i.n a12 , sp , 8 #, s32i.n a14 , sp , 0 #, mov.n a12 , a2 # s, s extui a14 , a4 , 0 , 8 # b, b call0 _ZN6String6concatEPKc # <- native char* add mov.n a3 , a13 #, a mov.n a2 , a12 #, s call0 _ZN6String6concatEh # <- native int add l32r a3 , .LC1032 #, mov.n a2 , a12 #, s call0 _ZN6String6concatEPKc # <- native char* add mov.n a3 , a14 #, b mov.n a2 , a12 #, s call0 _ZN6String6concatEh # <- native int add l32r a3 , .LC1033 #, mov.n a2 , a12 #, s call0 _ZN6String6concatEPKc # <- native char* add l32i.n a0 , sp , 12 #, l32i.n a12 , sp , 8 #, l32i.n a13 , sp , 4 #, l32i.n a14 , sp , 0 #, addi sp , sp , 16 #,, ret.n","title":"String concatenation"},{"location":"Sensor-Configuration/","text":"","title":"Sensor Configuration"},{"location":"Serial-to-TCP-Bridge/","text":"Serial to TCP Bridge ~ Connect to a serial device over the network Needs #define USE_TCP_BRIDGE . This is available in the zbbridge build so you can use that or compile your own build . This feature can be used to add a \"serial to network\" functionality to a device that is otherwise serial only. You connect the device to a ESP8266/ESP32 and Tasmota will bridge between serial and network. This is commonly used with a CCxxxx Zigbee based module to connect it to a remote ZHA or zigbee2mqtt instance. Commands ~ TCPBaudRate <x> : sets the baudrate for serial (only 8N1 mode), min 1200 , max 115200 by 1200 increments. TCPStart <port> : listens to port <port> . This features supports 2 parallel TCP connections, which can be useful if you need a terminal + a specific protocol (like XMODEM). The 3rd connection will disconnect an previous connection. The number of parallel connections is a compile-time option. TCPStart 0 or TCPStart : shuts down the TCP server and disconnects any existing connection. For security reasons, the TCP bridge is not started at boot, and requires an explicit TCPStart command (can be automated with Rules). Configuration ~ First assign two GPIOs to TCP Tx (208) and TCP Rx (209) types in the \"Configure Module\" page. The Rx/Tx are relative to the ESP device. For example with ESP01's hardware serial, set GPIO1 as TCP Tx and GPIO3 as TCP Rx. Then set baud rate with TCPBaudRate and port with TCPStart . You can add a rule to start the TCP server at boot. To do this for port 8888, run Rule1 ON System#Boot do TCPStart 8888 endon then enable with Rule1 1 and restart the device. Additional resources ~ PR Sonoff ZBBridge reference","title":"Serial to TCP Bridge"},{"location":"Serial-to-TCP-Bridge/#serial-to-tcp-bridge","text":"Connect to a serial device over the network Needs #define USE_TCP_BRIDGE . This is available in the zbbridge build so you can use that or compile your own build . This feature can be used to add a \"serial to network\" functionality to a device that is otherwise serial only. You connect the device to a ESP8266/ESP32 and Tasmota will bridge between serial and network. This is commonly used with a CCxxxx Zigbee based module to connect it to a remote ZHA or zigbee2mqtt instance.","title":"Serial to TCP Bridge"},{"location":"Serial-to-TCP-Bridge/#commands","text":"TCPBaudRate <x> : sets the baudrate for serial (only 8N1 mode), min 1200 , max 115200 by 1200 increments. TCPStart <port> : listens to port <port> . This features supports 2 parallel TCP connections, which can be useful if you need a terminal + a specific protocol (like XMODEM). The 3rd connection will disconnect an previous connection. The number of parallel connections is a compile-time option. TCPStart 0 or TCPStart : shuts down the TCP server and disconnects any existing connection. For security reasons, the TCP bridge is not started at boot, and requires an explicit TCPStart command (can be automated with Rules).","title":"Commands"},{"location":"Serial-to-TCP-Bridge/#configuration","text":"First assign two GPIOs to TCP Tx (208) and TCP Rx (209) types in the \"Configure Module\" page. The Rx/Tx are relative to the ESP device. For example with ESP01's hardware serial, set GPIO1 as TCP Tx and GPIO3 as TCP Rx. Then set baud rate with TCPBaudRate and port with TCPStart . You can add a rule to start the TCP server at boot. To do this for port 8888, run Rule1 ON System#Boot do TCPStart 8888 endon then enable with Rule1 1 and restart the device.","title":"Configuration"},{"location":"Serial-to-TCP-Bridge/#additional-resources","text":"PR Sonoff ZBBridge reference","title":"Additional resources"},{"location":"SetOption36/","text":"SetOption36 is deprecated in favour of using the sleep command to use either Dynamic or Normal sleep as from Tasmota version 6.3.0.15. Click here for Dynamic Sleep","title":"SetOption36"},{"location":"SetOption37/","text":"SetOption37 is used for re-mapping the RGBW c W w channels. This transformation happens right before the hardware-specific output, so all the advanced features (schemes, hsb setting, etc.) works with the original, un-mapped values. The main reason for this option is to provide support for bulbs whose physical wiring is almost the usual/standard one, but the channels are arranged in a different way. For technical reasons this transformation isn't a full N-to-N mapping, it can only the re-arrange the channels, which is equivalent to map the (R,G,B,W c ,W w ) channels to one of their permutations. The required permutation can be configured via SetOption37 n , where n is the systematic index of the permutation, a number from the [0 .. 119] interval, from 0=(R,G,B,W c ,W w ) to 119=(W w ,W c ,B,G,R): Idx Perm. Idx Perm. Idx Perm. Idx Perm. 0 R,G,B,W c ,W w 1 R,G,B,W w ,W c 2 R,G,W c ,B,W w 3 R,G,W c ,W w ,B 4 R,G,W w ,B,W c 5 R,G,W w ,W c ,B 6 R,B,G,W c ,W w 7 R,B,G,W w ,W c 8 R,B,W c ,G,W w 9 R,B,W c ,W w ,G 10 R,B,W w ,G,W c 11 R,B,W w ,W c ,G 12 R,W c ,G,B,W w 13 R,W c ,G,W w ,B 14 R,W c ,B,G,W w 15 R,W c ,B,W w ,G 16 R,W c ,W w ,G,B 17 R,W c ,W w ,B,G 18 R,W w ,G,B,W c 19 R,W w ,G,W c ,B 20 R,W w ,B,G,W c 21 R,W w ,B,W c ,G 22 R,W w ,W c ,G,B 23 R,W w ,W c ,B,G 24 G,R,B,W c ,W w 25 G,R,B,W w ,W c 26 G,R,W c ,B,W w 27 G,R,W c ,W w ,B 28 G,R,W w ,B,W c 29 G,R,W w ,W c ,B 30 G,B,R,W c ,W w 31 G,B,R,W w ,W c 32 G,B,W c ,R,W w 33 G,B,W c ,W w ,R 34 G,B,W w ,R,W c 35 G,B,W w ,W c ,R 36 G,W c ,R,B,W w 37 G,W c ,R,W w ,B 38 G,W c ,B,R,W w 39 G,W c ,B,W w ,R 40 G,W c ,W w ,R,B 41 G,W c ,W w ,B,R 42 G,W w ,R,B,W c 43 G,W w ,R,W c ,B 44 G,W w ,B,R,W c 45 G,W w ,B,W c ,R 46 G,W w ,W c ,R,B 47 G,W w ,W c ,B,R 48 B,R,G,W c ,W w 49 B,R,G,W w ,W c 50 B,R,W c ,G,W w 51 B,R,W c ,W w ,G 52 B,R,W w ,G,W c 53 B,R,W w ,W c ,G 54 B,G,R,W c ,W w 55 B,G,R,W w ,W c 56 B,G,W c ,R,W w 57 B,G,W c ,W w ,R 58 B,G,W w ,R,W c 59 B,G,W w ,W c ,R 60 B,W c ,R,G,W w 61 B,W c ,R,W w ,G 62 B,W c ,G,R,W w 63 B,W c ,G,W w ,R 64 B,W c ,W w ,R,G 65 B,W c ,W w ,G,R 66 B,W w ,R,G,W c 67 B,W w ,R,W c ,G 68 B,W w ,G,R,W c 69 B,W w ,G,W c ,R 70 B,W w ,W c ,R,G 71 B,W w ,W c ,G,R 72 W c ,R,G,B,W w 73 W c ,R,G,W w ,B 74 W c ,R,B,G,W w 75 W c ,R,B,W w ,G 76 W c ,R,W w ,G,B 77 W c ,R,W w ,B,G 78 W c ,G,R,B,W w 79 W c ,G,R,W w ,B 80 W c ,G,B,R,W w 81 W c ,G,B,W w ,R 82 W c ,G,W w ,R,B 83 W c ,G,W w ,B,R 84 W c ,B,R,G,W w 85 W c ,B,R,W w ,G 86 W c ,B,G,R,W w 87 W c ,B,G,W w ,R 88 W c ,B,W w ,R,G 89 W c ,B,W w ,G,R 90 W c ,W w ,R,G,B 91 W c ,W w ,R,B,G 92 W c ,W w ,G,R,B 93 W c ,W w ,G,B,R 94 W c ,W w ,B,R,G 95 W c ,W w ,B,G,R 96 W w ,R,G,B,W c 97 W w ,R,G,W c ,B 98 W w ,R,B,G,W c 99 W w ,R,B,W c ,G 100 W w ,R,W c ,G,B 101 W w ,R,W c ,B,G 102 W w ,G,R,B,W c 103 W w ,G,R,W c ,B 104 W w ,G,B,R,W c 105 W w ,G,B,W c ,R 106 W w ,G,W c ,R,B 107 W w ,G,W c ,B,R 108 W w ,B,R,G,W c 109 W w ,B,R,W c ,G 110 W w ,B,G,R,W c 111 W w ,B,G,W c ,R 112 W w ,B,W c ,R,G 113 W w ,B,W c ,G,R 114 W w ,W c ,R,G,B 115 W w ,W c ,R,B,G 116 W w ,W c ,G,R,B 117 W w ,W c ,G,B,R 118 W w ,W c ,B,R,G 119 W w ,W c ,B,G,R Source: this spreadsheet","title":"SetOption37"},{"location":"Shutter-and-Steppers/","text":"","title":"Shutter and Steppers"},{"location":"Smart-Meter-Interface/","text":"This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_SCRIPT #define USE_SCRIPT # adds about 17k flash size, variable ram size #endif #ifndef USE_SML_M #define USE_SML_M #endif #ifdef USE_RULES #undef USE_RULES #endif // define max number of decoder entries ( defaults to 20 if not defined ) #define SML_MAX_VARS N Driver for various meters , heating devices, and reed like contacts To use this interface, connect the meter to available GPIO pins. These GPIOs must be set as None (0) components in Tasmota. If the interface detects that a meter descriptor GPIO conflicts with a Tasmota GPIO setting, the interface will generate a \"duplicate GPIO defined\" error in the log and the meter descriptor will be ignored. (only for script driven descriptors) if you use the deprecated hard coded interface and no meter script the default harcoded descriptor uses Pin 3 (REC) for receive and thus may interfere with other Tasmota Defintions without warning. Note on an ESP32 due to a different implementation serial ports may not be used in conjunction with other Tasmota serial devices. Note when changing GPIO configurations especially in conjunction with other Tasmota drivers a restart may be required The Smart Meter Interface provides a means to connect many kinds of meters to Tasmota. The following types of meter protocols are supported: - ASCII OBIS telegrams emitted from many smart meters and also from P1 meter interface - Binary SML OBIS telegram emitted from many smart meters - Binary EBUS telegram emitted by many heaters and heat pumps (e.g., Vaillant, Wolf) - Binary MODBUS telegram used by many power meters - Binary RAW telegram decodes all kinds of binary data eg EMS heater bus - Counter interface (uses Tasmota counter storage) for e.g., reed contacts either in polling or IRQ mode There are many different meters that use the same protocol. There are multitudes of variants and use cases. A meter can be defined by using compilation time #define pragmas. This requires recompiling the firmware to make modifications. This interface provides a means of specifying these definitions through meter descriptors . This method uses the scripting language editor to define the descriptors. In this way, only one firmware binary version is required and a modification can be made easily \"on the fly\". Note If no >M section is found in the script or if the scripting language is not compiled, the driver reverts to the default #define definition(s). Note Additional hardware is required to read certain measuring devices. For example: RS485toTTL Adaper for Modbus, IR transistor for electricity meters. Sometimes an additional IR diode and resistors. Descriptor Syntax ~ This section must be present, but empty. In most cases, there is no need to define variables for this driver. >D Declare a script >B (boot) section to inform the interface to read the meter descriptor(s) >B => sensor53 r Declare a script >M section with the number of connected meters (n = 1..5 ) >M <n> Meter Declaration ~ +<M>,<rxGPIO>,<type>,<flag>,<parameter>,<jsonPrefix>{,<txGPIO>,<txPeriod>,<cmdTelegram>} Example +1,3,o,0,9600,OBIS1,1,2,2F3F210D0A +1,3,s,16,9600,SML1 +1,12,c,1,-10,H20_Cnt +1,3,m,0,9600,MODBUS,1,1,01040000,01040002,01040004,01040006,01040008,0104000a,0104000c,0104000e,01040010 +<M>,<rxGPIO>,<type>,<flag>,<parameter>,<jsonPrefix>{,<txGPIO>,<txPeriod>,<cmdTelegram>} - <M> - meter number. The number must be increased with each additional Meter. (1...5) - <rxGPIO> - meter data receive GPIO - <type> - meter type of meter: - o = OBIS ASCII type of coding - s = SML binary smart message coding - c = Counter type - e = EBus binary coding - m = MODBus binary coding with serial mode 8N1 - M = MODBus binary coding with serial mode 8E1 - r = Raw binary coding (any binary telegram) - <flag> - options flag: - 0 = counter without pullup - 1 = counter with pullup - 16 = enable median filter for that meter. Can help with sporadic dropouts eg. reading errors. (not available for counters) - <parameter> - parameters according to meter type: - for o,s,e,m,r : serial baud rate eg. 9600 - for c : - positive value >0 = counter poll interval - negative value <=0 = debounce time (milliseconds) for irq driven counters - <jsonPrefix> - prefix for Web UI and MQTT JSON payload. Up to 7 characters - <txGPIO> - meter command transmit GPIO (optional) - <txPeriod> - number of 100ms increments (n * 100ms). Period to repeat the transmission of commands to the meter (optional) - <cmdTelegram> - comma separated hex coded byte blocks to send to meter device. For modbus each comma separated block is a command to retrieve a certain register from the meter (Optional, only required for measuring devices that have to be triggered with a certain character string.) Modbus: Example +1,3,m,0,9600,MODBUS,1,1,01040000,01040002,01040004,01040006,01040008,0104000a,0104000c,0104000e,01040010 Components of the character string: ...01040000,01040002,... 01 = Modbus slave device ID 04 = Instruction to read an Input Register (alternatively, 03 = Instruction to read an Holding Register) 0000 / 0002 = Register # (as Hexadecimal codification, without the prefix 0x . Example: 0x0079 -> 0079 ) the number of requested registers is fixed to 2, however with the char 'r' before the hex string the complete request string may be specified ...r010400000001,r010400020003,... Note ID , Instruction to read the Register value (Input vs Holding) and Register # may differ depending on the measuring device. Meter Metrics ~ Each meter typically provides multiple metrics (voltage, power, current etc.) which it measures. An entry for each metric to be collected must be specified. up to 20 entries may be defined (default or #define SML_MAX_VARS N a larger number may be defined in user_config_override.h file). An entry defines how to decode the data and put it into variables. Example (OBIS/SML/MODBus): 1,1-0:1.8.1\\*255(@1,Total consumption,KWh,Total_in,4 1,77070100010801ff@1000,W1,kWh,w1,4 1,010304UUuuxxxxxxxx@i0:1,Spannung L1,V,Voltage_L1,0 <M>,<decoder>@<scale>,<label>,<UoM>,<var>,<precision> - <M> - meter number to which this decoder belongs - <decoder> - decoding specification. Decode OBIS as ASCII; SML, EBUS, MODBus, RAW as HEX ASCII - OBIS: ASCII OBIS code terminated with ( character which indicates the start of the meter value - SML: SML binary OBIS as hex terminated with 0xFF indicating start of SML encoded value - EBUS, MODBus, RAW: hex values of EBUS, MODBus, RAW block to compare - xx means ignore value (1 byte) - ss = extract a signed byte - uu = extract an unsigned byte - UUuu = extract an unsigned word (high order byte first) - uuUU = extract an unsigned word (low order byte first) - UUuuUUuu = extract an unsigned long word (high order byte first) - SSss = extract a signed word (high order byte first) - ssSS = extract a signed word (low order byte first) - SSssSSss = extract an signed long word (high order byte first) - ffffffff = extract a float value - FFffFFff = extract a reverse float value - @ decoding definition termination character - decoding a 0/1 bit is indicated by a @ character followed by bx: (x = 0..7 ) extracting the corresponding bit from a byte. e.g.: 1,xxxx5017xxuu@b0:1,Solarpump,,Solarpump,0 - in the case of MODBus , ix: designates the index (x = 0..n ) referring to the requested block in the transmit section of the meter definition Example +1,3,M,1,9600,SBC,1,2,01030023,01030028... 1,010304UUuuxxxxxxxx@i0:1,Voltage L1,V,Voltage_L1,0 < the i0:1 refers to: 01030023 with a scaling factor ( :1 ) of 1 1,010304UUuuxxxxxxxx@i1:10,Current L1,V,Current_L1,2 < the i1:10 refers to: 01030028 with a scaling factor ( :10 ) of 10 - <scale> - scaling factor (divisor) This can be a fraction (e.g., 0.1 => result * 10), or a negative value When decoding a string result (e.g., a serial meter), use # character for this parameter (only in one line per meter). For OBIS, you need a ) termination character after the # character Example: OBIS: 1,1-0:0.0.0\\*255(@#),Meter Nr,, Meter_number,0 SML: 1,77078181c78203ff@#,Service ID,,Meter_id,0 - <label> - web UI label (max 23 chars) if this label is the single char '*' the WEB UI is discarded for this line - <UoM> - unit of measure (max 7 chars) - <var> - MQTT variable name (max 23 chars) - <precision> - number of decimal places Add 16 to transmit the data immediately. Otherwise it is transmitted on TelePeriod Example 1,1-0:1.8.0*255(@1,consumption,KWh,Total_in,4 > Transmitted on TelePeriod 1,1-0:1.8.0*255(@1,consumption,KWh,Total_in,20 > Precision of 4. 4 + 16 = 20 >transmit its value immediately # character terminates the list Note in the decoding section of the meter defintions before the @ char no space chars are allowed Special Commands With the '=' char at the beginning of a line you may do some special decoding M,=m perform arithmetic ( +,-,*,/ ) on the metric. Use # before a number to designate a constant value Example 1,=m 3+4+5/#3 @100,Voltage L1+L2+L3/3,V,Volt_avg,2 1,=m 3+4+5/#3 add result of decoder entry 3,4,5 and divided by 3 (i.e., average) - M,=d calculate difference between metric values decoded at time intervals (up to 10 =d lines possible) Example 1,=d 3 10 calculate 10 second interval difference of decoder entry 3 - M,=h html text (up to 30 chars) inserts a html line between entries (these lines do not count as decoder entry) Example 1,=h================== insert a separator line With an asterisk * character replacing the name in a descriptor line, this line can be hidden in the main menu. (\"#define USE_SML_SCRIPT_CMD\" required) Example 1,010304ffffffff@i0:1,*,V,Voltage_L1-N,2 1,010304ffffffff@i1:1,*,V,Voltage_L2-N,2 1,010304ffffffff@i2:1,*,V,Voltage_L3-N,2 etc... With an asterisk * character as JSON Prefix in the Meter definiton suppresses the JSON output (\"#define USE_SML_SCRIPT_CMD\" required) Example +1,14,m,0,9600,*,12,2,01040000,01040002,01040004 To get the value of one of the descriptor lines, use sml[X]. X = Line number. Starts with 1. (\"#define USE_SML_SCRIPT_CMD\" required) Example >D v1=0 v2=0 >S ;Writes the value of Descriptorline 1 to v1 v1=sml[1] ;Writes the value of Descriptorline 2 to v2 v2=sml[2] Tip Use: sensor53 dM to output the received data in the console. M = the number of the defined meter in the script. Note During the output of the data in the console, the data in the WEB UI are not updated. To return write: sensor53 d0 Warning With a few meters, it is necessary to request the meter to send its data using a specific character string. This string has to be send at a very low baudrate. (300Baud) If you reply the meter with an acknowledge and ask the it for a new baudrate of 9600 baud, the baudrate of the SML driver has to be changed, too. To change the baudrate: sml( METERNUMBER 0 BAUDRATE ) For sending a specific character string: sml( METERNUMBER 1 STRING ) That works like this: Example >D res=0 scnt=0 ;For this Example in the >F section >F ;count 100ms scnt+=1 switch scnt case 6 ;set sml driver to 300 baud and send /?! as HEX to trigger the Meter res=sml(1 0 300) res=sml(1 1 \"2F3F210D0A\") ;1800ms later > Send ACK and ask for switching to 9600 baud case 18 res=sml(1 1 \"063035300D0A\") ;2000ms later > Switching sml driver to 9600 baud case 20 res=sml(1 0 9600) ;Restart sequence after 50x100ms case 50 ; 5000ms later > restart sequence scnt=0 ends >M 1 +1,3,o,0,9600, ,1 ...etc. You can find the example here. Attention This procedure is only necessary, if the meter explicitly asks for 300 baud. The most meters work directly with 9600 baud. Therefore it is easier to give this method a try: Example Meter#,GPIO# Input,TYPE,FLAG,Baudrate,JSONNAME,GPIO# Output,TX Period,Character string + 1,3, o, 0,9600, energy, 1,4,2F3F210D0A Example: here. Smart Meter Descriptors ~ JANZ C3801 (SML - MODBUS) EMH ED300L (SML) Hager EHZ363 (SML) Hager EHZ161 (OBIS) Landis + Gyr ZMR120AR (OBIS) COMBO Meter (Water,Gas,SML) WOLF CSZ 11/300 Heater SDM530 (MODBUS) SDM230 (MODBUS) Janitza B23 (MODBUS) Hager EHZ363 (SML) with daily values Iskra MT 174 SBC ALE3 (MODBUS) 2 * SBC ALE3 (MODBUS) Trovis 557x 4 * Hiking DDS238-2 ZN/S (MODBUS) JANZ C3801 (SML - MODBUS) ~ This is an example for one of the many quite similar smart meters implemented in Portugal, by EDP Distribui\u00e7\u00e3o S.A. . May be valid for many more models, as stated. You should configure your user_config_override.h as: #ifndef USE_SCRIPT #define USE_SCRIPT #endif #ifndef USE_SML_M #define USE_SML_M #endif #ifdef USE_RULES #undef USE_RULES #endif #define SML_MAX_VARS 10 Your Tasmota SML script : > D > B => sensor53 r > M 1 + 1 , 14 , m , 1 , 9600 , EB , 5 , 50 , 0104006 C , 01040079 , 0104007 A , 0104007 F , 01040026 , 01040027 , 01040028 , 0104000 B , 01040084 1 , = hVALORES T\u00c9CNICOS 1 , 010404 UUuuxxxx @i0 : 10 , Tens\u00e3o , V , Voltage_P1 , 17 1 , 010404 xxxxUUuu @i0 : 10 , Corrente , A , Current_P1 , 17 1 , 010408 UUuuUUuuxxxxxxxxxxxx @i1 : 1 , Pot\u00eancia ativa , W , Power_P1 , 16 1 , 010406 xxxxxxxxUUuu @i2 : 1000 , Fator de pot\u00eancia , pu , PFactor_P1 , 19 1 , 01040 aUUuuxxxx @i3 : 10 , Frequ\u00eancia , Hz , Frequency_P1 , 17 1 , = h & #8205 ; 1 , = hTOTALIZADORES DE ENERGIA 1 , 010408 UUuuUUuuxxxxxxxxxxxx @i4 : 1000 , Vazio ( 1 ), kWh , Energy_P1_R1 , 17 1 , 010408 UUuuUUuuxxxxxxxxxxxx @i5 : 1000 , Ponta ( 2 ), kWh , Energy_P1_R2 , 17 1 , 010408 UUuuUUuuxxxxxxxxxxxx @i6 : 1000 , Cheia ( 3 ), kWh , Energy_P1_R3 , 17 1 , = h & #8205 ; 1 , = hESTADOS 1 , 010406 uuxxxxxxxx @i7 : 1 , Tarifa ,, Tariff_P1 , 16 1 , 010406 uuxxxxxxxx @i8 : 1 , DCP ,, DCP_P1 , 16 # EMH ED300L (SML) ~ > D > B -> sensor53 r > M 2 + 1 , 13 , s , 0 , 9600 , Haus + 2 , 12 , s , 0 , 9600 , Heizung 1 , 770701000F0700F F @1 , Aktuell , W , Power_curr , 0 1 , 77070100010800F F @1000 , Z\u00e4hlerstand Verb ., kWh , Tariflos , 2 1 , 77070100020800F F @1000 , Z\u00e4hlerstand Einsp ., kWh , Tariflos , 2 2 , = h ================== 2 , 770701000F0700F F @1 , Aktuell , W , Power_curr , 0 2 , 77070100010800F F @1000 , Z\u00e4hlerstand Verb ., kWh , Tariflos , 2 2 , 77070100020800F F @1000 , Z\u00e4hlerstand Einsp ., kWh , Tariflos , 2 # Hager EHZ363 (SML) ~ > D > B -> sensor53 r > M 1 + 1 , 3 , s , 0 , 9600 , SML 1 , 77070100010800f f @1000 , Total consumption , KWh , Total_in , 4 1 , 77070100020800f f @1000 , Total Feed , KWh , Total_out , 4 1 , 77070100100700f f @1 , Current consumption , W , Power_curr , 0 1 , 77070100000009f f @ # , Meter Nr ,, Meter_number , 0 # Hager EHZ161 (OBIS) ~ > D > B -> sensor53 r > M 1 + 1 , 3 , o , 0 , 9600 , OBIS 1 , 1-0 : 1.8.1 \\ * 255 ( @1 , Total consumption , KWh , Total_in , 4 1 , 1-0 : 2.8.1 \\ * 255 ( @1 , Total Feed , KWh , Total_out , 4 1 , = d 2 10 @1 , Current consumption , W , Power_curr , 0 1 , 1-0 : 0.0.0 \\ * 255 (@ # ), Meter Nr ,, Meter_number , 0 # Landis + Gyr ZMR120AReS2R2sfCS (OBIS) ~ Example: Changing the baud rate during operation. > D ; Var Power consumption total HT + NT v1 = 0 ; HT Main electricity tariff consumption total v2 = 0 ; NT Night electricity tariff consumption total v3 = 0 ; Energie L1 + L2 + L3 v4 = 0 ; recent Energie L1 v5 = 0 ; recent Energie L2 v6 = 0 ; recent Energie L3 v7 = 0 ; Var minute min = 0 ; Var hour hr = 0 ; Var begin of the month 01. xx .20 xx 0 : 00 Uhr md = 0 ; Var begin of the year 01.01 . 0 : 00 Uhr yr = 0 ; Var for counter see > F = ms scnt = 0 ; Var for baudrate changeing res = 0 ; Permanent Var Meter1 0 : 00 p : sm = 0 p : HT_sm = 0 p : NT_sm = 0 ; Var for daily = 0 sd = 0 HT_sd = 0 NT_sd = 0 ; Permanent Var for month begin p : sma = 0 p : HT_sma = 0 p : NT_sma = 0 ; Var for monthly = 0 smn = 0 HT_smn = 0 NT_smn = 0 ; Permanent Var for year begin p : sya = 0 p : HT_sya = 0 p : NT_sya = 0 ; Var for yearly = 0 syn = 0 HT_syn = 0 NT_syn = 0 ; Fill vars with content on teleperiod > T v1 = # Total_in v2 = # HT_Total_in v3 = # NT_Total_in v4 = # kW_L1 + L2 + L3 v5 = # kw_L1 v6 = # kw_L2 v7 = # kw_L3 > B ; Restart driver -> sensor53 r ; Set teleperiod to 20 sec tper = 20 > F ; count 100 ms scnt += 1 switch scnt case 6 ; set sml driver to 300 baud and send /?! as HEX to trigger the Meter res = sml ( 1 0 300 ) res = sml ( 1 1 \"2F3F210D0A\" ) ; 1800 ms later \\ > Ack and ask for switching to 9600 baud case 18 res = sml ( 1 1 \"063035300D0A\" ) ; 2000 ms later \\ > Switching sml driver to 9600 baud case 20 res = sml ( 1 0 9600 ) ; Restart sequence after 50 x100ms case 50 ; 5000 ms later \\ > restart sequence scnt = 0 ends > S ; daily usage hr = hours if chg [ hr ] > 0 and hr == 0 and v1 > 0 then sm = v1 HT_sm = v2 NT_sm = v3 svars endif if upsecs % tper == 0 { sd = v1 - sm HT_sd = v2 - HT_sm NT_sd = v3 - NT_sm } ; Monthly usage md = day if chg [ md ] > 0 and md == 1 and v1 > 0 then sma = v1 HT_sma = v2 NT_sma = v3 svars endif if upsecs % tper == 0 { smn = v1 - sma HT_smn = v2 - HT_sma NT_smn = v3 - NT_sma } ; Yearly usage yr = year if chg [ yr ] > 0 and v1 > 0 then sya = v1 HT_sya = v2 NT_sya = v3 svars endif if upsecs % tper == 0 { syn = v1 - sya HT_syn = v2 - HT_sya NT_syn = v3 - NT_sya ; Json payload \\ > send on teleperiod > J , \"Strom_Vb_Tag\" :% 3 sd % , \"HT_Strom_Vb_Tag\" :% 3 HT_sd % , \"NT_Strom_Vb_Tag\" :% 3 NT_sd % , \"Strom_Vb_M\" :% 1 smn % , \"HT_Strom_Vb_M\" :% 1 HT_smn % , \"NT_Strom_Vb_M\" :% 1 NT_smn % , \"Strom_Vb_Jahr\" :% 0 syn % , \"HT_Strom_Vb_Jahr\" :% 0 HT_syn % , \"NT_Strom_Vb_Jahr\" :% 0 NT_syn % , \"Strom_0:00 _Uhr\" :% 1 sm % , \"HT_Strom_0:00 _Uhr\" :% 1 HT_sm % , \"NT_Strom_0:00 _Uhr\" :% 1 NT_sm % , \"Strom_Ma\" :% 3 sma % , \"HT_Strom_Ma\" :% 3 HT_sma % , \"NT_Strom_Ma\" :% 3 NT_sma % , \"Strom_Ja\" :% 3 sya % , \"HT_Strom_Ja\" :% 3 HT_sya % , \"NT_Strom_Ja\" :% 3 NT_sya % ; Webdisplay stuff > W ---------------------- 0 : 00 Uhr \u03a3 HT + NT : { m } % 0 sm % KWh HT : { m } % 0 HT_sm % KWh NT : { m } % 0 NT_sm % KWh ---------------------- Monatsanfang : { m } % 1 sma % KWh HT : { m } % 1 HT_sma % KWh NT : { m } % 1 NT_sma % KWh ---------------------- Jahresanfang : { m } % 0 sya % KWh HT : { m } % 0 HT_sya % KWh NT : { m } % 0 NT_sya % KWh ............................. Tagesverbrauch : { m } % 1 sd % KWh HT : { m } % 1 HT_sd % KWh NT : { m } % 1 NT_sd % KWh ---------------------- Monatsverbrauch : { m } % 0 smn % KWh HT : { m } % 0 HT_smn % KWh NT : { m } % 0 NT_smn % KWh --------------------- Jahresverbrauch : { m } % 0 syn % KWh HT : { m } % 0 HT_syn % KWh 0 : 00 Uhr \u03a3 HT + NT : { m } % 0 sm % KWh HT : { m } % 0 HT_sm % KWh NT : { m } % 0 NT_sm % KWh ---------------------- Monatsanfang : { m } % 1 sma % KWh HT : { m } % 1 HT_sma % KWh NT : { m } % 1 NT_sma % KWh ---------------------- Jahresanfang : { m } % 0 sya % KWh HT : { m } % 0 HT_sya % KWh NT : { m } % 0 NT_sya % KWh ............................. Tagesverbrauch : { m } % 1 sd % KWh HT : { m } % 1 HT_sd % KWh NT : { m } % 1 NT_sd % KWh ---------------------- Monatsverbrauch : { m } % 0 smn % KWh HT : { m } % 0 HT_smn % KWh NT : { m } % 0 NT_smn % KWh --------------------- Jahresverbrauch : { m } % 0 syn % KWh HT : { m } % 0 HT_syn % KWh NT : { m } % 0 NT_syn % KWhNT : { m } % 0 NT_syn % KWh > M 1 + 1 , 3 , o , 0 , 9600 ,, 1 1 , 0.0.1 ( @1 , Z\u00e4hlernummer ,, Meter_number , 0 1 , 0.9.1 (@ # ), Zeitstempel , Uhr , time - stamp , 0 1 , = h =================== 1 , 1.8.0 ( @1 , HT + NT Z\u00e4hlerstand , KWh , Total_in , 3 1 , 1.8.1 ( @1 , HT , KWh , HT_Total_in , 3 1 , 1.8.2 ( @1 , NT , KWh , NT_Total_in , 3 1 , = h =================== 1 , 36.7.0 ( @1 , Power_L1 , kW , kW_L1 , 2 1 , 56.7.0 ( @1 , Power_L2 , kW , kW_L2 , 2 1 , 76.7.0 ( @1 , Power_L3 , kW , kW_L3 , 2 1 , 16.7.0 ( @1 , \u03a3 _L1 + L2 + L3 , kW , kW_L1 + L2 + L3 , 2 1 , = h =================== 1 , 31.7.0 ( @1 , Strom_L1 , A , I_L1 , 2 1 , 51.7.0 ( @1 , Strom_L2 , A , I_L2 , 2 1 , 71.7.0 ( @1 , Strom_L3 , A , I_L3 , 2 # COMBO Meter (Water,Gas,SML) ~ > D > B -> sensor53 r > M 3 + 1 , 1 , c , 0 , 10 , H20 + 2 , 4 , c , 0 , 50 , GAS + 3 , 3 , s , 0 , 9600 , SML 1 , 1-0 : 1.8.0 \\ * 255 ( @10000 , Water reading , cbm , Count , 4 2 , = h ================== 2 , 1-0 : 1.8.0 \\ * 255 ( @100 , Gas reading , cbm , Count , 3 3 , 77070100010800f f @1000 , Total consumption , KWh , Total_in , 3 3 , = h ================== 3 , 77070100100700f f @1 , Current consumption , W , Power_curr , 2 3 , = h ------------------------------- 3 , = m 10 + 11 + 12 @100 , Currents L1 + L2 + L3 , A , Curr_summ , 2 3 , = m 13 + 14 + 15 / # 3 @100 , Voltage L1 + L2 + L3 / 3 , V , Volt_avg , 2 3 , = h ================== 3 , 77070100240700f f @1 , Consumption P1 , W , Power_p1 , 2 3 , 77070100380700f f @1 , Consumption P2 , W , Power_p2 , 2 3 , 770701004 c0700ff @1 , Consumption P3 , W , Power_p3 , 2 3 , = h ------------------------------- 3 , 770701001f0700f f @100 , Current L1 , A , Curr_p1 , 2 3 , 77070100330700f f @100 , Current L2 , A , Curr_p2 , 2 3 , 77070100470700f f @100 , Current L3 , A , Curr_p3 , 2 3 , = h ------------------------------- 3 , 77070100200700f f @100 , Voltage L1 , V , Volt_p1 , 2 3 , 77070100340700f f @100 , Voltage L2 , V , Volt_p2 , 2 3 , 77070100480700f f @100 , Voltage L3 , V , Volt_p3 , 2 3 , = h ================== 3 , 77070100000009f f @ # , Service ID ,, Meter_id , 0 3 , = h -------------------------------- # WOLF CSZ 11/300 Heater ~ > D > B -> sensor53 r > M 1 + 1 , 3 , e , 0 , 2400 , EBUS 1 , xxxx0503xxxxxxxxxxxxxxxxss @1 , Outside temperature , C , Outsidetemp , 0 1 , xxxx5014xxxxxxxxxxuu @1 , Romm temperature , C , Roomtemp , 0 1 , xxxx0503xxxxxxxxxxxxxxuu @1 , Warmwater , C , Warmwater , 0 1 , xxxx0503xxxxxxxxxxuu @1 , Boiler , C , Boiler , 0 1 , 03f e0503xxxxxxxxxxxxuu @1 , Returns , C , Returns , 0 1 , 03f e0503xxxxuu @1 , Status ,, Status , 0 1 , 03f e0503xxxxxxuu @ b3 : 1 , Burner on ,, Burner , 0 1 , xxxx5017xxxxxxuuuu @16 , Solar collektor , C , Collector , 1 1 , xxxx5017xxxxxxxxxxuuuu @16 , Solar storage , C , Solarstorage , 1 1 , xxxx5017xxuu @ b0 : 1 , Solar pump on ,, Solarpump , 0 # MODBUS Devices ~ SDM530 ~ >D >B ->sensor53 r >M 1 +1,3,m,0,9600,MODBUS,1,1,01040000,01040002,01040004,01040006,01040008,0104000a,0104000c,0104000e,01040010 1,010404ffffffff@i0:1,Voltage P1,V,Voltage_P1,2 1,010404ffffffff@i1:1,Voltage P2,V,Voltage_P2,2 1,010404ffffffff@i2:1,Voltage P3,V,Voltage_P3,2 1,010404ffffffff@i3:1,Current P1,A,Current_P1,2 1,010404ffffffff@i4:1,Current P2,A,Current_P2,2 1,010404ffffffff@i5:1,Current P3,A,Current_P3,2 1,010404ffffffff@i6:1,Active Power P1,W,Power_P1,2 1,010404ffffffff@i7:1,Active Power P2,W,Power_P2,2 1,010404ffffffff@i8:1,Active Power P3,W,Power_P3,2 # SDM230 ~ > D ms = \"1,010404ffffffff@\" > B -> sensor53 r > M 1 + 1 , 3 , m , 0 , 9600 , PV , 1 , 2 , 01040000 , 01040006 , 0104000 C , 01040012 , 0104001 8 , 0104001 E , 01040024 , 01040046 , 0104004 8 , 0104004 A , 0104004 C , 0104004 E , 01040054 , 01040056 , 0104005 8 , 0104005 A , 0104005 C , 0104005 E , 01040102 , 0104010 8 , 01040152 , 0104015 8 , 010401 80 , 010401 82 %ms%i0 : 1 , Volt , V , Volt , 2 %ms%i1 : 1 , Strom P1 , A , Strom , 3 %ms%i2 : 1 , * , W , Leistung , 2 %ms%i3 : 1 , Scheinleistung , VA , ScheinLeistung , 2 %ms%i4 : 1 , Blindleistung , VAr , Blindleistung , 2 %ms%i5 : 1 , P - Faktor ,, P_Faktor , 1 %ms%i6 : 1 , cosPhi , \u00b0 , cosPhi , 2 %ms%i7 : 1 , Frequenz , Hz , Frequenz , 1 %ms%i8 : 1 , Wirkleistung Import , kWh , Wirkleistung_Im1 , 3 %ms%i9 : 1 , Wirkleistung Export , kWh , Wirkleistung_Ex , 3 %ms%i10 : 1 , Blindleistung Import , VkkVARh , Blindleistung_Im , 3 %ms%i11 : 1 , Blindleistung Export , VkkVARh , Blindleistung_Ex , 3 %ms%i12 : 1 , Gesamtleistungsbedarf , W , GesLeistBed , 2 %ms%i13 : 1 , GesamtLeistung Max , W , GesLeistMax , 2 %ms%i14 : 1 , Akt . Nachfrage , W , AktNachfrage , 2 %ms%i15 : 1 , R\u00fcckleistungs Bed , W , RueckLeistBed , 2 %ms%i16 : 1 , R\u00fcckleistungs Bed Max , W , RueckLeistBedMax , 2 %ms%i17 : 1 , Strom Nachfrage , A , StromNachfrage2 , 2 %ms%i19 : 1 , Max Strombedarf , A , StromBedMax , 2 %ms%i20 : 1 , Wirkleistung Gesamt , kWh , Wirkleistung_total , 2 %ms%i21 : 1 , Blindleistung Gesamt , kVARh , Blindleistung_total , 2 %ms%i22 : 1 , Temp Gesamtleistung , kWh , TempGesamtLeist , 2 # Janitza B23 ~ > D > B -> sensor53 r > M 1 + 1 , 3 , m , 0 , 9600 , Janitza , 1 , 1 , 01034 A38 , 01034 A3A , 01034 A3C , 01034 A4C , 01034 A4E , 01034 A50 , 01034 A72 , 01034 A7A , 01034 A82 1 , 010304 ffffffff @i0 : 1 , Voltage L1 - N , V , Voltage_L1 - N , 2 1 , 010304 ffffffff @i1 : 1 , Voltage L2 - N , V , Voltage_L2 - N , 2 1 , 010304 ffffffff @i2 : 1 , Voltage L3 - N , V , Voltage_L3 - N , 2 1 , 010304 ffffffff @i3 : 1 , Real power L1 - N , W , Real_power_L1 - N , 2 1 , 010304 ffffffff @i4 : 1 , Real power L2 - N , W , Real_power_L2 - N , 2 1 , 010304 ffffffff @i5 : 1 , Real power L3 - N , W , Real_power_L3 - N , 2 1 , 010304 ffffffff @i6 : 1 , Real energy L3 , Wh , Real_energy_L3 , 2 1 , 010304 ffffffff @i7 : 1 , Real energy L3 - consumed , Wh , Real_energy_L3_consumed , 2 1 , 010304 ffffffff @i8 : 1 , Real energy L3 - delivered , Wh , Real_energy_L3_delivered , 2 # Hager EHZ363 (SML) with daily values ~ > D pin = 0 pout = 0 pi_d = 0 po_d = 0 hr = 0 ; permanent midnight values p : pi_m = 0 p : po_m = 0 > B -> sensor53 r > T ; get total consumption and total feed pin = SML # Total_in pout = SML # Total_out > S ; at midnight , save meter total values hr = hours if chg [ hr ] > 0 and hr == 0 then pi_m = pin po_m = pout svars endif ; on teleperiod calculate current daily values from midnight if upsecs % tper == 0 then pi_d = pin - pi_m po_d = pout - po_m endif ; show these values on WEB UI > W Tagesverbrauch : { m } % pi_d % kWh Tageseinspeisung : { m } % po_d % kWh ; transmit these values with MQTT > J , \"daily_consumption\" :% pi_d % , \"daily_feed\" :% po_d % ; meter definition > M 1 + 1 , 3 , s , 0 , 9600 , SML 1 , 77070100010800f f @1000 , Total Consumed , KWh , Total_in , 4 1 , 77070100020800f f @1000 , Total Delivered , KWh , Total_out , 4 1 , 77070100100700f f @1 , Current Consumption , W , Power_curr , 0 1 , 77070100000009f f @ # , Meter Number ,, Meter_number , 0 # Iskra MT 174 (OBIS) ~ > D > B -> sensor53 r > M 1 + 1 , 3 , o , 0 , 300 , STROM , 1 , 100 , 2F3F 210 D0A 1 , 1-0 : 1.8.1 * 255 ( @1 , Total Consumed , KWh , Total_in , 3 1 , 1-0 : 2.8.1 * 255 ( @1 , Total Delivered , KWh , Total_out , 3 1 , 1-0 : 0.0.0 * 255 (@ # ), Meter Number ,, Meter_number , 0 # SBC ALE3 MODBUS ~ > D > B -> sensor53 r > M 1 + 1 , 3 , M , 1 , 9600 , SBC , 1 , 1 , 02030023 , 02030028 , 0203002 d , 02030025 , 0203002 a , 0203002 f , 02030032 , 02030027 , 0203002 c , 02030031 , 02030021 , 02030015 , 02030018 1 , 020304 UUuu @i0 : 1 , Spannung L1 , V , Voltage_L1 , 0 1 , 020304 UUuu @i1 : 1 , Spannung L2 , V , Voltage_L2 , 0 1 , 020304 UUuu @i2 : 1 , Spannung L3 , V , Voltage_L3 , 0 1 , 020304 xxxxUUuu @i0 : 10 , Strom L1 , A , Current_L1 , 2 1 , 020304 xxxxUUuu @i1 : 10 , Strom L2 , A , Current_L2 , 2 1 , 020304 xxxxUUuu @i2 : 10 , Strom L3 , A , Current_L3 , 2 1 , = h = 1 , 020304 UUuu @i3 : 100 , Leistung L1 , kW , Power_L1 , 3 1 , 020304 UUuu @i4 : 100 , Leistung L2 , kW , Power_L2 , 3 1 , 020304 UUuu @i5 : 100 , Leistung L3 , kW , Power_L3 , 3 1 , 020304 UUuu @i6 : 100 , Leistung Total , kW , Power_Total , 3 1 , 020304 xxxxSSss @i3 : 100 , BlindLeistung L1 , kVAr , ReaktivePower_L1 , 3 1 , 020304 xxxxSSss @i4 : 100 , BlindLeistung L2 , kVAr , ReaktivePower_L2 , 3 1 , 020304 xxxxSSss @i5 : 100 , BlindLeistung L3 , kVAr , ReaktivePower_L3 , 3 1 , 020304 xxxxSSss @i6 : 100 , BLeistung Total , kVAr , ReaktivePower_Total , 3 1 , = h = 1 , 020304 UUuu @i7 : 100 , CosPhi L1 ,, CosPhi_L1 , 2 1 , 020304 UUuu @i8 : 100 , CosPhi L2 ,, CosPhi_L2 , 2 1 , 020304 UUuu @i9 : 100 , CosPhi L3 ,, CosPhi_L3 , 2 1 , = h = 1 , 020304 UUuuUUuu @i10 : 100 , T2 Wert , kWh , T2_Value , 2 # 2 * SBC ALE3 MODBUS ~ > D > B -> sensor53 r > M 1 + 1 , 3 , M , 1 , 9600 , Meter , 1 , 1 , 01030023 , 01030028 , 0103002 d , 01030025 , 0103002 a , 0103002 f , 01030032 , 01030027 , 0103002 c , 01030031 , 0103001 B , 0103001 d , 03030023 , 03030028 , 0303002 d , 03030025 , 0303002 a , 0303002 f , 03030032 , 03030027 , 0303002 c , 03030031 , 0303001 B , 0303001 d 1 , = h Domestic Electricity : 1 , 010304 UUuuUUuu @i10 : 100 , 1 Tariff 1 total , kWh , M1_T1_total , 2 1 , 010304 UUuuUUuu @i11 : 100 , 1 Tariff 1 partial , kWh , M1_T1_par , 2 1 , = h Readings : 1 , 010304 UUuu @i0 : 1 , 1 Voltage L1 , V , M1_Voltage_L1 , 0 1 , 010304 UUuu @i1 : 1 , 1 Voltage L2 , V , M1_Voltage_L2 , 0 1 , 010304 UUuu @i2 : 1 , 1 Voltage L3 , V , M1_Voltage_L3 , 0 1 , 010304 xxxxUUuu @i0 : 10 , 1 Current L1 , A , M1_Current_L1 , 2 1 , 010304 xxxxUUuu @i1 : 10 , 1 Current L2 , A , M1_Current_L2 , 2 1 , 010304 xxxxUUuu @i2 : 10 , 1 Current L3 , A , M1_Current_L3 , 2 1 , 010304 UUuu @i3 : 100 , 1 Active Power L1 , kW , M1_PRMS_L1 , 3 1 , 010304 UUuu @i4 : 100 , 1 Active Power L2 , kW , M1_PRMS_L2 , 3 1 , 010304 UUuu @i5 : 100 , 1 Active Power L3 , kW , M1_PRMS_L3 , 3 1 , 010304 UUuu @i6 : 100 , 1 Active Power total , kW , M1_PRMS_total , 3 1 , 010304 xxxxSSss @i3 : 100 , 1 Reactive Power L1 , kVAr , M1_QRMS_L1 , 3 1 , 010304 xxxxSSss @i4 : 100 , 1 Reactive Power L2 , kVAr , M1_QRMS_L2 , 3 1 , 010304 xxxxSSss @i5 : 100 , 1 Reactive Power L3 , kVAr , M1_QRMS_L3 , 3 1 , 010304 xxxxSSss @i6 : 100 , 1 Reactive Power total , kVAr , M1_QRMS_total , 3 1 , 010304 UUuu @i7 : 100 , 1 CosPhi L1 ,, M1_CosPhi_L1 , 2 1 , 010304 UUuu @i8 : 100 , 1 CosPhi L2 ,, M1_CosPhi_L2 , 2 1 , 010304 UUuu @i9 : 100 , 1 CosPhi L3 ,, M1_CosPhi_L3 , 2 1 , = h________________________________________________ ; meter 2 + 12 offset 1 , = h Heat Pump 1 , 030304 UUuuUUuu @i22 : 100 , 2 Tariff 1 total , kWh , M2_T1_total , 2 1 , 030304 UUuuUUuu @i23 : 100 , 2 Tariff 1 partial , kWh , M2_T1_par , 2 1 , = h Readings : 1 , 030304 UUuu @i12 : 1 , 2 Voltage L1 , V , M2_Voltage_L1 , 0 1 , 030304 UUuu @i13 : 1 , 2 Voltage L2 , V , M2_Voltage_L2 , 0 1 , 030304 UUuu @i14 : 1 , 2 Voltage L3 , V , M2_Voltage_L3 , 0 1 , 030304 xxxxUUuu @i12 : 10 , 2 Current L1 , A , M2_Current_L1 , 2 1 , 030304 xxxxUUuu @i13 : 10 , 2 Current L2 , A , M2_Current_L2 , 2 1 , 030304 xxxxUUuu @i14 : 10 , 2 Current L3 , A , M2_Current_L3 , 2 1 , 030304 UUuu @i15 : 100 , 2 Active Power L1 , kW , M2_PRMS_L1 , 3 1 , 030304 UUuu @i16 : 100 , 2 Active Power L2 , kW , M2_PRMS_L2 , 3 1 , 030304 UUuu @i17 : 100 , 2 Active Power L3 , kW , M2_PRMS_L3 , 3 1 , 030304 UUuu @i18 : 100 , 2 Active Power total , kW , M2_PRMS_total , 3 1 , 030304 xxxxSSss @i15 : 100 , 2 Reactive Power L1 , kVAr , M2_QRMS_L1 , 3 1 , 030304 xxxxSSss @i16 : 100 , 2 Reactive Power L2 , kVAr , M2_QRMS_L2 , 3 1 , 030304 xxxxSSss @i16 : 100 , 2 Reactive Power L3 , kVAr , M2_QRMS_L3 , 3 1 , 030304 xxxxSSss @i18 : 100 , 2 Reactive Power total , kVAr , M2_QRMS_total , 3 1 , 030304 UUuu @i19 : 100 , 2 CosPhi L1 ,, M2_CosPhi_L1 , 2 1 , 030304 UUuu @i20 : 100 , 2 CosPhi L2 ,, M2_CosPhi_L2 , 2 1 , 030304 UUuu @i21 : 100 , 2 CosPhi L3 ,, M2_CosPhi_L3 , 2 # 4 * Hiking DDS238-2 ZN/S3 MODBUS ~ This is an example for 4 MODBUS devices on the same bus >D >B ->sensor53 r >`>M 1` > +1,3,m,1,9600,Hiking,1,10,0103000c,0103000e,0303000c,0303000e,0403000c,0403000e,0503000c,0503000e ;---> two groups of registrers for each device --> default 2 registers returned ---> 4 values per device 1,=h Contatore 1 1,010304UUuu@i0:10,C1_Voltage,V,C1Voltage,1 ;---> decoder for the first registry returned for the first group 1,010304xxxxUUuu@i0:1000,C1_Current,A,C1Current,3 ;---> decoder for the second registry returned for the first group 1,010304SSss@i1:1,C1_ActivePower,W,C1ActivePower,0 1,010304xxxxUUuu@i1:1,C1_ReactivePower,Var,C1ReactivePower,0 1,=h Contatore 3 1,030304UUuu@i2:10,C3_Voltage,V,C3Voltage,1 1,030304xxxxUUuu@i2:1000,C3_Current,A,C3Current,3 1,030304SSss@i3:1,C3_ActivePower,W,C3ActivePower,0 1,030304xxxxUUuu@i3:1,C3_ReactivePower,Var,C3ReactivePower,0 1,=h Contatore 4 1,040304UUuu@i4:10,C4_Voltage,V,C4Voltage,1 1,040304xxxxUUuu@i4:1000,C4_Current,A,C4Current,3 1,040304SSss@i5:1,C4_ActivePower,W,C4ActivePower,0 1,040304xxxxUUuu@i5:1,C4_ReactivePower,Var,C4ReactivePower,0 1,=h Contatore 5 1,050304UUuu@i6:10,C5_Voltage,V,C5Voltage,1 1,050304xxxxUUuu@i6:1000,C5_Current,A,C5Current,3 1,050304SSss@i7:1,C5_ActivePower,W,C5ActivePower,0 1,050304xxxxUUuu@i7:1,C5_ReactivePower,Var,C5ReactivePower,0 # Trovis 557x ~ These heating regulators have a lot of registers . > D > B -> sensor53 r > M 1 + 1 , 3 , m , 0 , 19200 , Trovis , 1 , 2 , rF7030009000E , rF703001C0004 , F703006A 1 , F7031CUUuu @ i0 : 10 , Au\u00dfentemp . , \u00b0 C , Temp_Outside , 1 1 , F7031CxxxxxxxxxxxxUUuu @ i0 : 10 , Vorlauftemp . , \u00b0 C , Temp_Flow , 1 1 , F7031CxxxxxxxxxxxxxxxxxxxxxxxxxxxxUUuu @ i0 : 10 , R\u00fccklauftemp . , \u00b0 C , Temp_Return , 1 1 , F7031CxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxUUuu @ i0 : 10 , Speichertemp . , \u00b0 C , Temp_Vessel , 1 1 , F70308UUuu @ i1 : 1 , MesswertImp - h , imp / h , Metric_ImpH , 0 1 , F70308xxxxUUuu @ i1 : 100 , Messwertm3 - h , m\u00b3 / h , Metric_M3H , 2 1 , F70308xxxxxxxxUUuu @ i1 : 10 , AA10 - 10 V , V , Metric_AA10 , 1 1 , F70308xxxxxxxxxxxxUUuu @ i1 : 10 , AA20 - 10 V , V , Metric_AA20 , 1 1 , F70304UUuu @ i2 : 1 , StellsignalRk1 , % , CtrlSig_RK1 , 0 # EasyMeter Q3A ~ A 2-Tarif Meter which for Example SWM (Stadtwerke M\u00fcnchen) uses. Unfortunately this Version sends only whole kWh (precision 0). > D > B => sensor53 r > M 1 + 1 , 3 , s , 0 , 9600 , SML 1 , 77070100010801f f @1000 , Verbrauch_Tarif_1 , kWh , Total_Tarif1 , 0 1 , 77070100010802f f @1000 , Verbrauch_Tarif_2 , kWh , Total_Tarif2 , 0 1 , 77070100010800f f @1000 , Verbrauch_Summe , kWh , Total_Summe , 0 #","title":"Smart Meter Interface"},{"location":"Smart-Meter-Interface/#descriptor-syntax","text":"This section must be present, but empty. In most cases, there is no need to define variables for this driver. >D Declare a script >B (boot) section to inform the interface to read the meter descriptor(s) >B => sensor53 r Declare a script >M section with the number of connected meters (n = 1..5 ) >M <n>","title":"Descriptor Syntax"},{"location":"Smart-Meter-Interface/#meter-declaration","text":"+<M>,<rxGPIO>,<type>,<flag>,<parameter>,<jsonPrefix>{,<txGPIO>,<txPeriod>,<cmdTelegram>} Example +1,3,o,0,9600,OBIS1,1,2,2F3F210D0A +1,3,s,16,9600,SML1 +1,12,c,1,-10,H20_Cnt +1,3,m,0,9600,MODBUS,1,1,01040000,01040002,01040004,01040006,01040008,0104000a,0104000c,0104000e,01040010 +<M>,<rxGPIO>,<type>,<flag>,<parameter>,<jsonPrefix>{,<txGPIO>,<txPeriod>,<cmdTelegram>} - <M> - meter number. The number must be increased with each additional Meter. (1...5) - <rxGPIO> - meter data receive GPIO - <type> - meter type of meter: - o = OBIS ASCII type of coding - s = SML binary smart message coding - c = Counter type - e = EBus binary coding - m = MODBus binary coding with serial mode 8N1 - M = MODBus binary coding with serial mode 8E1 - r = Raw binary coding (any binary telegram) - <flag> - options flag: - 0 = counter without pullup - 1 = counter with pullup - 16 = enable median filter for that meter. Can help with sporadic dropouts eg. reading errors. (not available for counters) - <parameter> - parameters according to meter type: - for o,s,e,m,r : serial baud rate eg. 9600 - for c : - positive value >0 = counter poll interval - negative value <=0 = debounce time (milliseconds) for irq driven counters - <jsonPrefix> - prefix for Web UI and MQTT JSON payload. Up to 7 characters - <txGPIO> - meter command transmit GPIO (optional) - <txPeriod> - number of 100ms increments (n * 100ms). Period to repeat the transmission of commands to the meter (optional) - <cmdTelegram> - comma separated hex coded byte blocks to send to meter device. For modbus each comma separated block is a command to retrieve a certain register from the meter (Optional, only required for measuring devices that have to be triggered with a certain character string.) Modbus: Example +1,3,m,0,9600,MODBUS,1,1,01040000,01040002,01040004,01040006,01040008,0104000a,0104000c,0104000e,01040010 Components of the character string: ...01040000,01040002,... 01 = Modbus slave device ID 04 = Instruction to read an Input Register (alternatively, 03 = Instruction to read an Holding Register) 0000 / 0002 = Register # (as Hexadecimal codification, without the prefix 0x . Example: 0x0079 -> 0079 ) the number of requested registers is fixed to 2, however with the char 'r' before the hex string the complete request string may be specified ...r010400000001,r010400020003,... Note ID , Instruction to read the Register value (Input vs Holding) and Register # may differ depending on the measuring device.","title":"Meter Declaration"},{"location":"Smart-Meter-Interface/#meter-metrics","text":"Each meter typically provides multiple metrics (voltage, power, current etc.) which it measures. An entry for each metric to be collected must be specified. up to 20 entries may be defined (default or #define SML_MAX_VARS N a larger number may be defined in user_config_override.h file). An entry defines how to decode the data and put it into variables. Example (OBIS/SML/MODBus): 1,1-0:1.8.1\\*255(@1,Total consumption,KWh,Total_in,4 1,77070100010801ff@1000,W1,kWh,w1,4 1,010304UUuuxxxxxxxx@i0:1,Spannung L1,V,Voltage_L1,0 <M>,<decoder>@<scale>,<label>,<UoM>,<var>,<precision> - <M> - meter number to which this decoder belongs - <decoder> - decoding specification. Decode OBIS as ASCII; SML, EBUS, MODBus, RAW as HEX ASCII - OBIS: ASCII OBIS code terminated with ( character which indicates the start of the meter value - SML: SML binary OBIS as hex terminated with 0xFF indicating start of SML encoded value - EBUS, MODBus, RAW: hex values of EBUS, MODBus, RAW block to compare - xx means ignore value (1 byte) - ss = extract a signed byte - uu = extract an unsigned byte - UUuu = extract an unsigned word (high order byte first) - uuUU = extract an unsigned word (low order byte first) - UUuuUUuu = extract an unsigned long word (high order byte first) - SSss = extract a signed word (high order byte first) - ssSS = extract a signed word (low order byte first) - SSssSSss = extract an signed long word (high order byte first) - ffffffff = extract a float value - FFffFFff = extract a reverse float value - @ decoding definition termination character - decoding a 0/1 bit is indicated by a @ character followed by bx: (x = 0..7 ) extracting the corresponding bit from a byte. e.g.: 1,xxxx5017xxuu@b0:1,Solarpump,,Solarpump,0 - in the case of MODBus , ix: designates the index (x = 0..n ) referring to the requested block in the transmit section of the meter definition Example +1,3,M,1,9600,SBC,1,2,01030023,01030028... 1,010304UUuuxxxxxxxx@i0:1,Voltage L1,V,Voltage_L1,0 < the i0:1 refers to: 01030023 with a scaling factor ( :1 ) of 1 1,010304UUuuxxxxxxxx@i1:10,Current L1,V,Current_L1,2 < the i1:10 refers to: 01030028 with a scaling factor ( :10 ) of 10 - <scale> - scaling factor (divisor) This can be a fraction (e.g., 0.1 => result * 10), or a negative value When decoding a string result (e.g., a serial meter), use # character for this parameter (only in one line per meter). For OBIS, you need a ) termination character after the # character Example: OBIS: 1,1-0:0.0.0\\*255(@#),Meter Nr,, Meter_number,0 SML: 1,77078181c78203ff@#,Service ID,,Meter_id,0 - <label> - web UI label (max 23 chars) if this label is the single char '*' the WEB UI is discarded for this line - <UoM> - unit of measure (max 7 chars) - <var> - MQTT variable name (max 23 chars) - <precision> - number of decimal places Add 16 to transmit the data immediately. Otherwise it is transmitted on TelePeriod Example 1,1-0:1.8.0*255(@1,consumption,KWh,Total_in,4 > Transmitted on TelePeriod 1,1-0:1.8.0*255(@1,consumption,KWh,Total_in,20 > Precision of 4. 4 + 16 = 20 >transmit its value immediately # character terminates the list Note in the decoding section of the meter defintions before the @ char no space chars are allowed Special Commands With the '=' char at the beginning of a line you may do some special decoding M,=m perform arithmetic ( +,-,*,/ ) on the metric. Use # before a number to designate a constant value Example 1,=m 3+4+5/#3 @100,Voltage L1+L2+L3/3,V,Volt_avg,2 1,=m 3+4+5/#3 add result of decoder entry 3,4,5 and divided by 3 (i.e., average) - M,=d calculate difference between metric values decoded at time intervals (up to 10 =d lines possible) Example 1,=d 3 10 calculate 10 second interval difference of decoder entry 3 - M,=h html text (up to 30 chars) inserts a html line between entries (these lines do not count as decoder entry) Example 1,=h================== insert a separator line With an asterisk * character replacing the name in a descriptor line, this line can be hidden in the main menu. (\"#define USE_SML_SCRIPT_CMD\" required) Example 1,010304ffffffff@i0:1,*,V,Voltage_L1-N,2 1,010304ffffffff@i1:1,*,V,Voltage_L2-N,2 1,010304ffffffff@i2:1,*,V,Voltage_L3-N,2 etc... With an asterisk * character as JSON Prefix in the Meter definiton suppresses the JSON output (\"#define USE_SML_SCRIPT_CMD\" required) Example +1,14,m,0,9600,*,12,2,01040000,01040002,01040004 To get the value of one of the descriptor lines, use sml[X]. X = Line number. Starts with 1. (\"#define USE_SML_SCRIPT_CMD\" required) Example >D v1=0 v2=0 >S ;Writes the value of Descriptorline 1 to v1 v1=sml[1] ;Writes the value of Descriptorline 2 to v2 v2=sml[2] Tip Use: sensor53 dM to output the received data in the console. M = the number of the defined meter in the script. Note During the output of the data in the console, the data in the WEB UI are not updated. To return write: sensor53 d0 Warning With a few meters, it is necessary to request the meter to send its data using a specific character string. This string has to be send at a very low baudrate. (300Baud) If you reply the meter with an acknowledge and ask the it for a new baudrate of 9600 baud, the baudrate of the SML driver has to be changed, too. To change the baudrate: sml( METERNUMBER 0 BAUDRATE ) For sending a specific character string: sml( METERNUMBER 1 STRING ) That works like this: Example >D res=0 scnt=0 ;For this Example in the >F section >F ;count 100ms scnt+=1 switch scnt case 6 ;set sml driver to 300 baud and send /?! as HEX to trigger the Meter res=sml(1 0 300) res=sml(1 1 \"2F3F210D0A\") ;1800ms later > Send ACK and ask for switching to 9600 baud case 18 res=sml(1 1 \"063035300D0A\") ;2000ms later > Switching sml driver to 9600 baud case 20 res=sml(1 0 9600) ;Restart sequence after 50x100ms case 50 ; 5000ms later > restart sequence scnt=0 ends >M 1 +1,3,o,0,9600, ,1 ...etc. You can find the example here. Attention This procedure is only necessary, if the meter explicitly asks for 300 baud. The most meters work directly with 9600 baud. Therefore it is easier to give this method a try: Example Meter#,GPIO# Input,TYPE,FLAG,Baudrate,JSONNAME,GPIO# Output,TX Period,Character string + 1,3, o, 0,9600, energy, 1,4,2F3F210D0A Example: here.","title":"Meter Metrics"},{"location":"Smart-Meter-Interface/#smart-meter-descriptors","text":"JANZ C3801 (SML - MODBUS) EMH ED300L (SML) Hager EHZ363 (SML) Hager EHZ161 (OBIS) Landis + Gyr ZMR120AR (OBIS) COMBO Meter (Water,Gas,SML) WOLF CSZ 11/300 Heater SDM530 (MODBUS) SDM230 (MODBUS) Janitza B23 (MODBUS) Hager EHZ363 (SML) with daily values Iskra MT 174 SBC ALE3 (MODBUS) 2 * SBC ALE3 (MODBUS) Trovis 557x 4 * Hiking DDS238-2 ZN/S (MODBUS)","title":"Smart Meter Descriptors"},{"location":"Smart-Meter-Interface/#janz-c3801-sml-modbus","text":"This is an example for one of the many quite similar smart meters implemented in Portugal, by EDP Distribui\u00e7\u00e3o S.A. . May be valid for many more models, as stated. You should configure your user_config_override.h as: #ifndef USE_SCRIPT #define USE_SCRIPT #endif #ifndef USE_SML_M #define USE_SML_M #endif #ifdef USE_RULES #undef USE_RULES #endif #define SML_MAX_VARS 10 Your Tasmota SML script : > D > B => sensor53 r > M 1 + 1 , 14 , m , 1 , 9600 , EB , 5 , 50 , 0104006 C , 01040079 , 0104007 A , 0104007 F , 01040026 , 01040027 , 01040028 , 0104000 B , 01040084 1 , = hVALORES T\u00c9CNICOS 1 , 010404 UUuuxxxx @i0 : 10 , Tens\u00e3o , V , Voltage_P1 , 17 1 , 010404 xxxxUUuu @i0 : 10 , Corrente , A , Current_P1 , 17 1 , 010408 UUuuUUuuxxxxxxxxxxxx @i1 : 1 , Pot\u00eancia ativa , W , Power_P1 , 16 1 , 010406 xxxxxxxxUUuu @i2 : 1000 , Fator de pot\u00eancia , pu , PFactor_P1 , 19 1 , 01040 aUUuuxxxx @i3 : 10 , Frequ\u00eancia , Hz , Frequency_P1 , 17 1 , = h & #8205 ; 1 , = hTOTALIZADORES DE ENERGIA 1 , 010408 UUuuUUuuxxxxxxxxxxxx @i4 : 1000 , Vazio ( 1 ), kWh , Energy_P1_R1 , 17 1 , 010408 UUuuUUuuxxxxxxxxxxxx @i5 : 1000 , Ponta ( 2 ), kWh , Energy_P1_R2 , 17 1 , 010408 UUuuUUuuxxxxxxxxxxxx @i6 : 1000 , Cheia ( 3 ), kWh , Energy_P1_R3 , 17 1 , = h & #8205 ; 1 , = hESTADOS 1 , 010406 uuxxxxxxxx @i7 : 1 , Tarifa ,, Tariff_P1 , 16 1 , 010406 uuxxxxxxxx @i8 : 1 , DCP ,, DCP_P1 , 16 #","title":"JANZ C3801 (SML - MODBUS)"},{"location":"Smart-Meter-Interface/#emh-ed300l-sml","text":"> D > B -> sensor53 r > M 2 + 1 , 13 , s , 0 , 9600 , Haus + 2 , 12 , s , 0 , 9600 , Heizung 1 , 770701000F0700F F @1 , Aktuell , W , Power_curr , 0 1 , 77070100010800F F @1000 , Z\u00e4hlerstand Verb ., kWh , Tariflos , 2 1 , 77070100020800F F @1000 , Z\u00e4hlerstand Einsp ., kWh , Tariflos , 2 2 , = h ================== 2 , 770701000F0700F F @1 , Aktuell , W , Power_curr , 0 2 , 77070100010800F F @1000 , Z\u00e4hlerstand Verb ., kWh , Tariflos , 2 2 , 77070100020800F F @1000 , Z\u00e4hlerstand Einsp ., kWh , Tariflos , 2 #","title":"EMH ED300L (SML)"},{"location":"Smart-Meter-Interface/#hager-ehz363-sml","text":"> D > B -> sensor53 r > M 1 + 1 , 3 , s , 0 , 9600 , SML 1 , 77070100010800f f @1000 , Total consumption , KWh , Total_in , 4 1 , 77070100020800f f @1000 , Total Feed , KWh , Total_out , 4 1 , 77070100100700f f @1 , Current consumption , W , Power_curr , 0 1 , 77070100000009f f @ # , Meter Nr ,, Meter_number , 0 #","title":"Hager EHZ363 (SML)"},{"location":"Smart-Meter-Interface/#hager-ehz161-obis","text":"> D > B -> sensor53 r > M 1 + 1 , 3 , o , 0 , 9600 , OBIS 1 , 1-0 : 1.8.1 \\ * 255 ( @1 , Total consumption , KWh , Total_in , 4 1 , 1-0 : 2.8.1 \\ * 255 ( @1 , Total Feed , KWh , Total_out , 4 1 , = d 2 10 @1 , Current consumption , W , Power_curr , 0 1 , 1-0 : 0.0.0 \\ * 255 (@ # ), Meter Nr ,, Meter_number , 0 #","title":"Hager EHZ161 (OBIS)"},{"location":"Smart-Meter-Interface/#landis-gyr-zmr120ares2r2sfcs-obis","text":"Example: Changing the baud rate during operation. > D ; Var Power consumption total HT + NT v1 = 0 ; HT Main electricity tariff consumption total v2 = 0 ; NT Night electricity tariff consumption total v3 = 0 ; Energie L1 + L2 + L3 v4 = 0 ; recent Energie L1 v5 = 0 ; recent Energie L2 v6 = 0 ; recent Energie L3 v7 = 0 ; Var minute min = 0 ; Var hour hr = 0 ; Var begin of the month 01. xx .20 xx 0 : 00 Uhr md = 0 ; Var begin of the year 01.01 . 0 : 00 Uhr yr = 0 ; Var for counter see > F = ms scnt = 0 ; Var for baudrate changeing res = 0 ; Permanent Var Meter1 0 : 00 p : sm = 0 p : HT_sm = 0 p : NT_sm = 0 ; Var for daily = 0 sd = 0 HT_sd = 0 NT_sd = 0 ; Permanent Var for month begin p : sma = 0 p : HT_sma = 0 p : NT_sma = 0 ; Var for monthly = 0 smn = 0 HT_smn = 0 NT_smn = 0 ; Permanent Var for year begin p : sya = 0 p : HT_sya = 0 p : NT_sya = 0 ; Var for yearly = 0 syn = 0 HT_syn = 0 NT_syn = 0 ; Fill vars with content on teleperiod > T v1 = # Total_in v2 = # HT_Total_in v3 = # NT_Total_in v4 = # kW_L1 + L2 + L3 v5 = # kw_L1 v6 = # kw_L2 v7 = # kw_L3 > B ; Restart driver -> sensor53 r ; Set teleperiod to 20 sec tper = 20 > F ; count 100 ms scnt += 1 switch scnt case 6 ; set sml driver to 300 baud and send /?! as HEX to trigger the Meter res = sml ( 1 0 300 ) res = sml ( 1 1 \"2F3F210D0A\" ) ; 1800 ms later \\ > Ack and ask for switching to 9600 baud case 18 res = sml ( 1 1 \"063035300D0A\" ) ; 2000 ms later \\ > Switching sml driver to 9600 baud case 20 res = sml ( 1 0 9600 ) ; Restart sequence after 50 x100ms case 50 ; 5000 ms later \\ > restart sequence scnt = 0 ends > S ; daily usage hr = hours if chg [ hr ] > 0 and hr == 0 and v1 > 0 then sm = v1 HT_sm = v2 NT_sm = v3 svars endif if upsecs % tper == 0 { sd = v1 - sm HT_sd = v2 - HT_sm NT_sd = v3 - NT_sm } ; Monthly usage md = day if chg [ md ] > 0 and md == 1 and v1 > 0 then sma = v1 HT_sma = v2 NT_sma = v3 svars endif if upsecs % tper == 0 { smn = v1 - sma HT_smn = v2 - HT_sma NT_smn = v3 - NT_sma } ; Yearly usage yr = year if chg [ yr ] > 0 and v1 > 0 then sya = v1 HT_sya = v2 NT_sya = v3 svars endif if upsecs % tper == 0 { syn = v1 - sya HT_syn = v2 - HT_sya NT_syn = v3 - NT_sya ; Json payload \\ > send on teleperiod > J , \"Strom_Vb_Tag\" :% 3 sd % , \"HT_Strom_Vb_Tag\" :% 3 HT_sd % , \"NT_Strom_Vb_Tag\" :% 3 NT_sd % , \"Strom_Vb_M\" :% 1 smn % , \"HT_Strom_Vb_M\" :% 1 HT_smn % , \"NT_Strom_Vb_M\" :% 1 NT_smn % , \"Strom_Vb_Jahr\" :% 0 syn % , \"HT_Strom_Vb_Jahr\" :% 0 HT_syn % , \"NT_Strom_Vb_Jahr\" :% 0 NT_syn % , \"Strom_0:00 _Uhr\" :% 1 sm % , \"HT_Strom_0:00 _Uhr\" :% 1 HT_sm % , \"NT_Strom_0:00 _Uhr\" :% 1 NT_sm % , \"Strom_Ma\" :% 3 sma % , \"HT_Strom_Ma\" :% 3 HT_sma % , \"NT_Strom_Ma\" :% 3 NT_sma % , \"Strom_Ja\" :% 3 sya % , \"HT_Strom_Ja\" :% 3 HT_sya % , \"NT_Strom_Ja\" :% 3 NT_sya % ; Webdisplay stuff > W ---------------------- 0 : 00 Uhr \u03a3 HT + NT : { m } % 0 sm % KWh HT : { m } % 0 HT_sm % KWh NT : { m } % 0 NT_sm % KWh ---------------------- Monatsanfang : { m } % 1 sma % KWh HT : { m } % 1 HT_sma % KWh NT : { m } % 1 NT_sma % KWh ---------------------- Jahresanfang : { m } % 0 sya % KWh HT : { m } % 0 HT_sya % KWh NT : { m } % 0 NT_sya % KWh ............................. Tagesverbrauch : { m } % 1 sd % KWh HT : { m } % 1 HT_sd % KWh NT : { m } % 1 NT_sd % KWh ---------------------- Monatsverbrauch : { m } % 0 smn % KWh HT : { m } % 0 HT_smn % KWh NT : { m } % 0 NT_smn % KWh --------------------- Jahresverbrauch : { m } % 0 syn % KWh HT : { m } % 0 HT_syn % KWh 0 : 00 Uhr \u03a3 HT + NT : { m } % 0 sm % KWh HT : { m } % 0 HT_sm % KWh NT : { m } % 0 NT_sm % KWh ---------------------- Monatsanfang : { m } % 1 sma % KWh HT : { m } % 1 HT_sma % KWh NT : { m } % 1 NT_sma % KWh ---------------------- Jahresanfang : { m } % 0 sya % KWh HT : { m } % 0 HT_sya % KWh NT : { m } % 0 NT_sya % KWh ............................. Tagesverbrauch : { m } % 1 sd % KWh HT : { m } % 1 HT_sd % KWh NT : { m } % 1 NT_sd % KWh ---------------------- Monatsverbrauch : { m } % 0 smn % KWh HT : { m } % 0 HT_smn % KWh NT : { m } % 0 NT_smn % KWh --------------------- Jahresverbrauch : { m } % 0 syn % KWh HT : { m } % 0 HT_syn % KWh NT : { m } % 0 NT_syn % KWhNT : { m } % 0 NT_syn % KWh > M 1 + 1 , 3 , o , 0 , 9600 ,, 1 1 , 0.0.1 ( @1 , Z\u00e4hlernummer ,, Meter_number , 0 1 , 0.9.1 (@ # ), Zeitstempel , Uhr , time - stamp , 0 1 , = h =================== 1 , 1.8.0 ( @1 , HT + NT Z\u00e4hlerstand , KWh , Total_in , 3 1 , 1.8.1 ( @1 , HT , KWh , HT_Total_in , 3 1 , 1.8.2 ( @1 , NT , KWh , NT_Total_in , 3 1 , = h =================== 1 , 36.7.0 ( @1 , Power_L1 , kW , kW_L1 , 2 1 , 56.7.0 ( @1 , Power_L2 , kW , kW_L2 , 2 1 , 76.7.0 ( @1 , Power_L3 , kW , kW_L3 , 2 1 , 16.7.0 ( @1 , \u03a3 _L1 + L2 + L3 , kW , kW_L1 + L2 + L3 , 2 1 , = h =================== 1 , 31.7.0 ( @1 , Strom_L1 , A , I_L1 , 2 1 , 51.7.0 ( @1 , Strom_L2 , A , I_L2 , 2 1 , 71.7.0 ( @1 , Strom_L3 , A , I_L3 , 2 #","title":"Landis + Gyr ZMR120AReS2R2sfCS (OBIS)"},{"location":"Smart-Meter-Interface/#combo-meter-watergassml","text":"> D > B -> sensor53 r > M 3 + 1 , 1 , c , 0 , 10 , H20 + 2 , 4 , c , 0 , 50 , GAS + 3 , 3 , s , 0 , 9600 , SML 1 , 1-0 : 1.8.0 \\ * 255 ( @10000 , Water reading , cbm , Count , 4 2 , = h ================== 2 , 1-0 : 1.8.0 \\ * 255 ( @100 , Gas reading , cbm , Count , 3 3 , 77070100010800f f @1000 , Total consumption , KWh , Total_in , 3 3 , = h ================== 3 , 77070100100700f f @1 , Current consumption , W , Power_curr , 2 3 , = h ------------------------------- 3 , = m 10 + 11 + 12 @100 , Currents L1 + L2 + L3 , A , Curr_summ , 2 3 , = m 13 + 14 + 15 / # 3 @100 , Voltage L1 + L2 + L3 / 3 , V , Volt_avg , 2 3 , = h ================== 3 , 77070100240700f f @1 , Consumption P1 , W , Power_p1 , 2 3 , 77070100380700f f @1 , Consumption P2 , W , Power_p2 , 2 3 , 770701004 c0700ff @1 , Consumption P3 , W , Power_p3 , 2 3 , = h ------------------------------- 3 , 770701001f0700f f @100 , Current L1 , A , Curr_p1 , 2 3 , 77070100330700f f @100 , Current L2 , A , Curr_p2 , 2 3 , 77070100470700f f @100 , Current L3 , A , Curr_p3 , 2 3 , = h ------------------------------- 3 , 77070100200700f f @100 , Voltage L1 , V , Volt_p1 , 2 3 , 77070100340700f f @100 , Voltage L2 , V , Volt_p2 , 2 3 , 77070100480700f f @100 , Voltage L3 , V , Volt_p3 , 2 3 , = h ================== 3 , 77070100000009f f @ # , Service ID ,, Meter_id , 0 3 , = h -------------------------------- #","title":"COMBO Meter (Water,Gas,SML)"},{"location":"Smart-Meter-Interface/#wolf-csz-11300-heater","text":"> D > B -> sensor53 r > M 1 + 1 , 3 , e , 0 , 2400 , EBUS 1 , xxxx0503xxxxxxxxxxxxxxxxss @1 , Outside temperature , C , Outsidetemp , 0 1 , xxxx5014xxxxxxxxxxuu @1 , Romm temperature , C , Roomtemp , 0 1 , xxxx0503xxxxxxxxxxxxxxuu @1 , Warmwater , C , Warmwater , 0 1 , xxxx0503xxxxxxxxxxuu @1 , Boiler , C , Boiler , 0 1 , 03f e0503xxxxxxxxxxxxuu @1 , Returns , C , Returns , 0 1 , 03f e0503xxxxuu @1 , Status ,, Status , 0 1 , 03f e0503xxxxxxuu @ b3 : 1 , Burner on ,, Burner , 0 1 , xxxx5017xxxxxxuuuu @16 , Solar collektor , C , Collector , 1 1 , xxxx5017xxxxxxxxxxuuuu @16 , Solar storage , C , Solarstorage , 1 1 , xxxx5017xxuu @ b0 : 1 , Solar pump on ,, Solarpump , 0 #","title":"WOLF CSZ 11/300 Heater"},{"location":"Smart-Meter-Interface/#modbus-devices","text":"","title":"MODBUS Devices"},{"location":"Smart-Meter-Interface/#sdm530","text":">D >B ->sensor53 r >M 1 +1,3,m,0,9600,MODBUS,1,1,01040000,01040002,01040004,01040006,01040008,0104000a,0104000c,0104000e,01040010 1,010404ffffffff@i0:1,Voltage P1,V,Voltage_P1,2 1,010404ffffffff@i1:1,Voltage P2,V,Voltage_P2,2 1,010404ffffffff@i2:1,Voltage P3,V,Voltage_P3,2 1,010404ffffffff@i3:1,Current P1,A,Current_P1,2 1,010404ffffffff@i4:1,Current P2,A,Current_P2,2 1,010404ffffffff@i5:1,Current P3,A,Current_P3,2 1,010404ffffffff@i6:1,Active Power P1,W,Power_P1,2 1,010404ffffffff@i7:1,Active Power P2,W,Power_P2,2 1,010404ffffffff@i8:1,Active Power P3,W,Power_P3,2 #","title":"SDM530"},{"location":"Smart-Meter-Interface/#sdm230","text":"> D ms = \"1,010404ffffffff@\" > B -> sensor53 r > M 1 + 1 , 3 , m , 0 , 9600 , PV , 1 , 2 , 01040000 , 01040006 , 0104000 C , 01040012 , 0104001 8 , 0104001 E , 01040024 , 01040046 , 0104004 8 , 0104004 A , 0104004 C , 0104004 E , 01040054 , 01040056 , 0104005 8 , 0104005 A , 0104005 C , 0104005 E , 01040102 , 0104010 8 , 01040152 , 0104015 8 , 010401 80 , 010401 82 %ms%i0 : 1 , Volt , V , Volt , 2 %ms%i1 : 1 , Strom P1 , A , Strom , 3 %ms%i2 : 1 , * , W , Leistung , 2 %ms%i3 : 1 , Scheinleistung , VA , ScheinLeistung , 2 %ms%i4 : 1 , Blindleistung , VAr , Blindleistung , 2 %ms%i5 : 1 , P - Faktor ,, P_Faktor , 1 %ms%i6 : 1 , cosPhi , \u00b0 , cosPhi , 2 %ms%i7 : 1 , Frequenz , Hz , Frequenz , 1 %ms%i8 : 1 , Wirkleistung Import , kWh , Wirkleistung_Im1 , 3 %ms%i9 : 1 , Wirkleistung Export , kWh , Wirkleistung_Ex , 3 %ms%i10 : 1 , Blindleistung Import , VkkVARh , Blindleistung_Im , 3 %ms%i11 : 1 , Blindleistung Export , VkkVARh , Blindleistung_Ex , 3 %ms%i12 : 1 , Gesamtleistungsbedarf , W , GesLeistBed , 2 %ms%i13 : 1 , GesamtLeistung Max , W , GesLeistMax , 2 %ms%i14 : 1 , Akt . Nachfrage , W , AktNachfrage , 2 %ms%i15 : 1 , R\u00fcckleistungs Bed , W , RueckLeistBed , 2 %ms%i16 : 1 , R\u00fcckleistungs Bed Max , W , RueckLeistBedMax , 2 %ms%i17 : 1 , Strom Nachfrage , A , StromNachfrage2 , 2 %ms%i19 : 1 , Max Strombedarf , A , StromBedMax , 2 %ms%i20 : 1 , Wirkleistung Gesamt , kWh , Wirkleistung_total , 2 %ms%i21 : 1 , Blindleistung Gesamt , kVARh , Blindleistung_total , 2 %ms%i22 : 1 , Temp Gesamtleistung , kWh , TempGesamtLeist , 2 #","title":"SDM230"},{"location":"Smart-Meter-Interface/#janitza-b23","text":"> D > B -> sensor53 r > M 1 + 1 , 3 , m , 0 , 9600 , Janitza , 1 , 1 , 01034 A38 , 01034 A3A , 01034 A3C , 01034 A4C , 01034 A4E , 01034 A50 , 01034 A72 , 01034 A7A , 01034 A82 1 , 010304 ffffffff @i0 : 1 , Voltage L1 - N , V , Voltage_L1 - N , 2 1 , 010304 ffffffff @i1 : 1 , Voltage L2 - N , V , Voltage_L2 - N , 2 1 , 010304 ffffffff @i2 : 1 , Voltage L3 - N , V , Voltage_L3 - N , 2 1 , 010304 ffffffff @i3 : 1 , Real power L1 - N , W , Real_power_L1 - N , 2 1 , 010304 ffffffff @i4 : 1 , Real power L2 - N , W , Real_power_L2 - N , 2 1 , 010304 ffffffff @i5 : 1 , Real power L3 - N , W , Real_power_L3 - N , 2 1 , 010304 ffffffff @i6 : 1 , Real energy L3 , Wh , Real_energy_L3 , 2 1 , 010304 ffffffff @i7 : 1 , Real energy L3 - consumed , Wh , Real_energy_L3_consumed , 2 1 , 010304 ffffffff @i8 : 1 , Real energy L3 - delivered , Wh , Real_energy_L3_delivered , 2 #","title":"Janitza B23"},{"location":"Smart-Meter-Interface/#hager-ehz363-sml-with-daily-values","text":"> D pin = 0 pout = 0 pi_d = 0 po_d = 0 hr = 0 ; permanent midnight values p : pi_m = 0 p : po_m = 0 > B -> sensor53 r > T ; get total consumption and total feed pin = SML # Total_in pout = SML # Total_out > S ; at midnight , save meter total values hr = hours if chg [ hr ] > 0 and hr == 0 then pi_m = pin po_m = pout svars endif ; on teleperiod calculate current daily values from midnight if upsecs % tper == 0 then pi_d = pin - pi_m po_d = pout - po_m endif ; show these values on WEB UI > W Tagesverbrauch : { m } % pi_d % kWh Tageseinspeisung : { m } % po_d % kWh ; transmit these values with MQTT > J , \"daily_consumption\" :% pi_d % , \"daily_feed\" :% po_d % ; meter definition > M 1 + 1 , 3 , s , 0 , 9600 , SML 1 , 77070100010800f f @1000 , Total Consumed , KWh , Total_in , 4 1 , 77070100020800f f @1000 , Total Delivered , KWh , Total_out , 4 1 , 77070100100700f f @1 , Current Consumption , W , Power_curr , 0 1 , 77070100000009f f @ # , Meter Number ,, Meter_number , 0 #","title":"Hager EHZ363 (SML) with daily values"},{"location":"Smart-Meter-Interface/#iskra-mt-174-obis","text":"> D > B -> sensor53 r > M 1 + 1 , 3 , o , 0 , 300 , STROM , 1 , 100 , 2F3F 210 D0A 1 , 1-0 : 1.8.1 * 255 ( @1 , Total Consumed , KWh , Total_in , 3 1 , 1-0 : 2.8.1 * 255 ( @1 , Total Delivered , KWh , Total_out , 3 1 , 1-0 : 0.0.0 * 255 (@ # ), Meter Number ,, Meter_number , 0 #","title":"Iskra MT 174 (OBIS)"},{"location":"Smart-Meter-Interface/#sbc-ale3-modbus","text":"> D > B -> sensor53 r > M 1 + 1 , 3 , M , 1 , 9600 , SBC , 1 , 1 , 02030023 , 02030028 , 0203002 d , 02030025 , 0203002 a , 0203002 f , 02030032 , 02030027 , 0203002 c , 02030031 , 02030021 , 02030015 , 02030018 1 , 020304 UUuu @i0 : 1 , Spannung L1 , V , Voltage_L1 , 0 1 , 020304 UUuu @i1 : 1 , Spannung L2 , V , Voltage_L2 , 0 1 , 020304 UUuu @i2 : 1 , Spannung L3 , V , Voltage_L3 , 0 1 , 020304 xxxxUUuu @i0 : 10 , Strom L1 , A , Current_L1 , 2 1 , 020304 xxxxUUuu @i1 : 10 , Strom L2 , A , Current_L2 , 2 1 , 020304 xxxxUUuu @i2 : 10 , Strom L3 , A , Current_L3 , 2 1 , = h = 1 , 020304 UUuu @i3 : 100 , Leistung L1 , kW , Power_L1 , 3 1 , 020304 UUuu @i4 : 100 , Leistung L2 , kW , Power_L2 , 3 1 , 020304 UUuu @i5 : 100 , Leistung L3 , kW , Power_L3 , 3 1 , 020304 UUuu @i6 : 100 , Leistung Total , kW , Power_Total , 3 1 , 020304 xxxxSSss @i3 : 100 , BlindLeistung L1 , kVAr , ReaktivePower_L1 , 3 1 , 020304 xxxxSSss @i4 : 100 , BlindLeistung L2 , kVAr , ReaktivePower_L2 , 3 1 , 020304 xxxxSSss @i5 : 100 , BlindLeistung L3 , kVAr , ReaktivePower_L3 , 3 1 , 020304 xxxxSSss @i6 : 100 , BLeistung Total , kVAr , ReaktivePower_Total , 3 1 , = h = 1 , 020304 UUuu @i7 : 100 , CosPhi L1 ,, CosPhi_L1 , 2 1 , 020304 UUuu @i8 : 100 , CosPhi L2 ,, CosPhi_L2 , 2 1 , 020304 UUuu @i9 : 100 , CosPhi L3 ,, CosPhi_L3 , 2 1 , = h = 1 , 020304 UUuuUUuu @i10 : 100 , T2 Wert , kWh , T2_Value , 2 #","title":"SBC ALE3 MODBUS"},{"location":"Smart-Meter-Interface/#2-sbc-ale3-modbus","text":"> D > B -> sensor53 r > M 1 + 1 , 3 , M , 1 , 9600 , Meter , 1 , 1 , 01030023 , 01030028 , 0103002 d , 01030025 , 0103002 a , 0103002 f , 01030032 , 01030027 , 0103002 c , 01030031 , 0103001 B , 0103001 d , 03030023 , 03030028 , 0303002 d , 03030025 , 0303002 a , 0303002 f , 03030032 , 03030027 , 0303002 c , 03030031 , 0303001 B , 0303001 d 1 , = h Domestic Electricity : 1 , 010304 UUuuUUuu @i10 : 100 , 1 Tariff 1 total , kWh , M1_T1_total , 2 1 , 010304 UUuuUUuu @i11 : 100 , 1 Tariff 1 partial , kWh , M1_T1_par , 2 1 , = h Readings : 1 , 010304 UUuu @i0 : 1 , 1 Voltage L1 , V , M1_Voltage_L1 , 0 1 , 010304 UUuu @i1 : 1 , 1 Voltage L2 , V , M1_Voltage_L2 , 0 1 , 010304 UUuu @i2 : 1 , 1 Voltage L3 , V , M1_Voltage_L3 , 0 1 , 010304 xxxxUUuu @i0 : 10 , 1 Current L1 , A , M1_Current_L1 , 2 1 , 010304 xxxxUUuu @i1 : 10 , 1 Current L2 , A , M1_Current_L2 , 2 1 , 010304 xxxxUUuu @i2 : 10 , 1 Current L3 , A , M1_Current_L3 , 2 1 , 010304 UUuu @i3 : 100 , 1 Active Power L1 , kW , M1_PRMS_L1 , 3 1 , 010304 UUuu @i4 : 100 , 1 Active Power L2 , kW , M1_PRMS_L2 , 3 1 , 010304 UUuu @i5 : 100 , 1 Active Power L3 , kW , M1_PRMS_L3 , 3 1 , 010304 UUuu @i6 : 100 , 1 Active Power total , kW , M1_PRMS_total , 3 1 , 010304 xxxxSSss @i3 : 100 , 1 Reactive Power L1 , kVAr , M1_QRMS_L1 , 3 1 , 010304 xxxxSSss @i4 : 100 , 1 Reactive Power L2 , kVAr , M1_QRMS_L2 , 3 1 , 010304 xxxxSSss @i5 : 100 , 1 Reactive Power L3 , kVAr , M1_QRMS_L3 , 3 1 , 010304 xxxxSSss @i6 : 100 , 1 Reactive Power total , kVAr , M1_QRMS_total , 3 1 , 010304 UUuu @i7 : 100 , 1 CosPhi L1 ,, M1_CosPhi_L1 , 2 1 , 010304 UUuu @i8 : 100 , 1 CosPhi L2 ,, M1_CosPhi_L2 , 2 1 , 010304 UUuu @i9 : 100 , 1 CosPhi L3 ,, M1_CosPhi_L3 , 2 1 , = h________________________________________________ ; meter 2 + 12 offset 1 , = h Heat Pump 1 , 030304 UUuuUUuu @i22 : 100 , 2 Tariff 1 total , kWh , M2_T1_total , 2 1 , 030304 UUuuUUuu @i23 : 100 , 2 Tariff 1 partial , kWh , M2_T1_par , 2 1 , = h Readings : 1 , 030304 UUuu @i12 : 1 , 2 Voltage L1 , V , M2_Voltage_L1 , 0 1 , 030304 UUuu @i13 : 1 , 2 Voltage L2 , V , M2_Voltage_L2 , 0 1 , 030304 UUuu @i14 : 1 , 2 Voltage L3 , V , M2_Voltage_L3 , 0 1 , 030304 xxxxUUuu @i12 : 10 , 2 Current L1 , A , M2_Current_L1 , 2 1 , 030304 xxxxUUuu @i13 : 10 , 2 Current L2 , A , M2_Current_L2 , 2 1 , 030304 xxxxUUuu @i14 : 10 , 2 Current L3 , A , M2_Current_L3 , 2 1 , 030304 UUuu @i15 : 100 , 2 Active Power L1 , kW , M2_PRMS_L1 , 3 1 , 030304 UUuu @i16 : 100 , 2 Active Power L2 , kW , M2_PRMS_L2 , 3 1 , 030304 UUuu @i17 : 100 , 2 Active Power L3 , kW , M2_PRMS_L3 , 3 1 , 030304 UUuu @i18 : 100 , 2 Active Power total , kW , M2_PRMS_total , 3 1 , 030304 xxxxSSss @i15 : 100 , 2 Reactive Power L1 , kVAr , M2_QRMS_L1 , 3 1 , 030304 xxxxSSss @i16 : 100 , 2 Reactive Power L2 , kVAr , M2_QRMS_L2 , 3 1 , 030304 xxxxSSss @i16 : 100 , 2 Reactive Power L3 , kVAr , M2_QRMS_L3 , 3 1 , 030304 xxxxSSss @i18 : 100 , 2 Reactive Power total , kVAr , M2_QRMS_total , 3 1 , 030304 UUuu @i19 : 100 , 2 CosPhi L1 ,, M2_CosPhi_L1 , 2 1 , 030304 UUuu @i20 : 100 , 2 CosPhi L2 ,, M2_CosPhi_L2 , 2 1 , 030304 UUuu @i21 : 100 , 2 CosPhi L3 ,, M2_CosPhi_L3 , 2 #","title":"2 * SBC ALE3 MODBUS"},{"location":"Smart-Meter-Interface/#4-hiking-dds238-2-zns3-modbus","text":"This is an example for 4 MODBUS devices on the same bus >D >B ->sensor53 r >`>M 1` > +1,3,m,1,9600,Hiking,1,10,0103000c,0103000e,0303000c,0303000e,0403000c,0403000e,0503000c,0503000e ;---> two groups of registrers for each device --> default 2 registers returned ---> 4 values per device 1,=h Contatore 1 1,010304UUuu@i0:10,C1_Voltage,V,C1Voltage,1 ;---> decoder for the first registry returned for the first group 1,010304xxxxUUuu@i0:1000,C1_Current,A,C1Current,3 ;---> decoder for the second registry returned for the first group 1,010304SSss@i1:1,C1_ActivePower,W,C1ActivePower,0 1,010304xxxxUUuu@i1:1,C1_ReactivePower,Var,C1ReactivePower,0 1,=h Contatore 3 1,030304UUuu@i2:10,C3_Voltage,V,C3Voltage,1 1,030304xxxxUUuu@i2:1000,C3_Current,A,C3Current,3 1,030304SSss@i3:1,C3_ActivePower,W,C3ActivePower,0 1,030304xxxxUUuu@i3:1,C3_ReactivePower,Var,C3ReactivePower,0 1,=h Contatore 4 1,040304UUuu@i4:10,C4_Voltage,V,C4Voltage,1 1,040304xxxxUUuu@i4:1000,C4_Current,A,C4Current,3 1,040304SSss@i5:1,C4_ActivePower,W,C4ActivePower,0 1,040304xxxxUUuu@i5:1,C4_ReactivePower,Var,C4ReactivePower,0 1,=h Contatore 5 1,050304UUuu@i6:10,C5_Voltage,V,C5Voltage,1 1,050304xxxxUUuu@i6:1000,C5_Current,A,C5Current,3 1,050304SSss@i7:1,C5_ActivePower,W,C5ActivePower,0 1,050304xxxxUUuu@i7:1,C5_ReactivePower,Var,C5ReactivePower,0 #","title":"4 * Hiking DDS238-2 ZN/S3 MODBUS"},{"location":"Smart-Meter-Interface/#trovis-557x","text":"These heating regulators have a lot of registers . > D > B -> sensor53 r > M 1 + 1 , 3 , m , 0 , 19200 , Trovis , 1 , 2 , rF7030009000E , rF703001C0004 , F703006A 1 , F7031CUUuu @ i0 : 10 , Au\u00dfentemp . , \u00b0 C , Temp_Outside , 1 1 , F7031CxxxxxxxxxxxxUUuu @ i0 : 10 , Vorlauftemp . , \u00b0 C , Temp_Flow , 1 1 , F7031CxxxxxxxxxxxxxxxxxxxxxxxxxxxxUUuu @ i0 : 10 , R\u00fccklauftemp . , \u00b0 C , Temp_Return , 1 1 , F7031CxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxUUuu @ i0 : 10 , Speichertemp . , \u00b0 C , Temp_Vessel , 1 1 , F70308UUuu @ i1 : 1 , MesswertImp - h , imp / h , Metric_ImpH , 0 1 , F70308xxxxUUuu @ i1 : 100 , Messwertm3 - h , m\u00b3 / h , Metric_M3H , 2 1 , F70308xxxxxxxxUUuu @ i1 : 10 , AA10 - 10 V , V , Metric_AA10 , 1 1 , F70308xxxxxxxxxxxxUUuu @ i1 : 10 , AA20 - 10 V , V , Metric_AA20 , 1 1 , F70304UUuu @ i2 : 1 , StellsignalRk1 , % , CtrlSig_RK1 , 0 #","title":"Trovis 557x"},{"location":"Smart-Meter-Interface/#easymeter-q3a","text":"A 2-Tarif Meter which for Example SWM (Stadtwerke M\u00fcnchen) uses. Unfortunately this Version sends only whole kWh (precision 0). > D > B => sensor53 r > M 1 + 1 , 3 , s , 0 , 9600 , SML 1 , 77070100010801f f @1000 , Verbrauch_Tarif_1 , kWh , Total_Tarif1 , 0 1 , 77070100010802f f @1000 , Verbrauch_Tarif_2 , kWh , Total_Tarif2 , 0 1 , 77070100010800f f @1000 , Verbrauch_Summe , kWh , Total_Summe , 0 #","title":"EasyMeter Q3A"},{"location":"Sonoff-DIY/","text":"Some new Sonoff devices support the new Itead DIY architecture which allows OTA firmware upload. With Sonoff DIY , a user has more control over the hardware features of the device and also allows for upgrading the firmware without additional hardware. The following procedure upgrades Sonoff eWelink firmware to Tasmota. There are many reports this procedure has changed with newer versions of Sonoff DIY Tasmota does not provide any kind of support for flashing using this method. Please contact Sonoff Support for help. IMPORTANT: There are some reports suggesting that the Windows version of Sonoff DIY Tool contains a trojan. It is not clear if it actually contains the malicious code or these are just false positives due to the way Python code was converted to native executables. Nevertheless, proceed with care. Compatible devices ~ Currently the following devices officially support Sonoff DIY: - Sonoff Basic R3 - Sonoff RF R3 - Sonoff Mini As Sonoff DIY is enabled by connecting GPIO16 to GND it may well be possible that other Sonoff devices running eWelink will support it. Note The OTA process Sonoff provides through the Sonoff DIY procedure does not create a backup of the Itead firmware on the device. If you use this OTA method to flash Tasmota on the Sonoff device, you will not be able to revert to the original factory firmware. Flash procedure ~ Guide originally from @Brunas Follow instructions how to enter DIY mode from Sonoff . This is the excerpt from it: Power on; Long press the button for 5 seconds for entering Compatible Pairing Mode (AP) User tips: If the device has been paired with eWeLink APP, reset the device is necessary by long press the pairing button for 5 seconds, then press another 5 seconds for entering Compatible Pairing Mode (AP) The LED indicator will blink continuously; From mobile phone or PC WiFi setting, an Access Point of the device named ITEAD-XXXXXXXX will be found, connect it with default password 12345678 Open the browser and access http://10.10.7.1/ Next, Fill in WiFi SSID and password that the device would have connected with Succeed, Now the device is in DIY mode. Note: I needed to manually change IP address to 10.10.7.2, 255.0.0.0 with gateway 10.10.7.1 in adapter TCP/IPv4 settings to access that IP address. Use Fing or any similar local network scanning app on your smartphone or PC to find IP address of your Sonoff Mini device. MAC Vendor most likely is Espressif and the device has 8081 port open. Install Rester extension in Chrome or Firefox or any other preferred tool to perform REST API operations. To test your device DIY mode create new request in Rester : Method: POST URL: http://< IP of your device >:8081/zeroconf/info Body: {\"data\": {}} You might need to add Header Content-Type with value application/json Press SEND If all is OK, status code 200 should be returned with bunch of data: { \"seq\" : 1 , \"error\" : 0 , \"data\" : { \"switch\" : \"off\" , \"startup\" : \"off\" , \"pulse\" : \"off\" , \"pulseWidth\" : 2000 , \"ssid\" : \"YourWiFi\" , \"otaUnlock\" : false , \"fwVersion\" : \"3.6.0\" , \"deviceid\" : \"YourDeviceId\" , \"bssid\" : \"YourBSSId\" , \"signalStrength\" : -52 } } 7. If that doesn't return *200*, try going back to 5s+5s reset above. If all above works, let's unlock OTA: Method: POST URL: http://< IP of your device >:8081/zeroconf/ota_unlock Body: {\"data\": {}} You might need to add Header Content-Type with value application/json Press SEND You should get status code 200 Optionally for curiousity you could retry info query to check if otaUnlock value now is true Sonoff's flashing tool should see your device now! Download Tasmota-lite.bin from https://github.com/arendst/Tasmota/releases and flash it according to instructions everywhere on the Internet. Just the WiFi AP name is TASMOTA_XXXX and not sonoff_XXX. Video tutorials ~ Andreas Spiess DrZzs Paul Hibbert More info: ~ Michel Deslierres","title":"Sonoff DIY"},{"location":"Sonoff-DIY/#compatible-devices","text":"Currently the following devices officially support Sonoff DIY: - Sonoff Basic R3 - Sonoff RF R3 - Sonoff Mini As Sonoff DIY is enabled by connecting GPIO16 to GND it may well be possible that other Sonoff devices running eWelink will support it. Note The OTA process Sonoff provides through the Sonoff DIY procedure does not create a backup of the Itead firmware on the device. If you use this OTA method to flash Tasmota on the Sonoff device, you will not be able to revert to the original factory firmware.","title":"Compatible devices"},{"location":"Sonoff-DIY/#flash-procedure","text":"Guide originally from @Brunas Follow instructions how to enter DIY mode from Sonoff . This is the excerpt from it: Power on; Long press the button for 5 seconds for entering Compatible Pairing Mode (AP) User tips: If the device has been paired with eWeLink APP, reset the device is necessary by long press the pairing button for 5 seconds, then press another 5 seconds for entering Compatible Pairing Mode (AP) The LED indicator will blink continuously; From mobile phone or PC WiFi setting, an Access Point of the device named ITEAD-XXXXXXXX will be found, connect it with default password 12345678 Open the browser and access http://10.10.7.1/ Next, Fill in WiFi SSID and password that the device would have connected with Succeed, Now the device is in DIY mode. Note: I needed to manually change IP address to 10.10.7.2, 255.0.0.0 with gateway 10.10.7.1 in adapter TCP/IPv4 settings to access that IP address. Use Fing or any similar local network scanning app on your smartphone or PC to find IP address of your Sonoff Mini device. MAC Vendor most likely is Espressif and the device has 8081 port open. Install Rester extension in Chrome or Firefox or any other preferred tool to perform REST API operations. To test your device DIY mode create new request in Rester : Method: POST URL: http://< IP of your device >:8081/zeroconf/info Body: {\"data\": {}} You might need to add Header Content-Type with value application/json Press SEND If all is OK, status code 200 should be returned with bunch of data: { \"seq\" : 1 , \"error\" : 0 , \"data\" : { \"switch\" : \"off\" , \"startup\" : \"off\" , \"pulse\" : \"off\" , \"pulseWidth\" : 2000 , \"ssid\" : \"YourWiFi\" , \"otaUnlock\" : false , \"fwVersion\" : \"3.6.0\" , \"deviceid\" : \"YourDeviceId\" , \"bssid\" : \"YourBSSId\" , \"signalStrength\" : -52 } } 7. If that doesn't return *200*, try going back to 5s+5s reset above. If all above works, let's unlock OTA: Method: POST URL: http://< IP of your device >:8081/zeroconf/ota_unlock Body: {\"data\": {}} You might need to add Header Content-Type with value application/json Press SEND You should get status code 200 Optionally for curiousity you could retry info query to check if otaUnlock value now is true Sonoff's flashing tool should see your device now! Download Tasmota-lite.bin from https://github.com/arendst/Tasmota/releases and flash it according to instructions everywhere on the Internet. Just the WiFi AP name is TASMOTA_XXXX and not sonoff_XXX.","title":"Flash procedure"},{"location":"Sonoff-DIY/#video-tutorials","text":"Andreas Spiess DrZzs Paul Hibbert","title":"Video tutorials"},{"location":"Sonoff-DIY/#more-info","text":"Michel Deslierres","title":"More info:"},{"location":"Status-LED/","text":"","title":"Status LED"},{"location":"Subscribe-%26-Unsubscribe/","text":"This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef SUPPORT_MQTT_EVENT #define SUPPORT_MQTT_EVENT #endif Subscribe ~ Subscribes to an MQTT topic and assigns an Event name to it. Subscribe <eventName>, <mqttTopic> [, <key>] The <key> parameter is specified when you need to parse a key/value pair from a JSON payload in the MQTT message. In order to parse a value from a multi-level JSON pair, you can use one dot ( . ) syntax to split the key into sections. You subscribe to an MQTT topic and assign an event name. Once the subscribed MQTT message is received the configured event will be triggered. Command without any parameters will list all currently subscribed topics. You can set up a rule with ON EVENT#<event_name> DO ... ENDON to do what you want based on this MQTT message. The payload is passed as a parameter once the event has been triggered. If the payload is in JSON format, you are able to get the value of specified key as a parameter. For example, if you have a Tasmota based thermostat and multiple temperature sensors in different locations, usually you have to set up a home automation system like Domoticz to control the thermostat. Right now, with this new feature, you can write a rule to do this. Examples: Rule1 ON mqtt#connected DO Subscribe BkLight, stat/%topic%/POWER ENDON ON Event#BkLight=ON DO <command> ENDON Rule1 ON mqtt#connected DO Subscribe DnTemp, stat/%topic%/SENSOR, DS18B20.Temperature ENDON ON Event#DnTemp>=21 DO <command> ENDON where the MQTT message payload is `{\"Time\":\"2017-02-16T10:13:52\", \"DS18B20\":{\"Temperature\":20.6}}` Unsubscribe ~ Unsubscribe from topics which were subscribed to using the Subscribe command. Unsubscribe from a specific MQTT topic Unsubscribe <eventName> The command without a parameter will unsubscribe from all currently subscribed topics.","title":"Subscribe & Unsubscribe"},{"location":"Subscribe-%26-Unsubscribe/#subscribe","text":"Subscribes to an MQTT topic and assigns an Event name to it. Subscribe <eventName>, <mqttTopic> [, <key>] The <key> parameter is specified when you need to parse a key/value pair from a JSON payload in the MQTT message. In order to parse a value from a multi-level JSON pair, you can use one dot ( . ) syntax to split the key into sections. You subscribe to an MQTT topic and assign an event name. Once the subscribed MQTT message is received the configured event will be triggered. Command without any parameters will list all currently subscribed topics. You can set up a rule with ON EVENT#<event_name> DO ... ENDON to do what you want based on this MQTT message. The payload is passed as a parameter once the event has been triggered. If the payload is in JSON format, you are able to get the value of specified key as a parameter. For example, if you have a Tasmota based thermostat and multiple temperature sensors in different locations, usually you have to set up a home automation system like Domoticz to control the thermostat. Right now, with this new feature, you can write a rule to do this. Examples: Rule1 ON mqtt#connected DO Subscribe BkLight, stat/%topic%/POWER ENDON ON Event#BkLight=ON DO <command> ENDON Rule1 ON mqtt#connected DO Subscribe DnTemp, stat/%topic%/SENSOR, DS18B20.Temperature ENDON ON Event#DnTemp>=21 DO <command> ENDON where the MQTT message payload is `{\"Time\":\"2017-02-16T10:13:52\", \"DS18B20\":{\"Temperature\":20.6}}`","title":"Subscribe"},{"location":"Subscribe-%26-Unsubscribe/#unsubscribe","text":"Unsubscribe from topics which were subscribed to using the Subscribe command. Unsubscribe from a specific MQTT topic Unsubscribe <eventName> The command without a parameter will unsubscribe from all currently subscribed topics.","title":"Unsubscribe"},{"location":"Supported-Modules/","text":"Supported Modules ~ Sonoff 4CH Sonoff 4CH Pro Sonoff 4CH DIY Sonoff B1 / B1 R2 Sonoff Basic R1/R2/R3 Sonoff Dual Sonoff Dual R2 Sonoff iFan02 Sonoff iFan03 Sonoff Mini Sonoff Pow Sonoff Pow R2 Sonoff PSA Sonoff RF Sonoff RF R3 Sonoff RF Bridge 433 Sonoff S20 Smart Socket Sonoff S26 Smart Socket Sonoff S31 Sonoff SC Sonoff Slampher Sonoff SV Sonoff T1 Sonoff Touch Sonoff TH Arilux LC02 Armtronix Dimmers Blitzwolf BW-SHP2 Blitzwolf BW-SHP4 Blitzwolf BW-SHP6 Digoo DG-SP202 Geekcreit 2CH Gosund SP1 H801 LED Controller HuaFan Smart Socket Luminea LED Controller MagicHome LED Controller (ESP-12S/ESP-2M.md) MagicHome LED Controller (ESP8285.md) Mi Desk Lamp PS-16-DZ Dimmer OBI Socket OBI Socket 2 OBI Socket IP44 (Black.md) Shelly 1 Shelly 1PM Shelly 2 Shelly 2.5 SK03 Outdoor Smart Plug Teckin SP10 Smart Socket Teckin SP22 YTF IR Bridge WT003-EU 4 AC + 4 USB Outlet Tuya Power Strip EU Wemos D1 R1 & R2 Wemos D1 Mini Other Devices","title":"Supported Modules"},{"location":"Supported-Modules/#supported-modules","text":"Sonoff 4CH Sonoff 4CH Pro Sonoff 4CH DIY Sonoff B1 / B1 R2 Sonoff Basic R1/R2/R3 Sonoff Dual Sonoff Dual R2 Sonoff iFan02 Sonoff iFan03 Sonoff Mini Sonoff Pow Sonoff Pow R2 Sonoff PSA Sonoff RF Sonoff RF R3 Sonoff RF Bridge 433 Sonoff S20 Smart Socket Sonoff S26 Smart Socket Sonoff S31 Sonoff SC Sonoff Slampher Sonoff SV Sonoff T1 Sonoff Touch Sonoff TH Arilux LC02 Armtronix Dimmers Blitzwolf BW-SHP2 Blitzwolf BW-SHP4 Blitzwolf BW-SHP6 Digoo DG-SP202 Geekcreit 2CH Gosund SP1 H801 LED Controller HuaFan Smart Socket Luminea LED Controller MagicHome LED Controller (ESP-12S/ESP-2M.md) MagicHome LED Controller (ESP8285.md) Mi Desk Lamp PS-16-DZ Dimmer OBI Socket OBI Socket 2 OBI Socket IP44 (Black.md) Shelly 1 Shelly 1PM Shelly 2 Shelly 2.5 SK03 Outdoor Smart Plug Teckin SP10 Smart Socket Teckin SP22 YTF IR Bridge WT003-EU 4 AC + 4 USB Outlet Tuya Power Strip EU Wemos D1 R1 & R2 Wemos D1 Mini Other Devices","title":"Supported Modules"},{"location":"Supported-Peripherals/","text":"Supported Peripherals ~ Name Description A4988 Stepper Motor Controller ADC Analog input over A0 pin ADS111x A/D Converter AHT10 AHT15 Asair AHT10 / AHT15 Temperature and Humidity Sensor (I 2 C) AM2301 (DHT21) AM2302 (DHT22) AM2321 Temperature and Humidity Sensor (gpio) AS608 AS608 Optical and R503 Capacitive Fingerprint Sensor (I 2 C) AS3935 Franklin Lightning Sensor (serial) APDS-9960 Ambient Light, RGB Color and Proximity Sensor with Gesture Detection AZ 7798 CO 2 Meter Datalogger BH1750 Luminosity Sensor BMP280 BMP085 BMP180) Pressure Sensor BME280 Temperature, Humidity and Pressure Sensor BME680 Temperature, Humidity, Pressure and Gas Sensor Buzzer Audio Signalling Device CC2530 TI CC2530 Zigbee Adapter (serial) CCS811 Gas and Air Quality Sensor (I 2 C) Chirp! Soil Moisture Sensor Moisture Sensor (I 2 C) DHT11 Temperature and Humidity Sensor DHT12 DYP-ME007 Ultrasonic distance Sensor (serial) DS18x20 Temperature Sensor (1-Wire) DS1624 DS1621 Temperature Sensor (1-Wire) DS3231 Real-Time-Clock (I 2 C) EZO EZO series of chemical Sensors (I 2 C) F&F LE-01MR F&F LE-01MR Single Phase Modbus Energy meter GPS-NTP-server GPS-NTP-server (serial) HDC1080 Texas Instruments HDC1080 Humidity and Temperature Sensor (I 2 C) HM-10 BLE Bluetooth gateway (serial) HM-17 HM-16 Bluetooth iBeacon reader (serial) HP303B Barometric Pressure Shield (I 2 C) HR-E Water Meter Encoder interface (serial) HRXL MaxBotix HRXL line of Sonar Ranging Sensors (gpio) HC-SR04 HC-SR04P JSN-SR04T) Ultrasonic Sensor Honeywell HIH Temperature and Humidity Sensor (I 2 C) Honeywell HPMA115xx Particulate Matter Sensor (serial) HTU21 Temperature and Humidity Sensor (I 2 C) HX711 Load Cell Sensor (gpio) iAQ-Core Indoor Air Quality Sensor (I 2 C) iEM3000 Schenider Electric modbus energy meter (serial) INA219 High-Side DC Current and Voltage Sensor (I 2 C) IR Remote IR transmitter and receiver K30, K70, S8 CO 2 Sensor (I 2 C) LM75AD Temperature Sensor (I 2 C) LMT01 Temperature Sensor (gpio) MAX31855 MAX6675 Thermocouple Sensor (SPI) MAX31865 RTD Temperature Sensor Amplifier (SPI) MAX44009 Ambient Light Sensor (I 2 C) MCP23008 MCP23017 I/O Expander (I 2 C) MFRC522 NFC Tag Reader (SPI) MGC3130 3D Tracking and Gesture Controller MH-Z19B CO 2 Sensor MLX90614 MLX9061X Infrared Thermometer (I 2 C) MLX90640 MLX90640 Far Infrared Thermal Sensor Array (I 2 C) NRF24L01 NRF24L01 as BLE-bridge for Mijia BT Sensors (SPI) OpenTherm OpenTherm adapter (serial) MCP9808 Temperature Sensor (I 2 C) MPR121 Proximity Capacitive Touch Sensor Controller (I 2 C) MPU6050 3-Axis Gyroscope and 3-Axis Accelerometer Sensor (I 2 C) P1 Smart Meter Energy Meter (serial) PAJ7620 Gesture & Proximity Detection Sensor PIR Passive Infrared Sensor (gpio) PCA9685 16-channel, 12-bit PWM LED controller (I 2 C) PCF8574 8-port IO Expander (I 2 C) PMS3003 PMS5003 PMS7003 Particle Concentration Sensor (serial) PN532 NFC/RFID controller PZEM-004 PZEM-016 Energy Monitor (serial) RCWL-0516 Microwave Radar Presence detection RDM6300 125Khz RFID Module RF Transciever IR receiver and/or transmitter RX-4M50RR30SF RX-AM8SF RF Sensor receiver (gpio) SCD30 CO 2 Sensor (I 2 C) Eastron SDM120 Modbus Energy Meter (serial) Eastron SDM630 Modbus Energy Meter (serial) SDS011 SDS021 Laser Dust Sensor SGP30 Gas and Air Quality Sensor (I 2 C) SHT1x Temperature and Humidity Sensor (I 2 C) SHT30 Humidity & Temperature Sensor SI114x UV Index, IR and Visible Light Sensor (I 2 C) Si7021 Humidity and Temperature Sensor (I 2 C) Smart Meter Interface (serial) SolaX X1 SolaX X1 inverter (serial) SPS30 Particulate Matter (PM) T\u00e9l\u00e9info French energy measuring system (serial) TM1638 8 Switch, LED and 7 Segment Unit Sensor (gpio) TSL2561 Luminosity Sensor (I 2 C) TSL2591 Luminosity Sensor (I 2 C) TX20 TX23 La Crosse TX2x Series Anemometer VEML6070 UV Sensor (I 2 C) VEML6075 UVA/UVB/UVINDEX Sensor (I 2 C) VEML7700 Ambient light intensity Sensor (I 2 C) VL53L0x Time of flight Sensor (I 2 C) VL53L1x Time of flight Sensor (I 2 C) WindMeter Analog cup anemometer WS2812B Wemos RGB LED Shield WS2812B WS2813B LED Strip Xadow (Grove) Mutichannel Gas Sensor gas Sensor (I 2 C) Google Sheet list of supported peripherals Sensor API Documentation Expanding Specific Devices ~ LEGO nightstand switch using Sonoff SV Add a physical button to Sonoff Basic Remote button for Sonoff Expand Sonoff S20 with a jack plug Expand Sonoff 4CH with a jack plug Modify KaKu to WKaKu Power Socket GPIO Locations for some devices","title":"Supported Peripherals"},{"location":"Supported-Peripherals/#supported-peripherals","text":"Name Description A4988 Stepper Motor Controller ADC Analog input over A0 pin ADS111x A/D Converter AHT10 AHT15 Asair AHT10 / AHT15 Temperature and Humidity Sensor (I 2 C) AM2301 (DHT21) AM2302 (DHT22) AM2321 Temperature and Humidity Sensor (gpio) AS608 AS608 Optical and R503 Capacitive Fingerprint Sensor (I 2 C) AS3935 Franklin Lightning Sensor (serial) APDS-9960 Ambient Light, RGB Color and Proximity Sensor with Gesture Detection AZ 7798 CO 2 Meter Datalogger BH1750 Luminosity Sensor BMP280 BMP085 BMP180) Pressure Sensor BME280 Temperature, Humidity and Pressure Sensor BME680 Temperature, Humidity, Pressure and Gas Sensor Buzzer Audio Signalling Device CC2530 TI CC2530 Zigbee Adapter (serial) CCS811 Gas and Air Quality Sensor (I 2 C) Chirp! Soil Moisture Sensor Moisture Sensor (I 2 C) DHT11 Temperature and Humidity Sensor DHT12 DYP-ME007 Ultrasonic distance Sensor (serial) DS18x20 Temperature Sensor (1-Wire) DS1624 DS1621 Temperature Sensor (1-Wire) DS3231 Real-Time-Clock (I 2 C) EZO EZO series of chemical Sensors (I 2 C) F&F LE-01MR F&F LE-01MR Single Phase Modbus Energy meter GPS-NTP-server GPS-NTP-server (serial) HDC1080 Texas Instruments HDC1080 Humidity and Temperature Sensor (I 2 C) HM-10 BLE Bluetooth gateway (serial) HM-17 HM-16 Bluetooth iBeacon reader (serial) HP303B Barometric Pressure Shield (I 2 C) HR-E Water Meter Encoder interface (serial) HRXL MaxBotix HRXL line of Sonar Ranging Sensors (gpio) HC-SR04 HC-SR04P JSN-SR04T) Ultrasonic Sensor Honeywell HIH Temperature and Humidity Sensor (I 2 C) Honeywell HPMA115xx Particulate Matter Sensor (serial) HTU21 Temperature and Humidity Sensor (I 2 C) HX711 Load Cell Sensor (gpio) iAQ-Core Indoor Air Quality Sensor (I 2 C) iEM3000 Schenider Electric modbus energy meter (serial) INA219 High-Side DC Current and Voltage Sensor (I 2 C) IR Remote IR transmitter and receiver K30, K70, S8 CO 2 Sensor (I 2 C) LM75AD Temperature Sensor (I 2 C) LMT01 Temperature Sensor (gpio) MAX31855 MAX6675 Thermocouple Sensor (SPI) MAX31865 RTD Temperature Sensor Amplifier (SPI) MAX44009 Ambient Light Sensor (I 2 C) MCP23008 MCP23017 I/O Expander (I 2 C) MFRC522 NFC Tag Reader (SPI) MGC3130 3D Tracking and Gesture Controller MH-Z19B CO 2 Sensor MLX90614 MLX9061X Infrared Thermometer (I 2 C) MLX90640 MLX90640 Far Infrared Thermal Sensor Array (I 2 C) NRF24L01 NRF24L01 as BLE-bridge for Mijia BT Sensors (SPI) OpenTherm OpenTherm adapter (serial) MCP9808 Temperature Sensor (I 2 C) MPR121 Proximity Capacitive Touch Sensor Controller (I 2 C) MPU6050 3-Axis Gyroscope and 3-Axis Accelerometer Sensor (I 2 C) P1 Smart Meter Energy Meter (serial) PAJ7620 Gesture & Proximity Detection Sensor PIR Passive Infrared Sensor (gpio) PCA9685 16-channel, 12-bit PWM LED controller (I 2 C) PCF8574 8-port IO Expander (I 2 C) PMS3003 PMS5003 PMS7003 Particle Concentration Sensor (serial) PN532 NFC/RFID controller PZEM-004 PZEM-016 Energy Monitor (serial) RCWL-0516 Microwave Radar Presence detection RDM6300 125Khz RFID Module RF Transciever IR receiver and/or transmitter RX-4M50RR30SF RX-AM8SF RF Sensor receiver (gpio) SCD30 CO 2 Sensor (I 2 C) Eastron SDM120 Modbus Energy Meter (serial) Eastron SDM630 Modbus Energy Meter (serial) SDS011 SDS021 Laser Dust Sensor SGP30 Gas and Air Quality Sensor (I 2 C) SHT1x Temperature and Humidity Sensor (I 2 C) SHT30 Humidity & Temperature Sensor SI114x UV Index, IR and Visible Light Sensor (I 2 C) Si7021 Humidity and Temperature Sensor (I 2 C) Smart Meter Interface (serial) SolaX X1 SolaX X1 inverter (serial) SPS30 Particulate Matter (PM) T\u00e9l\u00e9info French energy measuring system (serial) TM1638 8 Switch, LED and 7 Segment Unit Sensor (gpio) TSL2561 Luminosity Sensor (I 2 C) TSL2591 Luminosity Sensor (I 2 C) TX20 TX23 La Crosse TX2x Series Anemometer VEML6070 UV Sensor (I 2 C) VEML6075 UVA/UVB/UVINDEX Sensor (I 2 C) VEML7700 Ambient light intensity Sensor (I 2 C) VL53L0x Time of flight Sensor (I 2 C) VL53L1x Time of flight Sensor (I 2 C) WindMeter Analog cup anemometer WS2812B Wemos RGB LED Shield WS2812B WS2813B LED Strip Xadow (Grove) Mutichannel Gas Sensor gas Sensor (I 2 C) Google Sheet list of supported peripherals Sensor API Documentation","title":"Supported Peripherals"},{"location":"Supported-Peripherals/#expanding-specific-devices","text":"LEGO nightstand switch using Sonoff SV Add a physical button to Sonoff Basic Remote button for Sonoff Expand Sonoff S20 with a jack plug Expand Sonoff 4CH with a jack plug Modify KaKu to WKaKu Power Socket GPIO Locations for some devices","title":"Expanding Specific Devices"},{"location":"TLS/","text":"This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_MQTT_TLS #define USE_MQTT_TLS // Use TLS for MQTT connection (+34.5k code, +7.0k mem and +4.8k additional during connection handshake) // #define USE_MQTT_TLS_CA_CERT // Force full CA validation instead of fingerprints, slower, but simpler to use. (+2.2k code, +1.9k mem during connection handshake) // This includes the LetsEncrypt CA in tasmota_ca.ino for verifying server certificates // #define USE_MQTT_TLS_FORCE_EC_CIPHER // Force Elliptic Curve cipher (higher security) required by some servers (automatically enabled with USE_MQTT_AWS_IOT) (+11.4k code, +0.4k mem) #endif and change port to 8883 #define MQTT_PORT 8883 // [ MqttPort ] MQTT port ( 10123 on CloudMQTT ) TLS offers increased security between your connected devices and your MQTT server, providing server authentication and encryption. Please refer to the general discussion in Securing-your-IoT-from-hacking Starting version 6.5.0.15, there are major changes to TLS to make it lighter in memory and easier to use. It has now reduced flash and memory requirements that makes it compatible with Web and Hue Emulation. If you are upgrading from a previous TLS activated version, there are breaking changes in the way Fingerprints are calculated At the Tasmota configuration, you need to enable to use the TLS Version. This is done by enable #define USE_MQTT_TLS in user_config_override.h and If you are using LetsEncrypt to generate your server certificates, you should activate #define USE_MQTT_TLS_CA_CERT . Tasmota will transparently check the server's certificate with LetsEncrypt CA. If you are generating self-signed certificates or prefer fingerprints, read below. Fingerprint Validation ~ The fingerprint is now calculated on the server's Public Key and no longer on its Certificate. The good news is that Public Keys tend to change far less often than certificates, i.e. LetsEncrypt triggers a certificate renewal every 3 months, the Public Key fingerprint will not change after a certificate renewal. The bad news is that there is no openssl command to retrieve the server's Public Key fingerprint, although a tool exists to calculate it from your certificate. So to simplify your task, we have added two more options: 1/ auto-learning of the fingerprint, 2/ disabling of the fingerprint validation altogether. Option 1: Fingerprint auto-learn If set, Tasmota will automatically learn the fingerprint during the first connection and will set the Fingerprint settings to the target fingerprint. To do so, use one of the following commands: MqttFingerprint1 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 or MqttFingerprint2 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 Option 2: Disable Fingerprint You can completely disable server fingerprint validation, which means that Tasmota will not check the server's identity. This also means that your traffic can possibly be intercepted and read/changed, so this option should only be used on trusted networks, i.e. with an MQTT on your local network. YOU HAVE BEEN WARNED! To do so, set one of the Fingerprints to all 0xFF: MqttFingerprint2 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF Limitations ~ Starting with 6.5.0.15, AxTLS has been replaced with BearSSL . This uses less memory, typically 6.0k constantly, and an additional 6.8k during TLS connection. This makes TLS compatible with Web and Hue/Wemo emulation. Main limitations are: Your SSL/TLS server must support TLS 1.2 and the RSA_WITH_AES_128_GCM_SHA256 cipher - which is the case with the default Mosquitto configuration The server certificate must have an RSA private key (max 2048 bits) and the certificate must be signed with RSA and SHA256 hash. This is the case with default LetsEncrypt certificates. Your SSL/TLS should support TLS 1.2 MFLN to limit buffer to 1024 bytes. If MFLN is not supported, it will still work well, as long as the server does not send any message above 1024 bytes (which should be ok, since Tasmota cannot parse MQTT messages above 1024 bytes) Implementation Notes ~ Arduino Core switched from AxTLS to BearSSL in 2.4.2, allowing further optimization of the TLS library footprint. BearSSL is designed for compactness, both in code size and memory requirements. Furthermore it is modular and allows for inclusion of only the code necessary for the subset of crypto-algorithms you want to support. Thanks to BearSSL's compactness and aggressive optimization, the minimal TLS configuration requires just 34.5k of Flash and 6.7k of Memory . The full-blown AWS IoT version with full certificate validation requires 48.3k of Flash and 9.4k of Memory. Here are the tips and tricks used to reduce Flash and Memory: MFLN (Maximum Fragment Length Negotiation): TLS normally uses 16k buffers for send and receive. 32k looks very small on a server, but immensely huge for ESP8266. TLS 1.2 introduced MFLN, which allows the TLS Client to reduce both buffers down to 512 bytes. MFLN is not widely supported yet, but it is by recent OpenSSL versions and by AWS IoT. This is a huge improvement in memory footprint. If your server does not support MFLN, it will still work as long as the messages sent by the server do not exceed the buffer length. In Tasmota the buffer length is 1024 bytes for send buffer and 1024 bytes for receive buffer. Going below creates message fragmentation and much longer TLS connection times (above 3s). If your server does not support MFLN, you'll see a message to that effect in the logs. Max Certificate size : BearSSL normally supports server certificates of up to RSA 4096 bits and EC 521 bits. These certificates are very uncommon currently. To save extra memory, the included BearSSL library is trimmed down to maximum RSA 2048 bit certificate and EC 256 bit certificate. This should not have any impact for you. EC private key : AWS IoT requires the client to authenticate with its own Private Key and Certificate. By default AWS IoT will generate an RSA 2048 bit private key. In Tasmota, we moved to an EC (Elliptic Curve) Private Key of 256 bits. EC keys are much smaller, and handshake is significantly faster. Note: the key being 256 bits does not mean it's less secure than RSA 2048, it's actually the opposite. Single Cipher : to reduce code size, we only support a single TLS cipher and embed only the code strictly necessary. When using TLS (e.g. LetsEncrypt on Mosquitto) the supported cipher is RSA_WITH_AES_128_GCM_SHA256 which is a very commonly supported cipher. For AWS IoT, the only supported cipher is ECDHE_RSA_WITH_AES_128_GCM_SHA256 which is one of the recommended ciphers. Additionally, ECDHE offers Perfect Forward Secrecy which means extra security. Adaptive Thunk Stack : BearSSL does not allocate memory on its own. It's either the caller's responsibility or memory is taken on the Stack. Stack usage can go above 5k, more than the ESP8266 stack. Arduino created a Thunk Stack , a secondary stack of 5.6k, allocated on Heap, and activated when a TLS connection is active. Actually the stack is mostly used during TLS handshake, and much less memory is required during TLS message processing. Tasmota only allocates the Thunk Stack during TLS handshake and switches back to the normal Stack afterwards. See below for details of actual memory usage. Keys and CA in PROGMEM : BearSSL was adapted from original source code to push most on the tables and static data into PROGMEM: https://github.com/earlephilhower/bearssl-esp8266. Additional work now allows us to put the Client Private Key, Certificate and CA in PROGMEM too, saving at least 3k of Memory. Memory Usage ~ TLS on Tasmota has been aggressively optimized to use as little memory (heap) as possible. It was also optimized to limit code size. Memory consumption (nominal): BearSSL lib: 1424 bytes (or 1024 bytes with LetsEncrypt or regular TLS) BearSSL ClientContext: 3440 bytes Buffers (1024 bytes in + 1024 bytes out + overhead): 2528 bytes Total = 7.4k (or 7.0k with LetsEncrypt or regular TLS) Note: if you use USE_WEBSERVER , your impact is lowered by 2k since the Web log buffer is reduced from 4k to 2k. Overall, when activating USE_WEBSERVER , you just see a memory impact of 5.4k. Memory needed during connection (TLS handshake - fingerprint validation): ThunkStack = 5308 bytes (or 3608 bytes with LetsEncrypt or regular TLS) DecoderContext = 1152 bytes Total for connection = 6.5k (or 4.8k with LetsEncrypt or regular TLS) Memory needed during connection (TLS handshake - full CA validation): ThunkStack = 5308 bytes (or 3608 bytes with LetsEncrypt or regular TLS) DecoderContext = 3072 bytes Total for connection = 8.4k (or 6.7k with LetsEncrypt or regular TLS) Connection Time ~ ESP8266 is quite slow compared to modern processors when it comes to SSL handshakes. Here are observed performance times when connecting to an SSL/TLS server, depending on CPU frequency (80MHz or 160MHz): AWS IoT Connection, with EC Private Key, simple fingerprint validation: 0.7s at 160MHz 1.3s at 80 MHz AWS IoT Connection, with EC Private Key, full CA validation (easier to configure than fingerprints): 1.0s at 160MHz 1.8s at 80 MHz LetsEncrypt based server (Mosquitto for ex), simple fingerprint validation: 0.3s at 160MHz 0.4s at 80MHz LetsEncrypt based server (Mosquitto for ex), with full CA validation (easier to configure than fingerprint): 0.4s at 160MHz 0.7s at 80MHz TLS Troubleshooting ~ Here are most common TLS errors: Error code Description -1004 Missing CA -1003 Missing EC private key -1002 Cannot connect to TCP port -1001 Cannot resolve IP address -1000 Out of memory error 1 Bad fingerprint 2 BR_ERR_BAD_STATE 3 BR_ERR_UNSUPPORTED_VERSION 4 BR_ERR_BAD_VERSION 5 BR_ERR_BAD_LENGTH 6 BR_ERR_TOO_LARGE 7 BR_ERR_BAD_MAC 8 BR_ERR_NO_RANDOM 9 BR_ERR_UNKNOWN_TYPE 10 BR_ERR_UNEXPECTED 12 BR_ERR_BAD_CCS 13 BR_ERR_BAD_ALERT 14 BR_ERR_BAD_HANDSHAKE 15 BR_ERR_OVERSIZED_ID 16 BR_ERR_BAD_CIPHER_SUITE 17 BR_ERR_BAD_COMPRESSION 18 BR_ERR_BAD_FRAGLEN 19 BR_ERR_BAD_SECRENEG 20 BR_ERR_EXTRA_EXTENSION 21 BR_ERR_BAD_SNI 22 BR_ERR_BAD_HELLO_DONE 23 BR_ERR_LIMIT_EXCEEDED: the server's public key is too large. Tasmota TLS is limited to 2048 RSA keys 24 BR_ERR_BAD_FINISHED 25 BR_ERR_RESUME_MISMATCH 26 BR_ERR_INVALID_ALGORITHM 27 BR_ERR_BAD_SIGNATURE 28 BR_ERR_WRONG_KEY_USAGE 29 BR_ERR_NO_CLIENT_AUTH 31 BR_ERR_IO 54 BR_ERR_X509_EXPIRED X.509 status: certificate is expired or not yet valid. 62 X509 not trusted, the server certificate is not signed by the CA (AWS IoT or LetsEncrypt) 266 SSL3_ALERT_UNEXPECTED_MESSAGE 276 TLS1_ALERT_BAD_RECORD_MAC 277 TLS1_ALERT_DECRYPTION_FAILED 278 TLS1_ALERT_RECORD_OVERFLOW 286 SSL3_ALERT_DECOMPRESSION_FAIL 296 SSL3_ALERT_HANDSHAKE_FAILURE 298 TLS1_ALERT_BAD_CERTIFICATE: Missing or bad client private key 299 TLS1_ALERT_UNSUPPORTED_CERT 300 TLS1_ALERT_CERTIFICATE_REVOKED 301 TLS1_ALERT_CERTIFICATE_EXPIRED 302 TLS1_ALERT_CERTIFICATE_UNKNOWN 303 SSL3_ALERT_ILLEGAL_PARAMETER 304 TLS1_ALERT_UNKNOWN_CA 305 TLS1_ALERT_ACCESS_DENIED 306 TLS1_ALERT_DECODE_ERROR 307 TLS1_ALERT_DECRYPT_ERROR 316 TLS1_ALERT_EXPORT_RESTRICTION 326 TLS1_ALERT_PROTOCOL_VERSION 327 TLS1_ALERT_INSUFFIENT_SECURITY 336 TLS1_ALERT_INTERNAL_ERROR 346 TLS1_ALERT_USER_CANCELED 356 TLS1_ALERT_NO_RENEGOTIATION 366 TLS1_ALERT_UNSUPPORTED_EXT Additional BR_ERR* error codes","title":"TLS Secured MQTT"},{"location":"TLS/#fingerprint-validation","text":"The fingerprint is now calculated on the server's Public Key and no longer on its Certificate. The good news is that Public Keys tend to change far less often than certificates, i.e. LetsEncrypt triggers a certificate renewal every 3 months, the Public Key fingerprint will not change after a certificate renewal. The bad news is that there is no openssl command to retrieve the server's Public Key fingerprint, although a tool exists to calculate it from your certificate. So to simplify your task, we have added two more options: 1/ auto-learning of the fingerprint, 2/ disabling of the fingerprint validation altogether.","title":"Fingerprint Validation"},{"location":"TLS/#limitations","text":"Starting with 6.5.0.15, AxTLS has been replaced with BearSSL . This uses less memory, typically 6.0k constantly, and an additional 6.8k during TLS connection. This makes TLS compatible with Web and Hue/Wemo emulation. Main limitations are: Your SSL/TLS server must support TLS 1.2 and the RSA_WITH_AES_128_GCM_SHA256 cipher - which is the case with the default Mosquitto configuration The server certificate must have an RSA private key (max 2048 bits) and the certificate must be signed with RSA and SHA256 hash. This is the case with default LetsEncrypt certificates. Your SSL/TLS should support TLS 1.2 MFLN to limit buffer to 1024 bytes. If MFLN is not supported, it will still work well, as long as the server does not send any message above 1024 bytes (which should be ok, since Tasmota cannot parse MQTT messages above 1024 bytes)","title":"Limitations"},{"location":"TLS/#implementation-notes","text":"Arduino Core switched from AxTLS to BearSSL in 2.4.2, allowing further optimization of the TLS library footprint. BearSSL is designed for compactness, both in code size and memory requirements. Furthermore it is modular and allows for inclusion of only the code necessary for the subset of crypto-algorithms you want to support. Thanks to BearSSL's compactness and aggressive optimization, the minimal TLS configuration requires just 34.5k of Flash and 6.7k of Memory . The full-blown AWS IoT version with full certificate validation requires 48.3k of Flash and 9.4k of Memory. Here are the tips and tricks used to reduce Flash and Memory: MFLN (Maximum Fragment Length Negotiation): TLS normally uses 16k buffers for send and receive. 32k looks very small on a server, but immensely huge for ESP8266. TLS 1.2 introduced MFLN, which allows the TLS Client to reduce both buffers down to 512 bytes. MFLN is not widely supported yet, but it is by recent OpenSSL versions and by AWS IoT. This is a huge improvement in memory footprint. If your server does not support MFLN, it will still work as long as the messages sent by the server do not exceed the buffer length. In Tasmota the buffer length is 1024 bytes for send buffer and 1024 bytes for receive buffer. Going below creates message fragmentation and much longer TLS connection times (above 3s). If your server does not support MFLN, you'll see a message to that effect in the logs. Max Certificate size : BearSSL normally supports server certificates of up to RSA 4096 bits and EC 521 bits. These certificates are very uncommon currently. To save extra memory, the included BearSSL library is trimmed down to maximum RSA 2048 bit certificate and EC 256 bit certificate. This should not have any impact for you. EC private key : AWS IoT requires the client to authenticate with its own Private Key and Certificate. By default AWS IoT will generate an RSA 2048 bit private key. In Tasmota, we moved to an EC (Elliptic Curve) Private Key of 256 bits. EC keys are much smaller, and handshake is significantly faster. Note: the key being 256 bits does not mean it's less secure than RSA 2048, it's actually the opposite. Single Cipher : to reduce code size, we only support a single TLS cipher and embed only the code strictly necessary. When using TLS (e.g. LetsEncrypt on Mosquitto) the supported cipher is RSA_WITH_AES_128_GCM_SHA256 which is a very commonly supported cipher. For AWS IoT, the only supported cipher is ECDHE_RSA_WITH_AES_128_GCM_SHA256 which is one of the recommended ciphers. Additionally, ECDHE offers Perfect Forward Secrecy which means extra security. Adaptive Thunk Stack : BearSSL does not allocate memory on its own. It's either the caller's responsibility or memory is taken on the Stack. Stack usage can go above 5k, more than the ESP8266 stack. Arduino created a Thunk Stack , a secondary stack of 5.6k, allocated on Heap, and activated when a TLS connection is active. Actually the stack is mostly used during TLS handshake, and much less memory is required during TLS message processing. Tasmota only allocates the Thunk Stack during TLS handshake and switches back to the normal Stack afterwards. See below for details of actual memory usage. Keys and CA in PROGMEM : BearSSL was adapted from original source code to push most on the tables and static data into PROGMEM: https://github.com/earlephilhower/bearssl-esp8266. Additional work now allows us to put the Client Private Key, Certificate and CA in PROGMEM too, saving at least 3k of Memory.","title":"Implementation Notes"},{"location":"TLS/#memory-usage","text":"TLS on Tasmota has been aggressively optimized to use as little memory (heap) as possible. It was also optimized to limit code size. Memory consumption (nominal): BearSSL lib: 1424 bytes (or 1024 bytes with LetsEncrypt or regular TLS) BearSSL ClientContext: 3440 bytes Buffers (1024 bytes in + 1024 bytes out + overhead): 2528 bytes Total = 7.4k (or 7.0k with LetsEncrypt or regular TLS) Note: if you use USE_WEBSERVER , your impact is lowered by 2k since the Web log buffer is reduced from 4k to 2k. Overall, when activating USE_WEBSERVER , you just see a memory impact of 5.4k. Memory needed during connection (TLS handshake - fingerprint validation): ThunkStack = 5308 bytes (or 3608 bytes with LetsEncrypt or regular TLS) DecoderContext = 1152 bytes Total for connection = 6.5k (or 4.8k with LetsEncrypt or regular TLS) Memory needed during connection (TLS handshake - full CA validation): ThunkStack = 5308 bytes (or 3608 bytes with LetsEncrypt or regular TLS) DecoderContext = 3072 bytes Total for connection = 8.4k (or 6.7k with LetsEncrypt or regular TLS)","title":"Memory Usage"},{"location":"TLS/#connection-time","text":"ESP8266 is quite slow compared to modern processors when it comes to SSL handshakes. Here are observed performance times when connecting to an SSL/TLS server, depending on CPU frequency (80MHz or 160MHz): AWS IoT Connection, with EC Private Key, simple fingerprint validation: 0.7s at 160MHz 1.3s at 80 MHz AWS IoT Connection, with EC Private Key, full CA validation (easier to configure than fingerprints): 1.0s at 160MHz 1.8s at 80 MHz LetsEncrypt based server (Mosquitto for ex), simple fingerprint validation: 0.3s at 160MHz 0.4s at 80MHz LetsEncrypt based server (Mosquitto for ex), with full CA validation (easier to configure than fingerprint): 0.4s at 160MHz 0.7s at 80MHz","title":"Connection Time"},{"location":"TLS/#tls-troubleshooting","text":"Here are most common TLS errors: Error code Description -1004 Missing CA -1003 Missing EC private key -1002 Cannot connect to TCP port -1001 Cannot resolve IP address -1000 Out of memory error 1 Bad fingerprint 2 BR_ERR_BAD_STATE 3 BR_ERR_UNSUPPORTED_VERSION 4 BR_ERR_BAD_VERSION 5 BR_ERR_BAD_LENGTH 6 BR_ERR_TOO_LARGE 7 BR_ERR_BAD_MAC 8 BR_ERR_NO_RANDOM 9 BR_ERR_UNKNOWN_TYPE 10 BR_ERR_UNEXPECTED 12 BR_ERR_BAD_CCS 13 BR_ERR_BAD_ALERT 14 BR_ERR_BAD_HANDSHAKE 15 BR_ERR_OVERSIZED_ID 16 BR_ERR_BAD_CIPHER_SUITE 17 BR_ERR_BAD_COMPRESSION 18 BR_ERR_BAD_FRAGLEN 19 BR_ERR_BAD_SECRENEG 20 BR_ERR_EXTRA_EXTENSION 21 BR_ERR_BAD_SNI 22 BR_ERR_BAD_HELLO_DONE 23 BR_ERR_LIMIT_EXCEEDED: the server's public key is too large. Tasmota TLS is limited to 2048 RSA keys 24 BR_ERR_BAD_FINISHED 25 BR_ERR_RESUME_MISMATCH 26 BR_ERR_INVALID_ALGORITHM 27 BR_ERR_BAD_SIGNATURE 28 BR_ERR_WRONG_KEY_USAGE 29 BR_ERR_NO_CLIENT_AUTH 31 BR_ERR_IO 54 BR_ERR_X509_EXPIRED X.509 status: certificate is expired or not yet valid. 62 X509 not trusted, the server certificate is not signed by the CA (AWS IoT or LetsEncrypt) 266 SSL3_ALERT_UNEXPECTED_MESSAGE 276 TLS1_ALERT_BAD_RECORD_MAC 277 TLS1_ALERT_DECRYPTION_FAILED 278 TLS1_ALERT_RECORD_OVERFLOW 286 SSL3_ALERT_DECOMPRESSION_FAIL 296 SSL3_ALERT_HANDSHAKE_FAILURE 298 TLS1_ALERT_BAD_CERTIFICATE: Missing or bad client private key 299 TLS1_ALERT_UNSUPPORTED_CERT 300 TLS1_ALERT_CERTIFICATE_REVOKED 301 TLS1_ALERT_CERTIFICATE_EXPIRED 302 TLS1_ALERT_CERTIFICATE_UNKNOWN 303 SSL3_ALERT_ILLEGAL_PARAMETER 304 TLS1_ALERT_UNKNOWN_CA 305 TLS1_ALERT_ACCESS_DENIED 306 TLS1_ALERT_DECODE_ERROR 307 TLS1_ALERT_DECRYPT_ERROR 316 TLS1_ALERT_EXPORT_RESTRICTION 326 TLS1_ALERT_PROTOCOL_VERSION 327 TLS1_ALERT_INSUFFIENT_SECURITY 336 TLS1_ALERT_INTERNAL_ERROR 346 TLS1_ALERT_USER_CANCELED 356 TLS1_ALERT_NO_RENEGOTIATION 366 TLS1_ALERT_UNSUPPORTED_EXT Additional BR_ERR* error codes","title":"TLS Troubleshooting"},{"location":"TSL2561/","text":"TSL2561 light sensor ~ This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_VEML6070 #define USE_TSL2561 // Enable TSL2561 sensor (I2C address 0x29, 0x39 or 0x49) (+2k3 code) #endif The TSL2561 luminosity sensor is an advanced digital light I 2 C sensor, ideal for use in a wide range of light situations. Configuration ~ Wiring ~ TSL2561 ESP8266 GND GND VCC 3.3V SCL GPIOy SDA GPIOx INT not used Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) After a reboot the driver will detect TSL2561 automatically and display Illuminance. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-11-03T21:04:05\" , \"TSL2561\" :{ \"Illuminance\" : 21.180 }} Breakout Boards ~","title":"TSL2561 light sensor"},{"location":"TSL2561/#tsl2561-light-sensor","text":"This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_VEML6070 #define USE_TSL2561 // Enable TSL2561 sensor (I2C address 0x29, 0x39 or 0x49) (+2k3 code) #endif The TSL2561 luminosity sensor is an advanced digital light I 2 C sensor, ideal for use in a wide range of light situations.","title":"TSL2561 light sensor"},{"location":"TSL2561/#configuration","text":"","title":"Configuration"},{"location":"TSL2561/#wiring","text":"TSL2561 ESP8266 GND GND VCC 3.3V SCL GPIOy SDA GPIOx INT not used","title":"Wiring"},{"location":"TSL2561/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) After a reboot the driver will detect TSL2561 automatically and display Illuminance. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-11-03T21:04:05\" , \"TSL2561\" :{ \"Illuminance\" : 21.180 }}","title":"Tasmota Settings"},{"location":"TSL2561/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"TX2x/","text":"TX20/TX23 anemometer ~ This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : For TX20 sensor #ifndef USE_TX20_WIND_SENSOR #define USE_TX20_WIND_SENSOR // Add support for La Crosse TX20 anemometer (+2k6/0k8 code) #endif For TX23 sensor #ifndef USE_TX23_WIND_SENSOR #define USE_TX23_WIND_SENSOR // Add support for La Crosse TX20 anemometer (+2k6/0k8 code) #endif This setting compiles Tasmota with sensor statistical values (needs the higher value size of code), which are useful for the wind sensor, since the measured values naturally change very quickly. The values generated in addition to the wind speed and wind direction are: Wind speed min/max Wind speed average (\u2205) Wind direction average (\u2205) Wind direction range (\u2220) and min/max The average (\u2205) values are continuously calculated values. The range (\u2220) and min/max values are held for the time TelePeriod and reset after MQTT SENSOR message has been output. If you do not want the statistical calculation having speed and direction value only, use #ifndef USE_TX2X_WIND_SENSOR_NOSTATISTICS #define USE_TX2X_WIND_SENSOR_NOSTATISTICS #endif in your user_config_override.h . This will save approx. 1k8 bytes of code. The TX20 (retired) and TX23 sensor supplies the two measured values wind speed and wind direction. The TX23 sensor is still available under various brand names such as \"La Crosse\", \"Technoline\". Unfortunately, the TX20 (at least in Europe) is almost impossible to get. However, the two sensors differ only in the protocol used, but deliver the same measured values. Configuration ~ Wiring ~ TX20 Pin Color Description ESP8266 1 Brown/Black TxD GPIOx 2 Red 3.3V 3.3V 3 Green DTR GND 4 Yellow GND GND TX23 Pin Color Description ESP8266 1 Brown/Black TxD GPIOx 2 Red 3.3V 3.3V 3 Green - - 4 Yellow GND GND Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to TX2x (104) The TX2 pin needs a pull-up resistor. The internal pull-up is activated for this so you can use any useful GPIO except GPIO15 and GPIO16 (GPIO15 is always pulled low, GPIO16 has a built-in pull-down resistor). To be on the save side you can add an additonal external 10k pull-up to TX2x GPIOx. After a reboot the driver will detect TX20/TX23 automatically and display the wind data: Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2020-03-03T00:00:00+00:00\" , \"TX23\" : { \"Speed\" : { \"Act\" : 14.8 , \"Avg\" : 8.5 , \"Min\" : 12.2 , \"Max\" : 14.8 }, \"Dir\" : { \"Card\" : \"WSW\" , \"Deg\" : 247.5 , \"Avg\" : 266.1 , \"AvgCard\" : \"W\" , \"Min\" : 247.5 , \"Max\" : 247.5 , \"Range\" : 0 } }, \"SpeedUnit\" : \"km/h\" } Commands ~ The wind speed unit is set to km/h as default. You can change the unit using the command SpeedUnit <x> where <x> = 1\u20266 : - 1 = m/s (meter per second) - 2 = km/h (kilometer per hour) - 3 = kn (knots) - 4 = mph (miles per hour) - 5 = ft/s (foot per second) - 6 = yd/s (yard per second) The changed unit will appear in the webUI and via MQTT SENSOR messages.","title":"TX20/TX23 anemometer"},{"location":"TX2x/#tx20tx23-anemometer","text":"This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : For TX20 sensor #ifndef USE_TX20_WIND_SENSOR #define USE_TX20_WIND_SENSOR // Add support for La Crosse TX20 anemometer (+2k6/0k8 code) #endif For TX23 sensor #ifndef USE_TX23_WIND_SENSOR #define USE_TX23_WIND_SENSOR // Add support for La Crosse TX20 anemometer (+2k6/0k8 code) #endif This setting compiles Tasmota with sensor statistical values (needs the higher value size of code), which are useful for the wind sensor, since the measured values naturally change very quickly. The values generated in addition to the wind speed and wind direction are: Wind speed min/max Wind speed average (\u2205) Wind direction average (\u2205) Wind direction range (\u2220) and min/max The average (\u2205) values are continuously calculated values. The range (\u2220) and min/max values are held for the time TelePeriod and reset after MQTT SENSOR message has been output. If you do not want the statistical calculation having speed and direction value only, use #ifndef USE_TX2X_WIND_SENSOR_NOSTATISTICS #define USE_TX2X_WIND_SENSOR_NOSTATISTICS #endif in your user_config_override.h . This will save approx. 1k8 bytes of code. The TX20 (retired) and TX23 sensor supplies the two measured values wind speed and wind direction. The TX23 sensor is still available under various brand names such as \"La Crosse\", \"Technoline\". Unfortunately, the TX20 (at least in Europe) is almost impossible to get. However, the two sensors differ only in the protocol used, but deliver the same measured values.","title":"TX20/TX23 anemometer"},{"location":"TX2x/#configuration","text":"","title":"Configuration"},{"location":"TX2x/#wiring","text":"","title":"Wiring"},{"location":"TX2x/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to TX2x (104) The TX2 pin needs a pull-up resistor. The internal pull-up is activated for this so you can use any useful GPIO except GPIO15 and GPIO16 (GPIO15 is always pulled low, GPIO16 has a built-in pull-down resistor). To be on the save side you can add an additonal external 10k pull-up to TX2x GPIOx. After a reboot the driver will detect TX20/TX23 automatically and display the wind data: Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2020-03-03T00:00:00+00:00\" , \"TX23\" : { \"Speed\" : { \"Act\" : 14.8 , \"Avg\" : 8.5 , \"Min\" : 12.2 , \"Max\" : 14.8 }, \"Dir\" : { \"Card\" : \"WSW\" , \"Deg\" : 247.5 , \"Avg\" : 266.1 , \"AvgCard\" : \"W\" , \"Min\" : 247.5 , \"Max\" : 247.5 , \"Range\" : 0 } }, \"SpeedUnit\" : \"km/h\" }","title":"Tasmota Settings"},{"location":"TX2x/#commands","text":"The wind speed unit is set to km/h as default. You can change the unit using the command SpeedUnit <x> where <x> = 1\u20266 : - 1 = m/s (meter per second) - 2 = km/h (kilometer per hour) - 3 = kn (knots) - 4 = mph (miles per hour) - 5 = ft/s (foot per second) - 6 = yd/s (yard per second) The changed unit will appear in the webUI and via MQTT SENSOR messages.","title":"Commands"},{"location":"TasUI/","text":"Warning Development of TasUI has stopped!!! TasUI is a zero-install device management interface web application for all your Tasmota devices. It will discover your deployed devices and allow you to set up and configure every device from a single dashboard. This initial version includes multiple views (Control, Health, Firmware, Wi-Fi, & MQTT) to allow you to quickly assess the state of your devices. There is also a detailed view (e.g., SetOptions, Status, etc.) available. TasUI provides a syntax-aware command interface for every Tasmota command by category (e.g., Configuration, Timers, Sensors, Lights, etc.) as well as the \"familiar\" Console interface to enter commands directly. This is a beta version (i.e., we expect you to find some unexpected features). As these issues are fixed, it will not require you to reinstall any software to get these fixes. This also applies to new features as they are added to the app. Join us on Discord ! Docker ~ For those who prefer to have everything installed locally, a Docker image for linux amd64 , arm32v7 , arm64v8 and i386 is available for download . docker pull iotreboot / tasui : latest docker run - p [ PORT ] : 80 iotreboot / tasui : latest Home Assistant ~ The add-on can be installed on amd64 , arm32v7 , arm64v8 and i386 builds. Simply add the TasUI repository on your addons list: https://github.com/iotreboot/TasUI No configuration is required.","title":"TasUI"},{"location":"TasUI/#docker","text":"For those who prefer to have everything installed locally, a Docker image for linux amd64 , arm32v7 , arm64v8 and i386 is available for download . docker pull iotreboot / tasui : latest docker run - p [ PORT ] : 80 iotreboot / tasui : latest","title":"Docker"},{"location":"TasUI/#home-assistant","text":"The add-on can be installed on amd64 , arm32v7 , arm64v8 and i386 builds. Simply add the TasUI repository on your addons list: https://github.com/iotreboot/TasUI No configuration is required.","title":"Home Assistant"},{"location":"TasmoAdmin/","text":"TasmoAdmin is an administrative Website for Devices flashed with Tasmota . You can find it here: TasmoAdmin GitHub . It supports running on Windows, Linux and as Docker container. Features ~ Login protected Multi Update Process Select devices to update Automatic Modus downloads latest firmware bin from Tasmota GitHub Show device information Mobile Responsive (Bootstrap4) Config devices SelfUpdate function for TasmoAdmin (disabled for Docker) NightMode (Enable/Disable/Auto) in settings AutoScan to find Tasmota Devices Support for multiple sensors chat (beta) Installation ~ Windows ~ A ready to use TasmoAdmin-XAMP-Portable-*.zip is available on the release page and is based on XAMPP. Download the XAMPP Zip package from the releases page Extract the Zip (recommend to put the xamp folder on C:\\ Run once the xamp\\setup_xampp.bat Start xampp-control.exe Start Apache in the opened ControlCenter Get your local IP Address Now you can type in your browser http://YOURLOCALIP and TasmoAdmin shows up. Linux ~ Running TasmoAdmin on a Linux/Unix hosts requires the following: * A Webserver * apache2 recommended * php7 recommended (works with php5 too) * php-curl php-zip Modules installed You need to install a web server with php-zip and php-curl modules installed. Also mod_rewrite must be enabled. I suggest to look in the Guide for Ubuntu Server 16.04 and try to adjust it to your server OS. Docker ~ TasmoAdmin is available as a Docker image at Docker Hub . This is a Linux Alpine (3.7) based image with Apache2 and Php7 installed. It supports multiple architectures, amd64 (i.e. Synology DSM), arm (i.e. Raspberry PI3) and arm64 (i.e. Pine64). Example Images ~ Login Page Start Page Devices Page Devices Add/Edit Page Config General Page Config Network Page Update Devices Page Settings Page Mobile","title":"TasmoAdmin"},{"location":"TasmoAdmin/#features","text":"Login protected Multi Update Process Select devices to update Automatic Modus downloads latest firmware bin from Tasmota GitHub Show device information Mobile Responsive (Bootstrap4) Config devices SelfUpdate function for TasmoAdmin (disabled for Docker) NightMode (Enable/Disable/Auto) in settings AutoScan to find Tasmota Devices Support for multiple sensors chat (beta)","title":"Features"},{"location":"TasmoAdmin/#installation","text":"","title":"Installation"},{"location":"TasmoAdmin/#windows","text":"A ready to use TasmoAdmin-XAMP-Portable-*.zip is available on the release page and is based on XAMPP. Download the XAMPP Zip package from the releases page Extract the Zip (recommend to put the xamp folder on C:\\ Run once the xamp\\setup_xampp.bat Start xampp-control.exe Start Apache in the opened ControlCenter Get your local IP Address Now you can type in your browser http://YOURLOCALIP and TasmoAdmin shows up.","title":"Windows"},{"location":"TasmoAdmin/#linux","text":"Running TasmoAdmin on a Linux/Unix hosts requires the following: * A Webserver * apache2 recommended * php7 recommended (works with php5 too) * php-curl php-zip Modules installed You need to install a web server with php-zip and php-curl modules installed. Also mod_rewrite must be enabled. I suggest to look in the Guide for Ubuntu Server 16.04 and try to adjust it to your server OS.","title":"Linux"},{"location":"TasmoAdmin/#docker","text":"TasmoAdmin is available as a Docker image at Docker Hub . This is a Linux Alpine (3.7) based image with Apache2 and Php7 installed. It supports multiple architectures, amd64 (i.e. Synology DSM), arm (i.e. Raspberry PI3) and arm64 (i.e. Pine64).","title":"Docker"},{"location":"TasmoAdmin/#example-images","text":"","title":"Example Images"},{"location":"Tasmota-Device-Locator/","text":"Tasmota Device Locator ~ Locate Tasmota Devices on your network when you only know the subnet of the device. The search is done with JavaScript in a browser and no software installation is required. Only newer devices with HTTP Cross-Origin Resource Sharing (CORS) support will be found. CORS is disabled in Tasmota by default. Use the CORS command to change this setting. Usage ~ Enter any IP address in the subnet and it will search for devices on the entire subnet. For example, specify 192.168.0.0 to locate all devices in the range 192.168.0.0 to 192.168.0.255. If the devices are password protected also enter the password. The password will be tried on all devices. If they have different passwords, multiple searches must be performed. Run the live version ~ The live version can be found here Local Deployment ~ If you want to run your own server, the Tasmota Device Locator can be served by any static http server (not https). - Checkout the branch gh-pages. - Copy the files to the root of the web server Development ~ Sources can be found on github, Tasmota Device Locator .","title":"Tasmota Device Locator"},{"location":"Tasmota-Device-Locator/#tasmota-device-locator","text":"Locate Tasmota Devices on your network when you only know the subnet of the device. The search is done with JavaScript in a browser and no software installation is required. Only newer devices with HTTP Cross-Origin Resource Sharing (CORS) support will be found. CORS is disabled in Tasmota by default. Use the CORS command to change this setting.","title":"Tasmota Device Locator"},{"location":"Tasmota-Device-Locator/#usage","text":"Enter any IP address in the subnet and it will search for devices on the entire subnet. For example, specify 192.168.0.0 to locate all devices in the range 192.168.0.0 to 192.168.0.255. If the devices are password protected also enter the password. The password will be tried on all devices. If they have different passwords, multiple searches must be performed.","title":"Usage"},{"location":"Tasmota-Device-Locator/#run-the-live-version","text":"The live version can be found here","title":"Run the live version"},{"location":"Tasmota-Device-Locator/#local-deployment","text":"If you want to run your own server, the Tasmota Device Locator can be served by any static http server (not https). - Checkout the branch gh-pages. - Copy the files to the root of the web server","title":"Local Deployment"},{"location":"Tasmota-Device-Locator/#development","text":"Sources can be found on github, Tasmota Device Locator .","title":"Development"},{"location":"Tasmota-Device-Manager/","text":"Tasmota Device Manager or TDM is a GUI application written in Python for discovery and monitoring of Tasmota flashed devices. Features ~ clean, readable interface autodetection of devices following the default topic template for Tasmota (%prefix%/%topic%/) and for HomeAssistant Auto Discovery protocol (%topic%/%prefix%/) module and GPIO configuration rules editor devices with different syntax can be added manually clean retained MQTT topic messages toggleable active querying of telemetry passive monitoring of state and telemetry (currently supported sensors are listed in \"status8.json\") relay control via context menu on device list (all ON/OFF, or individual) MQTT console with payload preview (dbl-click an entry to display), sorting and filtering selectable detail columns in device list BSSID aliasing for larger deployments Installation ~ Python 3.6+ is required. Clone the repo or download zip and extract, install prerequisites and run tdm.py using Python binary. Prerequisites ~ PyQt5: pip install PyQt5 paho-mqtt: pip install paho-mqtt","title":"Tasmota Device Manager"},{"location":"Tasmota-Device-Manager/#features","text":"clean, readable interface autodetection of devices following the default topic template for Tasmota (%prefix%/%topic%/) and for HomeAssistant Auto Discovery protocol (%topic%/%prefix%/) module and GPIO configuration rules editor devices with different syntax can be added manually clean retained MQTT topic messages toggleable active querying of telemetry passive monitoring of state and telemetry (currently supported sensors are listed in \"status8.json\") relay control via context menu on device list (all ON/OFF, or individual) MQTT console with payload preview (dbl-click an entry to display), sorting and filtering selectable detail columns in device list BSSID aliasing for larger deployments","title":"Features"},{"location":"Tasmota-Device-Manager/#installation","text":"Python 3.6+ is required. Clone the repo or download zip and extract, install prerequisites and run tdm.py using Python binary.","title":"Installation"},{"location":"Tasmota-Device-Manager/#prerequisites","text":"PyQt5: pip install PyQt5 paho-mqtt: pip install paho-mqtt","title":"Prerequisites"},{"location":"Tasmota-IR/","text":"The default Tasmota firmware variants include support for IR send/receive for a limited set of protocols (see IR Remote ). Tasmota uses the IRremoteESP8266 library that supports numerous protocols. Each protocol consumes some memory, especially air conditioner protocols (up to 81k of flash size). Also, every protocol included increases the time to decode the IR signal. There are two additional Tasmota firmware variants that provide almost all IRremoteESP8266 protocols. This requires disabling some other features to keep code size manageable. tasmota-ir is pre-packaged for IR blasters, like Eachen IR Bridge or YTF IR Bridge . Choose tasmota-ir if you are using an IR blaster. tasmota-ircustom is used if you want to customize your features (additional sensors, language, etc.). See compile your own firmware . You can flash the binary or upgrade your existing one. To test that you have the correct firmware on your device issue the following command in the web UI Console: IRhvac {\"Vendor\":\"xx\"} The output should be a list of the supported protocols/vendors. For example: RESULT = {\"IRHVAC\":\"Wrong Vendor (COOLIX|DAIKIN|KELVINATOR|MITSUBISHI_AC|GREE|ARGO|TROTEC|TOSHIBA_AC|FUJITSU_AC|MIDEA|HAIER_AC|HITACHI_AC|HAIER_AC_YRW02|WHIRLPOOL_AC|SAMSUNG_AC|ELECTRA_AC|PANASONIC_AC|DAIKIN2|VESTEL_AC|TECO|TCL112AC|MITSUBISHI_HEAVY_88|MITSUBISHI_HEAVY_152|DAIKIN216|SHARP_AC|GOODWEATHER|DAIKIN160|NEOCLIMA|DAIKIN176|DAIKIN128|AMCOR)\"} Sending IR Commands ~ Send an IR remote control code as a decimal or hexadecimal string in a JSON payload. In order to send IR data, you must configure one of the free device GPIO as IRsend (8) . Neither GPIO01 nor GPIO03 can be used. Command Parameters IRsend <x> <x> [ optional ] = number of times the IR message is sent. If not specified or 0..1 , the message is sent only once (i.e., not repeated) (default) >1 = emulate a long-press on the remote control, sending the message <x> times, or sending a repeat message for specific protocols (like NEC) {\"Protocol\":\"<value>\",\"Bits\":<value>,\"Data\":<value>,\"DataLSB\":<value>,\"Repeat\":<value>} \"Protocol\" or \"Vendor\" (select one of the following): RC5, RC6, NEC, SONY, PANASONIC, JVC, SAMSUNG, WHYNTER, AIWA_RC_T501, LG, MITSUBISHI, DISH, SHARP, DENON, SHERWOOD, RCMM, SANYO_LC7461, RC5X, NEC (non-strict), NIKAI, MAGIQUEST, LASERTAG, CARRIER_AC, MITSUBISHI2, HITACHI_AC1, HITACHI_AC2, GICABLE, LUTRON, PIONEER, LG2, SAMSUNG36, LEGOPF, INAX, DAIKIN152 \"Bits\":1..64 = required number of data bits for PANASONIC protocol this parameter is the the address, not the number of bits \"Data\":0x1..0xFFFFFFFFFFFFFFFF = data frame as 64 bit hexadecimal. e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x8166817E} Or \"DataLSB\":0x1..0xFFFFFFFFFFFFFFFF = data frame as 64 bit hexadecimal with LSB (each byte with bits reversed). e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x8166817E} DataLSB comes handy with LSB-first (Least Significant Bit First) protocols like NEC, and makes decoding/encoding easier. \"Repeat\":0..<x> if 0 send the frame once, if >0 simulates a long press; Note: \"Repeat\":1 sends the message twice. Alternatively, you can send IR remote control codes using RAW command encoding . See also SetOption29 - Set IR received data format SetOption38 - Set IR received protocol sensitivity SetOption58 - IR Raw data in JSON payload Sending IRHVAC Commands ~ Command Parameters IRhvac Send HVAC IR remote control code as JSON payload IRhvac {\"Vendor\":\"Mitsubishi_Heavy_152\", \"Power\":\"On\",\"Mode\":\"Hot\",\"FanSpeed\":3,\"Temp\":22.5} \"Protocol\" or \"Vendor\" (select one of the following): COOLIX, DAIKIN, KELVINATOR, MITSUBISHI_AC, GREE, ARGO, TROTEC, TOSHIBA_AC, FUJITSU_AC, MIDEA, HAIER_AC, HITACHI_AC, HAIER_AC_YRW02, WHIRLPOOL_AC, SAMSUNG_AC, ELECTRA_AC, PANASONIC_AC, DAIKIN2, VESTEL_AC, TECO, TCL112AC, MITSUBISHI_HEAVY_88, MITSUBISHI_HEAVY_152, DAIKIN216, SHARP_AC, GOODWEATHER, DAIKIN160, NEOCLIMA, DAIKIN176, DAIKIN128 \"Model\": Some HVAC have variants in protocols, this field allows to specify the variant, see detailed list . Fujitsu_AC : ARRAH2E|ARDB1 Panasonic_AC : LKE|NKE|DKE|JKE|CKP|RKR Whirlpool_AC : DG11J13A|DG11J104|DG11J1-04|DG11J191 \"Power\" : On, Yes, True, 1 Off, No, False, 0 \"Mode\" : Off, Stop Auto, Automatic Cool, Cooling Heat, Heating Dry, Drying, Dehumidify Fan, Fanonly, Fan_Only \"FanSpeed\" : Auto, Automatic Min, Minimum, Lowest, 1 Low, 2 Med, Medium, Mid, 3 High, Hi, 4 Max, Maximum, Highest, 5 \"SwingV\" : vertical swing of Fan Auto, Automatic, On, Swing Off, Stop Min, Minimum, Lowest, Bottom, Down Low Mid, Middle, Med, Medium, Centre, Center High, Hi Highest, Max, Maximum, Top, Up \"SwingH\" : horizontal swing of Fan Auto, Automatic, On, Swing Off, Stop LeftMax, Left Max, MaxLeft, Max Left, FarLeft, Far Left Left Mid, Middle, Med, Medium, Centre, Center Right RightMax, Right Max, MaxRight, Max Right, FarRight, Far Right Wide \"Celsius\" : temperature is in Celsius ( \"On\" ) of Farenheit ( \"Off\" ) \"Temp\" : Temperature, can be float if supported by protocol \"Quiet\" : Quiet mode ( \"On\" / \"Off\" ) \"Turbo\" : Turbo mode ( \"On\" / \"Off\" ) \"Econo\" : Econo mode ( \"On\" / \"Off\" ) \"Light\" : Light ( \"On\" / \"Off\" ) \"Filter\" : Filter active ( \"On\" / \"Off\" ) \"Clean\" : Clean mode ( \"On\" / \"Off\" ) \"Beep\" : Beep active ( \"On\" / \"Off\" ) \"Sleep\" : Timer in seconds \"StateMode\" : SendOnly (default) StoreOnly SendStore Controling ACs with toggle fields ~ Some ACs such as Airwell, Whirlpool and others use a differential IR protocol for some properites. If \"power\" is a toggle property, then value of '1' in the protocol will mean \"turn off\" if the AC is currently \"on\" and it will mean \"turn on\" if the AC is currently \"off\". This could also be the case for other properties such as \"light\", \"swing\", etc. Since Tasmota and IRRemote8266 send and receive absolute states (i.e. the HVAC JSON object has a field called 'Power' not 'PowerToggle'), some functionaly was added to keep track of the predicted state of the AC. This way, if the predicted state is in-sync with the actual state, the device can transmit a correct IR packet to transition the AC from the previous state to the desired state. This logic is controlled by the StateMode HVAC property. If your AC IR protocol sends absolute values you can ignore this property. If your AC has a differential protocol Tasmota will be able to control the AC assuming the Tasmota IR device has at most one differential AC in IR range. If you would like to also control your AC with the physical remote your Tamsota IR device will need to have an IR receiver so that it can sync with the actual state. If at some point the state in Tasmota and the actual state get out of sync, you can specify StateMode=StoreOnly to update Tasmota with the actual state. This will update state but not send an IR command. Normally when receiving an IR command via the IR reciever the command will be processed and the state will be updated. As a result it is not needed to store state when sending as it will cause duplication and the toggle will happen twice. The most common operation mode, and default, therefore is StateMode=SendOnly . If your Tasmota device does not have an IR receiver you can still control a differential AC with it by specifying StateMode=SendStore but you will not be able to use a physical remote without loosing sync between the actual and predicted states. Receiving IR Commands ~ If you have an IR receiver, a message will be logged each time an IR message is seen. IR driver will try to decode the message against all supported protocols. If unrecognized, the \"Protocol\":\"UNKNOWN\" will be shown. In this case, the \"Data\" field contains a hash of the received message. The hash can't be used to send the a message, but the same hash will be produced by the same message. An inexpensive IR sensor such as a TSOP1838 can be connected to a device running Tasmota. Configure a free device GPIO as 'IRrecv (51)'. When Tasmota receives an IR message, the data portion of the payload has the same format as the IRsend parameter. {\"IrReceived\":{\"Protocol\":\"<value>\",\"Bits\":<value>,\"Data\":<value>}} This JSON payload data can be used in a rule such as: ON IrReceived#Data=<value> DO <command> ENDON If the data is received on an unknown protocol use SetOption58 1 . See here . Examples: Pioneer Vol+ MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55A50AFA55A50AF\",\"DataLSB\":\"0xA55A0AF5A55A0AF5\",\"Repeat\":0}} Pioneer Vol- tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55AD02FA55AD02F\",\"DataLSB\":\"0xA55A0BF4A55A0BF4\",\"Repeat\":0}} Toshiba (NEC): Channel 1 MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x02FD807F\",\"DataLSB\":\"0x40BF01FE\",\"Repeat\":0}} Toshiba (NEC): Channel 2 MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x02FD40BF\",\"DataLSB\":\"0x40BF02FD\",\"Repeat\":0}} Toshiba (NEC): Channel 3 MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x02FDC03F\",\"DataLSB\":\"0x40BF03FC\",\"Repeat\":0}} As you can see above, \"DataLSB\" are easier to decode than \"Data\" . The third byte contains the command, and the fourth byte is the third with all bits reversed. Example of HVAC message: MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"MITSUBISHI_HEAVY_152\",\"Bits\":152,\"Data\":\"0xAD513CE51A08F705FA02FDC03F08F700FF807F\",\"Repeat\":0,\"IRHVAC\":{\"Vendor\":\"MITSUBISHI_HEAVY_152\",\"Model\":-1,\"Power\":\"on\",\"Mode\":\"auto\",\"Celsius\":\"on\",\"Temp\":22,\"FanSpeed\":\"medium\",\"SwingV\":\"off\",\"SwingH\":\"off\",\"Quiet\":\"off\",\"Turbo\":\"off\",\"Econo\":\"off\",\"Light\":\"off\",\"Filter\":\"off\",\"Clean\":\"off\",\"Beep\":\"off\",\"Sleep\":-1}}} MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"COOLIX\",\"Bits\":24,\"Data\":\"0xB25F78\",\"DataLSB\":\"0x4DFA1E\",\"Repeat\":0,\"IRHVAC\":{\"Vendor\":\"COOLIX\",\"Model\":-1,\"Power\":\"on\",\"Mode\":\"auto\",\"Celsius\":\"on\",\"Temp\":22,\"FanSpeed\":\"medium\",\"SwingV\":\"off\",\"SwingH\":\"off\",\"Quiet\":\"off\",\"Turbo\":\"off\",\"Econo\":\"off\",\"Light\":\"on\",\"Filter\":\"off\",\"Clean\":\"on\",\"Beep\":\"off\",\"Sleep\":-1}}} RSL: RESULT = {\"Time\":\"2019-09-09T21:52:35\",\"IrReceived\":{\"Protocol\":\"PANASONIC_AC\",\"Bits\":216,\"Data\":\"0x0220E004000000060220E00400032C805F06000EE0000081000089\",\"Repeat\":0,\"IRHVAC\":{\"Vendor\":\"PANASONIC_AC\",\"Model\":2,\"Power\":\"on\",\"Mode\":\"auto\",\"Celsius\":\"on\",\"Temp\":22,\"FanSpeed\":\"medium\",\"SwingV\":\"auto\",\"SwingH\":\"middle\",\"Quiet\":\"off\",\"Turbo\":\"off\",\"Econo\":\"off\",\"Light\":\"off\",\"Filter\":\"off\",\"Clean\":\"off\",\"Beep\":\"off\",\"Sleep\":-1}}}","title":"IR Communication"},{"location":"Tasmota-IR/#sending-ir-commands","text":"Send an IR remote control code as a decimal or hexadecimal string in a JSON payload. In order to send IR data, you must configure one of the free device GPIO as IRsend (8) . Neither GPIO01 nor GPIO03 can be used. Command Parameters IRsend <x> <x> [ optional ] = number of times the IR message is sent. If not specified or 0..1 , the message is sent only once (i.e., not repeated) (default) >1 = emulate a long-press on the remote control, sending the message <x> times, or sending a repeat message for specific protocols (like NEC) {\"Protocol\":\"<value>\",\"Bits\":<value>,\"Data\":<value>,\"DataLSB\":<value>,\"Repeat\":<value>} \"Protocol\" or \"Vendor\" (select one of the following): RC5, RC6, NEC, SONY, PANASONIC, JVC, SAMSUNG, WHYNTER, AIWA_RC_T501, LG, MITSUBISHI, DISH, SHARP, DENON, SHERWOOD, RCMM, SANYO_LC7461, RC5X, NEC (non-strict), NIKAI, MAGIQUEST, LASERTAG, CARRIER_AC, MITSUBISHI2, HITACHI_AC1, HITACHI_AC2, GICABLE, LUTRON, PIONEER, LG2, SAMSUNG36, LEGOPF, INAX, DAIKIN152 \"Bits\":1..64 = required number of data bits for PANASONIC protocol this parameter is the the address, not the number of bits \"Data\":0x1..0xFFFFFFFFFFFFFFFF = data frame as 64 bit hexadecimal. e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x8166817E} Or \"DataLSB\":0x1..0xFFFFFFFFFFFFFFFF = data frame as 64 bit hexadecimal with LSB (each byte with bits reversed). e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x8166817E} DataLSB comes handy with LSB-first (Least Significant Bit First) protocols like NEC, and makes decoding/encoding easier. \"Repeat\":0..<x> if 0 send the frame once, if >0 simulates a long press; Note: \"Repeat\":1 sends the message twice. Alternatively, you can send IR remote control codes using RAW command encoding . See also SetOption29 - Set IR received data format SetOption38 - Set IR received protocol sensitivity SetOption58 - IR Raw data in JSON payload","title":"Sending IR Commands"},{"location":"Tasmota-IR/#sending-irhvac-commands","text":"Command Parameters IRhvac Send HVAC IR remote control code as JSON payload IRhvac {\"Vendor\":\"Mitsubishi_Heavy_152\", \"Power\":\"On\",\"Mode\":\"Hot\",\"FanSpeed\":3,\"Temp\":22.5} \"Protocol\" or \"Vendor\" (select one of the following): COOLIX, DAIKIN, KELVINATOR, MITSUBISHI_AC, GREE, ARGO, TROTEC, TOSHIBA_AC, FUJITSU_AC, MIDEA, HAIER_AC, HITACHI_AC, HAIER_AC_YRW02, WHIRLPOOL_AC, SAMSUNG_AC, ELECTRA_AC, PANASONIC_AC, DAIKIN2, VESTEL_AC, TECO, TCL112AC, MITSUBISHI_HEAVY_88, MITSUBISHI_HEAVY_152, DAIKIN216, SHARP_AC, GOODWEATHER, DAIKIN160, NEOCLIMA, DAIKIN176, DAIKIN128 \"Model\": Some HVAC have variants in protocols, this field allows to specify the variant, see detailed list . Fujitsu_AC : ARRAH2E|ARDB1 Panasonic_AC : LKE|NKE|DKE|JKE|CKP|RKR Whirlpool_AC : DG11J13A|DG11J104|DG11J1-04|DG11J191 \"Power\" : On, Yes, True, 1 Off, No, False, 0 \"Mode\" : Off, Stop Auto, Automatic Cool, Cooling Heat, Heating Dry, Drying, Dehumidify Fan, Fanonly, Fan_Only \"FanSpeed\" : Auto, Automatic Min, Minimum, Lowest, 1 Low, 2 Med, Medium, Mid, 3 High, Hi, 4 Max, Maximum, Highest, 5 \"SwingV\" : vertical swing of Fan Auto, Automatic, On, Swing Off, Stop Min, Minimum, Lowest, Bottom, Down Low Mid, Middle, Med, Medium, Centre, Center High, Hi Highest, Max, Maximum, Top, Up \"SwingH\" : horizontal swing of Fan Auto, Automatic, On, Swing Off, Stop LeftMax, Left Max, MaxLeft, Max Left, FarLeft, Far Left Left Mid, Middle, Med, Medium, Centre, Center Right RightMax, Right Max, MaxRight, Max Right, FarRight, Far Right Wide \"Celsius\" : temperature is in Celsius ( \"On\" ) of Farenheit ( \"Off\" ) \"Temp\" : Temperature, can be float if supported by protocol \"Quiet\" : Quiet mode ( \"On\" / \"Off\" ) \"Turbo\" : Turbo mode ( \"On\" / \"Off\" ) \"Econo\" : Econo mode ( \"On\" / \"Off\" ) \"Light\" : Light ( \"On\" / \"Off\" ) \"Filter\" : Filter active ( \"On\" / \"Off\" ) \"Clean\" : Clean mode ( \"On\" / \"Off\" ) \"Beep\" : Beep active ( \"On\" / \"Off\" ) \"Sleep\" : Timer in seconds \"StateMode\" : SendOnly (default) StoreOnly SendStore","title":"Sending IRHVAC Commands"},{"location":"Tasmota-IR/#controling-acs-with-toggle-fields","text":"Some ACs such as Airwell, Whirlpool and others use a differential IR protocol for some properites. If \"power\" is a toggle property, then value of '1' in the protocol will mean \"turn off\" if the AC is currently \"on\" and it will mean \"turn on\" if the AC is currently \"off\". This could also be the case for other properties such as \"light\", \"swing\", etc. Since Tasmota and IRRemote8266 send and receive absolute states (i.e. the HVAC JSON object has a field called 'Power' not 'PowerToggle'), some functionaly was added to keep track of the predicted state of the AC. This way, if the predicted state is in-sync with the actual state, the device can transmit a correct IR packet to transition the AC from the previous state to the desired state. This logic is controlled by the StateMode HVAC property. If your AC IR protocol sends absolute values you can ignore this property. If your AC has a differential protocol Tasmota will be able to control the AC assuming the Tasmota IR device has at most one differential AC in IR range. If you would like to also control your AC with the physical remote your Tamsota IR device will need to have an IR receiver so that it can sync with the actual state. If at some point the state in Tasmota and the actual state get out of sync, you can specify StateMode=StoreOnly to update Tasmota with the actual state. This will update state but not send an IR command. Normally when receiving an IR command via the IR reciever the command will be processed and the state will be updated. As a result it is not needed to store state when sending as it will cause duplication and the toggle will happen twice. The most common operation mode, and default, therefore is StateMode=SendOnly . If your Tasmota device does not have an IR receiver you can still control a differential AC with it by specifying StateMode=SendStore but you will not be able to use a physical remote without loosing sync between the actual and predicted states.","title":"Controling ACs with toggle fields"},{"location":"Tasmota-IR/#receiving-ir-commands","text":"If you have an IR receiver, a message will be logged each time an IR message is seen. IR driver will try to decode the message against all supported protocols. If unrecognized, the \"Protocol\":\"UNKNOWN\" will be shown. In this case, the \"Data\" field contains a hash of the received message. The hash can't be used to send the a message, but the same hash will be produced by the same message. An inexpensive IR sensor such as a TSOP1838 can be connected to a device running Tasmota. Configure a free device GPIO as 'IRrecv (51)'. When Tasmota receives an IR message, the data portion of the payload has the same format as the IRsend parameter. {\"IrReceived\":{\"Protocol\":\"<value>\",\"Bits\":<value>,\"Data\":<value>}} This JSON payload data can be used in a rule such as: ON IrReceived#Data=<value> DO <command> ENDON If the data is received on an unknown protocol use SetOption58 1 . See here . Examples: Pioneer Vol+ MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55A50AFA55A50AF\",\"DataLSB\":\"0xA55A0AF5A55A0AF5\",\"Repeat\":0}} Pioneer Vol- tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55AD02FA55AD02F\",\"DataLSB\":\"0xA55A0BF4A55A0BF4\",\"Repeat\":0}} Toshiba (NEC): Channel 1 MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x02FD807F\",\"DataLSB\":\"0x40BF01FE\",\"Repeat\":0}} Toshiba (NEC): Channel 2 MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x02FD40BF\",\"DataLSB\":\"0x40BF02FD\",\"Repeat\":0}} Toshiba (NEC): Channel 3 MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x02FDC03F\",\"DataLSB\":\"0x40BF03FC\",\"Repeat\":0}} As you can see above, \"DataLSB\" are easier to decode than \"Data\" . The third byte contains the command, and the fourth byte is the third with all bits reversed. Example of HVAC message: MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"MITSUBISHI_HEAVY_152\",\"Bits\":152,\"Data\":\"0xAD513CE51A08F705FA02FDC03F08F700FF807F\",\"Repeat\":0,\"IRHVAC\":{\"Vendor\":\"MITSUBISHI_HEAVY_152\",\"Model\":-1,\"Power\":\"on\",\"Mode\":\"auto\",\"Celsius\":\"on\",\"Temp\":22,\"FanSpeed\":\"medium\",\"SwingV\":\"off\",\"SwingH\":\"off\",\"Quiet\":\"off\",\"Turbo\":\"off\",\"Econo\":\"off\",\"Light\":\"off\",\"Filter\":\"off\",\"Clean\":\"off\",\"Beep\":\"off\",\"Sleep\":-1}}} MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"COOLIX\",\"Bits\":24,\"Data\":\"0xB25F78\",\"DataLSB\":\"0x4DFA1E\",\"Repeat\":0,\"IRHVAC\":{\"Vendor\":\"COOLIX\",\"Model\":-1,\"Power\":\"on\",\"Mode\":\"auto\",\"Celsius\":\"on\",\"Temp\":22,\"FanSpeed\":\"medium\",\"SwingV\":\"off\",\"SwingH\":\"off\",\"Quiet\":\"off\",\"Turbo\":\"off\",\"Econo\":\"off\",\"Light\":\"on\",\"Filter\":\"off\",\"Clean\":\"on\",\"Beep\":\"off\",\"Sleep\":-1}}} RSL: RESULT = {\"Time\":\"2019-09-09T21:52:35\",\"IrReceived\":{\"Protocol\":\"PANASONIC_AC\",\"Bits\":216,\"Data\":\"0x0220E004000000060220E00400032C805F06000EE0000081000089\",\"Repeat\":0,\"IRHVAC\":{\"Vendor\":\"PANASONIC_AC\",\"Model\":2,\"Power\":\"on\",\"Mode\":\"auto\",\"Celsius\":\"on\",\"Temp\":22,\"FanSpeed\":\"medium\",\"SwingV\":\"auto\",\"SwingH\":\"middle\",\"Quiet\":\"off\",\"Turbo\":\"off\",\"Econo\":\"off\",\"Light\":\"off\",\"Filter\":\"off\",\"Clean\":\"off\",\"Beep\":\"off\",\"Sleep\":-1}}}","title":"Receiving IR Commands"},{"location":"TasmotaClient/","text":"It is possible to amend your existing Arduino Uno / Mini / Nano project to interface with a Tasmota powered ESP8266/ESP8285 generic development boards such as the Wemos D1 or NodeMCU branded hardware boards. The creation of a client driver interface implemented since Tasmota 7.0.0.2 enables this possibility. This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_TASMOTA_CLIENT #define USE_TASMOTA_CLIENT // Enable the driver #endif #ifndef USE_TASMOTA_CLIENT_FLASH_SPEED #define USE_TASMOTA_CLIENT_FLASH_SPEED 57600 // Configure the baud rate of the bootloader #endif #ifndef USE_TASMOTA_CLIENT_SERIAL_SPEED 57600 #define USE_TASMOTA_CLIENT_SERIAL_SPEED 57600 // Configure the baud rate at which the client microcontroller will be interfacing to Tasmota #endif Please note that the USE_TASMOTA_CLIENT_FLASH_SPEED will depend on the variant of Arduino Uno/Mini/Nano board you are using - The general observation is that the 3.3V devices usually run at 57600 whereas the 5V devices usually run on 115200 but this is provided for guidance only as it has been found that some boards will not necessarily adhere to this. The main driving factor behind the baud rate is the crystal oscillator on the board which is usually 8Mhz for 3.3V variants and 16Mhz for 5V variants - hence 57600 being 1/2 of 115200. It should also be noted that this option is only really applicable if you're actually using an Arduino UNO/Mini/Nano as a client device and you want to be able to update the firmware on the Arduino OTA via the Tasmota Web UI. If you are using another type of microcontroller, obviously the OTA update functionality will not work (for now, until support is added for other microcontrollers). But if you are able to program the device manually there is no reason why you cannot use any microcontroller or development board as a client to your Tasmota powered ESP8266/8285 hardware. Once you have compiled your own variant with the correct settings and flashed the self-compiled binary to your Tasmota device it is time to make the necessary configuration within Tasmota. Configuring Tasmota to use the TasmotaClient functionality ~ The communication interface between Tasmota and your client micro-controller will be over serial communication. To make this possible you will need to configure two of the GPIO pins to Client TX and Client RX respectively. In addition to this you also need to define the GPIO which will be used to pull the reset pin of your client microcontroller down to GND or up to 3.3V, so either Client RST for normal reset behaviour (active low) or Client RSTi for inverted reset behaviour (active high) As mentioned above it is possible to connect any microcontroller of your choice but for the purpose of this article, only the implementation of an Arduino Pro Mini (3.3V) will be covered. Getting things wired up ~ With Tasmota GPIO configuration provided above you may now proceed to make the necessary electrical connections between the ESP8266/ESP8285 and your client device, for example: ESP8266 Arduino Pro Mini (3.3V) VCC VCC GND GND D2 (GPIO4) RX (0) D1 (GPIO5) TX (1) D4 (GPIO2) Reset (RST) So to visualize the above: Please verify your specific board's pin naming as they are not always exactly the same depending on where they came from! Compiling a test sketch for the client ~ The TasmotaClient driver requires your client to operate within specific parameters allowed by the driver itself so head over to the TasmotaClient Library and install the library in your local Arduino development environment. Once installed you should be able to access the examples from the menu system: Make sure you have the correct board and speed selected: Now that everything is set, it's time to export the compiled binary by selecting it from the Arduino menu: Once completed head over to the known folder you chose in previous steps and locate the .hex file which should be in the same folder as where your sketch was originally saved to. You will most likely see a file listing like this: You are interested in Blink.ino.eightanaloginputs.hex and can ignore the one which has bootloader as part of the file name since the Arduino Pro Mini already has the bootloader flashed. Take note of the location and name of this file as you will need it in the next step to upload the compiled file to your client device. Uploading a new hex file to your client device ~ If you are using an Arduino Pro Mini as is the case in this example you would have created a .hex file in the previous step. This file can be flashed directly to the Arduino Pro Mini via the Tasmota Web UI. Navigate to the Firmware Upgrade page where you would normally upload a new binary file to upgrade Tasmota. The same method is used to upload a HEX file to the client device. Tasmota will automatically decide where it will flash the upload based on whether you're uploading a .bin file or a .hex file. Tasmota will prompt you for the firmware file you wish to upload - You need to navigate to the previously known location folder you chose in earlier steps and select the .hex file previously identified: After selecting the hex file you may proceed to click the Start Upgrade button: The hex file will upload to Tasmota and Tasmota will flash the new client firmware onto the Arduino Pro Mini and present you with the following web page: After the device completes a restart you should now have an Arduino Pro Mini running as a client where the blink is controlled from Tasmota's internal one-second callback.","title":"TasmotaClient"},{"location":"TasmotaClient/#configuring-tasmota-to-use-the-tasmotaclient-functionality","text":"The communication interface between Tasmota and your client micro-controller will be over serial communication. To make this possible you will need to configure two of the GPIO pins to Client TX and Client RX respectively. In addition to this you also need to define the GPIO which will be used to pull the reset pin of your client microcontroller down to GND or up to 3.3V, so either Client RST for normal reset behaviour (active low) or Client RSTi for inverted reset behaviour (active high) As mentioned above it is possible to connect any microcontroller of your choice but for the purpose of this article, only the implementation of an Arduino Pro Mini (3.3V) will be covered.","title":"Configuring Tasmota to use the TasmotaClient functionality"},{"location":"TasmotaClient/#getting-things-wired-up","text":"With Tasmota GPIO configuration provided above you may now proceed to make the necessary electrical connections between the ESP8266/ESP8285 and your client device, for example: ESP8266 Arduino Pro Mini (3.3V) VCC VCC GND GND D2 (GPIO4) RX (0) D1 (GPIO5) TX (1) D4 (GPIO2) Reset (RST) So to visualize the above: Please verify your specific board's pin naming as they are not always exactly the same depending on where they came from!","title":"Getting things wired up"},{"location":"TasmotaClient/#compiling-a-test-sketch-for-the-client","text":"The TasmotaClient driver requires your client to operate within specific parameters allowed by the driver itself so head over to the TasmotaClient Library and install the library in your local Arduino development environment. Once installed you should be able to access the examples from the menu system: Make sure you have the correct board and speed selected: Now that everything is set, it's time to export the compiled binary by selecting it from the Arduino menu: Once completed head over to the known folder you chose in previous steps and locate the .hex file which should be in the same folder as where your sketch was originally saved to. You will most likely see a file listing like this: You are interested in Blink.ino.eightanaloginputs.hex and can ignore the one which has bootloader as part of the file name since the Arduino Pro Mini already has the bootloader flashed. Take note of the location and name of this file as you will need it in the next step to upload the compiled file to your client device.","title":"Compiling a test sketch for the client"},{"location":"TasmotaClient/#uploading-a-new-hex-file-to-your-client-device","text":"If you are using an Arduino Pro Mini as is the case in this example you would have created a .hex file in the previous step. This file can be flashed directly to the Arduino Pro Mini via the Tasmota Web UI. Navigate to the Firmware Upgrade page where you would normally upload a new binary file to upgrade Tasmota. The same method is used to upload a HEX file to the client device. Tasmota will automatically decide where it will flash the upload based on whether you're uploading a .bin file or a .hex file. Tasmota will prompt you for the firmware file you wish to upload - You need to navigate to the previously known location folder you chose in earlier steps and select the .hex file previously identified: After selecting the hex file you may proceed to click the Start Upgrade button: The hex file will upload to Tasmota and Tasmota will flash the new client firmware onto the Arduino Pro Mini and present you with the following web page: After the device completes a restart you should now have an Arduino Pro Mini running as a client where the blink is controlled from Tasmota's internal one-second callback.","title":"Uploading a new hex file to your client device"},{"location":"Templates/","text":"Template is a definition of a device and how its GPIOs are assigned. Templates provide an easy way for you to create, modify and share configurations for various devices that have features supported in Tasmota. Bug Tasmota 9.1 completely redesigned template layout to allow for future expansion. Read more about the GPIO Conversion . Information in this article still refers to pre 9.1 templating To provide easy processing by Tasmota a template is written as a JSON string and could look like this: { \"NAME\" : \"UserModule1\" , \"GPIO\" :[ 17 , 148 , 29 , 149 , 7 , 255 , 255 , 255 , 138 , 255 , 139 , 255 , 255 ], \"FLAG\" : 0 , \"BASE\" : 18 } Tip Tasmota Device Templates Repository has a complete list of supported devices. We encourage everyone who creates a template for a new unknown device to submit it using Add New Template form . How to Use ~ Go to Configuration - Configure Template ... ... and you'll end up looking at this screen. Time to create your template. Creating Your Template ~ Change the template name (also defines the name for the module). Select a module to BASE your template on . If you're not sure, Module 18 is the best choice. In this example the device is based on Blitzwolf SHP (45) module. Configure the components assigned to the GPIOs to match your device. If you do not know what pins your device uses, read about the new device configuration procedure to determine the correct pin assignments. Any unused GPIO that has cannot have a peripheral connected should be set to None (0) . In our example the device has no exposed GPIO's so the unused ones are set to 0 compared to the original BlitzWolf module. GPIOs that can have peripherals connected to (exposed GPIOs) should be set to User (255) . This allows future configuration through the Configure Module dialog without the need to create a new template. Example Sonoff TH has a jack connected to GPIO4 that allows a user to plug in a sensor. Assigning GPIO4 as 255 allows a Template to have correct GPIOs for this device even if nothing is plugged in. But, when a user decides to connect a sensor using the jack, GPIO4 can be set to the type of sensor through the Configure Module page. Click on Save and you'll see this message Finally, the device will reboot with the new template name Exporting Your Template ~ Now that you've set up your previously unsupported device in Tasmota it is time to share the knowledge: Check that Module 0 is selected in the Configuration - Configure Module menu. Open up Console and issue command Template which will output a string with the configuration of your currently active template. Our example gives the following: MQT : s tat / tas mo ta /RESULT = { \"NAME\" : \"RGB Smart Plug\" , \"GPIO\" :[ 37 , 0 , 39 , 0 , 38 , 134 , 0 , 0 , 131 , 17 , 132 , 21 , 0 ], \"FLAG\" : 0 , \"BASE\" : 45 } Copy the string {\"NAME\":\"RGB Smart Plug\",\"GPIO\":[37,0,39,0,38,134,0,0,131,17,132,21,0],\"FLAG\":0,\"BASE\":45} and share it on the Tasmota Device Templates Repository . Importing Templates ~ Go to Configuration - Configure Other When there: Paste the template string into the Template field Make sure you check Activate Click on Save . The device will reboot with a name reflecting your template name and Module 0 selected which has your new template stored. If your device was previously configured you will have to manually change to Module 0 in * Configuration -> Configure Module * . Commands ~ A user provided template can be stored in Tasmota using the Template command. It has the following parameters. Parameter Description Show current Template 0 Create template from active module 1..71 Create template from a supported module { ... } Store template written in a JSON string 255 Merge configured template and current module Template {\"NAME\":\"UserModule1\",\"GPIO\":[17,148,29,149,7,255,255,255,138,255,139,255,255],\"FLAG\":0,\"BASE\":18} stores a complete template based on the Generic module Template {\"NAME\":\"AnotherModuleName\"} updates the name of a stored template Template {\"FLAG\":0} changes FLAG value Template {\"BASE\":18} updates the base of a stored template to Generic After setting a template in command line it is necessary to issue Module 0 command if the device doesn't reboot on its own. Merge Template with Module You can set up your device in module * Configuration -> Configure Module * and use command Template 255 to merge the settings of the Module with current template into a new Template named \"Merged\". Anatomy of a Template ~ Let's look again at our example template: {\"NAME\":\"UserModule1\",\"GPIO\":[17,148,29,149,7,255,255,255,138,255,139,255,255],\"FLAG\":0,\"BASE\":18} The four properties with UPPERCASE property names have the following functionality: Property name Property value description NAME Up to 60 characters for the Module name GPIO Up to 13 decimal numbers from 0 to 255 representing GPIO0 to GPIO5, GPIO09, GPIO10 and GPIO12 to GPIO16 FLAG 8 bit mask flag register BASE Module number of a hard-coded device to be used when device specific functionality is needed GPIO ~ GPIO order GPIO# |00| 01|02| 03|04| 05| 09| 10| 12| 13| 14| 15| 16| CODE [17,148,29,149,52,255,255,255,138,255,139,255,255] GPIO functionality The GPIO functionality numbers are the same as shown by command GPIOs . In addition code 255 is added to select a GPIO as user configurable via the GUI Configure Module menu. Example In our example the GPIO 00 data element is 17 which corresponds to the Button1 component, according to the following table. If you change that template element to 9 it would then be assigned as a Switch1 component instead. Components See Components for a complete list FLAG ~ Used to configure the ADC type. In most templates this should be set to 0 . FLAG Feature description 0 No features 1 Analog value 2 Temperature 3 Light 4 Button 5 Buttoni 15 User configured (same as GPIO 255 ) BASE ~ BASE is the starting module setup for the custom template. Some modules include special programming. If your device is similar to an existing built-in module it is best to use that as a starting point. When you're not sure which BASE module is suitable for your device use the Generic (18) module. A list of hard-coded devices can be found in Modules . Example In the RGB Smart Plug template we used the BlitzWolf SHP (45) module as BASE since the power monitoring circuitry is identical but GPIO00 and GPIO02 were changed and an unused GPIO04 was added to enable the RGB LED function. Using that specific module we took advantage of that module's calibrated power monitoring special programming which the Generic (18) module does not use.","title":"Templates"},{"location":"Templates/#how-to-use","text":"Go to Configuration - Configure Template ... ... and you'll end up looking at this screen. Time to create your template.","title":"How to Use"},{"location":"Templates/#creating-your-template","text":"Change the template name (also defines the name for the module). Select a module to BASE your template on . If you're not sure, Module 18 is the best choice. In this example the device is based on Blitzwolf SHP (45) module. Configure the components assigned to the GPIOs to match your device. If you do not know what pins your device uses, read about the new device configuration procedure to determine the correct pin assignments. Any unused GPIO that has cannot have a peripheral connected should be set to None (0) . In our example the device has no exposed GPIO's so the unused ones are set to 0 compared to the original BlitzWolf module. GPIOs that can have peripherals connected to (exposed GPIOs) should be set to User (255) . This allows future configuration through the Configure Module dialog without the need to create a new template. Example Sonoff TH has a jack connected to GPIO4 that allows a user to plug in a sensor. Assigning GPIO4 as 255 allows a Template to have correct GPIOs for this device even if nothing is plugged in. But, when a user decides to connect a sensor using the jack, GPIO4 can be set to the type of sensor through the Configure Module page. Click on Save and you'll see this message Finally, the device will reboot with the new template name","title":"Creating Your Template"},{"location":"Templates/#exporting-your-template","text":"Now that you've set up your previously unsupported device in Tasmota it is time to share the knowledge: Check that Module 0 is selected in the Configuration - Configure Module menu. Open up Console and issue command Template which will output a string with the configuration of your currently active template. Our example gives the following: MQT : s tat / tas mo ta /RESULT = { \"NAME\" : \"RGB Smart Plug\" , \"GPIO\" :[ 37 , 0 , 39 , 0 , 38 , 134 , 0 , 0 , 131 , 17 , 132 , 21 , 0 ], \"FLAG\" : 0 , \"BASE\" : 45 } Copy the string {\"NAME\":\"RGB Smart Plug\",\"GPIO\":[37,0,39,0,38,134,0,0,131,17,132,21,0],\"FLAG\":0,\"BASE\":45} and share it on the Tasmota Device Templates Repository .","title":"Exporting Your Template"},{"location":"Templates/#importing-templates","text":"Go to Configuration - Configure Other When there: Paste the template string into the Template field Make sure you check Activate Click on Save . The device will reboot with a name reflecting your template name and Module 0 selected which has your new template stored. If your device was previously configured you will have to manually change to Module 0 in * Configuration -> Configure Module * .","title":"Importing Templates"},{"location":"Templates/#commands","text":"A user provided template can be stored in Tasmota using the Template command. It has the following parameters. Parameter Description Show current Template 0 Create template from active module 1..71 Create template from a supported module { ... } Store template written in a JSON string 255 Merge configured template and current module Template {\"NAME\":\"UserModule1\",\"GPIO\":[17,148,29,149,7,255,255,255,138,255,139,255,255],\"FLAG\":0,\"BASE\":18} stores a complete template based on the Generic module Template {\"NAME\":\"AnotherModuleName\"} updates the name of a stored template Template {\"FLAG\":0} changes FLAG value Template {\"BASE\":18} updates the base of a stored template to Generic After setting a template in command line it is necessary to issue Module 0 command if the device doesn't reboot on its own.","title":"Commands"},{"location":"Templates/#anatomy-of-a-template","text":"Let's look again at our example template: {\"NAME\":\"UserModule1\",\"GPIO\":[17,148,29,149,7,255,255,255,138,255,139,255,255],\"FLAG\":0,\"BASE\":18} The four properties with UPPERCASE property names have the following functionality: Property name Property value description NAME Up to 60 characters for the Module name GPIO Up to 13 decimal numbers from 0 to 255 representing GPIO0 to GPIO5, GPIO09, GPIO10 and GPIO12 to GPIO16 FLAG 8 bit mask flag register BASE Module number of a hard-coded device to be used when device specific functionality is needed","title":"Anatomy of a Template"},{"location":"Templates/#gpio","text":"","title":"GPIO"},{"location":"Templates/#flag","text":"Used to configure the ADC type. In most templates this should be set to 0 . FLAG Feature description 0 No features 1 Analog value 2 Temperature 3 Light 4 Button 5 Buttoni 15 User configured (same as GPIO 255 )","title":"FLAG"},{"location":"Templates/#base","text":"BASE is the starting module setup for the custom template. Some modules include special programming. If your device is similar to an existing built-in module it is best to use that as a starting point. When you're not sure which BASE module is suitable for your device use the Generic (18) module. A list of hard-coded devices can be found in Modules . Example In the RGB Smart Plug template we used the BlitzWolf SHP (45) module as BASE since the power monitoring circuitry is identical but GPIO00 and GPIO02 were changed and an unused GPIO04 was added to enable the RGB LED function. Using that specific module we took advantage of that module's calibrated power monitoring special programming which the Generic (18) module does not use.","title":"BASE"},{"location":"Thermal-considerations/","text":"Even though LEDs consume far less energy than incandescent bulbs, these devices contain more complex circuitries and sometimes they still produce more heat than they can handle. The produced heat is proportional to the LED intensities, and if it builds up faster than how it dissipates from the chassis, then the temperature will rise. The circuitries usually (but not necessarily ) contain some last-resort countermeasure that shuts down the device when it is critically overheated, but it shouldn't be relied upon. When testing the device for the first time, especially at higher light intensities, monitor its temperature for some time , like for at least half an hour, and if it rises rapidly, then please consider: Reducing the overall brightness Using only one of the light sources (i.e. either the color LEDs, or the high-power white ones) For such a test use an electrically safe lamp in which you can access the bulb, and which you can easily disconnect from the mains anytime. For measuring the temperature the best tool is an IR thermometer: aim it at the heatsink part of the chassis from a direction perpendicular to it, from such a distance that its cone of sensitivity is fully on the chassis. If you choose to test the temperature by hand, then be prepared that it may be hot , so approach it slowly, and if you already feel its heat, then don't touch it . During this check please also consider that a bulb standing on your desk in a test socket has considerably better cooling than one in a closed armature right below your ceiling, so try to 'model' the operating conditions in which you plan to use the device. If you have found a solution that keeps the temperature stable, don't forget to configure a limit in your home automation system so you (or anyone else) won't accidentally set the device to overheating when it'll be already installed. Some of the devices' original firmwares do contain such software throttling, but as the thermal behaviour differs from one model to another, there is no generic way to apply the right amount of throttling that would be both required and enough for everyone, so \"your mileage may vary\". Technical background ~ Light bulb circuitries consist of 3 main stages: A small power supply unit that converts the 230V or 110V mains to approx. 20V for the LEDs and 3.3V for the controller. This is a small switching-mode power supply, but usually of a parsimonius design, so it's usually barely adequate for the average power requirement, and sometimes not enough for the maximum . The main problem is not the transformer, but the voltage regulators: they produce heat proportionally to the current that's drawn through them, and they aren't connected to the heatsink , so all their heat goes just into the air within the bulb. The controller module, usually a SoC that contains the CPU, memory, flash and wifi. It is a logic circuit, its heat production is negligible compared to the other stages. The LED circuitry, meaning the LEDs themselves and their driver chips, usually on a separate board. They produce a lot of heat, but they are always connected to the chassis via either thermal grease or thermally conductive glue. So the problems are: - Voltage regulators produce heat proportional to light intensity - Their thermal coupling to the chassis is terrible: via a huge air gap - The chassis is not an effective heatsink (for aesthetic reasons it can't be) - The overall system is designed for the average conditions and not for the maximum. Thus our goal is to limit the power consumption to such a level that the heat produced can be dissipated by the chassis heatsink, and the way to achieve this is throttling down the light intensity and/or limiting the switched-on time. Measured values ~ SYF05 (Fcmila/Sunyesmart) ~ At start: 23\u00b0C After 10 minutes: 40\u00b0C (warm) After 20 minutes: 48\u00b0C (hot) After 30 minutes: 53\u00b0C (barely touchable) After 40 minutes: 55\u00b0C At this point the thermal protection has shut the device down, and the local temperatures were: - Chassis: 55\u00b0C - RGB LED driver chip: 73\u00b0C - White LED driver chip: 76\u00b0C - Controller module: 76\u00b0C - Transformer: 85\u00b0C - Area around the voltage regulator: 91\u00b0C Sonoff B1 ~ At start: 26\u00b0C After 10 minutes: 33\u00b0C After 20 minutes: 40\u00b0C After 30 minutes: 44\u00b0C After 40 minutes: 47\u00b0C After 50 minutes: 48\u00b0C After 1 hour: 50\u00b0C The bulb was operational at this point, but I considered this temperature too high for sustained use.","title":"Thermal considerations"},{"location":"Thermal-considerations/#technical-background","text":"Light bulb circuitries consist of 3 main stages: A small power supply unit that converts the 230V or 110V mains to approx. 20V for the LEDs and 3.3V for the controller. This is a small switching-mode power supply, but usually of a parsimonius design, so it's usually barely adequate for the average power requirement, and sometimes not enough for the maximum . The main problem is not the transformer, but the voltage regulators: they produce heat proportionally to the current that's drawn through them, and they aren't connected to the heatsink , so all their heat goes just into the air within the bulb. The controller module, usually a SoC that contains the CPU, memory, flash and wifi. It is a logic circuit, its heat production is negligible compared to the other stages. The LED circuitry, meaning the LEDs themselves and their driver chips, usually on a separate board. They produce a lot of heat, but they are always connected to the chassis via either thermal grease or thermally conductive glue. So the problems are: - Voltage regulators produce heat proportional to light intensity - Their thermal coupling to the chassis is terrible: via a huge air gap - The chassis is not an effective heatsink (for aesthetic reasons it can't be) - The overall system is designed for the average conditions and not for the maximum. Thus our goal is to limit the power consumption to such a level that the heat produced can be dissipated by the chassis heatsink, and the way to achieve this is throttling down the light intensity and/or limiting the switched-on time.","title":"Technical background"},{"location":"Thermal-considerations/#measured-values","text":"","title":"Measured values"},{"location":"Thermal-considerations/#syf05-fcmilasunyesmart","text":"At start: 23\u00b0C After 10 minutes: 40\u00b0C (warm) After 20 minutes: 48\u00b0C (hot) After 30 minutes: 53\u00b0C (barely touchable) After 40 minutes: 55\u00b0C At this point the thermal protection has shut the device down, and the local temperatures were: - Chassis: 55\u00b0C - RGB LED driver chip: 73\u00b0C - White LED driver chip: 76\u00b0C - Controller module: 76\u00b0C - Transformer: 85\u00b0C - Area around the voltage regulator: 91\u00b0C","title":"SYF05 (Fcmila/Sunyesmart)"},{"location":"Thermal-considerations/#sonoff-b1","text":"At start: 26\u00b0C After 10 minutes: 33\u00b0C After 20 minutes: 40\u00b0C After 30 minutes: 44\u00b0C After 40 minutes: 47\u00b0C After 50 minutes: 48\u00b0C After 1 hour: 50\u00b0C The bulb was operational at this point, but I considered this temperature too high for sustained use.","title":"Sonoff B1"},{"location":"Thermostat/","text":"This feature is not included in precompiled binaries. To use it, you must compile your build . Add the following to user_config_override.h : #ifndef USE_THERMOSTAT #define USE_THERMOSTAT #endif Control over heating and cooling as a true HVAC unit Thermostat driver allows a Tasmota device, provided it receives the temperature input via MQTT or a locally connected sensor, to follow control heating/cooling strategies to reach the desired setpoint. The thermostat offers similar functions as feature rich commercial ones as the models found below: Typical setup: Heating floor system ~ A typical setup for heating room systems can be found in the picture below. A conventional room thermostat is connected to a heating floor valve actuator, both running at AC voltage (f.i. 220V). The thermostat is connected to neutral as well as to the phase, the actuator to the same neutral connection of the thermostat and to its actuation signal. The actuation signal will switch between the neutral voltage (actuation Off) and the phase voltage (actuation On). The conventional room thermostats offer nowadays either 2 point control with hysteresis or a more advanced PI (Proportional-Integral) control. The result of the PI control is typically transformed into a PWM signal with a pre-defined period and a variable duty cycle. Use of tasmota switch to bypass an existing wall thermostat ~ A tasmota switch can be installed in a way that it bypasses the existing wall thermostat. The advantage of this setup is that the thermostat driver offers the possibility to follow the output of the existing wall thermostat or acting autonomously. This setup allows a seamless integration with existing wall thermostats and gives the user the freedom to still use them. Below you can find an example of a Shelly switch bypassing a wall thermostat: Configuration for standalone application or bypass of existing wall thermostat ~ The driver by default does not consider the input switch states even if available and its therefore suitable for standalone use. If the application requires to follow the command of the input once active (see bypass setup explained in previous section). This bypass function is specially useful to allow the user to use the device bypassed, in case of a wall thermostat, to allow this thermostat to be used if desired. To enable this bypass function, the following command is to be sent to the tasmota device: cmnd/Tasmota_Name/INPUTSWITCHUSE 1 Note Some devices (such as the Sonoff 4CH Pro R2) even if having input buttons to manually switch the state of the output, report always its inputs in active state no matter if the button is pressed or not. For these devices the parameter above needs to be set to 0, otherwise the thermostat driver will activate the output continuously and stay permanently in manual mode. Once active, the thermostat, in case of its input being active, will switch to manual mode and set as output the same state of its input. The thermostat will switch back from manual to automatic mode after a defined time where the input is inactive. The following parameter can be set to modify the time window in minutes to switch back to automatic in case the input is inactive: cmnd/Tasmota_Name/TIMEMANUALTOAUTOSET 60 The default value for the time window to switch from manual to automatic is 60 minutes. Temperature input / setpoint ~ Local temperature sensor ~ The tasmota driver can receive the temperature either via the related MQTT command or via a local temperature sensor (see example of a DS18B20 temperature sensor and a shelly temperature sensor addon below). The default temperature input is MQTT. The following command can be used to select the local sensor as default input: cmnd/Tasmota_Name/SENSORINPUTSET 1 Note The default local temperature sensor is a DS18B20. In case a different Tasmota supported sensor is used, the following define in my_user_config.h is to be changed (or redefined in user_config_override.h ) and a user specific tasmota software needs to be compiled: #define THERMOSTAT_SENSOR_NAME \"DS18B20\" // Name of the local sensor to be used MQTT temperature value and setpoint ~ The following commands can be used to provide the driver with the temperature value of the room and the desired setpoint: cmnd/Tasmota_Name/TEMPTARGETSET 22.5 cmnd/Tasmota_Name/TEMPMEASUREDSET 21.8 Examples for room temperature of 21.8\u00b0C and temperature setpoint of 22.5\u00b0C There are several ways to send the MQTT room temperature. For the development and testing of this driver, a Raspberry Pi with Domoticz and a Z-Wave stick has been used to gather all room temperatures from Z-Wave sensors and send them to the respective Tasmota room thermostats. Customization of the controller for best results ~ The thermostat controller includes a default parameter set that targets a typical floor heating application for mid-sized rooms (< 20m2) with one heating circuit. The controller is however highly configurable via MQTT. The following sections will guide the user to adapt the main parameters to improve the performance of the thermostat controller via customization. Enable the thermostat driver ~ The thermostat driver is by default disabled. To enable it the following command can be used: cmnd/Tasmota_Name/THERMOSTATMODESET 1 Set the controller in degrees Celsius or Fahrenheit ~ The default temperature format is degrees Celsius. The format can be easily switched to degrees Fahrenheit via MQTT command, see below: cmnd/Tasmota_Name/TEMPFORMATSET 1 Set the control strategy ~ The control strategy by default is a Hybrid one. The hybrid control strategy mixes a so called \"Ramp-Up\" strategy (invention during the development of this driver, initially as a LUA script and ported to Tasmota later) and a PI one. The \"Ramp-Up\" strategy is typically used to reach as fast as possible the setpoint for big deltas between desired temperature and setpoint, the PI on the other hand for most part of the normal thermostat operation. The control strategy can be however modified, if the Hybrid one is not desired, the PI or \"Ramp-Up\" mode, can be forced. For that purpose the following command can be used: cmnd/Tasmota_Name/CONTROLLERMODESET 1 The value 1 forces the PI operation and the value 2 the \"Ramp-Up\" one. PI controller main parameters ~ Cycle time Depending on the heating system, the cycle time (PMW period) can be adapted. Very slow systems (high time constants) such as heating floor systems might need higher values (default value is 30 minutes), faster systems might need smaller cycle times. Below the command to adapt the cycle time can be found: cmnd/Tasmota_Name/TIMEPICYCLESET 30 Proportional Band Depending on the dimensioning of your heating system, the proportional band of the controller might be increased (if it takes too long to reach setpoint) or reduced (very high overshoot). The default proportional gain is 4, which means that the duty cycle due to the proportional part of the PI controller will be 100% for temperature deltas between setpoint and room temperature equal or bigger than 4\u00b0C. Below the command to adapt the proportional band can be found: cmnd/Tasmota_Name/PROPBANDSET 1 Note With the command above, the PI controller will output a proportional time equivalent to 100% of the duty cycle for delta temperatures between setpoint and room temp. above 1\u00b0C (f.i. for big rooms with weak dimensioned heating circuit). Reset Time The reset time is the time the PI controller takes to overcome steady-state errors. The default value for the reset time is 1800 seconds. This value can be for instance increased in case a stronger integral reaction of the controller is desired. Below the command to adapt the proportional band can be found: cmnd/Tasmota_Name/TIMERESETSET 1800 Temperature for the anti-windup reset To avoid the accummulated error and therefore integral component of the PI controller to grow too much and produce a high overshoot, a temperature delta can be defined within the integrator will work. Outside this range the accummulated error and integral part will be set to 0. The default value for the integrator to work is 0.8\u00b0C. Below the command to adapt the anti-windup temperature can be found: cmnd/Tasmota_Name/TEMPANTIWINDUPRESETSET 0.8 Temperature hysteresis A temperature hysteresis can be set to avoid any PI controller actions within a certain value arround the setpoint. The default value for the hysteresis is 0.1\u00b0C. In well configured controller this value should be as low as possible to avoid unwanted temperature oscillations which reduce efficiency and therefore increase costs. Below the command to adapt the anti-windup temperature can be found: cmnd/Tasmota_Name/TEMPHYSTSET 0.1 Maximum action of the controller The maximum On time (Duty Cycle) in minutes within a cycle can be set by this parameter. The default value is 20 minutes. This represents for the default cycle time of 30 minutes 2 thirds of the complete cycle. In case the controller takes too long to reach the setpoint, this value can be increased to values closer to the cycle time. Below the command to adapt the maximum action time can be found: cmnd/Tasmota_Name/TIMEMAXACTIONSET 20 Minimum action of the controller The minimum On time (Duty Cycle) in minutes within a cycle can be set by this parameter. The default value is 4 minutes. Below the command to adapt the minimum action time can be found: cmnd/Tasmota_Name/TIMEMINACTIONSET 4 It is very important to adapt this value to your heating system to obtain accurate temperature control If the value is very low, in case of floor heating systems for instance, the heating actuators might not have enough time to open the valves and the temperature will drop (depending on the actuator open/close time could take from 1 to 3 minutes) if it is too high, there will be unwanted oscillations arround the setpoint. One way to configure this value in heating mode is to manually tune it in worst case conditions (highest typically desired room temperature and lower winter temperature outside) checking that the proportional action generated by the controller is sufficient to raise slightly the temperature. If the temperature still goes down after the pulse plus delay time of the system and rises just once the accumulated error triggers integral actions then the value set is too low. Ramp-Up controller main parameters ~ Temperature delta to get into \"Ramp-Up\" mode When the controller is configured in Hybrid mode (default), the control strategy will be a mix-up between \"Ramp-Up\" (for big deltas between room temperature and setpoint) and PI (arround the setpoint). The following parameter can be set to define at above which delta temperature between measured and setpoint the \"Ramp-Up\" controller shall be active: cmnd/Tasmota_Name/TEMPRUPDELTINSET 30 The default value is 0.4\u00b0C. Time passed after latest setpoint change to get into \"Ramp-Up\" mode When the controller is configured in Hybrid mode (default), the activation of the \"Ramp-Up\" mode will not just depend on the defined temperature delta between measured and setpoint, but as well on the time in minutes passed since the last setpoint change occurred. This strategy matches the purpose of the \"Ramp-Up\" controller, which was developed to reach the desired temperature as fast as possible in very specific scenarios, f.i. after a night keeping the room temperature low. In hybrid mode, the controller active most part of the time should be the PI one. The following parameter can be used to define the time to allow switching to \"Ramp-Up\" in minutes. cmnd/Tasmota_Name/TIMEALLOWRAMPUPSET 300 The default value is 300 minutes. Cycle time Depending on the heating system, the cycle time (PMW period) can be adapted. Very slow systems (high time constants) such as heating floor systems might need higher values (default value is 30 minutes), faster systems might need smaller cycle times. Below the command to adapt the cycle time can be found: cmnd/Tasmota_Name/TIMERAMPUPCYCLESET 30 Maximum Ramp-Up time The maximum time the ramp-up phase of the controller shall be active can be configured. The default value is 960 minutes. Below the command to adapt this time can be found: cmnd/Tasmota_Name/TIMERAMPUPMAXSET 960 Thermostat persistent storage for configuration ~ The thermostat driver stores all configured parameters over MQTT exclusively in RAM, it does not use flash due to the amount of the parameters. This means that at every restart the default parameters will be set again. To avoid this behavior rules can be set-up to reconfigure desired parameters at every restart. See below an example: ON Power1#boot DO Backlog sensorinputset 1;controllermodeset 2;thermostatmodeset 1;temptargetset %mem1% ENDON ON mqtt#connected DO Publish2 stat/TestTopic/targetTempValue {\"Temp\":%mem1%} ENDON ON mem1#state DO Backlog temptargetset %value%;Publish2 stat/TestTopic/targetTempValue {\"Temp\":%mem1%} ENDON Advanced features ~ Multi-controller ~ The tasmota driver can be compiled to be used in devices with more than one output, allowing independant controllers for each one of the outputs. This feature has been successfully tested with a Sonoff 4CH PRO R2. To increase the number of controller outputs, modify the value of the thermostat controller outputs in my_user_config.h or redefine it in user_config_override.h and compile a customized tasmota software. #define THERMOSTAT_CONTROLLER_OUTPUTS 1 // Number of outputs to be controlled independently Alternative outputs: PWM duty cycle ~ The driver provides the possibility to read the duty cycle in % (0-100) of the actuated relay. Below the command to read the duty cycle can be found: cmnd/Tasmota_Name/CTRDUTYCYCLEREAD The physical switch of the output can as well be disabled via command. Below the command to disable it can be found: cmnd/Tasmota_Name/ENABLEOUTPUTSET 0 Future improvements ~ Cooling ~ The controller offers the possibility to switch from heating to cooling. Due to lack of cooling setup at the time of the development of the driver, this feature has however not been propertly tested. Testers for cooling are therefore welcomed. The following MQTT command can be used to switch from heating (default) to cooling: cmnd/Tasmota_Name/CLIMATEMODESET 1 Self learning process of the \"Ramp-Up\" controller to reduce overshoot ~ The \"Ramp-Up\" controller evaluates the time constant of the system and predicts when to switch off the actuator to reach the desired temperature as fast as possible. This controller offers the best speed to reach the Setpoint. This controller will be improved by a learning process to evaluate how accurate the target value has been reached and therefore minimize gradually the overshoot. This feature will improve the behavior of the current controller which depending on the application and thermal capacity of the system might produce some overshoot. By default the controller set is the Hybrid one, enabling \"Ramp-Up\" for big temperature deltas between Setpoint and measured temperature and PI for smaller ones. If you are not satisfied with the performance of this controller in your system, you can disable it by MQTT and force the use of the PI controller exclusively (see Controller configuration section above). PI Autotune ~ A PI autotune feature following the Zigler-Nichols closed loop algorithm has been implemented. This feature is untested and will be further developed soon. To enable it for testing purposes add the following define in user_config_override.h and compile a customized tasmota software. #define USE_PI_AUTOTUNING // (Ziegler-Nichols closed loop method)","title":"Thermostat"},{"location":"Thermostat/#typical-setup-heating-floor-system","text":"A typical setup for heating room systems can be found in the picture below. A conventional room thermostat is connected to a heating floor valve actuator, both running at AC voltage (f.i. 220V). The thermostat is connected to neutral as well as to the phase, the actuator to the same neutral connection of the thermostat and to its actuation signal. The actuation signal will switch between the neutral voltage (actuation Off) and the phase voltage (actuation On). The conventional room thermostats offer nowadays either 2 point control with hysteresis or a more advanced PI (Proportional-Integral) control. The result of the PI control is typically transformed into a PWM signal with a pre-defined period and a variable duty cycle.","title":"Typical setup: Heating floor system"},{"location":"Thermostat/#use-of-tasmota-switch-to-bypass-an-existing-wall-thermostat","text":"A tasmota switch can be installed in a way that it bypasses the existing wall thermostat. The advantage of this setup is that the thermostat driver offers the possibility to follow the output of the existing wall thermostat or acting autonomously. This setup allows a seamless integration with existing wall thermostats and gives the user the freedom to still use them. Below you can find an example of a Shelly switch bypassing a wall thermostat:","title":"Use of tasmota switch to bypass an existing wall thermostat"},{"location":"Thermostat/#configuration-for-standalone-application-or-bypass-of-existing-wall-thermostat","text":"The driver by default does not consider the input switch states even if available and its therefore suitable for standalone use. If the application requires to follow the command of the input once active (see bypass setup explained in previous section). This bypass function is specially useful to allow the user to use the device bypassed, in case of a wall thermostat, to allow this thermostat to be used if desired. To enable this bypass function, the following command is to be sent to the tasmota device: cmnd/Tasmota_Name/INPUTSWITCHUSE 1 Note Some devices (such as the Sonoff 4CH Pro R2) even if having input buttons to manually switch the state of the output, report always its inputs in active state no matter if the button is pressed or not. For these devices the parameter above needs to be set to 0, otherwise the thermostat driver will activate the output continuously and stay permanently in manual mode. Once active, the thermostat, in case of its input being active, will switch to manual mode and set as output the same state of its input. The thermostat will switch back from manual to automatic mode after a defined time where the input is inactive. The following parameter can be set to modify the time window in minutes to switch back to automatic in case the input is inactive: cmnd/Tasmota_Name/TIMEMANUALTOAUTOSET 60 The default value for the time window to switch from manual to automatic is 60 minutes.","title":"Configuration for standalone application or bypass of existing wall thermostat"},{"location":"Thermostat/#temperature-input-setpoint","text":"","title":"Temperature input / setpoint"},{"location":"Thermostat/#local-temperature-sensor","text":"The tasmota driver can receive the temperature either via the related MQTT command or via a local temperature sensor (see example of a DS18B20 temperature sensor and a shelly temperature sensor addon below). The default temperature input is MQTT. The following command can be used to select the local sensor as default input: cmnd/Tasmota_Name/SENSORINPUTSET 1 Note The default local temperature sensor is a DS18B20. In case a different Tasmota supported sensor is used, the following define in my_user_config.h is to be changed (or redefined in user_config_override.h ) and a user specific tasmota software needs to be compiled: #define THERMOSTAT_SENSOR_NAME \"DS18B20\" // Name of the local sensor to be used","title":"Local temperature sensor"},{"location":"Thermostat/#mqtt-temperature-value-and-setpoint","text":"The following commands can be used to provide the driver with the temperature value of the room and the desired setpoint: cmnd/Tasmota_Name/TEMPTARGETSET 22.5 cmnd/Tasmota_Name/TEMPMEASUREDSET 21.8 Examples for room temperature of 21.8\u00b0C and temperature setpoint of 22.5\u00b0C There are several ways to send the MQTT room temperature. For the development and testing of this driver, a Raspberry Pi with Domoticz and a Z-Wave stick has been used to gather all room temperatures from Z-Wave sensors and send them to the respective Tasmota room thermostats.","title":"MQTT temperature value and setpoint"},{"location":"Thermostat/#customization-of-the-controller-for-best-results","text":"The thermostat controller includes a default parameter set that targets a typical floor heating application for mid-sized rooms (< 20m2) with one heating circuit. The controller is however highly configurable via MQTT. The following sections will guide the user to adapt the main parameters to improve the performance of the thermostat controller via customization.","title":"Customization of the controller for best results"},{"location":"Thermostat/#enable-the-thermostat-driver","text":"The thermostat driver is by default disabled. To enable it the following command can be used: cmnd/Tasmota_Name/THERMOSTATMODESET 1","title":"Enable the thermostat driver"},{"location":"Thermostat/#set-the-controller-in-degrees-celsius-or-fahrenheit","text":"The default temperature format is degrees Celsius. The format can be easily switched to degrees Fahrenheit via MQTT command, see below: cmnd/Tasmota_Name/TEMPFORMATSET 1","title":"Set the controller in degrees Celsius or Fahrenheit"},{"location":"Thermostat/#set-the-control-strategy","text":"The control strategy by default is a Hybrid one. The hybrid control strategy mixes a so called \"Ramp-Up\" strategy (invention during the development of this driver, initially as a LUA script and ported to Tasmota later) and a PI one. The \"Ramp-Up\" strategy is typically used to reach as fast as possible the setpoint for big deltas between desired temperature and setpoint, the PI on the other hand for most part of the normal thermostat operation. The control strategy can be however modified, if the Hybrid one is not desired, the PI or \"Ramp-Up\" mode, can be forced. For that purpose the following command can be used: cmnd/Tasmota_Name/CONTROLLERMODESET 1 The value 1 forces the PI operation and the value 2 the \"Ramp-Up\" one.","title":"Set the control strategy"},{"location":"Thermostat/#pi-controller-main-parameters","text":"","title":"PI controller main parameters"},{"location":"Thermostat/#ramp-up-controller-main-parameters","text":"","title":"Ramp-Up controller main parameters"},{"location":"Thermostat/#thermostat-persistent-storage-for-configuration","text":"The thermostat driver stores all configured parameters over MQTT exclusively in RAM, it does not use flash due to the amount of the parameters. This means that at every restart the default parameters will be set again. To avoid this behavior rules can be set-up to reconfigure desired parameters at every restart. See below an example: ON Power1#boot DO Backlog sensorinputset 1;controllermodeset 2;thermostatmodeset 1;temptargetset %mem1% ENDON ON mqtt#connected DO Publish2 stat/TestTopic/targetTempValue {\"Temp\":%mem1%} ENDON ON mem1#state DO Backlog temptargetset %value%;Publish2 stat/TestTopic/targetTempValue {\"Temp\":%mem1%} ENDON","title":"Thermostat persistent storage for configuration"},{"location":"Thermostat/#advanced-features","text":"","title":"Advanced features"},{"location":"Thermostat/#multi-controller","text":"The tasmota driver can be compiled to be used in devices with more than one output, allowing independant controllers for each one of the outputs. This feature has been successfully tested with a Sonoff 4CH PRO R2. To increase the number of controller outputs, modify the value of the thermostat controller outputs in my_user_config.h or redefine it in user_config_override.h and compile a customized tasmota software. #define THERMOSTAT_CONTROLLER_OUTPUTS 1 // Number of outputs to be controlled independently","title":"Multi-controller"},{"location":"Thermostat/#alternative-outputs-pwm-duty-cycle","text":"The driver provides the possibility to read the duty cycle in % (0-100) of the actuated relay. Below the command to read the duty cycle can be found: cmnd/Tasmota_Name/CTRDUTYCYCLEREAD The physical switch of the output can as well be disabled via command. Below the command to disable it can be found: cmnd/Tasmota_Name/ENABLEOUTPUTSET 0","title":"Alternative outputs: PWM duty cycle"},{"location":"Thermostat/#future-improvements","text":"","title":"Future improvements"},{"location":"Thermostat/#cooling","text":"The controller offers the possibility to switch from heating to cooling. Due to lack of cooling setup at the time of the development of the driver, this feature has however not been propertly tested. Testers for cooling are therefore welcomed. The following MQTT command can be used to switch from heating (default) to cooling: cmnd/Tasmota_Name/CLIMATEMODESET 1","title":"Cooling"},{"location":"Thermostat/#self-learning-process-of-the-ramp-up-controller-to-reduce-overshoot","text":"The \"Ramp-Up\" controller evaluates the time constant of the system and predicts when to switch off the actuator to reach the desired temperature as fast as possible. This controller offers the best speed to reach the Setpoint. This controller will be improved by a learning process to evaluate how accurate the target value has been reached and therefore minimize gradually the overshoot. This feature will improve the behavior of the current controller which depending on the application and thermal capacity of the system might produce some overshoot. By default the controller set is the Hybrid one, enabling \"Ramp-Up\" for big temperature deltas between Setpoint and measured temperature and PI for smaller ones. If you are not satisfied with the performance of this controller in your system, you can disable it by MQTT and force the use of the PI controller exclusively (see Controller configuration section above).","title":"Self learning process of the \"Ramp-Up\" controller to reduce overshoot"},{"location":"Thermostat/#pi-autotune","text":"A PI autotune feature following the Zigler-Nichols closed loop algorithm has been implemented. This feature is untested and will be further developed soon. To enable it for testing purposes add the following define in user_config_override.h and compile a customized tasmota software. #define USE_PI_AUTOTUNING // (Ziegler-Nichols closed loop method)","title":"PI Autotune"},{"location":"Time-Proportioned-Output-support/","text":"This extension adds a Time Proportioned Digital Output feature into the Tasmota software. The relay output on a Sonoff device provides (obviously) just on/off control. Often it is desirable to be able to get a value between off and on, for example 25% power. The conventional way to achieve this with devices such as electrical heaters or hot water radiators is to switch the device on for a period and then off for a period. This extension allows a required power value between 0 and 1 to be specified via MQTT and the code will automatically cycle the relay on/off to achieve this power. The s/w is configured with a Cycle Time that specifies the period. So for example if a power value of 0.25 is specified with a cycle time of 12 minutes then the relay will be on for 3 minutes and off for 9 minutes every 12 minute period. The s/w includes a safety mechanism where the maximum time expected between MQTT power updates is specified. If this time is exceeded with no value being received then the power will revert to a specified fallback value. To add the feature into the standard Tasmotta s/w (at least version 5.12.0 is required) then have a look at the timeprop_branch of the tasmota fork at https://github.com/colinl/Sonoff-Tasmota/tree/timeprop_branch . Pick up the three files from there, lib/ProcessControl/Timeprop.cpp and Timeprop.h (which are from this process-control repository ) and sonoff/xdrv_91_timeprop.ino and add them into your Tasmota sources. Instructions for setting it up and using it are in xdrv_91_timeprop.ino . The feature adds about 1.2k to the compiled code. Currently all configuration parameters must be setup at build time. If anyone wanted to add these to the MQTT and/or web interfaces a PR would be gratefully received. For any issues please submit an issue to the Tasmota fork on gitub or ask on the sonoff mailing list .","title":"Time Proportioned Output support"},{"location":"Timers/","text":"Timers allow you to automate your device based on time triggers To control a device locally 16 timers are programmable. They can be configured with the Timer<x> command followed by a JSON payload with optional parameters. For example: Timer 1 will ENABLE output of POWER1 at exactly 2:23 every Tue/Wed and Sat Timer1 { \"Enable\" : 1 , \"Time\" : \"02:23\" , \"Window\" : 0 , \"Days\" : \"--TW--S\" , \"Repeat\" : 1 , \"Output\" : 1 , \"Action\" : 1 } Timer 4 will TOGGLE output of POWER2 within a 30 minute window centered around 16:23 each Sunday, Monday, Thursday and Friday and will disable (disarm) after executing. Timer4 { \"Enable\" : 1 , \"Time\" : \"16:23\" , \"Window\" : 15 , \"Days\" : \"SM00TF0\" , \"Repeat\" : 0 , \"Output\" : 2 , \"Action\" : 2 } When Mode 1 or Mode 2 is used, Latitude and Longitude become available. In that case the Time value is always used as an offset so make sure to set it to 00:00 if no offset is wanted. Timer1 { \"Enable\" : 1 , \"Mode\" : 2 , \"Time\" : \"-2:23\" , \"Window\" : 0 , \"Days\" : \"11TW11S\" , \"Repeat\" : 1 , \"Output\" : 1 , \"Action\" : 1 } Commands ~ Command Parameters Latitude <value> = set latitude Longitude <value> = set longitude Timers Timers control 0 = disable all timers\u2003 \u00bb v6.2.0 1 = enable all timers 2 = toggle all timers Timer<x> Parameters for Timer<x> where x = 1..16 0 = clear parameters for Timer<x>\u2003 \u00bb v6.2.0 1..16 = copy Timer<y> parameters to Timer<x> { \"name\":value ; .. } = set all or individual parameters using JSON payload with names and values of data pairs from the table below JSON Payload Anatomy ~ JSON Name JSON Value Enable 0 = disarm or disable timer 1 = arm or enable timer Mode 0 = use clock time 1 = Use local sunrise time using Longitude , Latitude and Time offset 2 = use local sunset time using Longitude , Latitude and Time offset Time hh:mm = set time in hours 0 .. 23 and minutes 0 .. 59 -hh:mm = set time in offset hours -11 .. 12 and minutes 0 .. 59 (used with Mode 1 and Mode 2 ) Window 0..15 = add or subtract a random number of minutes to Time Days SMTWTFS = set day of weeks mask where 0 or - = OFF and any different character = ON Repeat 0 = allow timer only once 1 = repeat timer execution Output 1..16 = select an output to be used if no rule is enabled Action 0 = turn output OFF 1 = turn output ON 2 = TOGGLE output 3 = RULE/BLINK If the Tasmota Rules feature has been activated by compiling the code (activated by default in all pre-compiled Tasmota binaries), a rule with Clock#Timer=<timer> will be triggered if written and turned on by the user. If Rules are not compiled, BLINK output using BlinkCount parameters.","title":"Timers"},{"location":"Timers/#commands","text":"Command Parameters Latitude <value> = set latitude Longitude <value> = set longitude Timers Timers control 0 = disable all timers\u2003 \u00bb v6.2.0 1 = enable all timers 2 = toggle all timers Timer<x> Parameters for Timer<x> where x = 1..16 0 = clear parameters for Timer<x>\u2003 \u00bb v6.2.0 1..16 = copy Timer<y> parameters to Timer<x> { \"name\":value ; .. } = set all or individual parameters using JSON payload with names and values of data pairs from the table below","title":"Commands"},{"location":"Timers/#json-payload-anatomy","text":"JSON Name JSON Value Enable 0 = disarm or disable timer 1 = arm or enable timer Mode 0 = use clock time 1 = Use local sunrise time using Longitude , Latitude and Time offset 2 = use local sunset time using Longitude , Latitude and Time offset Time hh:mm = set time in hours 0 .. 23 and minutes 0 .. 59 -hh:mm = set time in offset hours -11 .. 12 and minutes 0 .. 59 (used with Mode 1 and Mode 2 ) Window 0..15 = add or subtract a random number of minutes to Time Days SMTWTFS = set day of weeks mask where 0 or - = OFF and any different character = ON Repeat 0 = allow timer only once 1 = repeat timer execution Output 1..16 = select an output to be used if no rule is enabled Action 0 = turn output OFF 1 = turn output ON 2 = TOGGLE output 3 = RULE/BLINK If the Tasmota Rules feature has been activated by compiling the code (activated by default in all pre-compiled Tasmota binaries), a rule with Clock#Timer=<timer> will be triggered if written and turned on by the user. If Rules are not compiled, BLINK output using BlinkCount parameters.","title":"JSON Payload Anatomy"},{"location":"Tips/","text":"","title":"Tips"},{"location":"TouchPin/","text":"The ESP32 has 10 capacitive touch GPIOs. It is possible to use a maximum number of 4 as a touch button. Note Only special pins are usable and not all of these 10 pins are exposed on every dev-board. More info in this [article] (https://randomnerdtutorials.com/esp32-touch-pins-arduino-ide/) After wiring a cable or electrode to a supported pin you have to configure it in Configure Module as \"button_tc\". It is helpful to understand, what is going on under the hood: The continuous pin reading gives a unitless value, that will decrease when the pin (or connected cable) is touched. The touch pin driver will report a button touch when the pin reading falls below a threshold value for a certain amount of read cycles. The latter is important to filter out spikes. The default values are very conservative in order to rule out unwanted actions. In most cases it will be desirable to do a calibration. Commands: ~ Command Description TouchCal x x=button 1 .. 4. This plots the sensor values to the console, to get information regarding the setting of the 2 following commands 0 will turn off calibration 255 will turn on calibration for all buttons TouchThres x x=button 1 .. 4. This plots the sensor values to the console, to get information regarding the setting of the 2 following commands TouchNum x sets number of ignored measurements below the threshold, because there will likely be spikes. The default value of 3 is very conservative and 1 should be fine most of the time. A higher value is safer in a noisy environment, but for obvious reasons you will have to touch the pin (or cable ...) longer to trigger the button press. While the calibration process is running, the raw data values will be printed in the console in the format: PLOT: g, v, h, g - number of the graph (= number of the button) v - raw value of the corresponding touch pin h - number of continous hits below current threshold, useful to see the number and length of \"spikes\", should be 0 without touching The new values for a personal configuration can be stored in RULE: Example rule1 on System#Init do TouchNum 1 endon Tasmota Serial Plotter ~ This little tool should be helpful to get a feel for the touch values. It is located in the /tools folder of the Tasmota repository and needs the installation of \"mathplotlib\" and \"pyserial\" in the active python environment. It is confirmed to work under Windows 10 and macOS Catalina. Usage: ./serial-plotter.py --port /dev/XXX --baud 115200 You can send commands to Tasmota via SEND-box. !!! example for the touch button driver: TouchCal 255 - turns on calibration mode for all buttons (Note the short spikes, which in this config only would need TouchNum 1 to get filtered out)","title":"TouchPin"},{"location":"TouchPin/#commands","text":"Command Description TouchCal x x=button 1 .. 4. This plots the sensor values to the console, to get information regarding the setting of the 2 following commands 0 will turn off calibration 255 will turn on calibration for all buttons TouchThres x x=button 1 .. 4. This plots the sensor values to the console, to get information regarding the setting of the 2 following commands TouchNum x sets number of ignored measurements below the threshold, because there will likely be spikes. The default value of 3 is very conservative and 1 should be fine most of the time. A higher value is safer in a noisy environment, but for obvious reasons you will have to touch the pin (or cable ...) longer to trigger the button press. While the calibration process is running, the raw data values will be printed in the console in the format: PLOT: g, v, h, g - number of the graph (= number of the button) v - raw value of the corresponding touch pin h - number of continous hits below current threshold, useful to see the number and length of \"spikes\", should be 0 without touching The new values for a personal configuration can be stored in RULE: Example rule1 on System#Init do TouchNum 1 endon","title":"Commands:"},{"location":"TouchPin/#tasmota-serial-plotter","text":"This little tool should be helpful to get a feel for the touch values. It is located in the /tools folder of the Tasmota repository and needs the installation of \"mathplotlib\" and \"pyserial\" in the active python environment. It is confirmed to work under Windows 10 and macOS Catalina. Usage: ./serial-plotter.py --port /dev/XXX --baud 115200 You can send commands to Tasmota via SEND-box. !!! example for the touch button driver: TouchCal 255 - turns on calibration mode for all buttons (Note the short spikes, which in this config only would need TouchNum 1 to get filtered out)","title":"Tasmota Serial Plotter"},{"location":"Troubleshooting/","text":"Troubleshooting ~ Debugging ~ Logs ~ For debugging purposes you can use Level 4 or Level 5 logging to the MqttLog , WebLog , SerialLog , or remote SysLog . The logging level is set separately for each log destination. Log levels range from 0 to 5 . The higher the log level, the more information is logged. When troubleshooting your device its recommended to set the logging level to 4 . Web Logging These show up in the Web UI Console (http://deviceip/cs). The default logging level for WebLog logging is 2. Warning Never connect to serial while the device is connected to mains power. You can still collect the logs, but only when powering it via your serial connection. Some devices use the serial port to control the relays or an MCU, so serial logging might interfere with control and even switch relays or lights. The default logging level for SerialLog logging is 2. Unless explicitly set by a command (e.g., user input in the Console, a System#Boot triggered rule), SerialLog will be disabled automatically 10 minutes after the device reboots. Through a terminal program set the baud rate to 115200 (19200 for Sonoff Dual), both NL & CR, and disable hardware flow control. Debugging the Sonoff Pow is a bit tricky as the serial interface has a direct connection to one of the AC power lines . The schematic below uses two optocouplers separating the AC connection on the left from the low voltage connection on the right allowing for serial control at 115200 baud and uploading of firmware up to 57600 baud while AC is connected. Crashdumps If the ESP8266 crashes, it frequently dumps information about the crash out the serial port, so the process listed above to see serial logs can provide extremely useful information Syslog Logging If you have a Linux system, it is probably already running syslog . You just need to configure it to listen on the network. SysLog logging is disabled in Tasmota by default. On systems running rsyslog (most linux distros), edit the /etc/rsyslog.conf file. Adding (or uncommenting) the following lines will probably start making the logs show up in some file under /var/log $ModLoad imudp $UDPServerRun 514 If you do not have access to a Linux system, there are Microsoft Windows Syslog server options . MQTT Logging These log messages show up as MQTT messages. MqttLog logging is disabled by default. MQTT traffic ~ To check the flow of MQTT traffic you can use MQTT Explorer which shows your entire MQTT traffic in an organised and structured way. Tasmota Device Manager offers an overview of all your Tasmota devices using MQTT protocol. You can manage them, use device features and do basic troubleshooting with ease. It also cleanly displays if your device is dropping from the network often or reboots unexpectedly. Running out of RAM ~ This typically shows up in the device working when it first starts up (hitting the button toggles the relay), but some time later it either reboots or some function won't work. For example, you can't load the module configuration page. The only fix for this is to recompile the firmware and disable features you don't need. Known large features are web server and TLS, but other things to consider disabling if you don't need them are emulation support, Domoticz support and WS8212 support. Program Memory ~ A 512K firmware binary size is a good \"target\" and rule of thumb for allowing future OTA firmware updates. Flashing over the air (OTA) requires that there is enough free program memory available to upload the new firmware along with the existing copy before the old copy is deleted. If your firmware binary is larger than the available free program memory, you can replace the existing firmware with a minimal functionality version of Tasmota (roughly 375K). This leaves enough free in the 1024K program memory for the final copy of the firmware (i.e., larger than 512K). Flashing Tasmota makes it simpler to update to newer versions because it is built for OTA upgrades. In fact, if the new firmware is larger than the available free memory, Tasmota's OTA process will, automatically, first replace the existing firmware with \"minimal\" to then have enough space to put the new firmware in. If one is loading firmware only via the serial interface (i.e., wired), then theoretically you could load firmware as large at the program memory size. since you can erase the flash and then fill it to the rim with the new firmware. But then you'd be left with performing upgrades by having to have physical access to the device each time.","title":"Troubleshooting"},{"location":"Troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"Troubleshooting/#debugging","text":"","title":"Debugging"},{"location":"Troubleshooting/#logs","text":"For debugging purposes you can use Level 4 or Level 5 logging to the MqttLog , WebLog , SerialLog , or remote SysLog . The logging level is set separately for each log destination. Log levels range from 0 to 5 . The higher the log level, the more information is logged. When troubleshooting your device its recommended to set the logging level to 4 .","title":"Logs"},{"location":"Troubleshooting/#mqtt-traffic","text":"To check the flow of MQTT traffic you can use MQTT Explorer which shows your entire MQTT traffic in an organised and structured way. Tasmota Device Manager offers an overview of all your Tasmota devices using MQTT protocol. You can manage them, use device features and do basic troubleshooting with ease. It also cleanly displays if your device is dropping from the network often or reboots unexpectedly.","title":"MQTT traffic"},{"location":"Troubleshooting/#running-out-of-ram","text":"This typically shows up in the device working when it first starts up (hitting the button toggles the relay), but some time later it either reboots or some function won't work. For example, you can't load the module configuration page. The only fix for this is to recompile the firmware and disable features you don't need. Known large features are web server and TLS, but other things to consider disabling if you don't need them are emulation support, Domoticz support and WS8212 support.","title":"Running out of RAM"},{"location":"Troubleshooting/#program-memory","text":"A 512K firmware binary size is a good \"target\" and rule of thumb for allowing future OTA firmware updates. Flashing over the air (OTA) requires that there is enough free program memory available to upload the new firmware along with the existing copy before the old copy is deleted. If your firmware binary is larger than the available free program memory, you can replace the existing firmware with a minimal functionality version of Tasmota (roughly 375K). This leaves enough free in the 1024K program memory for the final copy of the firmware (i.e., larger than 512K). Flashing Tasmota makes it simpler to update to newer versions because it is built for OTA upgrades. In fact, if the new firmware is larger than the available free memory, Tasmota's OTA process will, automatically, first replace the existing firmware with \"minimal\" to then have enough space to put the new firmware in. If one is loading firmware only via the serial interface (i.e., wired), then theoretically you could load firmware as large at the program memory size. since you can erase the flash and then fill it to the rim with the new firmware. But then you'd be left with performing upgrades by having to have physical access to the device each time.","title":"Program Memory"},{"location":"Tutorials/","text":"Projects and Tutorials ~ Share your projects in our Discord server ! External Links to cool/amazing projects made with Tasmota ~ LEGO Nightstand Switch Tasmota based drop pin door lock Gallery of projects running Tasmota ~ Click on name for larger image TrDA's 3xINA219 (Solar+Sensor+Display) TrDA's Motorised Roller Blinds Solar and battery power monitoring station Schematic Water tank monitor Multisensor Aquarium controller Installation Tutorials ~ Installing Tasmota using Tasmotizer Flash your device using a RaspberryPi instead of USB-to-TTL serial connector Video tutorials ~ Tasmota and Tasmotizer Easy Flashing Guide for ESP8266 devices Installation tutorial of Tasmota using PlatformIO made by QuickPi. True 3-Way Smart Switch Make a motion activated switch with temperature and humidity sensor Sonoff Basic as UK Light Switch 3D Printed Cases ~ Don't have 3D printer? Depending on where you live, you may be able to find a third party to print the model for you. Some schools and public libraries provide printing services. Search for a printing service using 3D Hubs or send your design to a service like Shapeways . - Thingiverse - Yeggi Related YouTube Channels ~ DigiblurDIY - Great and Easy Tasmota related Videos DrZzs - Great and Easy Tasmota related Videos Super House - Home Automation Tutorials The Hook Up - Home Automation Tutorials BRUH Automation - Home Automation Tutorials Burns Home Automation - Home Automation Tutorials Step to Step Tutorials - Hobbytronics Tutorials Kiril Peyanski - Tasmota Tutorials Non-English Tutorials ~ ES - Cayetano YouTube Channel DE - Tuya Ger\u00e4te Flashen DE - ESP8266 flashen von A - Z FR - Ajouter un bouton physique au Sonoff basic IT - Installazione firmware Tasmota su Sonoff Basic IL - Hebrew - Install Tasmota firmware on all Sonoff devices ?? - Yuval Mejahez - Tasmota Flash tutorials Channel","title":"Projects and Tutorials"},{"location":"Tutorials/#projects-and-tutorials","text":"Share your projects in our Discord server !","title":"Projects and Tutorials"},{"location":"Tutorials/#external-links-to-coolamazing-projects-made-with-tasmota","text":"LEGO Nightstand Switch Tasmota based drop pin door lock","title":"External Links to cool/amazing projects made with Tasmota"},{"location":"Tutorials/#gallery-of-projects-running-tasmota","text":"Click on name for larger image TrDA's 3xINA219 (Solar+Sensor+Display) TrDA's Motorised Roller Blinds Solar and battery power monitoring station Schematic Water tank monitor Multisensor Aquarium controller","title":"Gallery of projects running Tasmota"},{"location":"Tutorials/#installation-tutorials","text":"Installing Tasmota using Tasmotizer Flash your device using a RaspberryPi instead of USB-to-TTL serial connector","title":"Installation Tutorials"},{"location":"Tutorials/#video-tutorials","text":"Tasmota and Tasmotizer Easy Flashing Guide for ESP8266 devices Installation tutorial of Tasmota using PlatformIO made by QuickPi. True 3-Way Smart Switch Make a motion activated switch with temperature and humidity sensor Sonoff Basic as UK Light Switch","title":"Video tutorials"},{"location":"Tutorials/#3d-printed-cases","text":"Don't have 3D printer? Depending on where you live, you may be able to find a third party to print the model for you. Some schools and public libraries provide printing services. Search for a printing service using 3D Hubs or send your design to a service like Shapeways . - Thingiverse - Yeggi","title":"3D Printed Cases"},{"location":"Tutorials/#related-youtube-channels","text":"DigiblurDIY - Great and Easy Tasmota related Videos DrZzs - Great and Easy Tasmota related Videos Super House - Home Automation Tutorials The Hook Up - Home Automation Tutorials BRUH Automation - Home Automation Tutorials Burns Home Automation - Home Automation Tutorials Step to Step Tutorials - Hobbytronics Tutorials Kiril Peyanski - Tasmota Tutorials","title":"Related YouTube Channels"},{"location":"Tutorials/#non-english-tutorials","text":"ES - Cayetano YouTube Channel DE - Tuya Ger\u00e4te Flashen DE - ESP8266 flashen von A - Z FR - Ajouter un bouton physique au Sonoff basic IT - Installazione firmware Tasmota su Sonoff Basic IL - Hebrew - Install Tasmota firmware on all Sonoff devices ?? - Yuval Mejahez - Tasmota Flash tutorials Channel","title":"Non-English Tutorials"},{"location":"Tuya-Convert/","text":"Tuya devices are sold under numerous brand names but they're all identifiable by the fact that they connect with these phone apps: \" Smart Life \" or \" Tuya Smart \". They incorporate different types of Tuya Wi-Fi modules internally. Tuya has begun manufacturing some Wi-Fi modules using a Realtek RTL8710BN Wi-Fi SOC instead of an ESP82xx chip. Tasmota cannot run on Realtek devices and there are no plans on supporting them . Tuya-Convert is the most successful method of flashing Tuya modules without opening the device and soldering. Tuya-Convert comes with tasmota-lite.bin build which includes basic Tasmota features required for normal operation with Tuya devices, while removing sensors, IR, RF and home automation integration support for reduced filesize. It is recommended to upgrade to a full build of the firmware ( tasmota.bin ) if needed. To ensure Tasmota runs reliably execute the command reset 5 after Tuya-Convert is finished and Tasmota is up and running. Doing this removes fragments of the original firmware left in flash which can create issues in the future. After all that is done you can proceed with the needed configuration of your device. Help and troubleshooting for Tuya-Convert is done on Tuya-Convert's Github . Danger The fact that you can flash Tasmota on your device does not mean all of its features are currently supported. Please research before purchasing to see if other users have successfully flashed the device and are able to use it fully Tuya-Convert video walkthrough TuyOTA walkthrough Mock Tuya Cloud - A general purpose framework for interacting with Tuya devices without the Tuya operated cloud. Tuya API - A library for communicating with devices that use the Tuya cloud network.","title":"Tuya Convert"},{"location":"Tuya-Protocols/","text":"","title":"Tuya Protocols"},{"location":"Tuya-generic-wifi-curtain-motor-WIP/","text":"","title":"Tuya generic wifi curtain motor WIP"},{"location":"TuyaMCU-Devices/","text":"There are several Tuya dimmer and switch variants made by various manufacturers. The switches range from 1 to 8 gangs. The dimmers are usually 1 gang. They dim mains voltage for various lighting types: incandescent, CFL, and LED. Consult the specific device for the type of bulbs and capacity it supports as well as the bulbs themselves to verify they support dimming. Identification and Technical details ~ The basic identification of a Tuya device is when the device information references the \"Tuya Smart\", \"SmartLife\", or \"Smart Living\" app. These switches and dimmers are based on a Tuya TYWE3S Wi-Fi PCB module along with an MCU. TYWE3S is based on the ESP8266 which is supported by Tasmota. Wiki page for TYWE3S The TYWE3S module mostly takes care of Wi-Fi and software features while the MCU controls the actual hardware (buttons, relays, dimmer, power measurement, etc). The MCU is interfaced to TYWE3S using the serial interface which connects to the Rx and Tx pins. The easiest way to identify if your switch or dimmer uses MCU is by using a continuity tester (multimeter, ohmmeter) and checking continuity from the Rx and Tx pins on TYWE3S to any other chip. Then check the datasheet of that chip to see if it is an MCU. Flashing - Preparation ~ To boot the TYWE3S in flashing mode, GPIO0 needs to be connected to GND while powering up. It can be left grounded for the entire process. Flashing a TYWE3S connected to a MCU is a bit trickier than one without MCU. This is due the same Rx Tx pins used by MCU and serial programmer for flashing. The TYWE3S cannot be booted to flash mode with MCU sending data over the same pins. To be able to do that, we need to disable MCU from sending data over Rx and Tx pins. There are few ways to do it: 1. Disconnect TYWE3S module from the rest of board. (Naah, too much work) 2. Just break the Rx track from MCU to TYWE3S, flash and then reconnect. (Messy work, we want cleaner approach) 3. Just keep MCU disabled while flashing TYWE3S without any soldering / cutting. (We like that) The easiest is to keep MCU disabled is by identifying the NRST/RST (Reset) pin of the MCU from its datasheet and connect it to GND for the entire flashing process. This will keep MCU disabled while you flash TYWE3S. If there are some contacts or test points in switches that connect to the MCU, you might be lucky to find contacts for RST that you can easily solder onto. TYWE3S Connection Options ~ 3D print a flashing Jig and use pogo pins to make nice and easy to use flashing jig Solder wires directly onto TYWE3S Use a jumper header like the one below and bend the pins to match VCC, Rx Tx GPIO0 and GND. You can just press the jumper header to the contacts during the flashing process Flashing - Process ~ Once you are done identifying the pins and ready to connect, BEFORE connecting USB to PC you need to connect them as follows: NOTE : Use 3.3V NOT 5V TYWE3S Serial Programmer RX TX TX RX GPIO0 GND GND GND VCC 3.3V If an MCU is present, bridge RST to GND on the MCU Use a 6.6.0.10 Tasmota version or higher. There are lots of Tuya Serial fixes / features added in there and the tutorial below expects them. Now you need to follow the commands explained in the flashing tutorial . TIP: If you are using jumper headers use sleep 15 && before your commands, this would free your hand and give you some time to set the jumper pins and connect the USB to PC. Configuration ~ Once Tasmota is flashed on the TYWE3S, just disconnect GND -> GPIO0 (and RST if there is an MCU), and power your device again from USB. On your PC, you should see a Wi-Fi network named sonoff-xxxx where xxxx is a number from the ESP's MAC address. Connect to it and go to 192.168.4.1 in your browser. Enter the Wi-Fi credentials for your network and click save. Connect your PC back to your network. Now you need to find the IP of newly connected Tasmota device. Refer to this very good video from SuperHouseTV (ignore flashing information) about configuring Tasmota. Once you get to the Tasmota configuration you need to select TuyaMCU module assign GPIO components as indicated below depending on your hardware. You already know the pin connections to the MCU. GPIO Component 01 Tuya Rx (108) 03 Tuya Tx (107) 13 Tuya Rx (108) 15 Tuya Tx (107) If the device is connecting fine to your network, now is the time to power it down and re-assemble it. Connect a test bulb (or to the final place if you don't mind testing there) Once this is saved and device is rebooted. Open the Tasmota configuration page and you should be able to use the Toggle button to toggle the dimmer or at least one of the gangs in a multi gang switch. Follow the process here depending on switch or dimmer. Product Specific guides ~ Otim Dimmer ~ This Device is based on a Tuya Wi-Fi Module. Refer to \"MCU Based Tuya Dimmers and Switches\" for details. Flashing and Setup Video Guide These devices use a Tuya TYWE3S Wi-Fi PCB module. Once the switch is carefully popped open you will need to remove the ribbon cables for flashing and ease of soldering. An easy soldering method is to take several Dupont style jumper wires, cut one end off, and apply a bit of solder to each stripped end. This will keep the wire flexible and prevent any circuit board pads from ripping off. Apply a bit of solder to each pad necessary to flash (double check your pin-outs). Once the wire and pad have solder simply put the two together and apply a bit of heat and they will join together. Attach the GPIO0 wire to ground during initial boot to flash. You may need to also connect MCU RST to GND during initial boot to get it into programming mode as described here . A 3-pin header bridged together works great with GPIO0, GND and the GND from the USB flasher attached. (TX pin to RX pin and RX pin to TX pin on USB flash adapter). Verify that you are using 3.3volts to flash, NOT 5V! Product Links: Oittm Moes DS01 ( Template ) Konesky Heygo Costco Charging Essentials ~ This devices use a Tuya TYWE1S Wi-Fi PCB module. And it uses U1TX (GPIO15) and U1RX (GPIO13) to communicate between ESP8266 and MCU, no other GPIO is used in this device. Flashing The CE dimmer uses standard Tuya GPIO Touch (EU and US) - Multiple manufacturers ~ Flashing The procedure is similar to above, additionally NRST must be connected to GND during flashing. Optional configuration (recommended) LedState 0 Only use the green LED for Wi-Fi/MQTT connectivity status. Product Links: ~ AIGLEN ALLOMN MakeGood Zemismart Curtain Motor ~ Curtain motors come in a confusing array. This one has a little Wi-Fi dongle, that looks like a USB stick. But it talks using 9600 8N1 , not USB. This means we can unplug the Tuya Dongle and flash it without worrying about the PCI micro. Excellent. U1RX and U1TX , top right of the module are connected to the USB plug on D- and D+ respectively. This dongle uses a Tuya TYWE1S, which is an ESP8266 with 2MB flash. USB3 pin R- connects the onboard LED to the MCU via a 4k7 resistor. R+ , T+ , and T- are all unused and unconnected on the motor PCB, so I liberated them for soldering to GPIO0 , U0RX and U0TX , to flash the chip. short GPIO0 and flash Tasmota Connect to your Wi-Fi and get MQTT and SSL working change to TuyaMCU with module 54 (will reboot) Switch from U0RX/TX to U1RX/TX with backlog gpio1 0; gpio3 0; gpio15 107; gpio13 108 (will reboot) Treat DpId 0x65 as a Dimmer with tuyamcu 21,101 Allow the dimmer to get down to 1% with setoption69 0 And done. The curtain motor now presents as a Dimmer, with 100% full brightness = fully closed, and 0% full darkness = fully open. The curtain motor also presents DpId 0x66 as a single event \"Full Open\" 00 , \"Full Close\" 01 , and \"Stop\" 02 command; but as of September 2019, I can't see how to get that working. The curtain motor also presents DpId 0x67 as a Boolean. I have only seen value 0x01 in all my prodding. 55 aa 00 07 00 05 67 01 00 01 01 75 = 07 Status, 0005 length, 67 DpId, 01 type, 0001 length, 01 value, 75 checksum Product Links: ~ ZemiSmart DM_WF_MDV4 Leading edge dimmer ~ This is a 240V Leading Edge Dimmer with a TYWE3S controller and an STM8 MCU Flashing: ~ The simplest approach is to use Tuya-Convert to flash the device In order to flash via serial, the NRST pin of the STM8 needs to be grounded upon boot to disable it, this is brought out to a header pin, along with ground and VCC from the TYWE3S. Confirm by checking continuity with a multimeter IO0 from the TYWE3s also needs to be grounded upon boot, otherwise it's normal tasmota flashing procedure. Header J3 (STM8 debug interface) pins from left to right (Pin 1 is the square shaped) *VCC *STM8 SWIM (Pin 18) *Ground *STM8 NRST (Pin 4) Config: ~ As per main TuyaMCU page using GPIO Component 01 Tuya Rx (108) 03 Tuya Tx (107) Note that the push button is wired to the MCU (PA3 Pin 10) so it cannot be used by Tasmota. Similarlly the devices has a bi-color LED where one color (green) is wired to the TYWE3S (GPIO14) and the other one (red) to the MCU (PC5 Pin15). More information: ~ Bought from ebay More information on TYWE3S ] Product Links: ~ AIGLEN ALLOMN MakeGood ZemiSmart","title":"TuyaMCU Devices"},{"location":"TuyaMCU-Devices/#identification-and-technical-details","text":"The basic identification of a Tuya device is when the device information references the \"Tuya Smart\", \"SmartLife\", or \"Smart Living\" app. These switches and dimmers are based on a Tuya TYWE3S Wi-Fi PCB module along with an MCU. TYWE3S is based on the ESP8266 which is supported by Tasmota. Wiki page for TYWE3S The TYWE3S module mostly takes care of Wi-Fi and software features while the MCU controls the actual hardware (buttons, relays, dimmer, power measurement, etc). The MCU is interfaced to TYWE3S using the serial interface which connects to the Rx and Tx pins. The easiest way to identify if your switch or dimmer uses MCU is by using a continuity tester (multimeter, ohmmeter) and checking continuity from the Rx and Tx pins on TYWE3S to any other chip. Then check the datasheet of that chip to see if it is an MCU.","title":"Identification and Technical details"},{"location":"TuyaMCU-Devices/#flashing-preparation","text":"To boot the TYWE3S in flashing mode, GPIO0 needs to be connected to GND while powering up. It can be left grounded for the entire process. Flashing a TYWE3S connected to a MCU is a bit trickier than one without MCU. This is due the same Rx Tx pins used by MCU and serial programmer for flashing. The TYWE3S cannot be booted to flash mode with MCU sending data over the same pins. To be able to do that, we need to disable MCU from sending data over Rx and Tx pins. There are few ways to do it: 1. Disconnect TYWE3S module from the rest of board. (Naah, too much work) 2. Just break the Rx track from MCU to TYWE3S, flash and then reconnect. (Messy work, we want cleaner approach) 3. Just keep MCU disabled while flashing TYWE3S without any soldering / cutting. (We like that) The easiest is to keep MCU disabled is by identifying the NRST/RST (Reset) pin of the MCU from its datasheet and connect it to GND for the entire flashing process. This will keep MCU disabled while you flash TYWE3S. If there are some contacts or test points in switches that connect to the MCU, you might be lucky to find contacts for RST that you can easily solder onto.","title":"Flashing - Preparation"},{"location":"TuyaMCU-Devices/#tywe3s-connection-options","text":"3D print a flashing Jig and use pogo pins to make nice and easy to use flashing jig Solder wires directly onto TYWE3S Use a jumper header like the one below and bend the pins to match VCC, Rx Tx GPIO0 and GND. You can just press the jumper header to the contacts during the flashing process","title":"TYWE3S Connection Options"},{"location":"TuyaMCU-Devices/#flashing-process","text":"Once you are done identifying the pins and ready to connect, BEFORE connecting USB to PC you need to connect them as follows: NOTE : Use 3.3V NOT 5V TYWE3S Serial Programmer RX TX TX RX GPIO0 GND GND GND VCC 3.3V If an MCU is present, bridge RST to GND on the MCU Use a 6.6.0.10 Tasmota version or higher. There are lots of Tuya Serial fixes / features added in there and the tutorial below expects them. Now you need to follow the commands explained in the flashing tutorial . TIP: If you are using jumper headers use sleep 15 && before your commands, this would free your hand and give you some time to set the jumper pins and connect the USB to PC.","title":"Flashing - Process"},{"location":"TuyaMCU-Devices/#configuration","text":"Once Tasmota is flashed on the TYWE3S, just disconnect GND -> GPIO0 (and RST if there is an MCU), and power your device again from USB. On your PC, you should see a Wi-Fi network named sonoff-xxxx where xxxx is a number from the ESP's MAC address. Connect to it and go to 192.168.4.1 in your browser. Enter the Wi-Fi credentials for your network and click save. Connect your PC back to your network. Now you need to find the IP of newly connected Tasmota device. Refer to this very good video from SuperHouseTV (ignore flashing information) about configuring Tasmota. Once you get to the Tasmota configuration you need to select TuyaMCU module assign GPIO components as indicated below depending on your hardware. You already know the pin connections to the MCU. GPIO Component 01 Tuya Rx (108) 03 Tuya Tx (107) 13 Tuya Rx (108) 15 Tuya Tx (107) If the device is connecting fine to your network, now is the time to power it down and re-assemble it. Connect a test bulb (or to the final place if you don't mind testing there) Once this is saved and device is rebooted. Open the Tasmota configuration page and you should be able to use the Toggle button to toggle the dimmer or at least one of the gangs in a multi gang switch. Follow the process here depending on switch or dimmer.","title":"Configuration"},{"location":"TuyaMCU-Devices/#product-specific-guides","text":"","title":"Product Specific guides"},{"location":"TuyaMCU-Devices/#otim-dimmer","text":"This Device is based on a Tuya Wi-Fi Module. Refer to \"MCU Based Tuya Dimmers and Switches\" for details. Flashing and Setup Video Guide These devices use a Tuya TYWE3S Wi-Fi PCB module. Once the switch is carefully popped open you will need to remove the ribbon cables for flashing and ease of soldering. An easy soldering method is to take several Dupont style jumper wires, cut one end off, and apply a bit of solder to each stripped end. This will keep the wire flexible and prevent any circuit board pads from ripping off. Apply a bit of solder to each pad necessary to flash (double check your pin-outs). Once the wire and pad have solder simply put the two together and apply a bit of heat and they will join together. Attach the GPIO0 wire to ground during initial boot to flash. You may need to also connect MCU RST to GND during initial boot to get it into programming mode as described here . A 3-pin header bridged together works great with GPIO0, GND and the GND from the USB flasher attached. (TX pin to RX pin and RX pin to TX pin on USB flash adapter). Verify that you are using 3.3volts to flash, NOT 5V! Product Links: Oittm Moes DS01 ( Template ) Konesky Heygo","title":"Otim Dimmer"},{"location":"TuyaMCU-Devices/#costco-charging-essentials","text":"This devices use a Tuya TYWE1S Wi-Fi PCB module. And it uses U1TX (GPIO15) and U1RX (GPIO13) to communicate between ESP8266 and MCU, no other GPIO is used in this device.","title":"Costco Charging Essentials"},{"location":"TuyaMCU-Devices/#touch-eu-and-us-multiple-manufacturers","text":"","title":"Touch (EU and US) - Multiple manufacturers"},{"location":"TuyaMCU-Devices/#product-links","text":"AIGLEN ALLOMN MakeGood","title":"Product Links:"},{"location":"TuyaMCU-Devices/#zemismart-curtain-motor","text":"Curtain motors come in a confusing array. This one has a little Wi-Fi dongle, that looks like a USB stick. But it talks using 9600 8N1 , not USB. This means we can unplug the Tuya Dongle and flash it without worrying about the PCI micro. Excellent. U1RX and U1TX , top right of the module are connected to the USB plug on D- and D+ respectively. This dongle uses a Tuya TYWE1S, which is an ESP8266 with 2MB flash. USB3 pin R- connects the onboard LED to the MCU via a 4k7 resistor. R+ , T+ , and T- are all unused and unconnected on the motor PCB, so I liberated them for soldering to GPIO0 , U0RX and U0TX , to flash the chip. short GPIO0 and flash Tasmota Connect to your Wi-Fi and get MQTT and SSL working change to TuyaMCU with module 54 (will reboot) Switch from U0RX/TX to U1RX/TX with backlog gpio1 0; gpio3 0; gpio15 107; gpio13 108 (will reboot) Treat DpId 0x65 as a Dimmer with tuyamcu 21,101 Allow the dimmer to get down to 1% with setoption69 0 And done. The curtain motor now presents as a Dimmer, with 100% full brightness = fully closed, and 0% full darkness = fully open. The curtain motor also presents DpId 0x66 as a single event \"Full Open\" 00 , \"Full Close\" 01 , and \"Stop\" 02 command; but as of September 2019, I can't see how to get that working. The curtain motor also presents DpId 0x67 as a Boolean. I have only seen value 0x01 in all my prodding. 55 aa 00 07 00 05 67 01 00 01 01 75 = 07 Status, 0005 length, 67 DpId, 01 type, 0001 length, 01 value, 75 checksum","title":"Zemismart Curtain Motor"},{"location":"TuyaMCU-Devices/#product-links_1","text":"ZemiSmart","title":"Product Links:"},{"location":"TuyaMCU-Devices/#dm_wf_mdv4-leading-edge-dimmer","text":"This is a 240V Leading Edge Dimmer with a TYWE3S controller and an STM8 MCU","title":"DM_WF_MDV4 Leading edge dimmer"},{"location":"TuyaMCU-Devices/#flashing","text":"The simplest approach is to use Tuya-Convert to flash the device In order to flash via serial, the NRST pin of the STM8 needs to be grounded upon boot to disable it, this is brought out to a header pin, along with ground and VCC from the TYWE3S. Confirm by checking continuity with a multimeter IO0 from the TYWE3s also needs to be grounded upon boot, otherwise it's normal tasmota flashing procedure. Header J3 (STM8 debug interface) pins from left to right (Pin 1 is the square shaped) *VCC *STM8 SWIM (Pin 18) *Ground *STM8 NRST (Pin 4)","title":"Flashing:"},{"location":"TuyaMCU-Devices/#config","text":"As per main TuyaMCU page using GPIO Component 01 Tuya Rx (108) 03 Tuya Tx (107) Note that the push button is wired to the MCU (PA3 Pin 10) so it cannot be used by Tasmota. Similarlly the devices has a bi-color LED where one color (green) is wired to the TYWE3S (GPIO14) and the other one (red) to the MCU (PC5 Pin15).","title":"Config:"},{"location":"TuyaMCU-Devices/#more-information","text":"Bought from ebay More information on TYWE3S ]","title":"More information:"},{"location":"TuyaMCU-Devices/#product-links_2","text":"AIGLEN ALLOMN MakeGood ZemiSmart","title":"Product Links:"},{"location":"TuyaMCU/","text":"TuyaMCU - Module (54) is configured for devices with a Tuya Wi-Fi module and a secondary MCU. Originally, in those devices, the Wi-Fi module takes care of network and software features. Meanwhile, the MCU controls the hardware based on commands received from the Wi-Fi module or built-in controls (buttons, switches, remotes and similar) and reports the status back to the Wi-Fi module. TuyaMCU module facilitates communication between Tasmota and the MCU using Tuya Serial Port Communication Protocol : TuyaMCU command maps device functions to Tasmota components TuyaSend<x> command calculates and sends complex serial commands using only two parameters TuyaReceived MCU response interpreted and publishes as status message and a JSON payload to an MQTT topic Warning Used only if your device is defined as module TuyaMCU (54) . Command value consists of two comma separated parameters: fnId and dpId. TuyaMCU <fnId>,<dpId> Example TuyaMCU 11,1 maps Relay1 (fnId 11) to dpId 1. If any existing entry with same fnId or dpId is already present, it will be updated to the new value. Entry is removed when fnId or dpId is 0 . When no parameters are provided TuyaMCU prints the current mapped values. dpId ~ All the device functions controlled by the MCU are identified by a dpId. Whenever a command is sent to the MCU, this dpId determines which component needs to be controlled and the applies when the status is received from MCU. There is no way to autodetect dpId's and their functions. To assist in the process of determining what dpId does what, there is a bookmarklet available that can be used on the console screen. This will send the weblog and other required commands automatically, and present the TuyaMCU information in a single table allowing for easier testing. Use this procedure to determine which dpId's are available: Go to Configure -> Console option in Tasmota web interface. Use command weblog 4 to enable verbose logging in web interface. Observe the log. After every 9-10 seconds you should see TYA messages. {\"TuyaReceived\":{\"Data\":\"55AA0107000501010001000F\",\"Cmnd\":7,\"CmndData\":\"0101000100\",\"DpType1Id1\":0,\"1\":{\"DpId\":1,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=11 is set for dpId=1 TYA: RX Relay-1 --> MCU State: Off Current State:Off {\"TuyaReceived\":{\"Data\":\"55AA01070005020100010010\",\"Cmnd\":7,\"CmndData\":\"0201000100\",\"DpType1Id2\":0,\"2\":{\"DpId\":2,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=0 is set for dpId=2 {\"TuyaReceived\":{\"Data\":\"55AA01070005030100010011\",\"Cmnd\":7,\"CmndData\":\"0301000100\",\"DpType1Id3\":0,\"3\":{\"DpId\":3,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=0 is set for dpId=3 {\"TuyaReceived\":{\"Data\":\"55AA01070005040100010012\",\"Cmnd\":7,\"CmndData\":\"0401000100\",\"DpType1Id4\":0,\"4\":{\"DpId\":4,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=0 is set for dpId=4 {\"TuyaReceived\":{\"Data\":\"55AA0107000807020004000000001C\",\"Cmnd\":7,\"CmndData\":\"0702000400000000\",\"DpType2Id7\":0,\"7\":{\"DpId\":7,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=7 {\"TuyaReceived\":{\"Data\":\"55AA0107000808020004000000001D\",\"Cmnd\":7,\"CmndData\":\"0802000400000000\",\"DpType2Id8\":0,\"8\":{\"DpId\":8,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=8 {\"TuyaReceived\":{\"Data\":\"55AA0107000809020004000000001E\",\"Cmnd\":7,\"CmndData\":\"0902000400000000\",\"DpType2Id9\":0,\"9\":{\"DpId\":9,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=9 {\"TuyaReceived\":{\"Data\":\"55AA010700080A020004000000001F\",\"Cmnd\":7,\"CmndData\":\"0A02000400000000\",\"DpType2Id10\":0,\"10\":{\"DpId\":10,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=10 {\"TuyaReceived\":{\"Data\":\"55AA0107000865020004000000007A\",\"Cmnd\":7,\"CmndData\":\"6502000400000000\",\"DpType2Id101\":0,\"101\":{\"DpId\":101,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=101 {\"TuyaReceived\":{\"Data\":\"55AA0107000866020004000000007B\",\"Cmnd\":7,\"CmndData\":\"6602000400000000\",\"DpType2Id102\":0,\"102\":{\"DpId\":102,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=102 {\"TuyaReceived\":{\"Data\":\"55AA0107000867020004000000007C\",\"Cmnd\":7,\"CmndData\":\"6702000400000000\",\"DpType2Id103\":0,\"103\":{\"DpId\":103,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=103 {\"TuyaReceived\":{\"Data\":\"55AA01070008680200040000099117\",\"Cmnd\":7,\"CmndData\":\"6802000400000991\",\"DpType2Id104\":2449,\"104\":{\"DpId\":104,\"DpIdType\":2,\"DpIdData\":\"00000991\"}}} TYA: fnId=0 is set for dpId=104 Observe all lines printed as TYA: FnId=0 is set for dpId=XXX and note all dpId values. Now that you have a list of usable dpId's you need to determine what their functions are: Consulting our list of commonly used dpId's and existing device configurations Observing Tasmota logs while activating features of the device (with a remote or on device controls) and correlating log messages and looking at the DpIdType and DpIdData values (eg: boolean vs value) Extrapolating possible function of the dpId based on Data Type and Function Command, then testing using TuyaSend<x> fnId ~ Identifier used in TuyaMCU command to map a dpId to a Tasmota component. Component FunctionId Note Switch1 to Switch4 1 to 4 Map only to dpId with on / off function Relay1 to Relay8 11 to 18 Map only to dpId with on / off function Lights 21 to 28 21 for Dimmer 22 for Dimmer2 23 for CCT Light 24 for RGB light 25 for white light 26 for light mode set (0 = white and 1 = color) 27 to report the state of Dimmer1 28 to report the state of Dimmer2 Power Monitoring 31 to 33 31 for Power (in deci Watt) 32 for Current (in milli Amps) 33 for Voltage (in deci Volt) Relay1i to Relay8i 41 to 48 Map only to dpId with on / off function Battery powered sensor mode 51 Battery powered devices use a slightly different protocol Fan control 61 to 64 61 for 3 speeds fan controller (possible values 0,1,2) 62 for 4 speeds fan controller (possible values 0,1,2,3) 63 for 5 speeds fan controller (possible values 0,1,2,3,4) 64 for 6 speeds fan controller (possible values 0,1,2,3,4,5) Extra functions 97 to 99 97 for motor direction 98 for error logging (report only) 99 as a dummy function Note This component is under active development which means the function list may expand in the future. Since the majority of devices have a power on/off functions on dpId 1 its mapped to fnId 11 (Relay1) by default. If you don't need it, map it to fnId 99 with TuyaMcu 99,1 Danger Mapping a relay or switch to a dpId that is not a simple on/off function (data Type 1) might result in unwanted power toggling (i.e. dpId sends value of 4 which toggles the relay to Power 4 aka blink mode) TuyaSend Command ~ Command TuyaSend is used to send commands to dpId's. It is required for dpId's that shouldn't be mapped to a fnId. With this command it is possible to control every function of the dpId that is controllable, providing you know its data type and data length. With them provided, the rest of the protocol command is calculated. Command's value consists of two comma separated parameters: dpId and data. TuyaSend<x> dpId,data TuyaSend0 Used without payload to query states of dpID's. TuyaSend1 Sends boolean (Type 1) data ( 0/1 ) to dpId (Max data length 1 byte) Example TuyaSend1 1,0 sends vaue 0 to dpId=1 switching the device off TuyaSend2 Sends integer or 4 byte (Type 2) data to dpId (Max data length 4 bytes) Example TuyaSend2 14,100 sends value 100 to dpId=14 setting timer to 100 minutes TuyaSend3 Sends string (Type 3) data to dpId (Max data length? Not known at this time). Warning Note that when sending color values, the MCU may interpret lower case and upper case hex codes differently. You may need to test with your specific MCU to ensure that the values sent properly render the color you desire. Example TuyaSend3 108,ff0000646464ff sends a 14 char hex string to dpId=108 (Type 3) containing RGBHSV values to control a light TuyaSend4 Sends enum (Type 4) data ( 0/1/2/3/4/5 ) to dpId (Max data length 1 bytes) Example TuyaSend4 103,2 sends value 2 to dpId=103 to set fan speed to high TuyaSend8 Used without payload to get device information and dpId states. Replaces SerialSend5 55aa000100000 TuyaSend9 Use without any payload to toggle a new STAT topic reporting changes to a dpId, for example: 17 : 45 : 38 MQT: stat / TuyaMCU / DPTYPE1ID1 = 1 TuyaReceived ~ Every status message from the MCU gets a JSON response named TuyaReceived which contains the MCU protocol status message inside key/value pairs which are hidden from the user by default. To publish them to an MQTT Topic of tele/%topic%/RESULT you need to enable SetOption66 1 . Example After issuing serial command 55aa0006000501010001010e (Device power (dpId=1) is mapped to Relay1 (fnId=11)) we get the following console output (with weblog 4 ): 19 : 54 : 18 TYA : Send \"55aa0006000501010001010e\" 19 : 54 : 18 MQT : stat /GD-30W/ STATE = { \"Time\" : \"2019-10-25T19:54:18\" , \"Uptime\" : \"0T01:45:51\" , \"UptimeSec\" : 6351 , \"Heap\" : 27 , \"SleepMode\" : \"Dynamic\" , \"Sleep\" : 0 , \"LoadAvg\" : 999 , \"MqttCount\" : 1 , \"POWER1\" : \"ON\" , \"POWER2\" : \"OFF\" , \"POWER3\" : \"ON\" , \"POWER4\" : \"OFF\" , \"POWER5\" : \"ON\" , \"Dimmer\" : 100 , \"Fade\" : \"OFF\" , \"Speed\" : 1 , \"LedTable\" : \"OFF\" , \"Wifi\" :{ \"AP\" : 1 , \"SSId\" : \"HTPC\" , \"BSSId\" : \"50:64:2B:5B:41:59\" , \"Channel\" : 10 , \"RSSI\" : 24 , \"LinkCount\" : 1 , \"Downtime\" : \"0T00:00:08\" }} 19 : 54 : 18 MQT : stat /GD-30W/ RESULT = { \"POWER1\" : \"ON\" } 19 : 54 : 18 MQT : stat /GD-30W/ POWER1 = ON 19 : 54 : 18 MQT : stat /GD-30W/ RESULT = { \"TuyaReceived\" :{ \"Data\" : \"55AA0007000501010001010F\" , \"ChkSum\" : \"0x0F\" , \"Cmnd\" : 7 , \"CmndDataLen\" : 5 , \"CmndData\" : \"0101000101\" , \"DpId\" : 1 , \"DpIdType\" : 1 , \"DpIdLen\" : 1 , \"DpIdData\" : \"01\" }} 19 : 54 : 18 TYA : fnId = 11 is set for dpId = 1 19 : 54 : 18 TYA : RX Relay - 1 --> MCU State : On Current State : On Above TYA: fnId=11 is set for dpId=1 you can see the JSON response for that dpId. This JSON string displays the response MCU gave to our command. \"Data\" field contains the complete response and the rest of the key/value pairs show the protocol broken into parts. \"DpId\", \"DpIdData\" and \"DpIdType\" are the ones we're most interested in since we can use them for TuyaSend . Tip Use command TuyaSend8 and/or TuyaSend0 at any time to request statuses of all dpId's from the MCU. Use in Rules This data can also be used as a trigger for rules using TuyaReceivedData#Data=hex_string Rule1 on TuyaReceived # Data = 55 AA000700056E040001007E do publish2 stat / tuya_light / effect rgb_cycle endon will publish a status message to a custom topic when 55AA000700056E040001007E appears in \"Data\" field of the response. Device Configurations ~ Before proceeding identify dpId's and their function. Dimmer ~ We need to configure four functions of a dimmer: Dimming dpId Dimming Range Dimming less than 10% Dimming dpId The dimmer FunctionId is 21 . On a dimmer dpId generally is 2 or 3 . Try both. Go to the Tasmota Console and type TuyaMCU 21,2 and wait for it to reboot. Enter Backlog Dimmer 10; Dimmer 100 in the Console. If your bulb responds to Dimmer commands, you have successfully configured the dimmer FunctionId. Make note of it. If not try id 3 and if even 3 doesn't work keep trying Ids from all unknown Ids from the log until one works. Dimming Range Once you have figured out the dimming functionId, we need to find the maximum dimming range. Once the dimming Id is set, the logs will continue TYA : Heartbeat TYA : RX Packet : \"55aa03070005010100010011\" TYA : RX Relay - 1 --> MCU State : Off Current State : Off TYA : RX Packet : \"55aa03070008020200040000000720\" TYA : FnId = 21 is set for dpId = 2 TYA : RX Dim State = 7 Now using the hardware buttons increase the dimmer to its maximum and observe the log. The Dim State=XXX shows the current dimmer level reported by MCU. Once the dimmer is at max, note this number. Again using hardware buttons decrease dimmer to minimum and note the number for minimum. Now we need to tell Tasmota to use maximum and minimum values. This controlled by DimmerRange command. We can set it using DimmerRange <Min>,<Max> where <Min> is the minimum dimmer state and <Max> maximum dimmer state reported in logs. Once set, try dimmer 100 in the Console and check if the brightness of bulb is same is the same as when the maximum was set using hardware buttons. Warning Some Tuya devices automatically send the state of a dimmer after a power off. Tasmota could misunderstand the command and try to turn on the light even with SetOption20 and SetOption54 enabled. Dual Dimmer ~ To enable a dual dimmer setup assign fnId's: 21 as Dimmer1 22 as Dimmer2 11 as Relay1 12 as Relay2 Tasmota will automatically enable SetOption68 and the dimmers will respond to Channel1 and Channel2 commands. Warning The use of SetOption68 is limited to two channels and will be automatically disabled if any other combination of lights is used. Lights ~ CCT Light To enable a CCT light assign fnId's: 21 as Dimmer1 11 as Relay1 23 as CT channel RGB Light To enable an RGB light assign fnId's: 21 as Dimmer1 11 as Relay1 24 as RGB controller TuyaMCU uses different types of RGB Hex format where the most recent is 0HUE0SAT0BRI0 (type 1) and the older being RRGGBBFFFF6464 (type 2). Depending on the MCU, code can be case sensitive. After enabling the RGB function check the TuyaReceived information and use TuyaRGB to configure and store the correct (or the closest) format: TuyaRGB 0 - Type 1, 12 characters uppercase. Example: 00DF00DC0244 (default) TuyaRGB 1 - Type 1, 12 characters lowercase. Example: 008003e8037a TuyaRGB 2 - Type 2, 14 characters uppercase. Example: 00FF00FFFF6464 TuyaRGB 3 - Type 2, 14 characters lowercase. Example: 00e420ffff6464 TuyaRGB without payload will return the actual configured format. RGB+X Light To enable an RGB+W light use RGB Light configuration and assign fnId 25 as white color. To enable an RGB+CCT light use RGB Light configuration and assign fnId 23 as CT channel. Light mode selector The majority of TuyaMCU devices with an RGB+W or an RGB+CCT light have a button or app function to switch between White and Colored light. To do the same in Tasmota, assign function (fnId) 26 to the mode select dpId. The possible values are 0 (white) and 1 (colorful). A button on the WebUI will be available once configured. When the ModeSet function is enabled it is not possible to update both lights at the same time. Only the currently selected light mode will be updated. Warning Use of SetOption68 for more than two channels and the light split option ( SetOption37 >= 128 ) are not supported in TuyaMCU mode. Enums ~ Better control over Type4 or enum dpId's. Up to four can be added, with a range from 0 to 31. 61 as Enum1 62 as Enum2 63 as Enum3 64 as Enum4 After an enum is configured, use TuyaEnumList to declare the range it must respect (note 0 is always the first item in range). TuyaEnumlist <enum>,<range> where <enum> is declared using TuyaMCU and <range> is 0..31 . Example: configure Enum 1 with a range from 0 to 8. 21 : 14 : 52 CMD : tuyaenumlist 1 , 8 21 : 14 : 52 MQT : stat / TuyaMCU / RESULT = { \"TuyaEnumList\" :{ \"Enum1\" : 8 , \"Enum2\" : 9 , \"Enum4\" : 1 }} Entering a value greater than 31 will return an error TuyaEnumList without payload will return the configuration of all the enums enabled in the list. To update an enum use the command TuyaEnum : Usage TuyaEnum [1|2|3|4],[TuyaEnumList range] Example: update Enum 2 to 4. 21 : 14 : 12 CMD : tuyaenum2 4 21 : 14 : 12 MQT : stat / TuyaMCU / RESULT = { \"TuyaEnum2\" : 4 } ntering a value not in range will return an error TuyaEnum without payload will return the state of all the enums configured. Sensors ~ These are the currently available sensors: 71 as Temperature Sensor 73 as Humidity Sensor 75 as Illuminance Sensor 76 as TVOC Sensor 77 as CO2 Sensor 78 as ECO2 Sensor If your device has a dpId for setting a specific Temperature and/or Humidity: 72 for Temperature Set 74 for Humidity Set Use TuyaSend2 to manage them. Temperature and Temperature Set default to \u00b0C . If you need \u00b0F change SetOption8 to 1 . Please note this will not update the value sent by the MCU but will just change the unit of measure reported on /SENSOR topic. You have to find a dpid to set the correct unit and change reported values (if it exists). Timers ~ 4 Type2 (integer) timers can be managed directly from Tasmota 81 as Timer1 82 as Timer2 83 as Timer3 84 as Timer4 Timers can be managed with TuyaSend2 and are visible in the WebUI. Covers ~ Single shutter or double shutters devices can be managed with a dimmer setup For devices that are reporting position to a another dpId assign fnId's: 27 to report the state of Dimmer1 28 to report the state of Dimmer2 If your cover device has a motor direction change option assign fnId 97 for motor direction. Switches ~ There is currenty no way to detect the number of relays present in an MCU based switch. We need to tell the number of relays to Tasmota using FunctionIDs 12 to 18 for Relay2 to Relay4. Example For a 4 gang switch set TuyaMCU 12,2 , TuyaMCU 13,3 and TuyaMCU 14,4 if the dpIds for Relays 2-4 are 2 , 3 , 4 . Tip You can configure all at once by using Backlog TuyaMCU 12,2; TuyaMCU 13,3; TuyaMCU 14,4 Power Metering ~ Some Tuya MCU devices support Power measurement support over serial. For this it is better to use a bulb with known wattage rating. Observe the logs in the Console TYA : Heartbeat { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000501010001000F\" , \"Cmnd\" : 7 , \"CmndData\" : \"0101000100\" , \"DpType1Id1\" : 0 , \"1\" :{ \"DpId\" : 1 , \"DpIdType\" : 1 , \"DpIdData\" : \"00\" }}} TYA : fnId = 11 is set for dpId = 1 TYA : RX Relay - 1 --> MCU State : Off Current State : Off { \"TuyaReceived\" :{ \"Data\" : \"55AA01070005020100010111\" , \"Cmnd\" : 7 , \"CmndData\" : \"0201000101\" , \"DpType1Id2\" : 1 , \"2\" :{ \"DpId\" : 2 , \"DpIdType\" : 1 , \"DpIdData\" : \"01\" }}} TYA : fnId = 0 is set for dpId = 2 { \"TuyaReceived\" :{ \"Data\" : \"55AA01070005030100010011\" , \"Cmnd\" : 7 , \"CmndData\" : \"0301000100\" , \"DpType1Id3\" : 0 , \"3\" :{ \"DpId\" : 3 , \"DpIdType\" : 1 , \"DpIdData\" : \"00\" }}} TYA : fnId = 0 is set for dpId = 3 { \"TuyaReceived\" :{ \"Data\" : \"55AA01070005040100010113\" , \"Cmnd\" : 7 , \"CmndData\" : \"0401000101\" , \"DpType1Id4\" : 1 , \"4\" :{ \"DpId\" : 4 , \"DpIdType\" : 1 , \"DpIdData\" : \"01\" }}} TYA : fnId = 0 is set for dpId = 4 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000807020004000000001C\" , \"Cmnd\" : 7 , \"CmndData\" : \"0702000400000000\" , \"DpType2Id7\" : 0 , \"7\" :{ \"DpId\" : 7 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 7 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000808020004000000001D\" , \"Cmnd\" : 7 , \"CmndData\" : \"0802000400000000\" , \"DpType2Id8\" : 0 , \"8\" :{ \"DpId\" : 8 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 8 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000809020004000000001E\" , \"Cmnd\" : 7 , \"CmndData\" : \"0902000400000000\" , \"DpType2Id9\" : 0 , \"9\" :{ \"DpId\" : 9 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 9 { \"TuyaReceived\" :{ \"Data\" : \"55AA010700080A020004000000001F\" , \"Cmnd\" : 7 , \"CmndData\" : \"0A02000400000000\" , \"DpType2Id10\" : 0 , \"10\" :{ \"DpId\" : 10 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 10 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000865020004000000007A\" , \"Cmnd\" : 7 , \"CmndData\" : \"6502000400000000\" , \"DpType2Id101\" : 0 , \"101\" :{ \"DpId\" : 101 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 101 { \"TuyaReceived\" :{ \"Data\" : \"55AA01070008660200040000009813\" , \"Cmnd\" : 7 , \"CmndData\" : \"6602000400000098\" , \"DpType2Id102\" : 152 , \"102\" :{ \"DpId\" : 102 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000098\" }}} TYA : fnId = 0 is set for dpId = 102 { \"TuyaReceived\" :{ \"Data\" : \"55AA01070008670200040000017EFB\" , \"Cmnd\" : 7 , \"CmndData\" : \"670200040000017E\" , \"DpType2Id103\" : 382 , \"103\" :{ \"DpId\" : 103 , \"DpIdType\" : 2 , \"DpIdData\" : \"0000017E\" }}} TYA : fnId = 0 is set for dpId = 103 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000868020004000009951B\" , \"Cmnd\" : 7 , \"CmndData\" : \"6802000400000995\" , \"DpType2Id104\" : 2453 , \"104\" :{ \"DpId\" : 104 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000995\" }}} TYA : fnId = 0 is set for dpId = 104 In the TuyaReceived we are interested in DpIdData . For example: 00000995 is the second last entry. Make sure the bulb if off. Find out the voltage standard of your country (generally 220, 240, 120v) from this table . Multiply that number by 10 (2400) and Convert that number (2400) to Hex using any hex converter (2400 = 0x960) Now look for the number nearest to 960 in the logs. In our case it is 00000995 . So we expect that's the voltage which is \"DpId\":104 in our example. Set voltage functionId 33 by entering TuyaMCU 33,104 . Now set dimmer to 100% using the dimmer 100 command, or power on using power1 on (depending on the device) and observe the logs. Now we need the power rating of your bulb, for example 40W . Multiply by 10 (400) and convert to hex which gives us 0x190. Check which unknown ID is close to 190 . I this example it is 17E for \"DpId\":103 . This is the Id of Active Power function. Set the active power functionId 31 by entering TuyaMCU 31,103 . Once Power and Voltage are set you should see something such as this in the logs: TYA : Heartbeat { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000501010001000F\" , \"Cmnd\" : 7 , \"CmndData\" : \"0101000100\" , \"DpType1Id1\" : 0 , \"1\" :{ \"DpId\" : 1 , \"DpIdType\" : 1 , \"DpIdData\" : \"00\" }}} TYA : fnId = 11 is set for dpId = 1 TYA : RX Relay - 1 --> MCU State : Off Current State : Off { \"TuyaReceived\" :{ \"Data\" : \"55AA01070005020100010111\" , \"Cmnd\" : 7 , \"CmndData\" : \"0201000101\" , \"DpType1Id2\" : 1 , \"2\" :{ \"DpId\" : 2 , \"DpIdType\" : 1 , \"DpIdData\" : \"01\" }}} TYA : fnId = 0 is set for dpId = 2 { \"TuyaReceived\" :{ \"Data\" : \"55AA01070005030100010011\" , \"Cmnd\" : 7 , \"CmndData\" : \"0301000100\" , \"DpType1Id3\" : 0 , \"3\" :{ \"DpId\" : 3 , \"DpIdType\" : 1 , \"DpIdData\" : \"00\" }}} TYA : fnId = 0 is set for dpId = 3 { \"TuyaReceived\" :{ \"Data\" : \"55AA01070005040100010113\" , \"Cmnd\" : 7 , \"CmndData\" : \"0401000101\" , \"DpType1Id4\" : 1 , \"4\" :{ \"DpId\" : 4 , \"DpIdType\" : 1 , \"DpIdData\" : \"01\" }}} TYA : fnId = 0 is set for dpId = 4 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000807020004000000001C\" , \"Cmnd\" : 7 , \"CmndData\" : \"0702000400000000\" , \"DpType2Id7\" : 0 , \"7\" :{ \"DpId\" : 7 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 7 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000808020004000000001D\" , \"Cmnd\" : 7 , \"CmndData\" : \"0802000400000000\" , \"DpType2Id8\" : 0 , \"8\" :{ \"DpId\" : 8 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 8 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000809020004000000001E\" , \"Cmnd\" : 7 , \"CmndData\" : \"0902000400000000\" , \"DpType2Id9\" : 0 , \"9\" :{ \"DpId\" : 9 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 9 { \"TuyaReceived\" :{ \"Data\" : \"55AA010700080A020004000000001F\" , \"Cmnd\" : 7 , \"CmndData\" : \"0A02000400000000\" , \"DpType2Id10\" : 0 , \"10\" :{ \"DpId\" : 10 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 10 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000865020004000000007A\" , \"Cmnd\" : 7 , \"CmndData\" : \"6502000400000000\" , \"DpType2Id101\" : 0 , \"101\" :{ \"DpId\" : 101 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 101 { \"TuyaReceived\" :{ \"Data\" : \"55AA01070008660200040000009712\" , \"Cmnd\" : 7 , \"CmndData\" : \"6602000400000097\" , \"DpType2Id102\" : 151 , \"102\" :{ \"DpId\" : 102 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000097\" }}} TYA : fnId = 0 is set for dpId = 102 { \"TuyaReceived\" :{ \"Data\" : \"55AA01070008670200040000017BF8\" , \"Cmnd\" : 7 , \"CmndData\" : \"670200040000017B\" , \"DpType2Id103\" : 379 , \"103\" :{ \"DpId\" : 103 , \"DpIdType\" : 2 , \"DpIdData\" : \"0000017B\" }}} TYA : fnId = 31 is set for dpId = 103 TYA : Rx ID = 103 Active_Power = 379 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000868020004000009961C\" , \"Cmnd\" : 7 , \"CmndData\" : \"6802000400000996\" , \"DpType2Id104\" : 2454 , \"104\" :{ \"DpId\" : 104 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000996\" }}} TYA : fnId = 33 is set for dpId = 104 TYA : Rx ID = 104 Voltage = 2454 To get the Id for the current, calculate Current = Power / Voltage ( 37.9 / 245.4 ) = ~0.1544 (Remember to divide each value by 10). Multiply this by 1000 = 154. Now convert 154 to hex which is 0x9A. This is closest to 97 which is Id \"DpId\":102 . Set the current FunctionId 32 using command TuyaMCU 32,102 . Observe the logs should start showing Current in addition to Active_Power and Voltage TYA : Heartbeat { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000501010001000F\" , \"Cmnd\" : 7 , \"CmndData\" : \"0101000100\" , \"DpType1Id1\" : 0 , \"1\" :{ \"DpId\" : 1 , \"DpIdType\" : 1 , \"DpIdData\" : \"00\" }}} TYA : fnId = 11 is set for dpId = 1 TYA : RX Relay - 1 --> MCU State : Off Current State : Off { \"TuyaReceived\" :{ \"Data\" : \"55AA01070005020100010111\" , \"Cmnd\" : 7 , \"CmndData\" : \"0201000101\" , \"DpType1Id2\" : 1 , \"2\" :{ \"DpId\" : 2 , \"DpIdType\" : 1 , \"DpIdData\" : \"01\" }}} TYA : fnId = 0 is set for dpId = 2 { \"TuyaReceived\" :{ \"Data\" : \"55AA01070005030100010011\" , \"Cmnd\" : 7 , \"CmndData\" : \"0301000100\" , \"DpType1Id3\" : 0 , \"3\" :{ \"DpId\" : 3 , \"DpIdType\" : 1 , \"DpIdData\" : \"00\" }}} TYA : fnId = 0 is set for dpId = 3 { \"TuyaReceived\" :{ \"Data\" : \"55AA01070005040100010113\" , \"Cmnd\" : 7 , \"CmndData\" : \"0401000101\" , \"DpType1Id4\" : 1 , \"4\" :{ \"DpId\" : 4 , \"DpIdType\" : 1 , \"DpIdData\" : \"01\" }}} TYA : fnId = 0 is set for dpId = 4 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000807020004000000001C\" , \"Cmnd\" : 7 , \"CmndData\" : \"0702000400000000\" , \"DpType2Id7\" : 0 , \"7\" :{ \"DpId\" : 7 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 7 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000808020004000000001D\" , \"Cmnd\" : 7 , \"CmndData\" : \"0802000400000000\" , \"DpType2Id8\" : 0 , \"8\" :{ \"DpId\" : 8 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 8 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000809020004000000001E\" , \"Cmnd\" : 7 , \"CmndData\" : \"0902000400000000\" , \"DpType2Id9\" : 0 , \"9\" :{ \"DpId\" : 9 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 9 { \"TuyaReceived\" :{ \"Data\" : \"55AA010700080A020004000000001F\" , \"Cmnd\" : 7 , \"CmndData\" : \"0A02000400000000\" , \"DpType2Id10\" : 0 , \"10\" :{ \"DpId\" : 10 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 10 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000865020004000000007A\" , \"Cmnd\" : 7 , \"CmndData\" : \"6502000400000000\" , \"DpType2Id101\" : 0 , \"101\" :{ \"DpId\" : 101 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 101 { \"TuyaReceived\" :{ \"Data\" : \"55AA01070008660200040000009712\" , \"Cmnd\" : 7 , \"CmndData\" : \"6602000400000097\" , \"DpType2Id102\" : 151 , \"102\" :{ \"DpId\" : 102 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000097\" }}} TYA : fnId = 32 is set for dpId = 102 TYA : Rx ID = 102 Current = 151 { \"TuyaReceived\" :{ \"Data\" : \"55AA01070008670200040000017BF8\" , \"Cmnd\" : 7 , \"CmndData\" : \"670200040000017B\" , \"DpType2Id103\" : 379 , \"103\" :{ \"DpId\" : 103 , \"DpIdType\" : 2 , \"DpIdData\" : \"0000017B\" }}} TYA : fnId = 31 is set for dpId = 103 TYA : Rx ID = 103 Active_Power = 379 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000868020004000009961C\" , \"Cmnd\" : 7 , \"CmndData\" : \"6802000400000996\" , \"DpType2Id104\" : 2454 , \"104\" :{ \"DpId\" : 104 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000996\" }}} TYA : fnId = 33 is set for dpId = 104 TYA : Rx ID = 104 Voltage = 2454 Power and current should change on dimming high / low or turning the device on and off. The Tasmota web UI should show power values now on the home page. Battery Powered Sensors ~ TYMC-1 Door/Window Sensor TY-01 Door/Window Sensor Gas Sensor Smoke Sensor PIR Sensor Specific Devices ~ Aromatherapy Diffuser Water Kettle Air Purifier Mouse Trap Humidifer Tuya Protocols ~ The MCU communicates with the Wi-Fi module through the serial port with a Tuya specified protocol. Those are classified into basic and functional protocols. Basic protocols ~ They are common protocols integrated in Tasmota's TuyaMCU module. They stay the same for each product and are mandatory for Tuya module to work correctly. Functional protocols ~ Functional protocols are used for delivering and reporting data of functions. These protocols differ between devices and manufacturers and might require configuration in Tasmota using TuyaMCU command or with TuyaSend<x> command. Anatomy of Tuya Protocol ~ Name Description Frame Header Version Fixed value of 0x55aa Command Word 0x06 - send commands 0x07 - report status Data Length defines expected length of data dpID numbered ID of a function (DP = Data Point or Define Product) Data Type see Data Type table below Function Length length of command Function Command formatted according to Data Type Verification Method checksum = remainder of the byte sum starting from Frame Header to 256 Data Type Hex Tasmota Command Decription Max length 0x01 TuyaSend1 boolean data 0/1 1 byte 0x02 TuyaSend2 value data. If a value contains less than 4 bytes, 0 is supplemented before 4 bytes 0x00 TuyaSend3 string data unknown 0x04 TuyaSend4 enum data 0/1/2/3/4/5 1 byte 0x05 ### fault data, report only 8 bytes Let's dissect and explain the MCU protocol using serial command 55aa0006000501010001010e : Frame Header Version Command Word Data Length dpID Data Type Function Length Function Command Verification Method 55aa00 06 0005 01 01 0001 01 0e This is the command which powers on the device sending Function Command = 1 to dpID 1 (Switch): Frame Header Version = 0x55aa00 which is a fixed value and always the same Command Word = 0x06 because we're sending a command Data Type = 0x01 since the command sent is a 1 byte boolean Function Length = 0x001 instruct 1 character only for function command length Function Command = 0x01 in hex which equals 1 in int Verification Method = 0e is calculated Protocol flow On device boot, TuyaMCU executes the required basic protocols and reads the functional protocol data received, which are used to update status of components mapped in TuyaMCU (Relays, dimmer, power monitoring data). After receiving a command from Tasmota (Command Word 0x06 ), the MCU performs corresponding logical control. When the dpID status is changed, the MCU reports the data (Command Word 0x07 ) to TuyaMCU component. dpId Function Tables ~ This information is just for orientation. Functions are assigned by the manufacturer and can be on different dpId's DP ID: dpId. Function Point\uff1aUsed to describe the product function. Identifier: Function codename. Can only be letters, numbers and underscores Data type\uff1a Issue and report: command data can be sent and status data can be reported back to the Wi-Fi module Report only: supports only status reporting, no control options Function Type (Referred as Data Type): Boolean (bool): non-true or false binary variable, such as: switch function, on / off Value (value): suitable for linear adjustment of the type of data, such as: temperature regulation, temperature range 20-40 \u2103 Enum (enum): custom finite set value, such as: working levels, low / mid / high Fault (fault): dedicated to reporting and statistical failure of the function points. Support multi-fault, the data is reported only Integer\uff08integer\uff09: transmitted as integer Transparent (raw): data in binary Switches or Plugs/Power Strips ~ DP ID Identifier Data type Function type Properties 1 switch_1 Control and report Boolean 2 switch_2 Control and report Boolean 3 switch_3 Control and report Boolean 4 switch_4 Control and report Boolean 5 switch_5 Control and report Boolean 9 countdown_1 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 10 countdown_2 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 11 countdown_3 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 12 countdown_4 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 13 countdown_5 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s Aromatherapy Machine (Oil Diffuser) ~ DP ID Function points Identifier Data type Function type Properties 1 Switch Power Issue and report Boolean 6 Amount of fog fog Issue and report Enum Enumerated values:small, large 11 Light Light Issue and report Boolean 12 Fault alarm fault Only report Fault Barrier values:1 13 Countdown countdown Issue and report Enum Enumerated values: 0, 1, 2, 3 14 Countdown remaining time countdown_left Only report Integer Values range: 0-360, Pitch1, Scale0, Unit:min 101 Light mode work_mode Issue and report Enum Enumerated values: white, colour, scene, scene1, scene2, scene3, scene4 102 Color value colour_data Issue and report Char type *see below 103 Light mode lightmode Issue and report Enum Enumerated values: 1, 2, 3 104 Brightness setting setlight Issue and report Integer Values range: 0-255, Pitch1, Scale0, Unit:\\% colour_data format of the lights is a string of 14 characters, for example, 00112233334455, where 00 indicates R, 11 indicates G, 22 indicates B, 3333 indicates the hue, 44 indicates the saturation, and 55 indicates the value. The initial value is saved by default. If you do not want to adjust the light, set the data to the maximum value 100% (0x64). The last four characters have fixed values. Curtain Motor ~ DP ID Function points Identifier Data type Function type Properties 1 Percentage percent_state Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 2 Motor Direction control_back Issue and report Boolean 3 Auto Power auto_power Issue and report Boolean 4 Left time countdown Issue and report Enum Enumerated values:cancel, 1, 2, 3, 4 5 Total Time time_total Only report Integer Values range:0-120000, Pitch1, Scale0, Unit:m Complete document on protocols DP ID Function points Identifier Data type Function type Properties 1 Control (required) control Issue and report Enum Enumerated values:open, stop, close, continue 2 Curtain position setting percent_control Issue and report Integer Values range:0-100, Pitch1, Scale0, Unit:% 3 Current curtain position percent_state Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 4 Mode mode Issue and report Enum Enumerated values:morning, night 5 Motor Direction control_back Issue and report Enum Enumerated values:forward, back 6 Auto Power auto_power Issue and report Boolean 7 Work State (required) work_state Only report Enum Enumerated values:opening, closing 11 Situation_set situation_set Only report Enum Enumerated values:fully_open, fully_close 12 Fault (required) fault Only report Fault Barrier values:motor_fault Power Monitoring Plug ~ DP ID Function points Identifier Data type Function type Properties 1 switch_1 switch_1 Control and report Boolean 9 countdown_1 countdown_1 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 17 statistics Function add_ele Control and report Integer undefined0-50000, undefined100, Scale3, Unit: 18 current cur_current Data report Integer undefined0-30000, undefined1, Scale0, Unit:mA 19 power cur_power Data report Integer undefined0-50000, undefined1, Scale1, Unit:W 20 voltage cur_voltage Data report Integer undefined0-5000, undefined1, Scale1, Unit:V 21 test flag test_bit Data report Integer undefined0-5, undefined1, Scale0, Unit: 22 voltage coefficient voltage_coe Data report Integer undefined0-1000000, undefined1, Scale0, Unit: 23 current coefficient electric_coe Data report Integer undefined0-1000000, undefined1, Scale0, Unit: 24 power coefficient power_coe Data report Integer undefined0-1000000, undefined1, Scale0, Unit: 25 statistics coefficient electricity_coe Data report Integer undefined0-1000000, undefined1, Scale0, Unit: 26 warning fault Data report Fault Barrier values:ov_cr Dehumidifier ~ DP ID Function points Identifier Data type Function type Properties 1 Switch Switch Issue and report Boolean 2 PM2.5 PM25 Only report Integer Values range:0-999, Pitch1, Scale0, Unit: 3 Work mode Mode Issue and report Enum Enumerated values:Manual, Auto, Sleep 4 Wind speed Speed Issue and report Enum Enumerated values:speed1, speed2, speed3, speed4, speed5 5 Filter usage Filter Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 6 Fresh Anion Issue and report Boolean 7 Child lock Lock Issue and report Boolean 9 UV light UV Issue and report Boolean 11 Filter reset FilterReset Issue and report Boolean 12 indoor temp Temp Only report Integer Values range:-20-50, Pitch1, Scale0, Unit:\u2103 13 Indoor humidity Humidity Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% Lighting ~ DP ID Function points Identifier Data type Function type Properties 1 Switch led_switch Control and report Boolean 2 Mode work_mode Control and report Enum Enumerated values:white, colour, scene, scene_1, scene_2, scene_3, scene_4 3 Bright bright_value Control and report Integer undefined25-255, undefined1, Scale0, Unit: 5 Colour mode colour_data Control and report Char type 6 Scene scene_data Control and report Char type 7 Scene1 flash_scene_1 Control and report Char type 8 Scene2 flash_scene_2 Control and report Char type 9 Scene3 flash_scene_3 Control and report Char type 10 Scene4 flash_scene_4 Control and report Char type Contact Sensor ~ DP ID Function points Identifier Data type Function type Properties 1 Door Sensor doorcontact_state Only report Boolean 2 Battery Level battery_percentage Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 3 Battery Level battery_state Only report Enum Enumerated values:low, middle, high 4 Anti-remove Alarm temper_alarm Only report Boolean Air purifier ~ DP ID Function points Identifier Data type Function type Properties 1 Switch Switch Issue and report Boolean 2 PM2.5 PM25 Only report Integer Values range:0-999, Pitch1, Scale0, Unit: 3 Work mode Mode Issue and report Enum Enumerated values:Manual, Auto, Sleep 4 Wind speed Speed Issue and report Enum Enumerated values:speed1, speed2, speed3, speed4, speed5 5 Filter usage Filter Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 6 Fresh Anion Issue and report Boolean 7 Child lock Lock Issue and report Boolean 9 UV light UV Issue and report Boolean 11 Filter reset FilterReset Issue and report Boolean 12 indoor temp Temp Only report Integer Values range:-20-50, Pitch1, Scale0, Unit:\u2103 13 Indoor humidity Humidity Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% Heater ~ DP ID Function points Identifier Data type Function type Properties 1 Switch Power Issue and report Boolean 2 Target temperature TempSet Issue and report Integer Values range:0-37, Pitch1, Scale0, Unit:\u2103 3 Current Temperature TempCurrent Only report Integer Values range:-9-99, Pitch1, Scale0, Unit:\u2103 4 Mode Mode Issue and report Enum Enumerated values:m, p 5 Fault alarm Fault Only report Fault Barrier values:1, 2, 3 6 Gear position gear Issue and report Enum Enumerated values:low, mid, high, off 7 Conservation eco_mode Issue and report Boolean Smart fan ~ DP ID Function points Identifier Data type Function type Properties 1 Switch switch Issue and report Boolean 2 Wind Speed Level fan_speed Issue and report Enum Enumerated values:1, 2, 3, 4 3 Left-and-Right Swing fan_horizontal Issue and report Enum Enumerated values:on, off 4 Up-and-Down Swing fan_vertical Issue and report Enum Enumerated values:on, off 5 Fault Alarm fault Only report Fault Barrier values:1, 2 6 Anion anion Issue and report Boolean 7 Humidify humidifier Issue and report Boolean 8 Oxygen oxygan Issue and report Boolean 9 Child Lock lock Issue and report Boolean 10 Cool fan_cool Issue and report Boolean 11 Set Temperate temp Issue and report Integer Values range:0-50, Pitch1, Scale0, Unit:\u2103 12 Current Temperature temp_current Only report Integer Values range:0-50, Pitch1, Scale0, Unit:\u2103 Kettle ~ DP ID Function points Identifier Data type Function type Properties 1 Working switch start Issue and report Boolean 2 Heat to target temperature shortcut (\u00b0C) temp_setting_quick_c Issue and report Enum Enumerated values:50, 65, 85, 90, 100 3 Heat to target temperature shortcut (\u00b0F) temp_setting_quick_f Issue and report Enum Enumerated values:122, 149, 185, 194, 212 4 Cool to the target temperature shortcut after boiling (\u00b0C) temp_boiling_quick_c Issue and report Enum Enumerated values:50, 65, 85, 90, 100 5 Cool to the target temperature shortcut after boiling (\u00b0F) temp_boiling_quick_f Issue and report Enum Enumerated values:122, 149, 185, 194, 212 6 Temperature scale switching temp_unit_convert Issue and report Enum Enumerated values:c, f 7 Insulation switch switch_keep_warm Issue and report Boolean 8 Holding time setting keep_warm_setting Issue and report Integer Values range:0-360, Pitch1, Scale0, Unit:min 9 Mode work_type Issue and report Enum Enumerated values: setting_quick, boiling_quick, temp_setting, temp_ BecaThermostat ~ Work in progress DP ID Function points Identifier Data type Function type Properties 1 Switch Power Issue and report Boolean 2 Target temperature TempSet Issue and report Integer Values range:0-37, Pitch1, Scale0, Unit:\u2103 3 Current Temperature TempCurrent Only report Integer Values range:-9-99, Pitch1, Scale0, Unit:\u2103 4 Mode Mode Issue and report Enum Enumerated values:m, p (wip) 102 Floor Temperature FloorCurrent Issue and report Integer Values range:0-37, Pitch1, Scale0, Unit:\u2103 Inkbird ITC-308-Wifi ~ Temperature controller with individual plug in sockets for heating/cooling DP ID Function points Identifier Data type Function type Properties 101 Temperature unit Cf Issue and report Integer 0=C, 1=F 102 Calibration Ca Issue and report Integer Unit is 0.1C 104 Temperature sensor Issue and report Integer Unit is 0.1C 106 Temperature set point Ts Issue and report Integer Unit is 0.1C 108 Compressor delay time Pt Issue and report Integer Unit is minutes 109 Alarm high temperature Ah Issue and report Integer Unit is 0.1C 110 Alarm low temperature Al Issue and report Integer Unit is 0.1C, For negative values use -(0xFFFFFFFF - value) 115 Relay status Only report Integer 01=cool, 02=off, 03=heating 116 Temperature sensor Issue and report Integer Unit is 0.1F 117 Heating differential value Hd Issue and report Integer Unit is 0.1C 118 Cooling differential value Cd Issue and report Integer Unit is 0.1C The unit will constantly be sending the temperature sensor value in celcius and fahrenheit: 104 and 116. To trigger the unit to send all settings, send any value to a non-used register, e.g. TuyaSend1 2,1 Example: Tasmota command Result TuyaSend1 2,1 Trigger the unit to reveal all settings TuyaSend2 106,250 Change set-point to 25.0C TuyaSend2 101,1 Change units to Fahrenheit Further Reading ~ TuyaMCU Flashing and Device Configuration","title":"TuyaMCU"},{"location":"TuyaMCU/#dpid","text":"All the device functions controlled by the MCU are identified by a dpId. Whenever a command is sent to the MCU, this dpId determines which component needs to be controlled and the applies when the status is received from MCU. There is no way to autodetect dpId's and their functions. To assist in the process of determining what dpId does what, there is a bookmarklet available that can be used on the console screen. This will send the weblog and other required commands automatically, and present the TuyaMCU information in a single table allowing for easier testing. Use this procedure to determine which dpId's are available: Go to Configure -> Console option in Tasmota web interface. Use command weblog 4 to enable verbose logging in web interface. Observe the log. After every 9-10 seconds you should see TYA messages. {\"TuyaReceived\":{\"Data\":\"55AA0107000501010001000F\",\"Cmnd\":7,\"CmndData\":\"0101000100\",\"DpType1Id1\":0,\"1\":{\"DpId\":1,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=11 is set for dpId=1 TYA: RX Relay-1 --> MCU State: Off Current State:Off {\"TuyaReceived\":{\"Data\":\"55AA01070005020100010010\",\"Cmnd\":7,\"CmndData\":\"0201000100\",\"DpType1Id2\":0,\"2\":{\"DpId\":2,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=0 is set for dpId=2 {\"TuyaReceived\":{\"Data\":\"55AA01070005030100010011\",\"Cmnd\":7,\"CmndData\":\"0301000100\",\"DpType1Id3\":0,\"3\":{\"DpId\":3,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=0 is set for dpId=3 {\"TuyaReceived\":{\"Data\":\"55AA01070005040100010012\",\"Cmnd\":7,\"CmndData\":\"0401000100\",\"DpType1Id4\":0,\"4\":{\"DpId\":4,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=0 is set for dpId=4 {\"TuyaReceived\":{\"Data\":\"55AA0107000807020004000000001C\",\"Cmnd\":7,\"CmndData\":\"0702000400000000\",\"DpType2Id7\":0,\"7\":{\"DpId\":7,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=7 {\"TuyaReceived\":{\"Data\":\"55AA0107000808020004000000001D\",\"Cmnd\":7,\"CmndData\":\"0802000400000000\",\"DpType2Id8\":0,\"8\":{\"DpId\":8,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=8 {\"TuyaReceived\":{\"Data\":\"55AA0107000809020004000000001E\",\"Cmnd\":7,\"CmndData\":\"0902000400000000\",\"DpType2Id9\":0,\"9\":{\"DpId\":9,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=9 {\"TuyaReceived\":{\"Data\":\"55AA010700080A020004000000001F\",\"Cmnd\":7,\"CmndData\":\"0A02000400000000\",\"DpType2Id10\":0,\"10\":{\"DpId\":10,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=10 {\"TuyaReceived\":{\"Data\":\"55AA0107000865020004000000007A\",\"Cmnd\":7,\"CmndData\":\"6502000400000000\",\"DpType2Id101\":0,\"101\":{\"DpId\":101,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=101 {\"TuyaReceived\":{\"Data\":\"55AA0107000866020004000000007B\",\"Cmnd\":7,\"CmndData\":\"6602000400000000\",\"DpType2Id102\":0,\"102\":{\"DpId\":102,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=102 {\"TuyaReceived\":{\"Data\":\"55AA0107000867020004000000007C\",\"Cmnd\":7,\"CmndData\":\"6702000400000000\",\"DpType2Id103\":0,\"103\":{\"DpId\":103,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=103 {\"TuyaReceived\":{\"Data\":\"55AA01070008680200040000099117\",\"Cmnd\":7,\"CmndData\":\"6802000400000991\",\"DpType2Id104\":2449,\"104\":{\"DpId\":104,\"DpIdType\":2,\"DpIdData\":\"00000991\"}}} TYA: fnId=0 is set for dpId=104 Observe all lines printed as TYA: FnId=0 is set for dpId=XXX and note all dpId values. Now that you have a list of usable dpId's you need to determine what their functions are: Consulting our list of commonly used dpId's and existing device configurations Observing Tasmota logs while activating features of the device (with a remote or on device controls) and correlating log messages and looking at the DpIdType and DpIdData values (eg: boolean vs value) Extrapolating possible function of the dpId based on Data Type and Function Command, then testing using TuyaSend<x>","title":"dpId"},{"location":"TuyaMCU/#fnid","text":"Identifier used in TuyaMCU command to map a dpId to a Tasmota component. Component FunctionId Note Switch1 to Switch4 1 to 4 Map only to dpId with on / off function Relay1 to Relay8 11 to 18 Map only to dpId with on / off function Lights 21 to 28 21 for Dimmer 22 for Dimmer2 23 for CCT Light 24 for RGB light 25 for white light 26 for light mode set (0 = white and 1 = color) 27 to report the state of Dimmer1 28 to report the state of Dimmer2 Power Monitoring 31 to 33 31 for Power (in deci Watt) 32 for Current (in milli Amps) 33 for Voltage (in deci Volt) Relay1i to Relay8i 41 to 48 Map only to dpId with on / off function Battery powered sensor mode 51 Battery powered devices use a slightly different protocol Fan control 61 to 64 61 for 3 speeds fan controller (possible values 0,1,2) 62 for 4 speeds fan controller (possible values 0,1,2,3) 63 for 5 speeds fan controller (possible values 0,1,2,3,4) 64 for 6 speeds fan controller (possible values 0,1,2,3,4,5) Extra functions 97 to 99 97 for motor direction 98 for error logging (report only) 99 as a dummy function Note This component is under active development which means the function list may expand in the future. Since the majority of devices have a power on/off functions on dpId 1 its mapped to fnId 11 (Relay1) by default. If you don't need it, map it to fnId 99 with TuyaMcu 99,1 Danger Mapping a relay or switch to a dpId that is not a simple on/off function (data Type 1) might result in unwanted power toggling (i.e. dpId sends value of 4 which toggles the relay to Power 4 aka blink mode)","title":"fnId"},{"location":"TuyaMCU/#tuyasend-command","text":"Command TuyaSend is used to send commands to dpId's. It is required for dpId's that shouldn't be mapped to a fnId. With this command it is possible to control every function of the dpId that is controllable, providing you know its data type and data length. With them provided, the rest of the protocol command is calculated. Command's value consists of two comma separated parameters: dpId and data. TuyaSend<x> dpId,data","title":"TuyaSend Command"},{"location":"TuyaMCU/#tuyareceived","text":"Every status message from the MCU gets a JSON response named TuyaReceived which contains the MCU protocol status message inside key/value pairs which are hidden from the user by default. To publish them to an MQTT Topic of tele/%topic%/RESULT you need to enable SetOption66 1 .","title":"TuyaReceived"},{"location":"TuyaMCU/#device-configurations","text":"Before proceeding identify dpId's and their function.","title":"Device Configurations"},{"location":"TuyaMCU/#dimmer","text":"We need to configure four functions of a dimmer: Dimming dpId Dimming Range Dimming less than 10%","title":"Dimmer"},{"location":"TuyaMCU/#dual-dimmer","text":"To enable a dual dimmer setup assign fnId's: 21 as Dimmer1 22 as Dimmer2 11 as Relay1 12 as Relay2 Tasmota will automatically enable SetOption68 and the dimmers will respond to Channel1 and Channel2 commands. Warning The use of SetOption68 is limited to two channels and will be automatically disabled if any other combination of lights is used.","title":"Dual Dimmer"},{"location":"TuyaMCU/#lights","text":"","title":"Lights"},{"location":"TuyaMCU/#enums","text":"Better control over Type4 or enum dpId's. Up to four can be added, with a range from 0 to 31. 61 as Enum1 62 as Enum2 63 as Enum3 64 as Enum4 After an enum is configured, use TuyaEnumList to declare the range it must respect (note 0 is always the first item in range). TuyaEnumlist <enum>,<range> where <enum> is declared using TuyaMCU and <range> is 0..31 . Example: configure Enum 1 with a range from 0 to 8. 21 : 14 : 52 CMD : tuyaenumlist 1 , 8 21 : 14 : 52 MQT : stat / TuyaMCU / RESULT = { \"TuyaEnumList\" :{ \"Enum1\" : 8 , \"Enum2\" : 9 , \"Enum4\" : 1 }} Entering a value greater than 31 will return an error TuyaEnumList without payload will return the configuration of all the enums enabled in the list. To update an enum use the command TuyaEnum : Usage TuyaEnum [1|2|3|4],[TuyaEnumList range] Example: update Enum 2 to 4. 21 : 14 : 12 CMD : tuyaenum2 4 21 : 14 : 12 MQT : stat / TuyaMCU / RESULT = { \"TuyaEnum2\" : 4 } ntering a value not in range will return an error TuyaEnum without payload will return the state of all the enums configured.","title":"Enums"},{"location":"TuyaMCU/#sensors","text":"These are the currently available sensors: 71 as Temperature Sensor 73 as Humidity Sensor 75 as Illuminance Sensor 76 as TVOC Sensor 77 as CO2 Sensor 78 as ECO2 Sensor If your device has a dpId for setting a specific Temperature and/or Humidity: 72 for Temperature Set 74 for Humidity Set Use TuyaSend2 to manage them. Temperature and Temperature Set default to \u00b0C . If you need \u00b0F change SetOption8 to 1 . Please note this will not update the value sent by the MCU but will just change the unit of measure reported on /SENSOR topic. You have to find a dpid to set the correct unit and change reported values (if it exists).","title":"Sensors"},{"location":"TuyaMCU/#timers","text":"4 Type2 (integer) timers can be managed directly from Tasmota 81 as Timer1 82 as Timer2 83 as Timer3 84 as Timer4 Timers can be managed with TuyaSend2 and are visible in the WebUI.","title":"Timers"},{"location":"TuyaMCU/#covers","text":"Single shutter or double shutters devices can be managed with a dimmer setup For devices that are reporting position to a another dpId assign fnId's: 27 to report the state of Dimmer1 28 to report the state of Dimmer2 If your cover device has a motor direction change option assign fnId 97 for motor direction.","title":"Covers"},{"location":"TuyaMCU/#switches","text":"There is currenty no way to detect the number of relays present in an MCU based switch. We need to tell the number of relays to Tasmota using FunctionIDs 12 to 18 for Relay2 to Relay4. Example For a 4 gang switch set TuyaMCU 12,2 , TuyaMCU 13,3 and TuyaMCU 14,4 if the dpIds for Relays 2-4 are 2 , 3 , 4 . Tip You can configure all at once by using Backlog TuyaMCU 12,2; TuyaMCU 13,3; TuyaMCU 14,4","title":"Switches"},{"location":"TuyaMCU/#power-metering","text":"Some Tuya MCU devices support Power measurement support over serial. For this it is better to use a bulb with known wattage rating. Observe the logs in the Console TYA : Heartbeat { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000501010001000F\" , \"Cmnd\" : 7 , \"CmndData\" : \"0101000100\" , \"DpType1Id1\" : 0 , \"1\" :{ \"DpId\" : 1 , \"DpIdType\" : 1 , \"DpIdData\" : \"00\" }}} TYA : fnId = 11 is set for dpId = 1 TYA : RX Relay - 1 --> MCU State : Off Current State : Off { \"TuyaReceived\" :{ \"Data\" : \"55AA01070005020100010111\" , \"Cmnd\" : 7 , \"CmndData\" : \"0201000101\" , \"DpType1Id2\" : 1 , \"2\" :{ \"DpId\" : 2 , \"DpIdType\" : 1 , \"DpIdData\" : \"01\" }}} TYA : fnId = 0 is set for dpId = 2 { \"TuyaReceived\" :{ \"Data\" : \"55AA01070005030100010011\" , \"Cmnd\" : 7 , \"CmndData\" : \"0301000100\" , \"DpType1Id3\" : 0 , \"3\" :{ \"DpId\" : 3 , \"DpIdType\" : 1 , \"DpIdData\" : \"00\" }}} TYA : fnId = 0 is set for dpId = 3 { \"TuyaReceived\" :{ \"Data\" : \"55AA01070005040100010113\" , \"Cmnd\" : 7 , \"CmndData\" : \"0401000101\" , \"DpType1Id4\" : 1 , \"4\" :{ \"DpId\" : 4 , \"DpIdType\" : 1 , \"DpIdData\" : \"01\" }}} TYA : fnId = 0 is set for dpId = 4 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000807020004000000001C\" , \"Cmnd\" : 7 , \"CmndData\" : \"0702000400000000\" , \"DpType2Id7\" : 0 , \"7\" :{ \"DpId\" : 7 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 7 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000808020004000000001D\" , \"Cmnd\" : 7 , \"CmndData\" : \"0802000400000000\" , \"DpType2Id8\" : 0 , \"8\" :{ \"DpId\" : 8 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 8 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000809020004000000001E\" , \"Cmnd\" : 7 , \"CmndData\" : \"0902000400000000\" , \"DpType2Id9\" : 0 , \"9\" :{ \"DpId\" : 9 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 9 { \"TuyaReceived\" :{ \"Data\" : \"55AA010700080A020004000000001F\" , \"Cmnd\" : 7 , \"CmndData\" : \"0A02000400000000\" , \"DpType2Id10\" : 0 , \"10\" :{ \"DpId\" : 10 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 10 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000865020004000000007A\" , \"Cmnd\" : 7 , \"CmndData\" : \"6502000400000000\" , \"DpType2Id101\" : 0 , \"101\" :{ \"DpId\" : 101 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 101 { \"TuyaReceived\" :{ \"Data\" : \"55AA01070008660200040000009813\" , \"Cmnd\" : 7 , \"CmndData\" : \"6602000400000098\" , \"DpType2Id102\" : 152 , \"102\" :{ \"DpId\" : 102 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000098\" }}} TYA : fnId = 0 is set for dpId = 102 { \"TuyaReceived\" :{ \"Data\" : \"55AA01070008670200040000017EFB\" , \"Cmnd\" : 7 , \"CmndData\" : \"670200040000017E\" , \"DpType2Id103\" : 382 , \"103\" :{ \"DpId\" : 103 , \"DpIdType\" : 2 , \"DpIdData\" : \"0000017E\" }}} TYA : fnId = 0 is set for dpId = 103 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000868020004000009951B\" , \"Cmnd\" : 7 , \"CmndData\" : \"6802000400000995\" , \"DpType2Id104\" : 2453 , \"104\" :{ \"DpId\" : 104 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000995\" }}} TYA : fnId = 0 is set for dpId = 104 In the TuyaReceived we are interested in DpIdData . For example: 00000995 is the second last entry. Make sure the bulb if off. Find out the voltage standard of your country (generally 220, 240, 120v) from this table . Multiply that number by 10 (2400) and Convert that number (2400) to Hex using any hex converter (2400 = 0x960) Now look for the number nearest to 960 in the logs. In our case it is 00000995 . So we expect that's the voltage which is \"DpId\":104 in our example. Set voltage functionId 33 by entering TuyaMCU 33,104 . Now set dimmer to 100% using the dimmer 100 command, or power on using power1 on (depending on the device) and observe the logs. Now we need the power rating of your bulb, for example 40W . Multiply by 10 (400) and convert to hex which gives us 0x190. Check which unknown ID is close to 190 . I this example it is 17E for \"DpId\":103 . This is the Id of Active Power function. Set the active power functionId 31 by entering TuyaMCU 31,103 . Once Power and Voltage are set you should see something such as this in the logs: TYA : Heartbeat { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000501010001000F\" , \"Cmnd\" : 7 , \"CmndData\" : \"0101000100\" , \"DpType1Id1\" : 0 , \"1\" :{ \"DpId\" : 1 , \"DpIdType\" : 1 , \"DpIdData\" : \"00\" }}} TYA : fnId = 11 is set for dpId = 1 TYA : RX Relay - 1 --> MCU State : Off Current State : Off { \"TuyaReceived\" :{ \"Data\" : \"55AA01070005020100010111\" , \"Cmnd\" : 7 , \"CmndData\" : \"0201000101\" , \"DpType1Id2\" : 1 , \"2\" :{ \"DpId\" : 2 , \"DpIdType\" : 1 , \"DpIdData\" : \"01\" }}} TYA : fnId = 0 is set for dpId = 2 { \"TuyaReceived\" :{ \"Data\" : \"55AA01070005030100010011\" , \"Cmnd\" : 7 , \"CmndData\" : \"0301000100\" , \"DpType1Id3\" : 0 , \"3\" :{ \"DpId\" : 3 , \"DpIdType\" : 1 , \"DpIdData\" : \"00\" }}} TYA : fnId = 0 is set for dpId = 3 { \"TuyaReceived\" :{ \"Data\" : \"55AA01070005040100010113\" , \"Cmnd\" : 7 , \"CmndData\" : \"0401000101\" , \"DpType1Id4\" : 1 , \"4\" :{ \"DpId\" : 4 , \"DpIdType\" : 1 , \"DpIdData\" : \"01\" }}} TYA : fnId = 0 is set for dpId = 4 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000807020004000000001C\" , \"Cmnd\" : 7 , \"CmndData\" : \"0702000400000000\" , \"DpType2Id7\" : 0 , \"7\" :{ \"DpId\" : 7 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 7 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000808020004000000001D\" , \"Cmnd\" : 7 , \"CmndData\" : \"0802000400000000\" , \"DpType2Id8\" : 0 , \"8\" :{ \"DpId\" : 8 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 8 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000809020004000000001E\" , \"Cmnd\" : 7 , \"CmndData\" : \"0902000400000000\" , \"DpType2Id9\" : 0 , \"9\" :{ \"DpId\" : 9 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 9 { \"TuyaReceived\" :{ \"Data\" : \"55AA010700080A020004000000001F\" , \"Cmnd\" : 7 , \"CmndData\" : \"0A02000400000000\" , \"DpType2Id10\" : 0 , \"10\" :{ \"DpId\" : 10 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 10 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000865020004000000007A\" , \"Cmnd\" : 7 , \"CmndData\" : \"6502000400000000\" , \"DpType2Id101\" : 0 , \"101\" :{ \"DpId\" : 101 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 101 { \"TuyaReceived\" :{ \"Data\" : \"55AA01070008660200040000009712\" , \"Cmnd\" : 7 , \"CmndData\" : \"6602000400000097\" , \"DpType2Id102\" : 151 , \"102\" :{ \"DpId\" : 102 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000097\" }}} TYA : fnId = 0 is set for dpId = 102 { \"TuyaReceived\" :{ \"Data\" : \"55AA01070008670200040000017BF8\" , \"Cmnd\" : 7 , \"CmndData\" : \"670200040000017B\" , \"DpType2Id103\" : 379 , \"103\" :{ \"DpId\" : 103 , \"DpIdType\" : 2 , \"DpIdData\" : \"0000017B\" }}} TYA : fnId = 31 is set for dpId = 103 TYA : Rx ID = 103 Active_Power = 379 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000868020004000009961C\" , \"Cmnd\" : 7 , \"CmndData\" : \"6802000400000996\" , \"DpType2Id104\" : 2454 , \"104\" :{ \"DpId\" : 104 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000996\" }}} TYA : fnId = 33 is set for dpId = 104 TYA : Rx ID = 104 Voltage = 2454 To get the Id for the current, calculate Current = Power / Voltage ( 37.9 / 245.4 ) = ~0.1544 (Remember to divide each value by 10). Multiply this by 1000 = 154. Now convert 154 to hex which is 0x9A. This is closest to 97 which is Id \"DpId\":102 . Set the current FunctionId 32 using command TuyaMCU 32,102 . Observe the logs should start showing Current in addition to Active_Power and Voltage TYA : Heartbeat { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000501010001000F\" , \"Cmnd\" : 7 , \"CmndData\" : \"0101000100\" , \"DpType1Id1\" : 0 , \"1\" :{ \"DpId\" : 1 , \"DpIdType\" : 1 , \"DpIdData\" : \"00\" }}} TYA : fnId = 11 is set for dpId = 1 TYA : RX Relay - 1 --> MCU State : Off Current State : Off { \"TuyaReceived\" :{ \"Data\" : \"55AA01070005020100010111\" , \"Cmnd\" : 7 , \"CmndData\" : \"0201000101\" , \"DpType1Id2\" : 1 , \"2\" :{ \"DpId\" : 2 , \"DpIdType\" : 1 , \"DpIdData\" : \"01\" }}} TYA : fnId = 0 is set for dpId = 2 { \"TuyaReceived\" :{ \"Data\" : \"55AA01070005030100010011\" , \"Cmnd\" : 7 , \"CmndData\" : \"0301000100\" , \"DpType1Id3\" : 0 , \"3\" :{ \"DpId\" : 3 , \"DpIdType\" : 1 , \"DpIdData\" : \"00\" }}} TYA : fnId = 0 is set for dpId = 3 { \"TuyaReceived\" :{ \"Data\" : \"55AA01070005040100010113\" , \"Cmnd\" : 7 , \"CmndData\" : \"0401000101\" , \"DpType1Id4\" : 1 , \"4\" :{ \"DpId\" : 4 , \"DpIdType\" : 1 , \"DpIdData\" : \"01\" }}} TYA : fnId = 0 is set for dpId = 4 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000807020004000000001C\" , \"Cmnd\" : 7 , \"CmndData\" : \"0702000400000000\" , \"DpType2Id7\" : 0 , \"7\" :{ \"DpId\" : 7 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 7 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000808020004000000001D\" , \"Cmnd\" : 7 , \"CmndData\" : \"0802000400000000\" , \"DpType2Id8\" : 0 , \"8\" :{ \"DpId\" : 8 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 8 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000809020004000000001E\" , \"Cmnd\" : 7 , \"CmndData\" : \"0902000400000000\" , \"DpType2Id9\" : 0 , \"9\" :{ \"DpId\" : 9 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 9 { \"TuyaReceived\" :{ \"Data\" : \"55AA010700080A020004000000001F\" , \"Cmnd\" : 7 , \"CmndData\" : \"0A02000400000000\" , \"DpType2Id10\" : 0 , \"10\" :{ \"DpId\" : 10 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 10 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000865020004000000007A\" , \"Cmnd\" : 7 , \"CmndData\" : \"6502000400000000\" , \"DpType2Id101\" : 0 , \"101\" :{ \"DpId\" : 101 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000000\" }}} TYA : fnId = 0 is set for dpId = 101 { \"TuyaReceived\" :{ \"Data\" : \"55AA01070008660200040000009712\" , \"Cmnd\" : 7 , \"CmndData\" : \"6602000400000097\" , \"DpType2Id102\" : 151 , \"102\" :{ \"DpId\" : 102 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000097\" }}} TYA : fnId = 32 is set for dpId = 102 TYA : Rx ID = 102 Current = 151 { \"TuyaReceived\" :{ \"Data\" : \"55AA01070008670200040000017BF8\" , \"Cmnd\" : 7 , \"CmndData\" : \"670200040000017B\" , \"DpType2Id103\" : 379 , \"103\" :{ \"DpId\" : 103 , \"DpIdType\" : 2 , \"DpIdData\" : \"0000017B\" }}} TYA : fnId = 31 is set for dpId = 103 TYA : Rx ID = 103 Active_Power = 379 { \"TuyaReceived\" :{ \"Data\" : \"55AA0107000868020004000009961C\" , \"Cmnd\" : 7 , \"CmndData\" : \"6802000400000996\" , \"DpType2Id104\" : 2454 , \"104\" :{ \"DpId\" : 104 , \"DpIdType\" : 2 , \"DpIdData\" : \"00000996\" }}} TYA : fnId = 33 is set for dpId = 104 TYA : Rx ID = 104 Voltage = 2454 Power and current should change on dimming high / low or turning the device on and off. The Tasmota web UI should show power values now on the home page.","title":"Power Metering"},{"location":"TuyaMCU/#battery-powered-sensors","text":"TYMC-1 Door/Window Sensor TY-01 Door/Window Sensor Gas Sensor Smoke Sensor PIR Sensor","title":"Battery Powered Sensors"},{"location":"TuyaMCU/#specific-devices","text":"Aromatherapy Diffuser Water Kettle Air Purifier Mouse Trap Humidifer","title":"Specific Devices"},{"location":"TuyaMCU/#tuya-protocols","text":"The MCU communicates with the Wi-Fi module through the serial port with a Tuya specified protocol. Those are classified into basic and functional protocols.","title":"Tuya Protocols"},{"location":"TuyaMCU/#basic-protocols","text":"They are common protocols integrated in Tasmota's TuyaMCU module. They stay the same for each product and are mandatory for Tuya module to work correctly.","title":"Basic protocols"},{"location":"TuyaMCU/#functional-protocols","text":"Functional protocols are used for delivering and reporting data of functions. These protocols differ between devices and manufacturers and might require configuration in Tasmota using TuyaMCU command or with TuyaSend<x> command.","title":"Functional protocols"},{"location":"TuyaMCU/#anatomy-of-tuya-protocol","text":"Name Description Frame Header Version Fixed value of 0x55aa Command Word 0x06 - send commands 0x07 - report status Data Length defines expected length of data dpID numbered ID of a function (DP = Data Point or Define Product) Data Type see Data Type table below Function Length length of command Function Command formatted according to Data Type Verification Method checksum = remainder of the byte sum starting from Frame Header to 256","title":"Anatomy of Tuya Protocol"},{"location":"TuyaMCU/#dpid-function-tables","text":"This information is just for orientation. Functions are assigned by the manufacturer and can be on different dpId's DP ID: dpId. Function Point\uff1aUsed to describe the product function. Identifier: Function codename. Can only be letters, numbers and underscores Data type\uff1a Issue and report: command data can be sent and status data can be reported back to the Wi-Fi module Report only: supports only status reporting, no control options Function Type (Referred as Data Type): Boolean (bool): non-true or false binary variable, such as: switch function, on / off Value (value): suitable for linear adjustment of the type of data, such as: temperature regulation, temperature range 20-40 \u2103 Enum (enum): custom finite set value, such as: working levels, low / mid / high Fault (fault): dedicated to reporting and statistical failure of the function points. Support multi-fault, the data is reported only Integer\uff08integer\uff09: transmitted as integer Transparent (raw): data in binary","title":"dpId Function Tables"},{"location":"TuyaMCU/#switches-or-plugspower-strips","text":"DP ID Identifier Data type Function type Properties 1 switch_1 Control and report Boolean 2 switch_2 Control and report Boolean 3 switch_3 Control and report Boolean 4 switch_4 Control and report Boolean 5 switch_5 Control and report Boolean 9 countdown_1 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 10 countdown_2 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 11 countdown_3 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 12 countdown_4 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 13 countdown_5 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s","title":"Switches or Plugs/Power Strips"},{"location":"TuyaMCU/#aromatherapy-machine-oil-diffuser","text":"DP ID Function points Identifier Data type Function type Properties 1 Switch Power Issue and report Boolean 6 Amount of fog fog Issue and report Enum Enumerated values:small, large 11 Light Light Issue and report Boolean 12 Fault alarm fault Only report Fault Barrier values:1 13 Countdown countdown Issue and report Enum Enumerated values: 0, 1, 2, 3 14 Countdown remaining time countdown_left Only report Integer Values range: 0-360, Pitch1, Scale0, Unit:min 101 Light mode work_mode Issue and report Enum Enumerated values: white, colour, scene, scene1, scene2, scene3, scene4 102 Color value colour_data Issue and report Char type *see below 103 Light mode lightmode Issue and report Enum Enumerated values: 1, 2, 3 104 Brightness setting setlight Issue and report Integer Values range: 0-255, Pitch1, Scale0, Unit:\\% colour_data format of the lights is a string of 14 characters, for example, 00112233334455, where 00 indicates R, 11 indicates G, 22 indicates B, 3333 indicates the hue, 44 indicates the saturation, and 55 indicates the value. The initial value is saved by default. If you do not want to adjust the light, set the data to the maximum value 100% (0x64). The last four characters have fixed values.","title":"Aromatherapy Machine (Oil Diffuser)"},{"location":"TuyaMCU/#curtain-motor","text":"DP ID Function points Identifier Data type Function type Properties 1 Percentage percent_state Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 2 Motor Direction control_back Issue and report Boolean 3 Auto Power auto_power Issue and report Boolean 4 Left time countdown Issue and report Enum Enumerated values:cancel, 1, 2, 3, 4 5 Total Time time_total Only report Integer Values range:0-120000, Pitch1, Scale0, Unit:m Complete document on protocols DP ID Function points Identifier Data type Function type Properties 1 Control (required) control Issue and report Enum Enumerated values:open, stop, close, continue 2 Curtain position setting percent_control Issue and report Integer Values range:0-100, Pitch1, Scale0, Unit:% 3 Current curtain position percent_state Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 4 Mode mode Issue and report Enum Enumerated values:morning, night 5 Motor Direction control_back Issue and report Enum Enumerated values:forward, back 6 Auto Power auto_power Issue and report Boolean 7 Work State (required) work_state Only report Enum Enumerated values:opening, closing 11 Situation_set situation_set Only report Enum Enumerated values:fully_open, fully_close 12 Fault (required) fault Only report Fault Barrier values:motor_fault","title":"Curtain Motor"},{"location":"TuyaMCU/#power-monitoring-plug","text":"DP ID Function points Identifier Data type Function type Properties 1 switch_1 switch_1 Control and report Boolean 9 countdown_1 countdown_1 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 17 statistics Function add_ele Control and report Integer undefined0-50000, undefined100, Scale3, Unit: 18 current cur_current Data report Integer undefined0-30000, undefined1, Scale0, Unit:mA 19 power cur_power Data report Integer undefined0-50000, undefined1, Scale1, Unit:W 20 voltage cur_voltage Data report Integer undefined0-5000, undefined1, Scale1, Unit:V 21 test flag test_bit Data report Integer undefined0-5, undefined1, Scale0, Unit: 22 voltage coefficient voltage_coe Data report Integer undefined0-1000000, undefined1, Scale0, Unit: 23 current coefficient electric_coe Data report Integer undefined0-1000000, undefined1, Scale0, Unit: 24 power coefficient power_coe Data report Integer undefined0-1000000, undefined1, Scale0, Unit: 25 statistics coefficient electricity_coe Data report Integer undefined0-1000000, undefined1, Scale0, Unit: 26 warning fault Data report Fault Barrier values:ov_cr","title":"Power Monitoring Plug"},{"location":"TuyaMCU/#dehumidifier","text":"DP ID Function points Identifier Data type Function type Properties 1 Switch Switch Issue and report Boolean 2 PM2.5 PM25 Only report Integer Values range:0-999, Pitch1, Scale0, Unit: 3 Work mode Mode Issue and report Enum Enumerated values:Manual, Auto, Sleep 4 Wind speed Speed Issue and report Enum Enumerated values:speed1, speed2, speed3, speed4, speed5 5 Filter usage Filter Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 6 Fresh Anion Issue and report Boolean 7 Child lock Lock Issue and report Boolean 9 UV light UV Issue and report Boolean 11 Filter reset FilterReset Issue and report Boolean 12 indoor temp Temp Only report Integer Values range:-20-50, Pitch1, Scale0, Unit:\u2103 13 Indoor humidity Humidity Only report Integer Values range:0-100, Pitch1, Scale0, Unit:%","title":"Dehumidifier"},{"location":"TuyaMCU/#lighting","text":"DP ID Function points Identifier Data type Function type Properties 1 Switch led_switch Control and report Boolean 2 Mode work_mode Control and report Enum Enumerated values:white, colour, scene, scene_1, scene_2, scene_3, scene_4 3 Bright bright_value Control and report Integer undefined25-255, undefined1, Scale0, Unit: 5 Colour mode colour_data Control and report Char type 6 Scene scene_data Control and report Char type 7 Scene1 flash_scene_1 Control and report Char type 8 Scene2 flash_scene_2 Control and report Char type 9 Scene3 flash_scene_3 Control and report Char type 10 Scene4 flash_scene_4 Control and report Char type","title":"Lighting"},{"location":"TuyaMCU/#contact-sensor","text":"DP ID Function points Identifier Data type Function type Properties 1 Door Sensor doorcontact_state Only report Boolean 2 Battery Level battery_percentage Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 3 Battery Level battery_state Only report Enum Enumerated values:low, middle, high 4 Anti-remove Alarm temper_alarm Only report Boolean","title":"Contact Sensor"},{"location":"TuyaMCU/#air-purifier","text":"DP ID Function points Identifier Data type Function type Properties 1 Switch Switch Issue and report Boolean 2 PM2.5 PM25 Only report Integer Values range:0-999, Pitch1, Scale0, Unit: 3 Work mode Mode Issue and report Enum Enumerated values:Manual, Auto, Sleep 4 Wind speed Speed Issue and report Enum Enumerated values:speed1, speed2, speed3, speed4, speed5 5 Filter usage Filter Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 6 Fresh Anion Issue and report Boolean 7 Child lock Lock Issue and report Boolean 9 UV light UV Issue and report Boolean 11 Filter reset FilterReset Issue and report Boolean 12 indoor temp Temp Only report Integer Values range:-20-50, Pitch1, Scale0, Unit:\u2103 13 Indoor humidity Humidity Only report Integer Values range:0-100, Pitch1, Scale0, Unit:%","title":"Air purifier"},{"location":"TuyaMCU/#heater","text":"DP ID Function points Identifier Data type Function type Properties 1 Switch Power Issue and report Boolean 2 Target temperature TempSet Issue and report Integer Values range:0-37, Pitch1, Scale0, Unit:\u2103 3 Current Temperature TempCurrent Only report Integer Values range:-9-99, Pitch1, Scale0, Unit:\u2103 4 Mode Mode Issue and report Enum Enumerated values:m, p 5 Fault alarm Fault Only report Fault Barrier values:1, 2, 3 6 Gear position gear Issue and report Enum Enumerated values:low, mid, high, off 7 Conservation eco_mode Issue and report Boolean","title":"Heater"},{"location":"TuyaMCU/#smart-fan","text":"DP ID Function points Identifier Data type Function type Properties 1 Switch switch Issue and report Boolean 2 Wind Speed Level fan_speed Issue and report Enum Enumerated values:1, 2, 3, 4 3 Left-and-Right Swing fan_horizontal Issue and report Enum Enumerated values:on, off 4 Up-and-Down Swing fan_vertical Issue and report Enum Enumerated values:on, off 5 Fault Alarm fault Only report Fault Barrier values:1, 2 6 Anion anion Issue and report Boolean 7 Humidify humidifier Issue and report Boolean 8 Oxygen oxygan Issue and report Boolean 9 Child Lock lock Issue and report Boolean 10 Cool fan_cool Issue and report Boolean 11 Set Temperate temp Issue and report Integer Values range:0-50, Pitch1, Scale0, Unit:\u2103 12 Current Temperature temp_current Only report Integer Values range:0-50, Pitch1, Scale0, Unit:\u2103","title":"Smart fan"},{"location":"TuyaMCU/#kettle","text":"DP ID Function points Identifier Data type Function type Properties 1 Working switch start Issue and report Boolean 2 Heat to target temperature shortcut (\u00b0C) temp_setting_quick_c Issue and report Enum Enumerated values:50, 65, 85, 90, 100 3 Heat to target temperature shortcut (\u00b0F) temp_setting_quick_f Issue and report Enum Enumerated values:122, 149, 185, 194, 212 4 Cool to the target temperature shortcut after boiling (\u00b0C) temp_boiling_quick_c Issue and report Enum Enumerated values:50, 65, 85, 90, 100 5 Cool to the target temperature shortcut after boiling (\u00b0F) temp_boiling_quick_f Issue and report Enum Enumerated values:122, 149, 185, 194, 212 6 Temperature scale switching temp_unit_convert Issue and report Enum Enumerated values:c, f 7 Insulation switch switch_keep_warm Issue and report Boolean 8 Holding time setting keep_warm_setting Issue and report Integer Values range:0-360, Pitch1, Scale0, Unit:min 9 Mode work_type Issue and report Enum Enumerated values: setting_quick, boiling_quick, temp_setting, temp_","title":"Kettle"},{"location":"TuyaMCU/#becathermostat","text":"Work in progress DP ID Function points Identifier Data type Function type Properties 1 Switch Power Issue and report Boolean 2 Target temperature TempSet Issue and report Integer Values range:0-37, Pitch1, Scale0, Unit:\u2103 3 Current Temperature TempCurrent Only report Integer Values range:-9-99, Pitch1, Scale0, Unit:\u2103 4 Mode Mode Issue and report Enum Enumerated values:m, p (wip) 102 Floor Temperature FloorCurrent Issue and report Integer Values range:0-37, Pitch1, Scale0, Unit:\u2103","title":"BecaThermostat"},{"location":"TuyaMCU/#inkbird-itc-308-wifi","text":"Temperature controller with individual plug in sockets for heating/cooling DP ID Function points Identifier Data type Function type Properties 101 Temperature unit Cf Issue and report Integer 0=C, 1=F 102 Calibration Ca Issue and report Integer Unit is 0.1C 104 Temperature sensor Issue and report Integer Unit is 0.1C 106 Temperature set point Ts Issue and report Integer Unit is 0.1C 108 Compressor delay time Pt Issue and report Integer Unit is minutes 109 Alarm high temperature Ah Issue and report Integer Unit is 0.1C 110 Alarm low temperature Al Issue and report Integer Unit is 0.1C, For negative values use -(0xFFFFFFFF - value) 115 Relay status Only report Integer 01=cool, 02=off, 03=heating 116 Temperature sensor Issue and report Integer Unit is 0.1F 117 Heating differential value Hd Issue and report Integer Unit is 0.1C 118 Cooling differential value Cd Issue and report Integer Unit is 0.1C The unit will constantly be sending the temperature sensor value in celcius and fahrenheit: 104 and 116. To trigger the unit to send all settings, send any value to a non-used register, e.g. TuyaSend1 2,1 Example: Tasmota command Result TuyaSend1 2,1 Trigger the unit to reveal all settings TuyaSend2 106,250 Change set-point to 25.0C TuyaSend2 101,1 Change units to Fahrenheit","title":"Inkbird ITC-308-Wifi"},{"location":"TuyaMCU/#further-reading","text":"TuyaMCU Flashing and Device Configuration","title":"Further Reading"},{"location":"Upgrade/","text":"","title":"Upgrade"},{"location":"Upgrading/","text":"Easily upgrade Tasmota to a newer version or different build while keeping all your settings The first rule of upgrading: If it ain't broke, don't fix it! In other words, ensure that there is a good reason to mess with a working installation (e.g., a need to use a new feature or address a found problem fixed in the current version). Backup before upgrading Any time you upgrade it is highly recommended to back up your device settings . That is easily done from the webUI using Configuration - Backup Config . If you wish to switch to a different build or use development branch you need to download a binary file (gzipped or regular) or change the OTA Url link. Download binaries from: GitHub releases official OTA Server development branch OTA Server your personal OTA server .gz binaries ~ Gzipped binaries can be used only once you've upgraded to atleast Tasmota 8.2 Trying to upgrade with a gzipped binary using versions older than 8.2 will fail. Tasmota 8.2 introduced upgrading using gzipped binaries which are smaller in size and will likely skip the intermediary minimal build installation. This makes the upgrade process faster and straightforward. To use simply add .gz to the existing OTA Url or download the .bin.gz binary from the official OTA Server and the next upgrade will use the compressed file. Upgrade Flow ~ v1.0.11 v3.9.22 v4.2.0 v5.14.0 v6.7.1 v7.2.0 v8.5.1 v9.1 Current release Follow the path strictly to ensure success. Do not install only tasmota-minimal.bin but upgrade to full, working firmware. Linked -lite.bin binaries will do the job. Tasmota v9.1 introduced a major change in GPIO mapping Downgrading is not recommended and will probably not work correctly. Tasmota v8.1 introduced a major change in parameter storage. Downgrading is not recommended and upgrading to 8.1 has to follow the recommended path and can still fail in some cases. Don't forget to backup! Upgrade using webUI ~ Upgrading the device firmware over-the-air , aka OTA, is the most convenient way to upgrade. To start the upgrade, open a web browser to your device's web UI and select Firmware Upgrade . You are presented with two choices: Upgrade by webserver - use an OTA server Ugprade by file upload - uploading a downloaded or self-compiled binary file from your computer Upgrade by web server ~ If you want to upgrade to the latest release version click the first Start Upgrade button. This screen should appear During this process Tasmota will download the new firmware from the url and install it. If you're not using a gzipped binary it might need to download tasmota-minimal.bin first, but all that happens automatically. All you have to do is wait 2 to 5 minutes . After the upgrade is completed you can reconnect back to the web UI and check the firmware version on the bottom of the page or in the Information tab of the webUI. Upgrade by file upload ~ Go to Firmware Upgrade . This time browse to the binary you want to upgrade to with Choose File and click Start upgrade . In our example its tasmota-sensors.bin . You will see an Upload starting... and then Upload successful message. Wait until the device restarts, reconnect back to the web UI and check the firmware version on the bottom of the page or in the Information tab of the webUI. Minimal build upgrade step If the binary you're upgrading with is larger than 500kb you also need to download the minimal build ( tasmota-minimal.bin(.gz) ) since the upload process needs the space in flash memory to upload the new binary. When you try to immediately upgrade with the new binary without using smaller minimal firmware you will be greeted with this error. Upload Buffer Miscompare Error ~ This step is necessary only if you get the \"Upload buffer miscompare\" error This means your flash doesn't have enough free space to install the binary you're trying to upload. Use a .gz binary instead of the .bin one. If you still receive the same error download tasmota-minimal.bin(.gz) and follow instructions: Browse to the minimal binary with Choose File . The chosen filename should be visible. In our example its tasmota-minimal.bin . Wait until the device restarts. In the Main Menu web UI will display this warning message on top. Proceed to upgrade Using Commands ~ Your device can be upgraded using commands via MQTT, web requests or Console in the web UI. OtaUrl is used to set your OTA address. OtaUrl http :// ota . tasmota . com / tasmota / tasmota - sensors . bin In this example we chose a development branch version with additional sensors support Initiate upgrade from OTA server Upgrade 1 Wait for the upgrade process to complete and check the Tasmota version. In console you can use Status 2 . Serial Upgrade ~ Upgrade over the serial connection using serial-to-USB adapter. Upload the new version over serial using the same process as in Flashing but DO NOT erase flash. The new binary will overwrite the old one and keep your settings. External Programs ~ Tasmota Device Manager or TDM is a multiplatform GUI application written in Python for discovery and management of Tasmota devices. You can set up OTA url and initiate OTA upgrade from TDM using GUI. openHAB - implement an automation rule to upgrade devices from openHAB Node-RED OTA server and firmware manager - Node-RED flow for managing OTA updates OTA over SCP - setup and configure \"OTA over SCP\" upload for PlatformIO Private OTA Server ~ It is possible to create your own simple http OTA server (https is not supported) using Python and perform upgrades from there. Install Python3 and from the folder where the binary resides (make sure tasmota-minimal.bin is located there too) run: python -m http.server 8000 (If the response is \"No module named http\" then try again with python3 instead of python .) Change your OtaUrl to http://ipoftheserver:8000/yourbinary.bin(.gz) and start the upgrade process. Note: do not use / , - , or . characters in the name of yourbinary . If your binary build (yourbinary.bin) is larger than the available free flash program space, Tasmota will need to first install the minimal version of Tasmota to make more space. To have this work via the web server OTA process, you have to copy the file tasmota-minimal.bin in the same folder where OTAURL for yourbinary.bin is placed, and rename tasmota-minimal.bin to yourbinary-minimal.bin . Migration Path ~ Until now several versions of Tasmota have been released starting with the C version Sonoff-MQTT-OTA followed by Sonoff-MQTT-OTA-Arduino, Sonoff-Tasmota and ultimately Tasmota. Intermediate upgrade steps are needed to migrate from older firmware to the current version. No migration is possible from original Sonoff-MQTT-OTA to Sonoff-MQTT-OTA-Arduino v1.0.11. DO NOT ATTEMPT TO UPGRADE VERSIONS PRIOR TO v7.x STRAIGHT TO THE CURRENT VERSION Remember that you must take each individual step between the device firmware version and the latest available.You can find all the required binaries in Tasmota Releases listed by version number. Tip As a safeguard perform \"Backup Configuration\" before upgrading. If settings are lost \"Restore Configuration\" should bring them back. Upgrading from one minor version to the next is mostly painless as the settings are saved in the same location in flash and newer settings are appended. As said, mostly painless! There are some deviations to this rule as the flash settings changed. Notice for versions between 6.6.0.7 and 6.6.0.11 If you've used development versions between 6.6.0.7 and 6.6.0.11 back up your device settings . Convert the backup to human readable form as you MUST restore these settings manually. Perform a Reset 6 before upgrading the firmware and, for safe measure, after the upgrade completes. Downgrading ~ While fallback or downgrading is common practice it was never supported due to Settings additions or changes in newer releases. Starting with release v8.1.0 Doris settings in flash are re-allocated in such a way that fallback is only allowed and possible to v7.2.0. Once at v7.2.0 you're on your own when downgrading even further. Backing Up Settings ~ Tasmota uses flash memory to store options and settings. New versions add (or remove) features that use various regions of that memory. If you did not erase flash when you flashed your device, an updated version of Tasmota may be accessing areas with values left over from the old Tasmota or even the original factory firmware. This might cause unexpected and unwanted behavior or even major problems (constant reboots or reconnects). To avoid this use our decode-config tool to easily create and restore backups in Tasmota: decode-config tool ~ decode-config - OS independent Python program to backup and restore Tasmota configuration data, also available as precompiled executables for Windows, MacOS and Linux. See Using instructions for details. If using one of the precompiled binary for your OS replace decode-config.py with decode-config_win32.exe , decode-config_win64.exe , decode-config_mac or decode-config_linux from the instruction examples. 1. make a configuration backup: Create a new backup straight from your device decode-config.py --source <deviceIP> --backup-file Config-@f @f will be replaced by decode-config to device's FriendlyName or Create a backup from previously made .dmp file decode-config.py --source <dmp_filename> --backup-file Config-@f 2. perform a device reset Erase flash settings area but keep Wi-Fi and MQTT settings Reset 6 3. upgrade the firmware via OTA or file upload 4. restore configuration decode-config.py --source <deviceIP> --restore-file <backupfile> ...and you're done! If you can't restore configuration directly you can configure the device manually referring to the Commands article and the settings (e.g., SetOptions, Rules, etc.) in the JSON file you created in step #1. You can paste the JSON into a JSON parser to make it easily readable. Tip If Backup Configuration -> Restore Configuration fails, reset to firmware defaults and use decode-config tool to restore your backed up configuration.","title":"Upgrading"},{"location":"Upgrading/#gz-binaries","text":"Gzipped binaries can be used only once you've upgraded to atleast Tasmota 8.2 Trying to upgrade with a gzipped binary using versions older than 8.2 will fail. Tasmota 8.2 introduced upgrading using gzipped binaries which are smaller in size and will likely skip the intermediary minimal build installation. This makes the upgrade process faster and straightforward. To use simply add .gz to the existing OTA Url or download the .bin.gz binary from the official OTA Server and the next upgrade will use the compressed file.","title":".gz binaries"},{"location":"Upgrading/#upgrade-flow","text":"v1.0.11 v3.9.22 v4.2.0 v5.14.0 v6.7.1 v7.2.0 v8.5.1 v9.1 Current release Follow the path strictly to ensure success. Do not install only tasmota-minimal.bin but upgrade to full, working firmware. Linked -lite.bin binaries will do the job. Tasmota v9.1 introduced a major change in GPIO mapping Downgrading is not recommended and will probably not work correctly. Tasmota v8.1 introduced a major change in parameter storage. Downgrading is not recommended and upgrading to 8.1 has to follow the recommended path and can still fail in some cases. Don't forget to backup!","title":"Upgrade Flow"},{"location":"Upgrading/#upgrade-using-webui","text":"Upgrading the device firmware over-the-air , aka OTA, is the most convenient way to upgrade. To start the upgrade, open a web browser to your device's web UI and select Firmware Upgrade . You are presented with two choices: Upgrade by webserver - use an OTA server Ugprade by file upload - uploading a downloaded or self-compiled binary file from your computer","title":"Upgrade using webUI"},{"location":"Upgrading/#upgrade-by-web-server","text":"If you want to upgrade to the latest release version click the first Start Upgrade button. This screen should appear During this process Tasmota will download the new firmware from the url and install it. If you're not using a gzipped binary it might need to download tasmota-minimal.bin first, but all that happens automatically. All you have to do is wait 2 to 5 minutes . After the upgrade is completed you can reconnect back to the web UI and check the firmware version on the bottom of the page or in the Information tab of the webUI.","title":"Upgrade by web server"},{"location":"Upgrading/#upgrade-by-file-upload","text":"Go to Firmware Upgrade . This time browse to the binary you want to upgrade to with Choose File and click Start upgrade . In our example its tasmota-sensors.bin . You will see an Upload starting... and then Upload successful message. Wait until the device restarts, reconnect back to the web UI and check the firmware version on the bottom of the page or in the Information tab of the webUI. Minimal build upgrade step If the binary you're upgrading with is larger than 500kb you also need to download the minimal build ( tasmota-minimal.bin(.gz) ) since the upload process needs the space in flash memory to upload the new binary. When you try to immediately upgrade with the new binary without using smaller minimal firmware you will be greeted with this error.","title":"Upgrade by file upload"},{"location":"Upgrading/#upload-buffer-miscompare-error","text":"This step is necessary only if you get the \"Upload buffer miscompare\" error This means your flash doesn't have enough free space to install the binary you're trying to upload. Use a .gz binary instead of the .bin one. If you still receive the same error download tasmota-minimal.bin(.gz) and follow instructions: Browse to the minimal binary with Choose File . The chosen filename should be visible. In our example its tasmota-minimal.bin . Wait until the device restarts. In the Main Menu web UI will display this warning message on top. Proceed to upgrade","title":"Upload Buffer Miscompare Error"},{"location":"Upgrading/#using-commands","text":"Your device can be upgraded using commands via MQTT, web requests or Console in the web UI. OtaUrl is used to set your OTA address. OtaUrl http :// ota . tasmota . com / tasmota / tasmota - sensors . bin In this example we chose a development branch version with additional sensors support Initiate upgrade from OTA server Upgrade 1 Wait for the upgrade process to complete and check the Tasmota version. In console you can use Status 2 .","title":"Using Commands"},{"location":"Upgrading/#serial-upgrade","text":"Upgrade over the serial connection using serial-to-USB adapter. Upload the new version over serial using the same process as in Flashing but DO NOT erase flash. The new binary will overwrite the old one and keep your settings.","title":"Serial Upgrade"},{"location":"Upgrading/#external-programs","text":"Tasmota Device Manager or TDM is a multiplatform GUI application written in Python for discovery and management of Tasmota devices. You can set up OTA url and initiate OTA upgrade from TDM using GUI. openHAB - implement an automation rule to upgrade devices from openHAB Node-RED OTA server and firmware manager - Node-RED flow for managing OTA updates OTA over SCP - setup and configure \"OTA over SCP\" upload for PlatformIO","title":"External Programs"},{"location":"Upgrading/#private-ota-server","text":"It is possible to create your own simple http OTA server (https is not supported) using Python and perform upgrades from there. Install Python3 and from the folder where the binary resides (make sure tasmota-minimal.bin is located there too) run: python -m http.server 8000 (If the response is \"No module named http\" then try again with python3 instead of python .) Change your OtaUrl to http://ipoftheserver:8000/yourbinary.bin(.gz) and start the upgrade process. Note: do not use / , - , or . characters in the name of yourbinary . If your binary build (yourbinary.bin) is larger than the available free flash program space, Tasmota will need to first install the minimal version of Tasmota to make more space. To have this work via the web server OTA process, you have to copy the file tasmota-minimal.bin in the same folder where OTAURL for yourbinary.bin is placed, and rename tasmota-minimal.bin to yourbinary-minimal.bin .","title":"Private OTA Server"},{"location":"Upgrading/#migration-path","text":"Until now several versions of Tasmota have been released starting with the C version Sonoff-MQTT-OTA followed by Sonoff-MQTT-OTA-Arduino, Sonoff-Tasmota and ultimately Tasmota. Intermediate upgrade steps are needed to migrate from older firmware to the current version. No migration is possible from original Sonoff-MQTT-OTA to Sonoff-MQTT-OTA-Arduino v1.0.11. DO NOT ATTEMPT TO UPGRADE VERSIONS PRIOR TO v7.x STRAIGHT TO THE CURRENT VERSION Remember that you must take each individual step between the device firmware version and the latest available.You can find all the required binaries in Tasmota Releases listed by version number. Tip As a safeguard perform \"Backup Configuration\" before upgrading. If settings are lost \"Restore Configuration\" should bring them back. Upgrading from one minor version to the next is mostly painless as the settings are saved in the same location in flash and newer settings are appended. As said, mostly painless! There are some deviations to this rule as the flash settings changed. Notice for versions between 6.6.0.7 and 6.6.0.11 If you've used development versions between 6.6.0.7 and 6.6.0.11 back up your device settings . Convert the backup to human readable form as you MUST restore these settings manually. Perform a Reset 6 before upgrading the firmware and, for safe measure, after the upgrade completes.","title":"Migration Path"},{"location":"Upgrading/#downgrading","text":"While fallback or downgrading is common practice it was never supported due to Settings additions or changes in newer releases. Starting with release v8.1.0 Doris settings in flash are re-allocated in such a way that fallback is only allowed and possible to v7.2.0. Once at v7.2.0 you're on your own when downgrading even further.","title":"Downgrading"},{"location":"Upgrading/#backing-up-settings","text":"Tasmota uses flash memory to store options and settings. New versions add (or remove) features that use various regions of that memory. If you did not erase flash when you flashed your device, an updated version of Tasmota may be accessing areas with values left over from the old Tasmota or even the original factory firmware. This might cause unexpected and unwanted behavior or even major problems (constant reboots or reconnects). To avoid this use our decode-config tool to easily create and restore backups in Tasmota:","title":"Backing Up Settings"},{"location":"Upgrading/#decode-config-tool","text":"decode-config - OS independent Python program to backup and restore Tasmota configuration data, also available as precompiled executables for Windows, MacOS and Linux. See Using instructions for details. If using one of the precompiled binary for your OS replace decode-config.py with decode-config_win32.exe , decode-config_win64.exe , decode-config_mac or decode-config_linux from the instruction examples.","title":"decode-config tool"},{"location":"User-created-templates/","text":"Follow this link to new templates repository .","title":"User created templates"},{"location":"VEML6070/","text":"VEML6070 UV light sensor ~ This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_VEML6070 #define USE_VEML6070 // Add I2C code for VEML6070 sensor (+0k5 code) #endif This little sensor is a great way to add UV light sensing to any microcontroller project. The VEML6070 from Vishay has a true UV A light sensor and an I 2 C-controlled ADC that will take readings and integrate them for you over ~60ms to 500ms.\" See VEML6070 UV Sensor for more information. Configuration ~ Wiring ~ VEML6070 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) Tasmota Main ~ After a reboot the driver will detect VEML6070 automatically and display UV light intensity. Breakout Boards ~","title":"VEML6070 UV light sensor"},{"location":"VEML6070/#veml6070-uv-light-sensor","text":"This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_VEML6070 #define USE_VEML6070 // Add I2C code for VEML6070 sensor (+0k5 code) #endif This little sensor is a great way to add UV light sensing to any microcontroller project. The VEML6070 from Vishay has a true UV A light sensor and an I 2 C-controlled ADC that will take readings and integrate them for you over ~60ms to 500ms.\" See VEML6070 UV Sensor for more information.","title":"VEML6070 UV light sensor"},{"location":"VEML6070/#configuration","text":"","title":"Configuration"},{"location":"VEML6070/#wiring","text":"VEML6070 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"VEML6070/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5)","title":"Tasmota Settings"},{"location":"VEML6070/#tasmota-main","text":"After a reboot the driver will detect VEML6070 automatically and display UV light intensity.","title":"Tasmota Main"},{"location":"VEML6070/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"VEML6075/","text":"VEML6075 UVA/UVB/UVINDEX Sensor ~ This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_VEML6075 #define USE_VEML6075 // Add I2C code for VEML6075 sensor #endif This little sensor is a great way to add UVA and UVB light sensing to any microcontroller project. The VEML6075 from Vishay has both true UVA and UVB band light sensors and an I2C-controlled ADC that will take readings and integrate them. The sensor also comes with calibration registers so you can easily convert the UVA/UVB readings into the UV Index. Configuration ~ Wiring ~ VEML6075 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) Commands and Use ~ Console Commands Description values VEML6075power Power on/off the modul 0/1 VEML6075inttime UV integration time (50ms, 100ms, 200ms, 400ms, 800ms) 0/1/2/3/4 VEML6075dynamic dynamic setting (low, high) 0/1 Tasmota Main ~ After a reboot the driver will detect VEML6075 automatically and display UVA/UVB/UVindex intensity. Breakout Boards ~","title":"VEML6075 UVA/UVB/UVINDEX Sensor"},{"location":"VEML6075/#veml6075-uvauvbuvindex-sensor","text":"This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_VEML6075 #define USE_VEML6075 // Add I2C code for VEML6075 sensor #endif This little sensor is a great way to add UVA and UVB light sensing to any microcontroller project. The VEML6075 from Vishay has both true UVA and UVB band light sensors and an I2C-controlled ADC that will take readings and integrate them. The sensor also comes with calibration registers so you can easily convert the UVA/UVB readings into the UV Index.","title":"VEML6075 UVA/UVB/UVINDEX Sensor"},{"location":"VEML6075/#configuration","text":"","title":"Configuration"},{"location":"VEML6075/#wiring","text":"VEML6075 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"VEML6075/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5)","title":"Tasmota Settings"},{"location":"VEML6075/#commands-and-use","text":"Console Commands Description values VEML6075power Power on/off the modul 0/1 VEML6075inttime UV integration time (50ms, 100ms, 200ms, 400ms, 800ms) 0/1/2/3/4 VEML6075dynamic dynamic setting (low, high) 0/1","title":"Commands and Use"},{"location":"VEML6075/#tasmota-main","text":"After a reboot the driver will detect VEML6075 automatically and display UVA/UVB/UVindex intensity.","title":"Tasmota Main"},{"location":"VEML6075/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"VEML7700/","text":"VEML7700 Ambient light sensor ~ This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_VEML7700 #define USE_VEML7700 // Add I2C code for VEML7700 sensor #endif VEML7700 is a high accuracy ambient light digital 16-bitresolution sensor in a miniature transparent 6.8 mm x2.35 mm x 3.0 mm package. It includes a high sensitivephoto diode, a low noise amplifier, a 16-bit A/D converterand supports an easy to use I2C bus communicationinterface.The ambient light result is as digital value available. Configuration ~ Wiring ~ VEML7700 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) Commands and Use ~ Console Commands Description values VEML7700power Power on/off the modul 0/1 VEML7700inttime integration time in ms 25, 50, 100, 200, 400, 800 VEML7700gain Gain Setting (x1, x2, x1/8, x1/4) 0 = x1 1 = x2 2 = x1/8 3 = x1/4 VEML7700persist ALS persistence protect number setting 0 = 1 1 = 2 2 = 4 3 = 8 With gain 1/8 and inttime 25 the Sensor goes up to 120.000 Lux if someone needed. Tasmota Main ~ After a reboot the driver will detect VEML7700 automatically and display light intensity. Breakout Boards ~","title":"VEML7700 Ambient light sensor"},{"location":"VEML7700/#veml7700-ambient-light-sensor","text":"This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_VEML7700 #define USE_VEML7700 // Add I2C code for VEML7700 sensor #endif VEML7700 is a high accuracy ambient light digital 16-bitresolution sensor in a miniature transparent 6.8 mm x2.35 mm x 3.0 mm package. It includes a high sensitivephoto diode, a low noise amplifier, a 16-bit A/D converterand supports an easy to use I2C bus communicationinterface.The ambient light result is as digital value available.","title":"VEML7700 Ambient light sensor"},{"location":"VEML7700/#configuration","text":"","title":"Configuration"},{"location":"VEML7700/#wiring","text":"VEML7700 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"VEML7700/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5)","title":"Tasmota Settings"},{"location":"VEML7700/#commands-and-use","text":"Console Commands Description values VEML7700power Power on/off the modul 0/1 VEML7700inttime integration time in ms 25, 50, 100, 200, 400, 800 VEML7700gain Gain Setting (x1, x2, x1/8, x1/4) 0 = x1 1 = x2 2 = x1/8 3 = x1/4 VEML7700persist ALS persistence protect number setting 0 = 1 1 = 2 2 = 4 3 = 8 With gain 1/8 and inttime 25 the Sensor goes up to 120.000 Lux if someone needed.","title":"Commands and Use"},{"location":"VEML7700/#tasmota-main","text":"After a reboot the driver will detect VEML7700 automatically and display light intensity.","title":"Tasmota Main"},{"location":"VEML7700/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"VL53L0x/","text":"VL53L0X laser ranging module ~ The VL53L0X is a Time-of-Flight (ToF) laser-ranging module. Configuration ~ Wiring ~ VL53L0x ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) After a reboot the driver will detect VL530L0x automatically and display Illuminance. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-12-20T11:29:22\" , \"VL53L0X\" :{ \"Distance\" : 263 }} Breakout Boards ~","title":"VL53L0X laser ranging module"},{"location":"VL53L0x/#vl53l0x-laser-ranging-module","text":"The VL53L0X is a Time-of-Flight (ToF) laser-ranging module.","title":"VL53L0X laser ranging module"},{"location":"VL53L0x/#configuration","text":"","title":"Configuration"},{"location":"VL53L0x/#wiring","text":"VL53L0x ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"VL53L0x/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) After a reboot the driver will detect VL530L0x automatically and display Illuminance. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-12-20T11:29:22\" , \"VL53L0X\" :{ \"Distance\" : 263 }}","title":"Tasmota Settings"},{"location":"VL53L0x/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"Visual-Studio-Code/","text":"How to setup and configure Visual Studio Code with PlatformIO for Tasmota compilation and upload. Easy way (only Windows): Portable install of Visual Studio Code for Tasmota ~ Download the ready made Portable Installation of VSC/PlatformIO and extract the ZIP to a folder or a fast extern drive. Grab the Tasmota compile package and extract it to the same destination. Start VS Code.exe (in folder VSC) Full Install (Windows, Linux and Mac) ~ Download and Install Visual Studio Code ~ Download Visual Studio Code (VSC) from https://code.visualstudio.com/ Install PlatformIO Extension ~ Install the PlatformIO IDE extension in VSC. Select View - Extensions and type PlatformIO in the search box. Make sure to select the official PlatformIO.org PlatformIO IDE extension and select Install . Accept to install dependencies. Download Tasmota ~ Download the latest Tasmota version from https://github.com/arendst/Tasmota and unzip to a known folder. Copy files ~ Copy all files from the Tasmota Source code into your VSC working folder. Compile Tasmota ~ Start VSC and select File - Open Folder... to point to the working folder. Note: Press Ctrl + Shift + P and type PlatformIO to see all options. Select the desired firmware by editing file platformio.ini as needed. Easy compilation can be performed from the icons at the bottom of the VSC screen. Upload Tasmota ~ Enable desired options in platformio.ini for serial upload like: ; *** Upload Serial reset method for Wemos and NodeMCU upload_port = COM5 ; upload_speed = 512000 upload_speed = 115200 ; upload_resetmethod = nodemcu Special options (not needed for compiling Tasmota!) are enabled in platformio_override.ini : ; *** Upload file to OTA server using HTTP upload_port = domus1 : 80 / api / upload - arduino . php extra_scripts = pio / http - uploader . py Easy compilation and upload can be performed from the icons at the bottom of the VSC screen or use Ctrl + Alt + U to upload (will build if needed). Hint: ~ In case vscode shows a huge amount of errors using PlatformIO - Intellisense a possible \"solution\" is to change the cpp-Intelli Sense Engine type to \"TAG PARSER\" This setting can be changed in workspace settings by: Use Ctrl + Shift + P and type Preferences: Open Workspace Settings and type intelli Sense in the search box. Now change the value for Intelli Sense Engine to Tag Parser .","title":"Visual Studio Code"},{"location":"Visual-Studio-Code/#easy-way-only-windows-portable-install-of-visual-studio-code-for-tasmota","text":"Download the ready made Portable Installation of VSC/PlatformIO and extract the ZIP to a folder or a fast extern drive. Grab the Tasmota compile package and extract it to the same destination. Start VS Code.exe (in folder VSC)","title":"Easy way (only Windows): Portable install of Visual Studio Code for Tasmota"},{"location":"Visual-Studio-Code/#full-install-windows-linux-and-mac","text":"","title":"Full Install (Windows, Linux and Mac)"},{"location":"Visual-Studio-Code/#download-and-install-visual-studio-code","text":"Download Visual Studio Code (VSC) from https://code.visualstudio.com/","title":"Download and Install Visual Studio Code"},{"location":"Visual-Studio-Code/#install-platformio-extension","text":"Install the PlatformIO IDE extension in VSC. Select View - Extensions and type PlatformIO in the search box. Make sure to select the official PlatformIO.org PlatformIO IDE extension and select Install . Accept to install dependencies.","title":"Install PlatformIO Extension"},{"location":"Visual-Studio-Code/#download-tasmota","text":"Download the latest Tasmota version from https://github.com/arendst/Tasmota and unzip to a known folder.","title":"Download Tasmota"},{"location":"Visual-Studio-Code/#copy-files","text":"Copy all files from the Tasmota Source code into your VSC working folder.","title":"Copy files"},{"location":"Visual-Studio-Code/#compile-tasmota","text":"Start VSC and select File - Open Folder... to point to the working folder. Note: Press Ctrl + Shift + P and type PlatformIO to see all options. Select the desired firmware by editing file platformio.ini as needed. Easy compilation can be performed from the icons at the bottom of the VSC screen.","title":"Compile Tasmota"},{"location":"Visual-Studio-Code/#upload-tasmota","text":"Enable desired options in platformio.ini for serial upload like: ; *** Upload Serial reset method for Wemos and NodeMCU upload_port = COM5 ; upload_speed = 512000 upload_speed = 115200 ; upload_resetmethod = nodemcu Special options (not needed for compiling Tasmota!) are enabled in platformio_override.ini : ; *** Upload file to OTA server using HTTP upload_port = domus1 : 80 / api / upload - arduino . php extra_scripts = pio / http - uploader . py Easy compilation and upload can be performed from the icons at the bottom of the VSC screen or use Ctrl + Alt + U to upload (will build if needed).","title":"Upload Tasmota"},{"location":"Visual-Studio-Code/#hint","text":"In case vscode shows a huge amount of errors using PlatformIO - Intellisense a possible \"solution\" is to change the cpp-Intelli Sense Engine type to \"TAG PARSER\" This setting can be changed in workspace settings by: Use Ctrl + Shift + P and type Preferences: Open Workspace Settings and type intelli Sense in the search box. Now change the value for Intelli Sense Engine to Tag Parser .","title":"Hint:"},{"location":"WS2812B-RGB-Shield/","text":"WS2812B RGB Shield (single pin) ~ From the Wemos ws2812b shield specs the DATA pin is connected to D2 of the Wemos. Tasmota Settings ~ In the Configuration -> Configure Module page, select the following: * D2 GPIO4 : 07 WS2812 Tasmota Main ~ After reboot of the device the dark-bright slider and toggle button are displayed to control the led.","title":"WS2812B RGB Shield"},{"location":"WS2812B-RGB-Shield/#ws2812b-rgb-shield-single-pin","text":"From the Wemos ws2812b shield specs the DATA pin is connected to D2 of the Wemos.","title":"WS2812B RGB Shield (single pin)"},{"location":"WS2812B-RGB-Shield/#tasmota-settings","text":"In the Configuration -> Configure Module page, select the following: * D2 GPIO4 : 07 WS2812","title":"Tasmota Settings"},{"location":"WS2812B-RGB-Shield/#tasmota-main","text":"After reboot of the device the dark-bright slider and toggle button are displayed to control the led.","title":"Tasmota Main"},{"location":"WS2812B-and-WS2813/","text":"WS2813B versus WS2812B ~ The newer version of ws2812b is the ws2813b, which has dual signal lines to prevent a led failure also consecutive leds fail. ESP8266 needs Level shifting - WS281x schematic ~ Below the schematics to connect a ESP82xx to a WS281x. About this circuit diagram and the oscilloscope traces ~ Channel 1 (yellow) is connected to an output of the ESP8266 Chip, and therefore shows the input voltage of the level shifting circuit. Channel 2 (green) is connected to the output of the level shifting circuit, and therefore shows the input voltage to the first WS281X pixel. How does the MOSFET circuit work and what are the challenges? When the GPIO is HIGH (3.3V), the voltage between Gate and Source of the FET is zero since the Gate is tied to +3.3V through R4 and the Source follows the GPIO. The FET is not conducting between its Source and Drain connections. In this state the Output is pulled to +5V by R5. (BTW: R4 is only there to charge/discharge the parasitic input capacitance of the FET and could be omitted entirely for an ideal FET.) When the GPIO goes low, it pulls the Source of the FET to GND (0V). That increases the voltage across Gate and Source of the FET (VGS) to 3.3V, causing the FET to become conductive between Source and Drain, and consequently pull the output to GND. The major flaw of this circuit is that its usefulness degrades towards higher frequencies (shorter pulses) and capacitive loads because the only force pulling the output to HIGH is the pull-up resistor R5. So the load capacitance gets charged through R5 only. You can mitigate the effect partially by selecting a smaller R5 but the tradeoff will be increased power consumption of the circuit. A WS2813 signal input imposes a capacitive load of 15 pF onto the level shifter\u2019s output according to its datasheet. That doesn\u2019t sound like a lot, but you can see from the plots that we have only few nanoseconds time to charge the parasitic capacitor. It also partially adds up with the reverse transfer capacitance of the BSS138 FET (Crss=6pF according to the datasheet). The result is clearly visible in the oscilloscope plot: the leading edges are not sharp and therefore reducing the pulse duration acquired by the pixel\u2019s input, depending on the input voltage threshold of the pixel (0.7 x VDD = 3.5V @ 5V according to the datasheet). The effect of sampled pulse shortening gets worse with rising input HIGH threshold of the pixel. NB: The design frequency of this circuit would be 1 / (433 ns x 2) = 1.155 MHz So what would be a better solution? Better Circuit: TTL logic gates We need a circuit with well-defined and matching input voltage thresholds. TTL gates represent such circuits. For a power supply of 5V, a TTL input is guaranteed logic LOW when the input voltage is below 0.8V. That same input is guaranteed logic HIGH when the input voltage is above 2.0V. That perfectly matches our 3.3V GPIO output voltage! The output weakness of the MOSFET circuit does not apply to a TTL gate\u2019s output since it can drive to HIGH as well as to LOW by means of a circuit known as \u201cTotem Pole\u201d push-pull transistor output stage. 74HCT and 74AHCT chips will drive the output to a voltage close to VCC. This output stage gives much sharper leading edges as can be seen on the lower right oscilloscope picture. So this is actually the circuit I would suggest for the application. A large variety of TTL chips can be used: 74HCTXX series, 74AHCTXX series, but not 74HC or 74AHC! Which logic function you choose is up to your liking and availability in your parts bin. The input characteristics are the same for all of them (with a slight deviation for those with Schmitt trigger inputs like the 74XX14). 5V power supply: the power of the power supply depends on the number of leds. A pixel has 3 leds (RGB), each led drains a max of 20mA, so a pixel drains a max of 60mA (3 * 20mA). So the total current that the power supply must deliver is 60mA times the number of pixels. For example 80 pixels: 60mA * 80 = 4800mA = 4.8A. Also the ESP8266 is powered by the power supply so in this example a power supply of 6A (30W) will do. note: connect the ledstrip from both sides to the power supply Tasmota Configuration ~ In the Configuration -> Configure Module page, select the following: D1 GPIO5 : WS2812 Tasmota Main ~","title":"WS2812B and WS2813"},{"location":"WS2812B-and-WS2813/#ws2813b-versus-ws2812b","text":"The newer version of ws2812b is the ws2813b, which has dual signal lines to prevent a led failure also consecutive leds fail.","title":"WS2813B versus WS2812B"},{"location":"WS2812B-and-WS2813/#esp8266-needs-level-shifting-ws281x-schematic","text":"Below the schematics to connect a ESP82xx to a WS281x.","title":"ESP8266 needs Level shifting - WS281x schematic"},{"location":"WS2812B-and-WS2813/#about-this-circuit-diagram-and-the-oscilloscope-traces","text":"Channel 1 (yellow) is connected to an output of the ESP8266 Chip, and therefore shows the input voltage of the level shifting circuit. Channel 2 (green) is connected to the output of the level shifting circuit, and therefore shows the input voltage to the first WS281X pixel. How does the MOSFET circuit work and what are the challenges? When the GPIO is HIGH (3.3V), the voltage between Gate and Source of the FET is zero since the Gate is tied to +3.3V through R4 and the Source follows the GPIO. The FET is not conducting between its Source and Drain connections. In this state the Output is pulled to +5V by R5. (BTW: R4 is only there to charge/discharge the parasitic input capacitance of the FET and could be omitted entirely for an ideal FET.) When the GPIO goes low, it pulls the Source of the FET to GND (0V). That increases the voltage across Gate and Source of the FET (VGS) to 3.3V, causing the FET to become conductive between Source and Drain, and consequently pull the output to GND. The major flaw of this circuit is that its usefulness degrades towards higher frequencies (shorter pulses) and capacitive loads because the only force pulling the output to HIGH is the pull-up resistor R5. So the load capacitance gets charged through R5 only. You can mitigate the effect partially by selecting a smaller R5 but the tradeoff will be increased power consumption of the circuit. A WS2813 signal input imposes a capacitive load of 15 pF onto the level shifter\u2019s output according to its datasheet. That doesn\u2019t sound like a lot, but you can see from the plots that we have only few nanoseconds time to charge the parasitic capacitor. It also partially adds up with the reverse transfer capacitance of the BSS138 FET (Crss=6pF according to the datasheet). The result is clearly visible in the oscilloscope plot: the leading edges are not sharp and therefore reducing the pulse duration acquired by the pixel\u2019s input, depending on the input voltage threshold of the pixel (0.7 x VDD = 3.5V @ 5V according to the datasheet). The effect of sampled pulse shortening gets worse with rising input HIGH threshold of the pixel. NB: The design frequency of this circuit would be 1 / (433 ns x 2) = 1.155 MHz So what would be a better solution? Better Circuit: TTL logic gates We need a circuit with well-defined and matching input voltage thresholds. TTL gates represent such circuits. For a power supply of 5V, a TTL input is guaranteed logic LOW when the input voltage is below 0.8V. That same input is guaranteed logic HIGH when the input voltage is above 2.0V. That perfectly matches our 3.3V GPIO output voltage! The output weakness of the MOSFET circuit does not apply to a TTL gate\u2019s output since it can drive to HIGH as well as to LOW by means of a circuit known as \u201cTotem Pole\u201d push-pull transistor output stage. 74HCT and 74AHCT chips will drive the output to a voltage close to VCC. This output stage gives much sharper leading edges as can be seen on the lower right oscilloscope picture. So this is actually the circuit I would suggest for the application. A large variety of TTL chips can be used: 74HCTXX series, 74AHCTXX series, but not 74HC or 74AHC! Which logic function you choose is up to your liking and availability in your parts bin. The input characteristics are the same for all of them (with a slight deviation for those with Schmitt trigger inputs like the 74XX14). 5V power supply: the power of the power supply depends on the number of leds. A pixel has 3 leds (RGB), each led drains a max of 20mA, so a pixel drains a max of 60mA (3 * 20mA). So the total current that the power supply must deliver is 60mA times the number of pixels. For example 80 pixels: 60mA * 80 = 4800mA = 4.8A. Also the ESP8266 is powered by the power supply so in this example a power supply of 6A (30W) will do. note: connect the ledstrip from both sides to the power supply","title":"About this circuit diagram and the oscilloscope traces"},{"location":"WS2812B-and-WS2813/#tasmota-configuration","text":"In the Configuration -> Configure Module page, select the following: D1 GPIO5 : WS2812","title":"Tasmota Configuration"},{"location":"WS2812B-and-WS2813/#tasmota-main","text":"","title":"Tasmota Main"},{"location":"WebUI/","text":"Tasmota's web user interface is a practical way to control and manage your tasmotized device. Warning WebUI does not and can not have all the features and commands implemented. For precise and complete control use Console or MQTT commands! To access the webUI use your device's IP address in your favorite web browser. By default, webUI starts in unprotected admin mode which allows complete access to your device to anyone with access to that IP. If you want to restrict other users to only control through the webUI, use WebServer 1 . Command WebPassword will set up a password that needs to be entered when trying to access webUI. This is a very thin layer of protection since everything is transmitted over unencrypted http protocol. Menus ~ Configuration Configuration menu allows you to configure everything from components to Wi-Fi and gives you the option to backup and restore the configuration in a secure location. Information Displays a single page loaded with information about the device including: current Tasmota version, Wi-Fi AP data, MQTT host data and more Firmware Upgrade An easy to use menu to initiate a firmware upgrade from an uploaded .bin or an OTA server. Console Terminal access to Tasmota. Issue commands here or follow the information stream. Useful for debugging when using \u02d9Weblog 4` . Customizing ~ WebButton ~ Change names of the toggle buttons using WebButton . Themes ~ WebUI is themable using WebColor commands. To apply the theme copy the entire code block and send it in console or via MQTT. Dark (default theme) WebColor { \"WebColor\" : [ \"#eaeaea\" , \"#252525\" , \"#4f4f4f\" , \"#000000\" , \"#dddddd\" , \"#65c115\" , \"#1f1f1f\" , \"#ff5661\" , \"#008000\" , \"#faffff\" , \"#1fa3ec\" , \"#0e70a4\" , \"#d43535\" , \"#931f1f\" , \"#47c266\" , \"#5aaf6f\" , \"#faffff\" , \"#999999\" , \"#eaeaea\" ]} Light (default until 6.7.1.) WebColor { \"WebColor\" : [ \"#000000\" , \"#ffffff\" , \"#f2f2f2\" , \"#000000\" , \"#ffffff\" , \"#000000\" , \"#ffffff\" , \"#ff0000\" , \"#008000\" , \"#ffffff\" , \"#1fa3ec\" , \"#0e70a4\" , \"#d43535\" , \"#931f1f\" , \"#47c266\" , \"#5aaf6f\" , \"#ffffff\" , \"#999999\" , \"#000000\" ]} Halloween WebColor { \"WebColor\" : [ \"#cccccc\" , \"#2f3133\" , \"#3d3f41\" , \"#dddddd\" , \"#293134\" , \"#ffb000\" , \"#293134\" , \"#ff5661\" , \"#008000\" , \"#ffffff\" , \"#ec7600\" , \"#bf5f00\" , \"#d43535\" , \"#931f1f\" , \"#47c266\" , \"#5aaf6f\" , \"#ffffff\" , \"#999999\" , \"#bc4d90\" ]} Navy WebColor { \"WebColor\" : [ \"#e0e0c0\" , \"#000033\" , \"#4f4f4f\" , \"#000000\" , \"#dddddd\" , \"#a7f432\" , \"#1e1e1e\" , \"#ff0000\" , \"#008000\" , \"#ffffff\" , \"#1fa3ec\" , \"#0e70a4\" , \"#d43535\" , \"#931f1f\" , \"#47c266\" , \"#5aaf6f\" , \"#ffffff\" , \"#999999\" , \"#eedd77\" ]} Purple Rain WebColor { \"WebColor\" : [ \"#eaeaea\" , \"#252525\" , \"#282531\" , \"#eaeaea\" , \"#282531\" , \"#d7ccff\" , \"#1d1b26\" , \"#ff5661\" , \"#008000\" , \"#faffff\" , \"#694fa8\" , \"#4d3e7f\" , \"#b73d5d\" , \"#822c43\" , \"#1f917c\" , \"#156353\" , \"#faffff\" , \"#716b7f\" , \"#eaeaea\" ]} Tip When using an MQTT client such as mosquitto_pub , enclose the message payload in single quotes ( ' ) mosquitto_pub -h 192.168.1.20 -t \"cmnd/myTopic/WebColor\" -m '{\"WebColor\":[\"#eaeaea\",\"#252525\",\"#4f4f4f\",\"#000000\",\"#dddddd\",\"#65c115\",\"#1f1f1f\",\"#ff5661\",\"#008000\",\"#faffff\",\"#1fa3ec\",\"#0e70a4\",\"#d43535\",\"#931f1f\",\"#47c266\",\"#5aaf6f\",\"#faffff\",\"#999999\",\"#eaeaea\"]}'","title":"WebUI"},{"location":"WebUI/#menus","text":"","title":"Menus"},{"location":"WebUI/#customizing","text":"","title":"Customizing"},{"location":"WebUI/#webbutton","text":"Change names of the toggle buttons using WebButton .","title":"WebButton"},{"location":"WebUI/#themes","text":"WebUI is themable using WebColor commands. To apply the theme copy the entire code block and send it in console or via MQTT.","title":"Themes"},{"location":"White-Blend-Mode/","text":"White Blend Mode for lights ~ White Blend Mode is used for 4 channel (RGBW) and 5 channel (RGBWC) devices. It is enabled by setting the last PWM channel to zero (e.g., RGBWWTable 255,255,255,<n>,0 ) to lower the white channel intensity. Generally, white LEDs are brighter than RGB LEDs. If you want to keep the same brightness, you need to calibrate the white level. In this mode, any white component will be removed from RGB LEDs and sent to the white LEDs. This makes whites look much better. Example: Color 30508000 will be converted to Color 0020503000 (0x30 is subtracted from R,G,B channels and added to the White channel) To calibrate: Color FFFFFF00 RGBWWTable 255,255,255,255,255 - reset to RGB mode RGBWWTable 255,255,255,<n>,0 (begin the calibration process with <n> == 150) If too bright, decrease <n> . If too dim, increase <n> Go back to step 2 and iterate until satisfied with the color intensities. Examples: * Sonoff B1: RGBWWTable 255,255,255,35,0 * Teckin SB50: RGBWWTable 255,255,255,80,0","title":"White Blend Mode for lights"},{"location":"White-Blend-Mode/#white-blend-mode-for-lights","text":"White Blend Mode is used for 4 channel (RGBW) and 5 channel (RGBWC) devices. It is enabled by setting the last PWM channel to zero (e.g., RGBWWTable 255,255,255,<n>,0 ) to lower the white channel intensity. Generally, white LEDs are brighter than RGB LEDs. If you want to keep the same brightness, you need to calibrate the white level. In this mode, any white component will be removed from RGB LEDs and sent to the white LEDs. This makes whites look much better. Example: Color 30508000 will be converted to Color 0020503000 (0x30 is subtracted from R,G,B channels and added to the White channel) To calibrate: Color FFFFFF00 RGBWWTable 255,255,255,255,255 - reset to RGB mode RGBWWTable 255,255,255,<n>,0 (begin the calibration process with <n> == 150) If too bright, decrease <n> . If too dim, increase <n> Go back to step 2 and iterate until satisfied with the color intensities. Examples: * Sonoff B1: RGBWWTable 255,255,255,35,0 * Teckin SB50: RGBWWTable 255,255,255,80,0","title":"White Blend Mode for lights"},{"location":"WifiPower/","text":"WifiPower Command ~ WifiPower allows you to fine tune the Wi-Fi transmission power level. The default is 17dBm which should be enough power for the device to transmit to the Wi-Fi access point (AP) in a normal network environment use case. Changing this setting will impact the Wi-Fi range of the device. The general rule of thumb is for every 3dBm change up or down will double or halve the range, respectively. However, this is largely dependent on the Wi-Fi router's capabilities. Use the RSSI signal level reported by the router for a particular Tasmota device to adjust the power level of a device. Lower the value incrementally until you achieve a balance between connection stability and energy saving. In some cases a device may require slightly more power to maintain a stable connection to the Wi-Fi network. In this case, increment the value in 1 dBm increments until stable connectivity is observed. Do not exceed 17dBm! Exceeding the default 17dBm transmit power setting may cause unreliable device operation. Most devices have been designed with the 17dBm theoretical power setting and may not have the ability to dissipate the additional heat generated. Setting the transmit power too high may cause interference in the device antenna causing Wi-Fi reception problems. This setting will not affect the signal level received from the AP (i.e., the RSSI reading that Tasmota reports). Improper setting of this parameter may cause operational instability and can generate exceptions. Increasing WifiPower puts additional demand on the device electrical power supply. Exceeding the capabilities of the power supply can cause other erratic device behaviors. Of course, the opposite may be the case when reducing transmit power levels allowing a device with a borderline power regulator to operate reliably. You should perform substantial testing and monitoring to find the sweet spot for WifiPower .","title":"WifiPower Command"},{"location":"WifiPower/#wifipower-command","text":"WifiPower allows you to fine tune the Wi-Fi transmission power level. The default is 17dBm which should be enough power for the device to transmit to the Wi-Fi access point (AP) in a normal network environment use case. Changing this setting will impact the Wi-Fi range of the device. The general rule of thumb is for every 3dBm change up or down will double or halve the range, respectively. However, this is largely dependent on the Wi-Fi router's capabilities. Use the RSSI signal level reported by the router for a particular Tasmota device to adjust the power level of a device. Lower the value incrementally until you achieve a balance between connection stability and energy saving. In some cases a device may require slightly more power to maintain a stable connection to the Wi-Fi network. In this case, increment the value in 1 dBm increments until stable connectivity is observed. Do not exceed 17dBm! Exceeding the default 17dBm transmit power setting may cause unreliable device operation. Most devices have been designed with the 17dBm theoretical power setting and may not have the ability to dissipate the additional heat generated. Setting the transmit power too high may cause interference in the device antenna causing Wi-Fi reception problems. This setting will not affect the signal level received from the AP (i.e., the RSSI reading that Tasmota reports). Improper setting of this parameter may cause operational instability and can generate exceptions. Increasing WifiPower puts additional demand on the device electrical power supply. Exceeding the capabilities of the power supply can cause other erratic device behaviors. Of course, the opposite may be the case when reducing transmit power levels allowing a device with a borderline power regulator to operate reliably. You should perform substantial testing and monitoring to find the sweet spot for WifiPower .","title":"WifiPower Command"},{"location":"Zigbee-CCLib-Flashing/","text":"Flash using CClib ~ To simplify this procedure, a ready to use fork of the needed firmware files is available. Flash CCLib on an ESP82xx Device ~ Flashing the CC2530 normally requires a CC_DEBUGGER . Using an ESP82xx device like a Wemos D1 Mini is a lower cost alternative. If you are using a Wemos D1 Mini or NodeMCU, just plug the microUSB port. Vcc (3.3V), GND, Tx (GPIO1), and Rx (GPIO3) are connected via the microUSB port. Be sure that you are using a USB data cable. For ESP devices that do not have a microUSB connector, make the following connections: ESP Device Serial Programming Adapter Vcc Vcc GND GND GPIO0 GND GPIO1 Rx GPIO3 Tx Follow the usual ESP82xx flashing process - you are just using CCLib_proxy.ino.bin instead of Tasmota. Once the firmware upload completes, retain the serial interface connections (3.3V, GND, Tx, Rx). These will be used later for flashing the CC2530. C. Flash a DL-20 Zigbee module The DL-20 Zigbee module has a 5-pin 1.27mm pitch unpopulated header with 0.6mm througholes. For flashing any of the Zigbee modules, you need the following connections: ESP Pin D1 Mini NodeMCU CC2530 Pin DL-20 J2 Pin Location GPIO12 D6 CC_DD (A.K.A. P2_1 ('P21') or Debug Data) 5 GPIO4 D2 CC_DC (A.K.A. P2_2 ('P22') or Debug Clock) 4 Vcc 3.3v Vcc 3 GPIO5 D1 CC_RST 2 GND GND GND 1 DL-20 Flashing Jumpers Insert alternating male Dupont jumpers; one jumper on one side, the next one on other side. This allows the pins to provide the friction themselves to maintain contact and remain firmly in place. You only need DD, DC, and RST (a fourth jumper is shown which is used to keep the RST jumper in place). Vcc and GND are available on the main serial interface pins. D. Upload the firmware to the CC2530 The CC2530 requires Z-Stack_Home_1.2 , of type Default (not Source Routing ). For convenience, ready to use firmware files are provided. Select the right one for your hardware: CC2530 , CC2530 + CC2591 or CC2530 + CC2592 . These Python scripts require Python 2.7. 1) Ensure that you have Python 2.7 installed 2) Install pyserial 3.0.1: pip install pyserial==3.0.1 3) Check for connectivity before flashing: python Python/cc_info.py -p <serial_port> where <serial_port> is the serial port for the ESP82xx device. e.g. /dev/cu.usbserial-xxxx or COM7 Example of result: INFO : Found a CC2530 chip on / dev / cu . usbserial - xxxx Chip information : Chip ID : 0xa524 Flash size : 16 Kb Page size : 2 Kb SRAM size : 1 Kb USB : No Device information : IEEE Address : 000000000000 PC : 0000 Debug status : [ ] CHIP_ERASE_BUSY [ ] PCON_IDLE [ X ] CPU_HALTED [ ] PM_ACTIVE [ ] HALT_STATUS [ X ] DEBUG_LOCKED [ X ] OSCILLATOR_STABLE [ ] STACK_OVERFLOW Debug config : [ ] SOFT_POWER_MODE [ ] TIMERS_OFF [ ] DMA_PAUSE [ ] TIMER_SUSPEND If your CC2530 is DEBUG_LOCKED, then the flash size will be incorrectly reported as 16kB. Dont worry flashing the Z-Stack firmware will work and reset the DEBUG_LOCKED bit. In some situation flashing fails with a error message flash have not enough space . If this happens do the following: python Python/cc_read_flash.py -p <serial_port> -o x.hex python Python/cc_write_flash.py --erase -p <serial_port> -i x.hex Recheck for connectivity and the correct flash size by repeating step #3. 4) Flash the Z-Stack firmware using the following command: Flashing the CC2530 takes about 20 minutes python Python/cc_write_flash.py -e -p <serial_port> -i Bin/CC2530_DEFAULT_20190608_CC2530ZNP-Prod.hex INFO : Found a CC2530 chip on /dev/ cu . usbserial - xxxx Chip information : Chip ID : 0xa524 Flash size : 256 Kb Page size : 2 Kb SRAM size : 8 Kb USB : No Sections in Bin / CC2530_DEFAULT_20190608_CC2530ZNP - Prod . hex : Addr . Size -------- ------------- 0x0000 8176 B 0x1ff6 10 B 0x3fff0 1 B 0x2000 239616 B This is going to ERASE and REPROGRAM the chip . Are you sure ? < y / N >: y Flashing : - Chip erase ... - Flashing 4 memory blocks ... -> 0x0000 : 8176 bytes Progress 100 %... OK -> 0x1ff6 : 10 bytes Progress 100 %... OK -> 0x3fff0 : 1 bytes Progress 100 %... OK -> 0x2000 : 239616 bytes Progress 100 %... OK Completed If you don't see any on screen activity that flashing has begun (i.e., progress percentages increasing) within a couple minutes, then abort the command, cycle power on the ESP82xx, and start this step over. Described in greater detail in this blog post .","title":"Zigbee CCLib Flashing"},{"location":"Zigbee-CCLib-Flashing/#flash-using-cclib","text":"To simplify this procedure, a ready to use fork of the needed firmware files is available.","title":"Flash using CClib"},{"location":"Zigbee-CCLib-Flashing/#flash-cclib-on-an-esp82xx-device","text":"Flashing the CC2530 normally requires a CC_DEBUGGER . Using an ESP82xx device like a Wemos D1 Mini is a lower cost alternative. If you are using a Wemos D1 Mini or NodeMCU, just plug the microUSB port. Vcc (3.3V), GND, Tx (GPIO1), and Rx (GPIO3) are connected via the microUSB port. Be sure that you are using a USB data cable. For ESP devices that do not have a microUSB connector, make the following connections: ESP Device Serial Programming Adapter Vcc Vcc GND GND GPIO0 GND GPIO1 Rx GPIO3 Tx Follow the usual ESP82xx flashing process - you are just using CCLib_proxy.ino.bin instead of Tasmota. Once the firmware upload completes, retain the serial interface connections (3.3V, GND, Tx, Rx). These will be used later for flashing the CC2530. C. Flash a DL-20 Zigbee module The DL-20 Zigbee module has a 5-pin 1.27mm pitch unpopulated header with 0.6mm througholes. For flashing any of the Zigbee modules, you need the following connections: ESP Pin D1 Mini NodeMCU CC2530 Pin DL-20 J2 Pin Location GPIO12 D6 CC_DD (A.K.A. P2_1 ('P21') or Debug Data) 5 GPIO4 D2 CC_DC (A.K.A. P2_2 ('P22') or Debug Clock) 4 Vcc 3.3v Vcc 3 GPIO5 D1 CC_RST 2 GND GND GND 1 DL-20 Flashing Jumpers Insert alternating male Dupont jumpers; one jumper on one side, the next one on other side. This allows the pins to provide the friction themselves to maintain contact and remain firmly in place. You only need DD, DC, and RST (a fourth jumper is shown which is used to keep the RST jumper in place). Vcc and GND are available on the main serial interface pins. D. Upload the firmware to the CC2530 The CC2530 requires Z-Stack_Home_1.2 , of type Default (not Source Routing ). For convenience, ready to use firmware files are provided. Select the right one for your hardware: CC2530 , CC2530 + CC2591 or CC2530 + CC2592 . These Python scripts require Python 2.7. 1) Ensure that you have Python 2.7 installed 2) Install pyserial 3.0.1: pip install pyserial==3.0.1 3) Check for connectivity before flashing: python Python/cc_info.py -p <serial_port> where <serial_port> is the serial port for the ESP82xx device. e.g. /dev/cu.usbserial-xxxx or COM7 Example of result: INFO : Found a CC2530 chip on / dev / cu . usbserial - xxxx Chip information : Chip ID : 0xa524 Flash size : 16 Kb Page size : 2 Kb SRAM size : 1 Kb USB : No Device information : IEEE Address : 000000000000 PC : 0000 Debug status : [ ] CHIP_ERASE_BUSY [ ] PCON_IDLE [ X ] CPU_HALTED [ ] PM_ACTIVE [ ] HALT_STATUS [ X ] DEBUG_LOCKED [ X ] OSCILLATOR_STABLE [ ] STACK_OVERFLOW Debug config : [ ] SOFT_POWER_MODE [ ] TIMERS_OFF [ ] DMA_PAUSE [ ] TIMER_SUSPEND If your CC2530 is DEBUG_LOCKED, then the flash size will be incorrectly reported as 16kB. Dont worry flashing the Z-Stack firmware will work and reset the DEBUG_LOCKED bit. In some situation flashing fails with a error message flash have not enough space . If this happens do the following: python Python/cc_read_flash.py -p <serial_port> -o x.hex python Python/cc_write_flash.py --erase -p <serial_port> -i x.hex Recheck for connectivity and the correct flash size by repeating step #3. 4) Flash the Z-Stack firmware using the following command: Flashing the CC2530 takes about 20 minutes python Python/cc_write_flash.py -e -p <serial_port> -i Bin/CC2530_DEFAULT_20190608_CC2530ZNP-Prod.hex INFO : Found a CC2530 chip on /dev/ cu . usbserial - xxxx Chip information : Chip ID : 0xa524 Flash size : 256 Kb Page size : 2 Kb SRAM size : 8 Kb USB : No Sections in Bin / CC2530_DEFAULT_20190608_CC2530ZNP - Prod . hex : Addr . Size -------- ------------- 0x0000 8176 B 0x1ff6 10 B 0x3fff0 1 B 0x2000 239616 B This is going to ERASE and REPROGRAM the chip . Are you sure ? < y / N >: y Flashing : - Chip erase ... - Flashing 4 memory blocks ... -> 0x0000 : 8176 bytes Progress 100 %... OK -> 0x1ff6 : 10 bytes Progress 100 %... OK -> 0x3fff0 : 1 bytes Progress 100 %... OK -> 0x2000 : 239616 bytes Progress 100 %... OK Completed If you don't see any on screen activity that flashing has begun (i.e., progress percentages increasing) within a couple minutes, then abort the command, cycle power on the ESP82xx, and start this step over. Described in greater detail in this blog post .","title":"Flash CCLib on an ESP82xx Device"},{"location":"Zigbee-Internals/","text":"Zigbee internals ~ Back to Zigbee This page is for developers who want to understand how Zigbee2Tasmota (Z2T) works and its implementation details. CC2530 Serial protocol ~ The CC2530 is flashed with Texas Instrument ZNP Software version 1.2. The protocol is build on a serial communication between the main cpu and the CC2530. Z-Stack 1.2 Monitor and Test API Serial communication is configured as 8N1, 115200 bauds. We suggest to use GPIO13/15 because they have hardware serial support. Please note that there is only one usable hardware serial, either on GPIO1/3 or GPIO13/15. To enable hardware serial on GPIO13/15 for Tasmota, set Serial 0 and restart. Otherwise Z2T will use Software serial provided by TasmotaSerial. Receiving 115200 bauds in software is a timing challenge. Here is the anatomy of a byte transmitted in serial mode. Each bit is 8.7\u00b5s, or ~700 CPU cycles at 80MHz (1400 cycles at 160MHz). It all starts with a LOW \"start bit\" that generates an interrupt transferred to TasmotaSerial. Then TasmotaSerial enters a tightly controlled loop to read each bit (least sifnificant first). The frame stops with a HIGH stop bit. What can go wrong? Tasmota may be already handling an interrupt when the start bit arrives, potentially causing a shift by 1 bit and a wrong message. Here is a 0xFE byte correctly received: Same frame with a delay in the interrupt handler, and mistakenly read 0xFF: TasmotaSerial has been improved to allow receiving a train of bytes withtout any disruption. CC2530 generally sends all the bytes one after the other for a single ZNP message (up to 250 bytes). Instead of giving back control after the first byte, the TasmotaSerial interrupt handler continues to monitor the serial RX line for the next 4 bits and checks whether a new start bit arrived. It avoids any error after the first byte was received. Still the first byte in the message could have been wrong. Fortunately, the first byte sent by ZNP is always 0xFE (see below). This means that if the interrupt arrives too late, Tasmota will read 0xFF instead of 0xFE. Z2T software does automatic error correction in this case, i.e. if the first byte received is 0xFF, it is automatically assumed to be 0xFE and the rest of the message is read normally. With these two schemes, software serial for Zigbee proved to be extremely reliable, even at 80MHz. It is highly recommended though to run at 160MHz. State machine - CC2530 initialization and configuration ~ After Tasmota boots, it sends the sequence 410001 to force a CC2530 hardware reset. Z2T implements an asynchronous state machine to handle the initialization and configuration of the CC2530. The state machine sends commands and waits for responses (with time-outs) and takes different branches depending on the responses. Instruction set ~ The program is encoded as a list of 32 bits instructions, stored in Flash in the zb_prog array of type Zigbee_Instruction[] . There is a PC (program counter) that is increased at each tick (i.e. every 50ms). The state machine has very simple instructions. Instructions encoded with 4 bytes: NOOP : no-operation, do nothing and move to the next instruction LABEL(x) : no-operation, and defines a Label (8 bits) that can be called by code. GOTO(x) : moves the PC to the instruction with LABEL(x) ZI_ON_ERROR_GOTO(x) : if an error occurs, move to label ZI_ON_TIMEOUT_GOTO(x) : if a timeout occurs, move to lavel WAIT(y) : wait for milliseconds (unsigned 16 bits). Note the granularity is 50ms and the wait is non-blocking WAIT_FOREVER : pause the state machine and wait for an external goto STOP : stop completely the state machine, only used after an unrecoverable error Instructions encoded with 8 bytes: CALL(f, x) : call a function, is the address of the function of type uint32_t f(uint8_t) . The input parameter is . The response is according to callbacks responses, except -1 (time-out) simply continues the flow. LOG(m) : log the string . can be in PROGMEM. For debugging only. MQTT_STATE(x, m) : sends a MQTT ZbState message, with status code and message . can be in PROGMEM. SEND(d) : send a ZNP sequence to CC2530. is an array of , a macro computes automatically the size of the array. can be in PROGMEM. WAIT_RECV(x, m) : wait for a specific message to be received with a time-out of (uint16_t). Messages take into account are owly those matching the first 2 bytes. The complete message match is expected or an error is generated. If the message received is longer than , additional bytes are ignored WAIT_UNTIL(x, m) : similar to WAIT_RECV but message that don't match are ignored, until a matching message is received. ON_RECV_UNEXPECTED(f) : if we received an unexpected (or unsupported) zigbee message, call function Instructions encoded with 12 bytes: WAIT_RECV_FUNC(x, m, f) : similar to WAIT_RECV and a function is called when the message matches. All callbacks return int32_t with the following effect: > 0 : goto the corresponding label 0 : continue -1 : signal a time-out < -1 : trigger an error (goto on_error) Initialization code for the state machine ~ At Tasmota start-up, the state-machine fires. The current Z2T pseudo-code does the following: Init: Set-up all the error handling functions Wait for 10.5 seconds after boot Send a RESET to CC2530 Wait for CC2530 boot Check configuration (if something is wrong, go to CONFIGURE): Check if the CC2530 was previously configured. It uses the same 1-byte Non-Volatile 0xF00 address and stores 0x55. Checks the Z-Stack version Checks the internal configuration: PanID, Ext PanID, Channel, PFGK and PFGKEN. If all good, emit an MQTT message saying Zigbee is configured Goto Start Configure (only if needed): Emit an MQTT message for reconfiguration Do a factory reset of CC2530 Reset the device once again Configure the following: PanId, Ext PanId, Channel, set type to Coordinator, PFKEY, PFKEYEN, Security Module Create NF 0xF00 location and store 0x55 Goto Start Start: Wait for CC2530 message saying the coordinator sucessfully started Query DeviceInfo Query Node Descriptor Query Active Endpoints Register 2 endpoints with profile 0x0104 (Home Automation) : 0x01 (default), 0x0B (for Xiaomi) Query Active Endpoints to verify 0x01 and 0x0B are active Close PermitJoin: don't accept any pairing Emit an MQTT message to indicate Zigbee started Mark Zigbee as initialized, accept incoming messages Load device configuration from Flash Query any lights declared with ZbLight to read their current states Pause the state machine Pairing devices ~ When you open pairing with ZbPermitJoin 1 (60 seconds) or ZbPermitJoin 99 (until next reboot), you allow new devices to join the network. Example below is for an OSRAM Plug. When a new devices joins, Z2T receives a TC Device Indication: ZDO_TC_DEV_IND (45CA) message with the device short (16 bits) address and IEEEAddress (64 bits). 16 : 39 : 26 MQT : tele /Zigbee_home/RESULT = { \"ZbState\" :{ \"Status\" : 30 , \"IEEEAddr\" : \"0x7CB03EAA0A0292DD\" , \"ShortAddr\" : \"0xF75D\" , \"PowerSource\" : true , \"ReceiveWhenIdle\" : true , \"Security\" : false }} Z2T then queries the device for additional information, like ZbProbe would do. First probe for Active Endpoint ZDO_ACTIVE_EP_REQ 16 : 39 : 26 MQT : tele /Zigbee_home/RESULT = { \"ZbState\" :{ \"Status\" : 32 , \"ActiveEndpoints\" :[ \"0x03\" ]}} Finally query for the following general attributes: Manufacturer Id and Model Id. 16 : 39 : 26 ZIG : ZbZCLRawReceived : { \"0xF75D\" :{ \"0000/0004\" : \"OSRAM\" , \"0000/0005\" : \"Plug 01\" }} 16 : 39 : 26 MQT : tele /tasmota/Zigbee_home/ SENSOR = { \"ZbReceived\" :{ \"0xF75D\" :{ \"Manufacturer\" : \"OSRAM\" , \"ModelId\" : \"Plug 01\" , \"Endpoint\" : 3 , \"LinkQuality\" : 36 }}} Code flow when a message is received ~ Message Serial decoding ~ Here is a detailed view of the code flow and transformations applied when a Zigbee message is received. It's simple but has many ramifications. During the Tasmota event loop, Z2T first checks any incoming message by calling ZigbeeInputLoop() , and after parsing incoming messages, it sends any outgoing message by calling ZigbeeOutputLoop() . Note: outgoing messages are not sent directly but stacked into a buffer and sent once per event tick. This avoids lost messages when sending them too fast. For ZNP , the serial buffer is read if there is any incoming data. The message is checked for checksum and put into a SBuffer object of maximum size of 256 bytes. If a message is ready, it calls ZigbeeProcessInput(znp_buffer) For EZSP , the flow is a little more complex because multiple layers of decoding are required. The first layer receives the message and handles UART-EZSP protocol messages: ignores XON/XOFF, decodes ESCAPE characters, CANCEL... It then decodes according to the pseudo-random generator, and checks the final CRC. If ok, it calls the second stage via ZigbeeProcessInputRaw(ezsp_buffer) . Note: the green light of the ZBBridge Led_i 1 is set to blink when a message is received from EZSP (which does not mean an actual Zigbee radio message was received). EZSP second stage decodes the ASH protocol, including ACK/NAK of messages, RSTACK (reset confirmation) and ERROR. In case of ERROR, the EZSP stack is not able to respond anymore and requires a complete reset. In this case a log entry is produced and the entire Tasmota is automatically restarted. This stage automatically sends ACK messages to confirm reception of messages. If a DATA frame is received, it then calls the third stage via ZigbeeProcessInputEZSP(buf) . The third stage of EZSP decoding extracts the message, logs if needed and then calls ZigbeeProcessInput(buf) . State machine handling ~ The message is passed to the state machine that will either automatically match the message and pass to the next state, or pass it to the default handler. When the stack is fully initialized, zigbee.init_phase == false , the default handler is ZNP_Recv_Default() for ZNP or EZ_Recv_Default() for EZSP. For ZNP , ZDO messages are dispatched to the relevant handlers: ZDO_END_DEVICE_ANNCE_IND , ZDO_TC_DEV_IND , ZDO_PERMIT_JOIN_IND , ZDO_NODE_DESC_RSP , ZDO_ACTIVE_EP_RSP , ZDO_SIMPLE_DESC_RSP , ZDO_IEEE_ADDR_RSP , ZDO_BIND_RSP , ZDO_UNBIND_RSP , ZDO_MGMT_LQI_RSP , ZDO_MGMT_BIND_RSP . Note: PARENT_ANNCE is handled at ZNP level and not passed to the application. AF_DATA_CONFIRM emits a log message, and data messages are handled in ZNP_ReceiveAfIncomingMessage() . The ZCL frame is decoded into a ZCLFrame object and sent to Z_IncomingMessage() . For EZSP , messages are directly dispatched for trustCenterJoinHandler , incomingRouteErrorHandler , permitJoining and messageSentHandler . All other incoming messages, including ZDO, are sent to EZ_IncomingMessage() . EZSP : EZ_IncomingMessage() then decodes ZDO messages and dispatches them: ZDO_Device_annce , ZDO_Active_EP_rsp , ZDO_IEEE_addr_rsp , ZDO_Simple_Desc_rsp , ZDO_Bind_rsp , Z_UnbindRsp , Z_MgmtLqiRsp , Z_MgmtBindRsp , ZDO_Parent_annce , ZDO_Parent_annce_rsp . Other non-ZDO messages decoded into a ZCLFrame object and sent to Z_IncomingMessage() . Incoming messages handling: Z_IncomingMessage ~ The starting point is Z_IncomingMessage() with a ZCLFrame object corresponding to the received Zigbee message. Details of Z_IncomingMessage() : 1. Log the raw message at LogLevel 3 (DEBUG) 2. Update the LQI for the device 3. Update the last_seen value 4. Dispatch according to message type If ZCL_DEFAULT_RESPONSE , log and ignore (it's just the device acknowledge for the last message). If ZCL_REPORT_ATTRIBUTES , call parseReportAttributes() . This is the general case for sensor values (temperature...) If ZCL_READ_ATTRIBUTES_RESPONSE , call parseReadAttributesResponse() . This happens as a response to reading attributes, and the handling is similar to the attribute reporting (although the syntax of the message is slightly differen). If ZCL_READ_ATTRIBUTES , call parseReadAttributes() . This happens rarely, typically when a device asks the coordinator for attributes like the local_time . If ZCL_READ_REPORTING_CONFIGURATION_RESPONSE , call parseReadConfigAttributes() . This is the response to ZbBindState command. If ZCL_CONFIGURE_REPORTING_RESPONSE , call parseConfigAttributes() . This is the response to ZbBind command. For cluster specific commands, call parseClusterSpecificCommand() . This is the general case when a command is received (for ex \"Power\":\"toggle\" ). All the previous commands add attributes to a local attr_list object. These attributes are have a key of eiher Cluster/Attribute type of String type. Note: it is important to keep attributes as Cluster/Attribute types so that we can later apply transformations on them. Note2: LinkQuality , Device , Name , Group and Endpoint are special values that do are not registered as actual attributes. 6. Apply transoformations to the attributes. There are many transformations that are required because some device use proprietary values, or we need to compute new values out of the existing attributes. Generate synthetic attributes generateSyntheticAttributes() . This is mainly used for Xiaomi Aqara devices. Aqara uses cluster 0xFF01 and 0xFF02 to send structured messages. The good side is that it allows to send attributes from different clusters in a single message, whereas the ZCL standard would have required several messages. The bad side is that Aqara reuses the same attribute numbers for different value, and you need to know the device type to decode; which makes the whole process work only if the pairing process sucessfully got the ModelId. Compute synthetic attributes computeSyntheticAttributes() . This is used to add computed attributes or fix some bugs in devices. Currently it computes the BatteryPercentage from the BatteryVoltage if the BatteryPercentage is not already present. It computes SeaPressure using the Tasmota Altitude setting. It fixes an Eurotronic bug in the encoding of Pi Heating Demand which is sent in the 0..255 range instead of 0..100 range. It fixes the IKEA Remote battery value which is half what it needs to be. Generate callbacks and timers generateCallBacks() . This is used to register deferres callbacks. It is only used for Occypancy for now. Many PIR sensors report \"Occupancy\":1 but don't report the lack of occupancy. This function sets a timer to artificially generate \"Occupancy\":0 after a definite amount of time (defaults to 90 seconds). Post-process attributes Z_postProcessAttributes() . This function does the final transformation of attributes to their human readable format. First the endpoint is added as suffix if SetOption101 1 is set, if the source endpoint is not 1 , and if the device is known to have more than one endpoint (check with ZbStatus2 ). Then the attribute is looked-up from the global Z_PostProcess table. If the attribute is mapped into Z_Data , the value is saved into its corresponding object. See ZbData . This allows for keeping last seen values for the Web UI. Similarly, some device specific values are recorded: ModelId , ManufacturerId , BatteryPercent . If the attribute as a multiplier value, the raw value is multiplied/divided by this value (ex: Temperature raw value is 1/100th of degrees, so the raw value is divided by 100). Finally the attribute name is replaced by its string value (ex: 0402/0000 is replace with Temperature ). 7. Publish the final message to MQTT or defer the message. In the general case, attributes are not published immediately but kept in memory for a short period of time. This allows for debouncing of identical messages, and coalescing of values (Temperature, Pressure, Humidity) in a single MQTT message, even if there were received in 3 seperate messages. The default timer is a compile time #define USE_ZIGBEE_COALESCE_ATTR_TIMER with a default value of 350 ms. Once a message is ready, it first checks if the value conflict with previously held values. If so, the previous message is immediately sent, and the new values are held in memory. Then is sets a timer to publish the values after the timer expired.","title":"Zigbee internals"},{"location":"Zigbee-Internals/#zigbee-internals","text":"Back to Zigbee This page is for developers who want to understand how Zigbee2Tasmota (Z2T) works and its implementation details.","title":"Zigbee internals"},{"location":"Zigbee-Internals/#cc2530-serial-protocol","text":"The CC2530 is flashed with Texas Instrument ZNP Software version 1.2. The protocol is build on a serial communication between the main cpu and the CC2530. Z-Stack 1.2 Monitor and Test API Serial communication is configured as 8N1, 115200 bauds. We suggest to use GPIO13/15 because they have hardware serial support. Please note that there is only one usable hardware serial, either on GPIO1/3 or GPIO13/15. To enable hardware serial on GPIO13/15 for Tasmota, set Serial 0 and restart. Otherwise Z2T will use Software serial provided by TasmotaSerial. Receiving 115200 bauds in software is a timing challenge. Here is the anatomy of a byte transmitted in serial mode. Each bit is 8.7\u00b5s, or ~700 CPU cycles at 80MHz (1400 cycles at 160MHz). It all starts with a LOW \"start bit\" that generates an interrupt transferred to TasmotaSerial. Then TasmotaSerial enters a tightly controlled loop to read each bit (least sifnificant first). The frame stops with a HIGH stop bit. What can go wrong? Tasmota may be already handling an interrupt when the start bit arrives, potentially causing a shift by 1 bit and a wrong message. Here is a 0xFE byte correctly received: Same frame with a delay in the interrupt handler, and mistakenly read 0xFF: TasmotaSerial has been improved to allow receiving a train of bytes withtout any disruption. CC2530 generally sends all the bytes one after the other for a single ZNP message (up to 250 bytes). Instead of giving back control after the first byte, the TasmotaSerial interrupt handler continues to monitor the serial RX line for the next 4 bits and checks whether a new start bit arrived. It avoids any error after the first byte was received. Still the first byte in the message could have been wrong. Fortunately, the first byte sent by ZNP is always 0xFE (see below). This means that if the interrupt arrives too late, Tasmota will read 0xFF instead of 0xFE. Z2T software does automatic error correction in this case, i.e. if the first byte received is 0xFF, it is automatically assumed to be 0xFE and the rest of the message is read normally. With these two schemes, software serial for Zigbee proved to be extremely reliable, even at 80MHz. It is highly recommended though to run at 160MHz.","title":"CC2530 Serial protocol"},{"location":"Zigbee-Internals/#state-machine-cc2530-initialization-and-configuration","text":"After Tasmota boots, it sends the sequence 410001 to force a CC2530 hardware reset. Z2T implements an asynchronous state machine to handle the initialization and configuration of the CC2530. The state machine sends commands and waits for responses (with time-outs) and takes different branches depending on the responses.","title":"State machine - CC2530 initialization and configuration"},{"location":"Zigbee-Internals/#instruction-set","text":"The program is encoded as a list of 32 bits instructions, stored in Flash in the zb_prog array of type Zigbee_Instruction[] . There is a PC (program counter) that is increased at each tick (i.e. every 50ms). The state machine has very simple instructions. Instructions encoded with 4 bytes: NOOP : no-operation, do nothing and move to the next instruction LABEL(x) : no-operation, and defines a Label (8 bits) that can be called by code. GOTO(x) : moves the PC to the instruction with LABEL(x) ZI_ON_ERROR_GOTO(x) : if an error occurs, move to label ZI_ON_TIMEOUT_GOTO(x) : if a timeout occurs, move to lavel WAIT(y) : wait for milliseconds (unsigned 16 bits). Note the granularity is 50ms and the wait is non-blocking WAIT_FOREVER : pause the state machine and wait for an external goto STOP : stop completely the state machine, only used after an unrecoverable error Instructions encoded with 8 bytes: CALL(f, x) : call a function, is the address of the function of type uint32_t f(uint8_t) . The input parameter is . The response is according to callbacks responses, except -1 (time-out) simply continues the flow. LOG(m) : log the string . can be in PROGMEM. For debugging only. MQTT_STATE(x, m) : sends a MQTT ZbState message, with status code and message . can be in PROGMEM. SEND(d) : send a ZNP sequence to CC2530. is an array of , a macro computes automatically the size of the array. can be in PROGMEM. WAIT_RECV(x, m) : wait for a specific message to be received with a time-out of (uint16_t). Messages take into account are owly those matching the first 2 bytes. The complete message match is expected or an error is generated. If the message received is longer than , additional bytes are ignored WAIT_UNTIL(x, m) : similar to WAIT_RECV but message that don't match are ignored, until a matching message is received. ON_RECV_UNEXPECTED(f) : if we received an unexpected (or unsupported) zigbee message, call function Instructions encoded with 12 bytes: WAIT_RECV_FUNC(x, m, f) : similar to WAIT_RECV and a function is called when the message matches. All callbacks return int32_t with the following effect: > 0 : goto the corresponding label 0 : continue -1 : signal a time-out < -1 : trigger an error (goto on_error)","title":"Instruction set"},{"location":"Zigbee-Internals/#initialization-code-for-the-state-machine","text":"At Tasmota start-up, the state-machine fires. The current Z2T pseudo-code does the following: Init: Set-up all the error handling functions Wait for 10.5 seconds after boot Send a RESET to CC2530 Wait for CC2530 boot Check configuration (if something is wrong, go to CONFIGURE): Check if the CC2530 was previously configured. It uses the same 1-byte Non-Volatile 0xF00 address and stores 0x55. Checks the Z-Stack version Checks the internal configuration: PanID, Ext PanID, Channel, PFGK and PFGKEN. If all good, emit an MQTT message saying Zigbee is configured Goto Start Configure (only if needed): Emit an MQTT message for reconfiguration Do a factory reset of CC2530 Reset the device once again Configure the following: PanId, Ext PanId, Channel, set type to Coordinator, PFKEY, PFKEYEN, Security Module Create NF 0xF00 location and store 0x55 Goto Start Start: Wait for CC2530 message saying the coordinator sucessfully started Query DeviceInfo Query Node Descriptor Query Active Endpoints Register 2 endpoints with profile 0x0104 (Home Automation) : 0x01 (default), 0x0B (for Xiaomi) Query Active Endpoints to verify 0x01 and 0x0B are active Close PermitJoin: don't accept any pairing Emit an MQTT message to indicate Zigbee started Mark Zigbee as initialized, accept incoming messages Load device configuration from Flash Query any lights declared with ZbLight to read their current states Pause the state machine","title":"Initialization code for the state machine"},{"location":"Zigbee-Internals/#pairing-devices","text":"When you open pairing with ZbPermitJoin 1 (60 seconds) or ZbPermitJoin 99 (until next reboot), you allow new devices to join the network. Example below is for an OSRAM Plug. When a new devices joins, Z2T receives a TC Device Indication: ZDO_TC_DEV_IND (45CA) message with the device short (16 bits) address and IEEEAddress (64 bits). 16 : 39 : 26 MQT : tele /Zigbee_home/RESULT = { \"ZbState\" :{ \"Status\" : 30 , \"IEEEAddr\" : \"0x7CB03EAA0A0292DD\" , \"ShortAddr\" : \"0xF75D\" , \"PowerSource\" : true , \"ReceiveWhenIdle\" : true , \"Security\" : false }} Z2T then queries the device for additional information, like ZbProbe would do. First probe for Active Endpoint ZDO_ACTIVE_EP_REQ 16 : 39 : 26 MQT : tele /Zigbee_home/RESULT = { \"ZbState\" :{ \"Status\" : 32 , \"ActiveEndpoints\" :[ \"0x03\" ]}} Finally query for the following general attributes: Manufacturer Id and Model Id. 16 : 39 : 26 ZIG : ZbZCLRawReceived : { \"0xF75D\" :{ \"0000/0004\" : \"OSRAM\" , \"0000/0005\" : \"Plug 01\" }} 16 : 39 : 26 MQT : tele /tasmota/Zigbee_home/ SENSOR = { \"ZbReceived\" :{ \"0xF75D\" :{ \"Manufacturer\" : \"OSRAM\" , \"ModelId\" : \"Plug 01\" , \"Endpoint\" : 3 , \"LinkQuality\" : 36 }}}","title":"Pairing devices"},{"location":"Zigbee-Internals/#code-flow-when-a-message-is-received","text":"","title":"Code flow when a message is received"},{"location":"Zigbee-Internals/#message-serial-decoding","text":"Here is a detailed view of the code flow and transformations applied when a Zigbee message is received. It's simple but has many ramifications. During the Tasmota event loop, Z2T first checks any incoming message by calling ZigbeeInputLoop() , and after parsing incoming messages, it sends any outgoing message by calling ZigbeeOutputLoop() . Note: outgoing messages are not sent directly but stacked into a buffer and sent once per event tick. This avoids lost messages when sending them too fast. For ZNP , the serial buffer is read if there is any incoming data. The message is checked for checksum and put into a SBuffer object of maximum size of 256 bytes. If a message is ready, it calls ZigbeeProcessInput(znp_buffer) For EZSP , the flow is a little more complex because multiple layers of decoding are required. The first layer receives the message and handles UART-EZSP protocol messages: ignores XON/XOFF, decodes ESCAPE characters, CANCEL... It then decodes according to the pseudo-random generator, and checks the final CRC. If ok, it calls the second stage via ZigbeeProcessInputRaw(ezsp_buffer) . Note: the green light of the ZBBridge Led_i 1 is set to blink when a message is received from EZSP (which does not mean an actual Zigbee radio message was received). EZSP second stage decodes the ASH protocol, including ACK/NAK of messages, RSTACK (reset confirmation) and ERROR. In case of ERROR, the EZSP stack is not able to respond anymore and requires a complete reset. In this case a log entry is produced and the entire Tasmota is automatically restarted. This stage automatically sends ACK messages to confirm reception of messages. If a DATA frame is received, it then calls the third stage via ZigbeeProcessInputEZSP(buf) . The third stage of EZSP decoding extracts the message, logs if needed and then calls ZigbeeProcessInput(buf) .","title":"Message Serial decoding"},{"location":"Zigbee-Internals/#state-machine-handling","text":"The message is passed to the state machine that will either automatically match the message and pass to the next state, or pass it to the default handler. When the stack is fully initialized, zigbee.init_phase == false , the default handler is ZNP_Recv_Default() for ZNP or EZ_Recv_Default() for EZSP. For ZNP , ZDO messages are dispatched to the relevant handlers: ZDO_END_DEVICE_ANNCE_IND , ZDO_TC_DEV_IND , ZDO_PERMIT_JOIN_IND , ZDO_NODE_DESC_RSP , ZDO_ACTIVE_EP_RSP , ZDO_SIMPLE_DESC_RSP , ZDO_IEEE_ADDR_RSP , ZDO_BIND_RSP , ZDO_UNBIND_RSP , ZDO_MGMT_LQI_RSP , ZDO_MGMT_BIND_RSP . Note: PARENT_ANNCE is handled at ZNP level and not passed to the application. AF_DATA_CONFIRM emits a log message, and data messages are handled in ZNP_ReceiveAfIncomingMessage() . The ZCL frame is decoded into a ZCLFrame object and sent to Z_IncomingMessage() . For EZSP , messages are directly dispatched for trustCenterJoinHandler , incomingRouteErrorHandler , permitJoining and messageSentHandler . All other incoming messages, including ZDO, are sent to EZ_IncomingMessage() . EZSP : EZ_IncomingMessage() then decodes ZDO messages and dispatches them: ZDO_Device_annce , ZDO_Active_EP_rsp , ZDO_IEEE_addr_rsp , ZDO_Simple_Desc_rsp , ZDO_Bind_rsp , Z_UnbindRsp , Z_MgmtLqiRsp , Z_MgmtBindRsp , ZDO_Parent_annce , ZDO_Parent_annce_rsp . Other non-ZDO messages decoded into a ZCLFrame object and sent to Z_IncomingMessage() .","title":"State machine handling"},{"location":"Zigbee-Internals/#incoming-messages-handling-z_incomingmessage","text":"The starting point is Z_IncomingMessage() with a ZCLFrame object corresponding to the received Zigbee message. Details of Z_IncomingMessage() :","title":"Incoming messages handling: Z_IncomingMessage"},{"location":"Zigbee/","text":"Zigbee2Tasmota serves as a gateway for devices connected to a Zigbee wireless network to bridge their communications over to Wi-Fi Zigbee2Tasmota (Z2T) is a lightweight Zigbee solution running on an ESP82xx Wi-Fi chip. Hence it is easier to deploy wherever you want in your home. It is largely inspired by Zigbee2mqtt but it's a complete rewrite to make it fit on an ESP82xx with 80kB of RAM and only 1MB of flash memory. Hardware ~ This integration works with any Texas Instruments CC2530 chip based device as well as with Silicon Labs EFR32 chip based devices like Sonoff ZBBridge . A complete list of compatible Zigbee coordinators and Zigbee devices compatible with Z2T is in the Zigbee Device Compatibility Repository . While Z2T was initially designed for Texas Instruments Z-Stack firmware and protocol for CC253x based device, since then support for Silicon Labs EZSP (EmberZNet Serial Protocol) firmware has also been added. Once the Zigbee coordinator is started and communicates with Tasmota, the end result is the same and there is no difference in their operation. Flashing and installation instructions for: Sonoff ZBBridge by ITead CC2530 based devices Introduction ~ Before using Zigbee with Tasmota, you need to understand a few concepts. Here is a simplified comparison to the Wi-Fi equivalent (sort of). Zigbee concept Wi-Fi equivalent Zigbee coordinator The coordinator is responsible for selecting the channel, PanID, security policy, and stack profile for a network. Zigbee2Tasmota will act as a coordinator. You can have multiple coordinators as long as they have different PanIDs. Wi-Fi Access Point PanID (Personal Area Network IDentifier) This parameter is unique in a Zigbee network (16-bit integer, 0x0000\u20130x3FFF). Default: 0x1A63 SSID (the Wi-Fi network name) ShortAddr Address of the device on the Zigbee network. This address is randomly assigned when the device first connects to the coordinator (16 bits integer, 0x0000\u20130xFFF7). The coordinator has address 0x0000. You need to track which device has which address or assign a \"Friendly Name\" to each new discovered device. IP address GroupAddr Group address of a collection of devices, it allows a single message to address multiple devices at once (16 bits integer, 0x0000\u20130xFFFF). For example a remote can turn on/off a group of lights. GroupAddr 0x0000 is not assigned. Multicast Endpoint The endpoint on the coordinator or on the Zigbee device the message is sent from/to. You can see endpoints as logical device providing distinct features (8 bits integer, 1\u2013240). IP Port IEEEAddr Device hardware address (64 bits). This is unique per device and factory assigned. MAC address Channel 11-26 Default: 11 (See Zigbee-Wifi coexistence ) Wi-Fi Channel Encryption Key 128-bit encryption key. default: 0x0D0C0A08060402000F0D0B0907050301 Wi-Fi password Pairing By default the coordinator does not accept new devices unless put in pairing mode. When in pairing mode, it will accept pairing requests from any device within range. Default: pairing disabled WPS Cluster Clusters are a group of commands and attributes that define what a device can do. Think of clusters as a group of actions by function. A device can support multiple clusters to do a whole variety of tasks. The majority of clusters are defined by the ZigBee Alliance and listed in the ZigBee Cluster Library Usage ~ For a list of available commands see Zigbee Commands . Pairing Devices ~ When you create a new Zigbee network, it contains no devices except the coordinator. The first step is to add devices to the network, which is called pairing . By default, and for security reasons, the Zigbee coordinator does not automatically accept new devices. To pair new devices, use ZbPermitJoin 1 . Once Zigbee2Tasmota is in pairing mode, put the Zigbee device into pairing mode. This is usually accomplished by pressing the button on the device for 5 seconds or more. To stop pairing, use ZbPermitJoin 0 . ZbPermitJoin 1 CMD : ZbPermi t Joi n 1 MQT : s tat /% t opic%/RESULT = { \"ZbPermitJoin\" : \"Done\" } MQT : tele /% t opic%/RESULT = { \"ZbState\" :{ \"Status\" : 21 , \"Message\" : \"Enable Pairing mode for 60 seconds\" }} 60 seconds later: MQT : tele /% t opic%/RESULT = { \"ZbState\" :{ \"Status\" : 20 , \"Message\" : \"Disable Pairing mode\" }} ZbPermitJoin 0 MQT : tele /% t opic%/RESULT = { \"ZbState\" :{ \"Status\" : 20 , \"Message\" : \"Disable Pairing mode\" }} Info Although this is highly discouraged, you can permanently enable Zigbee pairing, until the next reboot, with ZbPermitJoin 99 . After the device has successfully paired it will be shown in the webui with its short address and its link quality number (LQI). When it is a battery powered device, the battery percentage will be displayed as soon as it is received from the device. Devices will show friendly name once you set it. Setting Friendly Name ~ Instead of a short address like 0x8F20 you can assign a, memorable, friendly name such as \"Bedroom_Sensor\" . See ZbName command for all options. Xiaomi Aqara Cube with address 0x128F MQT : tele /% t opic%/RESULT = { \"ZbReceived\" :{ \"0x128F\" :{ \"AqaraVibrationMode\" : \"tilt\" , \"AqaraVibrationsOrAngle\" : 162 , \"AqaraAccelerometer\" :[ -690 , 2 , 138 ], \"AqaraAngles\" :[ -78 , 0 , 11 ], \"LinkQuality\" : 158 }}} Setting its friendly name to Vibration_sensor : ZbName 0 x 128 F , Vibra t io n _se ns or CMD : ZbName 0 x 128 F , Vibra t io n _se ns or MQT : s tat /% t opic%/RESULT = { \"0x128F\" :{ \"Name\" : \"Vibration_sensor\" }} ( 10 seco n ds la ter ) ZIG : Zigbee Devices Da ta s t ore i n Flash ( 0 x 402 FF 800 - 270 by tes ) Now the sensor readings includes the friendly name: MQT : tele /% t opic%/RESULT = { \"ZbReceived\" :{ \"0x128F\" :{ \"Name\" : \"Vibration_sensor\" , \"AqaraVibrationMode\" : \"tilt\" , \"AqaraVibrationsOrAngle\" : 171 , \"AqaraAccelerometer\" :[ -691 , 12 , 130 ], \"AqaraAngles\" :[ -78 , 1 , 11 ], \"LinkQuality\" : 153 }}} If you set SetOption83 1 sensor readings will use the friendly name as JSON key, short address is added as Device : MQT : tele /% t opic%/RESULT = { \"ZbReceived\" :{ \"Vibration_sensor\" :{ \"Device\" : \"0x128F\" , \"AqaraVibrationMode\" : \"tilt\" , \"AqaraVibrationsOrAngle\" : 171 , \"AqaraAccelerometer\" :[ -691 , 8 , 136 ], \"AqaraAngles\" :[ -78 , 1 , 11 ], \"LinkQuality\" : 153 }}} Removing Devices ~ To remove a device from Zigbee2Tasmota use command ZbForget <device> or ZbForget <friendlyname> . Pairing Example ~ This is an example of a pairing process for the Aqara Temperature & Humidity Sensor . To pair this sensor, issue ZbPermitJoin 1 and then press and hold the reset button for 5 seconds. The sensor LED will flash several times and you will see log entries in the console, especially this one: MQT : tele /%topic%/ SENSOR = { \"ZbState\" :{ \"Status\" : 30 , \"IEEEAddr\" : \"0x00158D00036B50AE\" , \"ShortAddr\" : \"0x8F20\" , \"PowerSource\" : false , \"ReceiveWhenIdle\" : false , \"Security\" : false }} Message with \"Status\":30 shows some characteristics of the device: Field name Value Status 30 indicates a device connect or reconnect. This is the opportunity to match IEEEAddress and short address IEEEAddr Long unique address (64 bits) of the device - factory set ShortAddr Short address (16 bits) randomly assigned to the device on this Zigbee network PowerSource true = the device is connected to a power source false = the device runs on battery ReceiveWhenIdle true = the device can receive commands when idle false = the device is not listening. Commands should be sent when the device reconnects and is idle Security Security capability (meaning unknown, to be determined) Reading Sensors ~ Most sensors will publish their readings regularly or once a significant change has happened: temperature, pressure, humidity, presence, illuminance... Sensor messages are published via MQTT when they are received from the Zigbee device. Similar to Zigbee2MQTT, Z2T tries to group and debounce sensor values when they are received within a 300ms window. Aqara Temperature & Humidity Sensor This sensor monitors humidity, temperature, and air pressure. Its Zigbee model ID is lumi.weather . This device publishes sensor values roughly every hour or when a change occurs. You can also force an update pressing the device's button. It sends two kinds of messages, either 3x standard Zigbee messages, or a single proprietary message containing all sensor values. 0x8F20 is the ShortAddress of the sensor, and its name is Kitchen if you used ZbName 0x8F20,Kithchen . MQT : tele /% t opic%/SENSOR = { \"ZbReceived\" : { \"0x8F20\" : { \"Name\" : \"Kitchen\" , \"Voltage\" : 2.995 , \"Battery\" : 98 , \"Temperature\" : 21.01 , \"Humidity\" : 53.68 , \"Pressure\" : 1004.04 , \"PressureUnit\" : \"hPa\" , \"Endpoint\" : 1 , \"LinkQuality\" : 88 }} or prefixed by name if you set SetOption83 1 MQT : tele /% t opic%/SENSOR = { \"ZbReceived\" : { \"Kitchen\" : { \"Device\" : \"0x8F20\" , \"Voltage\" : 2.995 , \"Battery\" : 98 , \"Temperature\" : 21.01 , \"Humidity\" : 53.68 , \"Pressure\" : 1004.04 , \"PressureUnit\" : \"hPa\" , \"Endpoint\" : 1 , \"LinkQuality\" : 88 }} Topic is device specific, to allow more effective retained messages, if you set SetOption89 1 MQT : tele /% t opic%/ 8 F 20 /SENSOR = { \"ZbReceived\" : { \"Kitchen\" : { \"Device\" : \"0x8F20\" , \"Voltage\" : 2.995 , \"Battery\" : 98 , \"Temperature\" : 21.01 , \"Humidity\" : 53.68 , \"Pressure\" : 1004.04 , \"PressureUnit\" : \"hPa\" , \"Endpoint\" : 1 , \"LinkQuality\" : 88 }} Supported values: Field name Value LinkQuality Stength of the Zigbee signal, between 1 and 254 (integer). See this ZigBee and WiFi Coexistence Humidity Humidity in percentage (float) Pressure and PressureUnit Atmospheric pressure (float) and unit (string) Currently only hPa (A.K.A. mbar) is supported Temperature Temperature in Celsius (float) Voltage Battery voltage (float) Battery Battery charge in percentage (integer) ModelId Model name of the Zigbee device (string) Ex: lumi.weather ScaledValue and Scale Give the raw measure and the scale correction as 10^scale And many more... If a value is not decoded, it will appear as \"<cluster>_<attr>\":<value> where <cluster> is the Zigbee ZCL Cluster of the attribute (family), <attr> is the attribute number and <value> its published value. Example \"0402_0000\":2240 is attribute 0x0000 from cluster 0x0402, which is the temperature in hundredth of \u00b0C. It is automatically converted to \"Temperature\":22.40 . Device Information ~ You can dump the internal information gathered about connected Zigbee devices with the command ZbStatus . You can use ZbStatus2 to display all information and endpoints. If probing was successful (at pairing time or using ZbProbe ), Tasmota will automatically find the right endpoint. Depending on the number of devices you have, ZbStatus2 output can exceed the maximum MQTT message size. You can request the status of each individual device using ZbStatus2 1 , ZbStatus2 2 , ZbStatus2 3 or ZbStatus2 <friendly_name> ZbStatus1 - List all connected devices { \"ZbStatus1\" :[{ \"Device\" : \"0x6B58\" },{ \"Device\" : \"0xE9C3\" },{ \"Device\" : \"0x3D82\" }]} ZbStatus2 - Display detailed information for each device, including long address, model and manufacturer ID: { \"ZbStatus2\" :[{ \"Device\" : \"0x4773\" , \"IEEEAddr\" : \"0x7CB03EAA0A0292DD\" , \"ModelId\" : \"Plug 01\" , \"Manufacturer\" : \"OSRAM\" , \"Endpoints\" :[ \"0x03\" ]},{ \"Device\" : \"0x135D\" , \"Name\" : \"Temp_sensor\" , \"IEEEAddr\" : \"0x00158D00036B50AE\" , \"ModelId\" : \"lumi.weather\" , \"Manufacturer\" : \"LUMI\" , \"Endpoints\" :[ \"0x01\" ]}]} (formatted for readability) { \"ZbStatus2\" : [{ \"Device\" : \"0x4773\" , \"IEEEAddr\" : \"0x7CB03EAA0A0292DD\" , \"ModelId\" : \"Plug 01\" , \"Manufacturer\" : \"OSRAM\" , \"Endpoints\" : [ \"0x03\" ] }, { \"Device\" : \"0x135D\" , \"Name\" : \"Temp_sensor\" , \"IEEEAddr\" : \"0x00158D00036B50AE\" , \"ModelId\" : \"lumi.weather\" , \"Manufacturer\" : \"LUMI\" , \"Endpoints\" : [ \"0x01\" ] }] } ZbStatus3 - Display detailed information for each device, including long address, model and manufacturer ID and a list of endpoints and clusters Understanding Endpoints and Clusters ~ An endpoint supports different functions separated in clusters and a device can have multiple endpoints to do different things. To simplify, think of your Zigbee device as a normal Tasmota device with a Zigbee radio instead of Wi-Fi. Each endpoint is akin to a GPIO that has connected Components or Clusters, in Zigbee terms. Cluster definitions in relation to their endpoint are determined by Zigbee Alliance . Not all manufacturers followed the proposed allocations but in general it is a cornerstone document. Z2T will automatically take the first endpoint in the list which works most of the time. You normally don't need to specify the endpoint number. In rare cases, you can force a specific endpoint. Sending Device Commands ~ You can send commands to a device or groups of devices similar to a normal Tasmota command. For example to turn on a light or switch off a plug. Here is a list of supported commands, see below how to send any unlisted command. Command Parameters Cluster number Power 1 or true or \"true\" or \"on\" : On 0 or false or \"false\" or \"off\" : Off 2 or \"toggle\" : Toggle 0x0006 Dimmer 0..254 : Dimmer value 255 is normally considered as invalid, and may be converted to 254 0x0008 DimmerUp : no parameter. Increases dimmer by 10% 0x0008 DimmerDown : no parameter. Decreases dimmer by 10% 0x0008 DimmerStop : no parameter. Stops any running increase of decrease of dimmer. 0x0008 ResetAlarm <alarmcode>,<clusterid> : (to be documented later) 0x0009 ResetAllAlarms : no parameter, (to be documented later) 0x0009 Hue 0..254 : change Hue value 0x0300 Sat 0..254 : change Sat value 0x0300 HueSat 0..254,0..254 : change both Hue and Sat values 0x0300 Color 0..65534,0..65534 : change the color using [x,y] coordinates 0x0300 CT 0..65534 : change the white color-temperature in mireds 0x0300 Shutter 0..254 : send any Shutter command (prefer the commands below) 0x0102 ShutterOpen : no parameter, open shutter 0x0102 ShutterClose : no parameter, close shutter 0x0102 ShutterStop : no parameter, stop shutter movement 0x0102 ShutterLift 0..100 : move shutter to a specific position in percent 0 %=open, 100 %=closed 0x0102 ShutterTilt 0..100 : move the shutter to the specific tilt position in percent 0x0102 The format of the command is following: ZbSend {\"Device\":\"<device>\",\"Send\":{\"<sendcmd>\":<sendparam>}} where <device> identifies the target and can be a shortaddr 0x1234 , a longaddr 0x1234567812345678 or a friendly name Kitchen . \u2003 \"<sendcmd>\":<sendparam> is the command and its parameters from the table. If the device has been correctly paired and its endpoints recorded by Z2T, you shouldn't need to specify a target endpoint. You can use an option \"endpoint\":<endpoint> parameter if Z2T can't find the correct endpoint or if you want to change from the default endpoint. Low-level Commands ~ There is a special syntax if you want to send arbitrary commands: \"Send\":\"<send_bytes>\" where <send_bytes> has the following syntax: \"<cluster>_<cmd>/<bytes>\" : send a non-cluster specific command for cluster id <cluster> , command id <cmd> and payload <bytes> . Example ZbSend {\"Device\":\"0x1234\",\"Send\":\"0000_00/0500\"} Send a Read command (0x00) to the general cluster (0x0000) for attribute ManufId (0x0005). Note: all values are little-endian. Or use '!' instead of '_' to specify cluster-specific commands: \"<cluster>!<cmd>/<bytes>\" : send a cluster specific command for cluster id <cluster> , command id <cmd> and payload <bytes> . Example ZbSend {\"Device\":\"0x1234\",\"Send\":\"0008_04/800A00\"} Send a Dimmer command (0x04) from Level Control cluster (0x0008) with payload being: Dimmer value 0x80, and transition time of 1 second (0x000A = 10 tenths of seconds). Of course the latter example could be simply: ZbSend {\"Device\":\"0x1234\",\"Send\":{\"Dimmer\":\"0x80\"} Examples ~ Plug ZbSe n d { \"device\" : \"0x4773\" , \"send\" :{ \"Power\" : \"On\" } } ZbSe n d { \"device\" : \"0x4773\" , \"send\" :{ \"Power\" : 1 } } ZbSe n d { \"device\" : \"0x4773\" , \"send\" :{ \"Power\" : false } } ZbSe n d { \"device\" : \"0x4773\" , \"send\" :{ \"Power\" : \"Toggle\" } } Read the On/Off status: (all three commands below are synonyms) ZbSe n d { \"device\" : \"0x4773\" , \"endpoint\" : \"0x03\" , \"cluster\" : \"0x0006\" , \"read\" : \"0x0000\" } ZbSe n d { \"device\" : \"0x4773\" , \"endpoint\" : \"0x03\" , \"cluster\" : \"0x0006\" , \"read\" :[ \"0x0000\" ] } ZbSe n d { \"device\" : \"0x4773\" , \"endpoint\" : 3 , \"cluster\" : 6 , \"read\" : 0 } MQT : tele / tas mo ta /SENSOR = { \"ZbReceived\" :{ \"0x4773\" :{ \"Power\" : true , \"LinkQuality\" : 52 }}} Bulb ZbSe n d { \"device\" : \"0x3D82\" , \"send\" :{ \"Power\" : \"Off\" } } ZbSe n d { \"device\" : \"0x3D82\" , \"send\" :{ \"Dimmer\" : 128 } } ZbSe n d { \"device\" : \"0x3D82\" , \"send\" :{ \"Dimmer\" : 254 } } ZbSe n d { \"device\" : \"0x3D82\" , \"endpoint\" : \"0x0B\" , \"send\" :{ \"Dimmer\" : 0 } } Receiving Commands ~ If you pair devices such as switches or remotes, you will also receive commands from those devices. When a command is received, attributes are published both in their low-level and high-level formats (if known). Low level format is the following: \"<cluster>!<cmd>\":\"<payload\" IKEA On/Off Switch {\"ZbReceived\":{\"0x3476\":{\"Device\":\"0x3476\",\"Name\":\"ikea_switch\",\"0006!01\":\"\",\"Power\":1,\"Endpoint\":1,\"LinkQuality\":134}}} The command received \"0006!01\":\"\" is Power On (0x01) from On/Off cluster (0x0006) with no payload. It is also translated as \"Power\":1 . \"Endpoint\":1 tells you from which endpoint the command was sent. Light State Tracking Once Z2T receives a command related to a light (Power, Dimmer, Color, ColorTemp), it sends right after a Read command to get the actual state of the light. This is used for Hue Emulation and Alexa support. The final attributes are read betwenn 200ms and 1000ms later, to allow for the light to achieve its target state. Example 16 : 02 : 04 MQT : tele /%topic%/ SENSOR = { \"ZbReceived\" :{ \"IKEA_remote\" :{ \"Device\" : \"0xF72F\" , \"0006!02\" : \"\" , \"Power\" : 2 , \"Endpoint\" : 1 , \"Group\" : 100 , \"LinkQuality\" : 75 }}} 16 : 02 : 05 MQT : tele /%topic%/ SENSOR = { \"ZbReceived\" :{ \"IKEA_Light\" :{ \"Device\" : \"0x5ADF\" , \"Power\" : true , \"Endpoint\" : 1 , \"LinkQuality\" : 80 }}} 16 : 02 : 06 MQT : tele /%topic%/ SENSOR = { \"ZbReceived\" :{ \"IKEA_remote\" :{ \"Device\" : \"0xF72F\" , \"0008!06\" : \"002B0500\" , \"DimmerUp\" : true , \"Endpoint\" : 1 , \"Group\" : 100 , \"LinkQuality\" : 75 }}} 16 : 02 : 08 MQT : tele /%topic%/ SENSOR = { \"ZbReceived\" :{ \"IKEA_Light\" :{ \"Device\" : \"0x5ADF\" , \"Dimmer\" : 102 , \"Endpoint\" : 1 , \"LinkQuality\" : 80 }}} Example Ikea Tradfri Remote received commands: Short press center button - \"0006!02\":\"\" and \"Power\":2 Short press dimmer up - \"0008!06\":\"002B0500\" and \"DimmerUp\":true Short press dimmer down - \"0008!02\":\"012B05000000\" and \"DimmerStep\":1 Short press arrow right - \"0005!07\":\"00010D00\" and \"ArrowClick\":0 Short press arrow left - \"0xF72F\",\"0005!07\":\"01010D00\" and \"ArrowClick\":1 Long press dimmer up - \"0008!05\":\"0054\" and \"DimmerMove\":0 Long press dimmer up release - \"0008!07\":\"\" and \"DimmerStop\":true Long press dimmer down - \"0008!01\":\"01540000\" and \"DimmerMove\":1 Long press dimmer down release - ,\"0008!03\":\"0000\" and \"DimmerStop\":true Zigbee Binding ~ Binding allows a device to send command to another device in the same Zigbee network, without any additional logic. For example, you can set a remote to control directly a group of lights, without any rules on the coordinator. The coordinator will still receive all commands. Example of direct binding ZbBind {\"Device\":\"0xC2EF\",\"ToDevice\":\"0x5ADF\",\"Endpoint\":1,\"ToEndpoint\":1,\"Cluster\":6} This command links the device 0xC2EF that will send all commands for cluster 6 (On/off cluster) frome endpoint 1 to the target device 0x5ADF on endpoint 1 . Example of group binding ZbBind {\"Device\":\"0xC2EF\",\"ToGroup\":100,\"Endpoint\":1,\"Cluster\":6} This command links the device 0xC2EF that will send all commands for cluster 6 (On/off clustre) and from endpoint 1 to the group 100 . Reponse in case of success MQT : tele /%topic%/ RESULT = { \"ZbBind\" :{ \"Device\" : \"0xF72F\" , \"Name\" : \"IKEA_Remote\" , \"Status\" : 0 , \"StatusMessage\" : \"SUCCESS\" }} Example: IKEA remote and IKEA Light IKEA remotes only support 1 group and can be linked to a light only via group numbers (no direct binding). Add the light to group 100 ZbSend {\"device\":\"IKEA_Light\",\"Send\":{\"AddGroup\":100}} Bind the remote to group 100. Note: you need to press a button on the remote right before sending this command to make sure it's not in sleep mode ZbBind {\"Device\":\"IKEA_Remote\",\"ToGroup\":100,\"Endpoint\":1,\"Cluster\":6} Zigbee Groups ~ Zigbee has a unique feature call Groups. It allows you to send a single command to a group of devices. For example: a remote can control a group of multiple lights when grouped. Zigbee groups are 16 bits arbitrary numbers that you can freely assign. When you send to a group, you don't specify a target address anymore, nor an endpoint. Groups works in two steps: first you add devices to groups, second you send commands to groups. See Zigbee Binding on how to configure a remote to send commands to a specific group. Configuring groups for devices requires to send commands. Make sure the device is powered and awake (wake-up battery powered devices). List all groups for a device ZbSend {\"device\":\"IKEA_Light\",\"Send\":{\"GetAllGroups\":true}} MQT : tele /%topic%/ SENSOR = { \"ZbReceived\" :{ \"IKEA_Light\" :{ \"Device\" : \"0x5ADF\" , \"0004<02\" : \"FF00\" , \"GetGroupCapacity\" : 255 , \"GetGroupCount\" : 0 , \"GetGroup\" :[], \"Endpoint\" : 1 , \"LinkQuality\" : 80 }}} The following response tells you: \"GetGroupCount\":1 the light belongs to one group \"GetGroup\":[100] and the group number is 100 . MQT : tele /%topic%/ SENSOR = { \"ZbReceived\" :{ \"IKEA_Light\" :{ \"Device\" : \"0x5ADF\" , \"0004<02\" : \"FF016400\" , \"GetGroupCapacity\" : 255 , \"GetGroupCount\" : 1 , \"GetGroup\" :[ 100 ], \"Endpoint\" : 1 , \"LinkQuality\" : 80 }}} Assign a group to a device ZbSend {\"device\":\"IKEA_Light\",\"Send\":{\"AddGroup\":100}} MQT : tele /%topic%/ SENSOR = { \"ZbReceived\" :{ \"IKEA_Light\" :{ \"Device\" : \"0x5ADF\" , \"0004<00\" : \"006400\" , \"AddGroup\" : 100 , \"AddGroupStatus\" : 0 , \"AddGroupStatusMsg\" : \"SUCCESS\" , \"Endpoint\" : 1 , \"LinkQuality\" : 80 }}} Or if the group already exists: MQT : tele /%topic%/ SENSOR = { \"ZbReceived\" :{ \"IKEA_Light\" :{ \"Device\" : \"0x5ADF\" , \"0004<00\" : \"8A6400\" , \"AddGroup\" : 100 , \"AddGroupStatus\" : 138 , \"AddGroupStatusMsg\" : \"DUPLICATE_EXISTS\" , \"Endpoint\" : 1 , \"LinkQuality\" : 80 }}} Remove a group ZbSend {\"device\":\"IKEA_Light\",\"Send\":{\"RemoveGroup\":100}} MQT : tele /%topic%/ SENSOR = { \"ZbReceived\" :{ \"IKEA_Light\" :{ \"Device\" : \"0x5ADF\" , \"0004<03\" : \"006400\" , \"RemoveGroup\" : 100 , \"RemoveGroupStatus\" : 0 , \"RemoveGroupStatusMsg\" : \"SUCCESS\" , \"Endpoint\" : 1 , \"LinkQuality\" : 80 }}} or if the group does not exist MQT : tele /%topic%/ SENSOR = { \"ZbReceived\" :{ \"IKEA_Light\" :{ \"Device\" : \"0x5ADF\" , \"0004<03\" : \"8B6400\" , \"RemoveGroup\" : 100 , \"RemoveGroupStatus\" : 139 , \"RemoveGroupStatusMsg\" : \"NOT_FOUND\" , \"Endpoint\" : 1 , \"LinkQuality\" : 80 }}} Remove all groups ZbSend {\"device\":\"IKEA_Light\",\"Send\":{\"RemoveAllGroups\":true}} MQT : tele /%topic%/ SENSOR = { \"ZbResponse\" :{ \"Device\" : \"0x5ADF\" , \"Name\" : \"IKEA_Light\" , \"Command\" : \"0004!04\" , \"Status\" : 0 , \"StatusMessage\" : \"SUCCESS\" , \"Endpoint\" : 1 , \"LinkQuality\" : 80 }} Sending commands to a group Just use the attribute \"Group\":<group_id> instead of \"Device\":<device> when sending a command. Example: power on all light in group 100: ZbSend {\"group\":100,\"Send\":{\"Power\":1}} set all dimmers in group 100 to 50%: ZbSend {\"group\":100,\"Send\":{\"Dimmer\":127}} Zigbee and Hue Emulation for Alexa ~ Z2T now supports Hue Emulation for Zigbee lights. It will mimic most of Zigbee gateways, and allows you to control Zigbee lights directly with Alexa, without any MQTT broker nor Alexa skill. Command ZbLight configures a Zigbee device to be Alexa controllable. Specify the number of channels the light supports: 0 Simple On/Off light 1 White Light with Dimmer 2 White Light with Dimmer and Cold/Warm White 3 RGB Light 4 RGBW Light 5 RGBCW Light, RGB and Cold/Warm White To set the light, use ZbLight <device>,<nb_of_channels . Ex: ZbLight 0x1234,2 ZbLight Kitchen_Light,1 (see ZbName) Once a light is declared, Z2T will monitor any change made to the light via Z2T or via remotes, either from a direct message or via a group message. Z2T will then send a read command to the light, between 200ms and 1000ms later, and memorize the last value. To read the last known status of a light, use ZbLight <device> Example ZbLight Kitchen_Light MQT : stat /%topic%/ RESULT = { \"ZbLight\" :{ \"Kitchen_Light\" :{ \"Device\" : \"0x5ADF\" , \"Light\" : 2 , \"Power\" : 0 , \"Dimmer\" : 130 , \"Colormode\" : 2 , \"CT\" : 350 }}} Specific Device Configuration ~ If your device pairs successfully with Zigbee2Tasmota but doesn't report on standardised endpoints you will see messages similar to: {\"ZbReceived\":{\"0x099F\":{\"0500!00\":\"010000FF0000\",\"LinkQuality\":70}}} {\"ZbReceived\":{\"0x7596\":{\"0006!01\":\"\",\"LinkQuality\":65}}} In this case you will have to use rules or an external home automation solution to parse those messages. The following section will focus only on rules to utilize the device inside Tasmota ecosystem. <!-- ### Ikea ON/OFF Switch \"ModelId\":\"TRADFRI on/off switch\",\"Manufacturer\":\"IKEA of Sweden\" Short press O - 0006!00 Short press I - 0006!01 Long press O - 0008!01 Long press I - 0008!05 Long press release O or I - 0008!07 In this example Tradfri switch reports on 0x7596 and is used to control another Tasmota light device: Rule on ZbReceived # 0x7596 # 0006 ! 00 do publish cmnd /% topic %/ POWER OFF endon on ZbReceived # 0x7596 # 0006 ! 01 do publish cmnd /% topic %/ POWER ON endon on ZbReceived # 0x7596 # 0008 ! 01 do publish cmnd /% topic %/ Dimmer - endon on ZbReceived # 0x7596 # 0008 ! 05 do publish cmnd /% topic %/ Dimmer + endon ``` --> ### Aqara Water Leak Sensor ` \"ModelId\" : \"lumi.sensor_wleak.aq1\" ` In this example sensor reports on ` 0x099F ` and sends an mqtt message to topic ` stat / leak_sensor / LEAK ` : ``` haskell Rule on ZbReceived # 0x099F # 0500 ! 00 = 010000 FF0000 do publish stat / leak_sensor / LEAK ON endon on ZbReceived # 0x099F # 0500 ! 00 = 000000 FF0000 do publish stat / leak_sensor / LEAK OFF endon Aqara Vibration Sensor ~ \"ModelId\":\"lumi.vibration.aq1\" To modify sensor sensitivity use command. Replace \"device\" with your own device name: # for high sensitivity ZbSend { \"device\" : \"vibration\" , \"Endpoint\" : 1 , \"Cluster\" : 0 , \"Manuf\" : \"0x115F\" , \"Write\" : { \"0000/FF0D%20\" : \"0x01\" }} # for medium sensitivity ZbSend { \"device\" : \"vibration\" , \"Endpoint\" : 1 , \"Cluster\" : 0 , \"Manuf\" : \"0x115F\" , \"Write\" : { \"0000/FF0D%20\" : \"0x0B\" }} # for low sensitivity ZbSend { \"device\" : \"vibration\" , \"Endpoint\" : 1 , \"Cluster\" : 0 , \"Manuf\" : \"0x115F\" , \"Write\" : { \"0000/FF0D%20\" : \"0x15\" }} Command needs to be issued shortly after pressing the device button. There will be no response to the command but you can check if the new option is active by using ZbSend { \"Device\" : \"vibration\" , \"Endpoint\" : 1 , \"Cluster\" : 0 , \"Manuf\" : \"0x115F\" , \"Read\" : \"0xFF0D\" } Received response will be : { \"ZbReceived\" : { \"vibration\" : { \"Device\" : \"0x0B2D\" , \"Name\" : \"vibration\" , \"0000/FF0D\" : 1 , \"Endpoint\" : 1 , \"LinkQuality\" : 72 }}} \"0000/FF0D\" is the key, value 1 is high sensitivity, 11 medium and 21 is low. Zigbee2Tasmota Status Codes ~ You can inspect the log output to determine whether Zigbee2Tasmota started correctly. Zigbee2Tasmota sends several status messages to inform the MQTT host about initialization. {\"ZbState\":{\"Status\":1,\"Message\":\"CC2530 booted\",\"RestartReason\":\"Watchdog\",\"MajorRel\":2,\"MinorRel\":6}} Status contains a numeric code about the status message 0 : initialization complete, Zigbee2Tasmota is running normally 1 : booting 2 : resetting CC2530 configuration 3 : starting Zigbee coordinator 20 : disabling Permit Join 21 : allowing Permit Join for 60 seconds 22 : allowing Permit Join until next boot 30 : Zigbee device connects or reconnects 31 : Received Node Descriptor information for a Zigbee device 32 : Received the list of active endpoints for a Zigbee device 33 : Received the simple Descriptor with active ZCL clusters for a Zigbee device 50 : reporting CC2530 firmware version 51 : reporting CC2530 device information and associated devices 98 : error, unsupported CC2530 firmware 99 : general error, Zigbee2Tasmota was unable to start Message (optional) a human-readable message other fields depending on the message (e.g., Status= 50 or Status= 51 ) Zigbee Internals ~ If you want a more technical explanation on how all this works read Zigbee-Internals","title":"Zigbee"},{"location":"Zigbee/#hardware","text":"This integration works with any Texas Instruments CC2530 chip based device as well as with Silicon Labs EFR32 chip based devices like Sonoff ZBBridge . A complete list of compatible Zigbee coordinators and Zigbee devices compatible with Z2T is in the Zigbee Device Compatibility Repository . While Z2T was initially designed for Texas Instruments Z-Stack firmware and protocol for CC253x based device, since then support for Silicon Labs EZSP (EmberZNet Serial Protocol) firmware has also been added. Once the Zigbee coordinator is started and communicates with Tasmota, the end result is the same and there is no difference in their operation. Flashing and installation instructions for: Sonoff ZBBridge by ITead CC2530 based devices","title":"Hardware"},{"location":"Zigbee/#introduction","text":"Before using Zigbee with Tasmota, you need to understand a few concepts. Here is a simplified comparison to the Wi-Fi equivalent (sort of). Zigbee concept Wi-Fi equivalent Zigbee coordinator The coordinator is responsible for selecting the channel, PanID, security policy, and stack profile for a network. Zigbee2Tasmota will act as a coordinator. You can have multiple coordinators as long as they have different PanIDs. Wi-Fi Access Point PanID (Personal Area Network IDentifier) This parameter is unique in a Zigbee network (16-bit integer, 0x0000\u20130x3FFF). Default: 0x1A63 SSID (the Wi-Fi network name) ShortAddr Address of the device on the Zigbee network. This address is randomly assigned when the device first connects to the coordinator (16 bits integer, 0x0000\u20130xFFF7). The coordinator has address 0x0000. You need to track which device has which address or assign a \"Friendly Name\" to each new discovered device. IP address GroupAddr Group address of a collection of devices, it allows a single message to address multiple devices at once (16 bits integer, 0x0000\u20130xFFFF). For example a remote can turn on/off a group of lights. GroupAddr 0x0000 is not assigned. Multicast Endpoint The endpoint on the coordinator or on the Zigbee device the message is sent from/to. You can see endpoints as logical device providing distinct features (8 bits integer, 1\u2013240). IP Port IEEEAddr Device hardware address (64 bits). This is unique per device and factory assigned. MAC address Channel 11-26 Default: 11 (See Zigbee-Wifi coexistence ) Wi-Fi Channel Encryption Key 128-bit encryption key. default: 0x0D0C0A08060402000F0D0B0907050301 Wi-Fi password Pairing By default the coordinator does not accept new devices unless put in pairing mode. When in pairing mode, it will accept pairing requests from any device within range. Default: pairing disabled WPS Cluster Clusters are a group of commands and attributes that define what a device can do. Think of clusters as a group of actions by function. A device can support multiple clusters to do a whole variety of tasks. The majority of clusters are defined by the ZigBee Alliance and listed in the ZigBee Cluster Library","title":"Introduction"},{"location":"Zigbee/#usage","text":"For a list of available commands see Zigbee Commands .","title":"Usage"},{"location":"Zigbee/#pairing-devices","text":"When you create a new Zigbee network, it contains no devices except the coordinator. The first step is to add devices to the network, which is called pairing . By default, and for security reasons, the Zigbee coordinator does not automatically accept new devices. To pair new devices, use ZbPermitJoin 1 . Once Zigbee2Tasmota is in pairing mode, put the Zigbee device into pairing mode. This is usually accomplished by pressing the button on the device for 5 seconds or more. To stop pairing, use ZbPermitJoin 0 . ZbPermitJoin 1 CMD : ZbPermi t Joi n 1 MQT : s tat /% t opic%/RESULT = { \"ZbPermitJoin\" : \"Done\" } MQT : tele /% t opic%/RESULT = { \"ZbState\" :{ \"Status\" : 21 , \"Message\" : \"Enable Pairing mode for 60 seconds\" }} 60 seconds later: MQT : tele /% t opic%/RESULT = { \"ZbState\" :{ \"Status\" : 20 , \"Message\" : \"Disable Pairing mode\" }} ZbPermitJoin 0 MQT : tele /% t opic%/RESULT = { \"ZbState\" :{ \"Status\" : 20 , \"Message\" : \"Disable Pairing mode\" }} Info Although this is highly discouraged, you can permanently enable Zigbee pairing, until the next reboot, with ZbPermitJoin 99 . After the device has successfully paired it will be shown in the webui with its short address and its link quality number (LQI). When it is a battery powered device, the battery percentage will be displayed as soon as it is received from the device. Devices will show friendly name once you set it.","title":"Pairing Devices"},{"location":"Zigbee/#setting-friendly-name","text":"Instead of a short address like 0x8F20 you can assign a, memorable, friendly name such as \"Bedroom_Sensor\" . See ZbName command for all options. Xiaomi Aqara Cube with address 0x128F MQT : tele /% t opic%/RESULT = { \"ZbReceived\" :{ \"0x128F\" :{ \"AqaraVibrationMode\" : \"tilt\" , \"AqaraVibrationsOrAngle\" : 162 , \"AqaraAccelerometer\" :[ -690 , 2 , 138 ], \"AqaraAngles\" :[ -78 , 0 , 11 ], \"LinkQuality\" : 158 }}} Setting its friendly name to Vibration_sensor : ZbName 0 x 128 F , Vibra t io n _se ns or CMD : ZbName 0 x 128 F , Vibra t io n _se ns or MQT : s tat /% t opic%/RESULT = { \"0x128F\" :{ \"Name\" : \"Vibration_sensor\" }} ( 10 seco n ds la ter ) ZIG : Zigbee Devices Da ta s t ore i n Flash ( 0 x 402 FF 800 - 270 by tes ) Now the sensor readings includes the friendly name: MQT : tele /% t opic%/RESULT = { \"ZbReceived\" :{ \"0x128F\" :{ \"Name\" : \"Vibration_sensor\" , \"AqaraVibrationMode\" : \"tilt\" , \"AqaraVibrationsOrAngle\" : 171 , \"AqaraAccelerometer\" :[ -691 , 12 , 130 ], \"AqaraAngles\" :[ -78 , 1 , 11 ], \"LinkQuality\" : 153 }}} If you set SetOption83 1 sensor readings will use the friendly name as JSON key, short address is added as Device : MQT : tele /% t opic%/RESULT = { \"ZbReceived\" :{ \"Vibration_sensor\" :{ \"Device\" : \"0x128F\" , \"AqaraVibrationMode\" : \"tilt\" , \"AqaraVibrationsOrAngle\" : 171 , \"AqaraAccelerometer\" :[ -691 , 8 , 136 ], \"AqaraAngles\" :[ -78 , 1 , 11 ], \"LinkQuality\" : 153 }}}","title":"Setting Friendly Name"},{"location":"Zigbee/#removing-devices","text":"To remove a device from Zigbee2Tasmota use command ZbForget <device> or ZbForget <friendlyname> .","title":"Removing Devices"},{"location":"Zigbee/#pairing-example","text":"This is an example of a pairing process for the Aqara Temperature & Humidity Sensor . To pair this sensor, issue ZbPermitJoin 1 and then press and hold the reset button for 5 seconds. The sensor LED will flash several times and you will see log entries in the console, especially this one: MQT : tele /%topic%/ SENSOR = { \"ZbState\" :{ \"Status\" : 30 , \"IEEEAddr\" : \"0x00158D00036B50AE\" , \"ShortAddr\" : \"0x8F20\" , \"PowerSource\" : false , \"ReceiveWhenIdle\" : false , \"Security\" : false }} Message with \"Status\":30 shows some characteristics of the device: Field name Value Status 30 indicates a device connect or reconnect. This is the opportunity to match IEEEAddress and short address IEEEAddr Long unique address (64 bits) of the device - factory set ShortAddr Short address (16 bits) randomly assigned to the device on this Zigbee network PowerSource true = the device is connected to a power source false = the device runs on battery ReceiveWhenIdle true = the device can receive commands when idle false = the device is not listening. Commands should be sent when the device reconnects and is idle Security Security capability (meaning unknown, to be determined)","title":"Pairing Example"},{"location":"Zigbee/#reading-sensors","text":"Most sensors will publish their readings regularly or once a significant change has happened: temperature, pressure, humidity, presence, illuminance... Sensor messages are published via MQTT when they are received from the Zigbee device. Similar to Zigbee2MQTT, Z2T tries to group and debounce sensor values when they are received within a 300ms window. Aqara Temperature & Humidity Sensor This sensor monitors humidity, temperature, and air pressure. Its Zigbee model ID is lumi.weather . This device publishes sensor values roughly every hour or when a change occurs. You can also force an update pressing the device's button. It sends two kinds of messages, either 3x standard Zigbee messages, or a single proprietary message containing all sensor values. 0x8F20 is the ShortAddress of the sensor, and its name is Kitchen if you used ZbName 0x8F20,Kithchen . MQT : tele /% t opic%/SENSOR = { \"ZbReceived\" : { \"0x8F20\" : { \"Name\" : \"Kitchen\" , \"Voltage\" : 2.995 , \"Battery\" : 98 , \"Temperature\" : 21.01 , \"Humidity\" : 53.68 , \"Pressure\" : 1004.04 , \"PressureUnit\" : \"hPa\" , \"Endpoint\" : 1 , \"LinkQuality\" : 88 }} or prefixed by name if you set SetOption83 1 MQT : tele /% t opic%/SENSOR = { \"ZbReceived\" : { \"Kitchen\" : { \"Device\" : \"0x8F20\" , \"Voltage\" : 2.995 , \"Battery\" : 98 , \"Temperature\" : 21.01 , \"Humidity\" : 53.68 , \"Pressure\" : 1004.04 , \"PressureUnit\" : \"hPa\" , \"Endpoint\" : 1 , \"LinkQuality\" : 88 }} Topic is device specific, to allow more effective retained messages, if you set SetOption89 1 MQT : tele /% t opic%/ 8 F 20 /SENSOR = { \"ZbReceived\" : { \"Kitchen\" : { \"Device\" : \"0x8F20\" , \"Voltage\" : 2.995 , \"Battery\" : 98 , \"Temperature\" : 21.01 , \"Humidity\" : 53.68 , \"Pressure\" : 1004.04 , \"PressureUnit\" : \"hPa\" , \"Endpoint\" : 1 , \"LinkQuality\" : 88 }} Supported values: Field name Value LinkQuality Stength of the Zigbee signal, between 1 and 254 (integer). See this ZigBee and WiFi Coexistence Humidity Humidity in percentage (float) Pressure and PressureUnit Atmospheric pressure (float) and unit (string) Currently only hPa (A.K.A. mbar) is supported Temperature Temperature in Celsius (float) Voltage Battery voltage (float) Battery Battery charge in percentage (integer) ModelId Model name of the Zigbee device (string) Ex: lumi.weather ScaledValue and Scale Give the raw measure and the scale correction as 10^scale And many more... If a value is not decoded, it will appear as \"<cluster>_<attr>\":<value> where <cluster> is the Zigbee ZCL Cluster of the attribute (family), <attr> is the attribute number and <value> its published value. Example \"0402_0000\":2240 is attribute 0x0000 from cluster 0x0402, which is the temperature in hundredth of \u00b0C. It is automatically converted to \"Temperature\":22.40 .","title":"Reading Sensors"},{"location":"Zigbee/#device-information","text":"You can dump the internal information gathered about connected Zigbee devices with the command ZbStatus . You can use ZbStatus2 to display all information and endpoints. If probing was successful (at pairing time or using ZbProbe ), Tasmota will automatically find the right endpoint. Depending on the number of devices you have, ZbStatus2 output can exceed the maximum MQTT message size. You can request the status of each individual device using ZbStatus2 1 , ZbStatus2 2 , ZbStatus2 3 or ZbStatus2 <friendly_name> ZbStatus1 - List all connected devices { \"ZbStatus1\" :[{ \"Device\" : \"0x6B58\" },{ \"Device\" : \"0xE9C3\" },{ \"Device\" : \"0x3D82\" }]} ZbStatus2 - Display detailed information for each device, including long address, model and manufacturer ID: { \"ZbStatus2\" :[{ \"Device\" : \"0x4773\" , \"IEEEAddr\" : \"0x7CB03EAA0A0292DD\" , \"ModelId\" : \"Plug 01\" , \"Manufacturer\" : \"OSRAM\" , \"Endpoints\" :[ \"0x03\" ]},{ \"Device\" : \"0x135D\" , \"Name\" : \"Temp_sensor\" , \"IEEEAddr\" : \"0x00158D00036B50AE\" , \"ModelId\" : \"lumi.weather\" , \"Manufacturer\" : \"LUMI\" , \"Endpoints\" :[ \"0x01\" ]}]} (formatted for readability) { \"ZbStatus2\" : [{ \"Device\" : \"0x4773\" , \"IEEEAddr\" : \"0x7CB03EAA0A0292DD\" , \"ModelId\" : \"Plug 01\" , \"Manufacturer\" : \"OSRAM\" , \"Endpoints\" : [ \"0x03\" ] }, { \"Device\" : \"0x135D\" , \"Name\" : \"Temp_sensor\" , \"IEEEAddr\" : \"0x00158D00036B50AE\" , \"ModelId\" : \"lumi.weather\" , \"Manufacturer\" : \"LUMI\" , \"Endpoints\" : [ \"0x01\" ] }] } ZbStatus3 - Display detailed information for each device, including long address, model and manufacturer ID and a list of endpoints and clusters","title":"Device Information"},{"location":"Zigbee/#understanding-endpoints-and-clusters","text":"An endpoint supports different functions separated in clusters and a device can have multiple endpoints to do different things. To simplify, think of your Zigbee device as a normal Tasmota device with a Zigbee radio instead of Wi-Fi. Each endpoint is akin to a GPIO that has connected Components or Clusters, in Zigbee terms. Cluster definitions in relation to their endpoint are determined by Zigbee Alliance . Not all manufacturers followed the proposed allocations but in general it is a cornerstone document. Z2T will automatically take the first endpoint in the list which works most of the time. You normally don't need to specify the endpoint number. In rare cases, you can force a specific endpoint.","title":"Understanding Endpoints and Clusters"},{"location":"Zigbee/#sending-device-commands","text":"You can send commands to a device or groups of devices similar to a normal Tasmota command. For example to turn on a light or switch off a plug. Here is a list of supported commands, see below how to send any unlisted command. Command Parameters Cluster number Power 1 or true or \"true\" or \"on\" : On 0 or false or \"false\" or \"off\" : Off 2 or \"toggle\" : Toggle 0x0006 Dimmer 0..254 : Dimmer value 255 is normally considered as invalid, and may be converted to 254 0x0008 DimmerUp : no parameter. Increases dimmer by 10% 0x0008 DimmerDown : no parameter. Decreases dimmer by 10% 0x0008 DimmerStop : no parameter. Stops any running increase of decrease of dimmer. 0x0008 ResetAlarm <alarmcode>,<clusterid> : (to be documented later) 0x0009 ResetAllAlarms : no parameter, (to be documented later) 0x0009 Hue 0..254 : change Hue value 0x0300 Sat 0..254 : change Sat value 0x0300 HueSat 0..254,0..254 : change both Hue and Sat values 0x0300 Color 0..65534,0..65534 : change the color using [x,y] coordinates 0x0300 CT 0..65534 : change the white color-temperature in mireds 0x0300 Shutter 0..254 : send any Shutter command (prefer the commands below) 0x0102 ShutterOpen : no parameter, open shutter 0x0102 ShutterClose : no parameter, close shutter 0x0102 ShutterStop : no parameter, stop shutter movement 0x0102 ShutterLift 0..100 : move shutter to a specific position in percent 0 %=open, 100 %=closed 0x0102 ShutterTilt 0..100 : move the shutter to the specific tilt position in percent 0x0102 The format of the command is following: ZbSend {\"Device\":\"<device>\",\"Send\":{\"<sendcmd>\":<sendparam>}} where <device> identifies the target and can be a shortaddr 0x1234 , a longaddr 0x1234567812345678 or a friendly name Kitchen . \u2003 \"<sendcmd>\":<sendparam> is the command and its parameters from the table. If the device has been correctly paired and its endpoints recorded by Z2T, you shouldn't need to specify a target endpoint. You can use an option \"endpoint\":<endpoint> parameter if Z2T can't find the correct endpoint or if you want to change from the default endpoint.","title":"Sending Device Commands"},{"location":"Zigbee/#low-level-commands","text":"There is a special syntax if you want to send arbitrary commands: \"Send\":\"<send_bytes>\" where <send_bytes> has the following syntax: \"<cluster>_<cmd>/<bytes>\" : send a non-cluster specific command for cluster id <cluster> , command id <cmd> and payload <bytes> . Example ZbSend {\"Device\":\"0x1234\",\"Send\":\"0000_00/0500\"} Send a Read command (0x00) to the general cluster (0x0000) for attribute ManufId (0x0005). Note: all values are little-endian. Or use '!' instead of '_' to specify cluster-specific commands: \"<cluster>!<cmd>/<bytes>\" : send a cluster specific command for cluster id <cluster> , command id <cmd> and payload <bytes> . Example ZbSend {\"Device\":\"0x1234\",\"Send\":\"0008_04/800A00\"} Send a Dimmer command (0x04) from Level Control cluster (0x0008) with payload being: Dimmer value 0x80, and transition time of 1 second (0x000A = 10 tenths of seconds). Of course the latter example could be simply: ZbSend {\"Device\":\"0x1234\",\"Send\":{\"Dimmer\":\"0x80\"}","title":"Low-level Commands"},{"location":"Zigbee/#examples","text":"","title":"Examples"},{"location":"Zigbee/#receiving-commands","text":"If you pair devices such as switches or remotes, you will also receive commands from those devices. When a command is received, attributes are published both in their low-level and high-level formats (if known). Low level format is the following: \"<cluster>!<cmd>\":\"<payload\" IKEA On/Off Switch {\"ZbReceived\":{\"0x3476\":{\"Device\":\"0x3476\",\"Name\":\"ikea_switch\",\"0006!01\":\"\",\"Power\":1,\"Endpoint\":1,\"LinkQuality\":134}}} The command received \"0006!01\":\"\" is Power On (0x01) from On/Off cluster (0x0006) with no payload. It is also translated as \"Power\":1 . \"Endpoint\":1 tells you from which endpoint the command was sent.","title":"Receiving Commands"},{"location":"Zigbee/#zigbee-binding","text":"Binding allows a device to send command to another device in the same Zigbee network, without any additional logic. For example, you can set a remote to control directly a group of lights, without any rules on the coordinator. The coordinator will still receive all commands. Example of direct binding ZbBind {\"Device\":\"0xC2EF\",\"ToDevice\":\"0x5ADF\",\"Endpoint\":1,\"ToEndpoint\":1,\"Cluster\":6} This command links the device 0xC2EF that will send all commands for cluster 6 (On/off cluster) frome endpoint 1 to the target device 0x5ADF on endpoint 1 . Example of group binding ZbBind {\"Device\":\"0xC2EF\",\"ToGroup\":100,\"Endpoint\":1,\"Cluster\":6} This command links the device 0xC2EF that will send all commands for cluster 6 (On/off clustre) and from endpoint 1 to the group 100 . Reponse in case of success MQT : tele /%topic%/ RESULT = { \"ZbBind\" :{ \"Device\" : \"0xF72F\" , \"Name\" : \"IKEA_Remote\" , \"Status\" : 0 , \"StatusMessage\" : \"SUCCESS\" }}","title":"Zigbee Binding"},{"location":"Zigbee/#zigbee-groups","text":"Zigbee has a unique feature call Groups. It allows you to send a single command to a group of devices. For example: a remote can control a group of multiple lights when grouped. Zigbee groups are 16 bits arbitrary numbers that you can freely assign. When you send to a group, you don't specify a target address anymore, nor an endpoint. Groups works in two steps: first you add devices to groups, second you send commands to groups. See Zigbee Binding on how to configure a remote to send commands to a specific group. Configuring groups for devices requires to send commands. Make sure the device is powered and awake (wake-up battery powered devices).","title":"Zigbee Groups"},{"location":"Zigbee/#zigbee-and-hue-emulation-for-alexa","text":"Z2T now supports Hue Emulation for Zigbee lights. It will mimic most of Zigbee gateways, and allows you to control Zigbee lights directly with Alexa, without any MQTT broker nor Alexa skill. Command ZbLight configures a Zigbee device to be Alexa controllable. Specify the number of channels the light supports: 0 Simple On/Off light 1 White Light with Dimmer 2 White Light with Dimmer and Cold/Warm White 3 RGB Light 4 RGBW Light 5 RGBCW Light, RGB and Cold/Warm White To set the light, use ZbLight <device>,<nb_of_channels . Ex: ZbLight 0x1234,2 ZbLight Kitchen_Light,1 (see ZbName) Once a light is declared, Z2T will monitor any change made to the light via Z2T or via remotes, either from a direct message or via a group message. Z2T will then send a read command to the light, between 200ms and 1000ms later, and memorize the last value. To read the last known status of a light, use ZbLight <device> Example ZbLight Kitchen_Light MQT : stat /%topic%/ RESULT = { \"ZbLight\" :{ \"Kitchen_Light\" :{ \"Device\" : \"0x5ADF\" , \"Light\" : 2 , \"Power\" : 0 , \"Dimmer\" : 130 , \"Colormode\" : 2 , \"CT\" : 350 }}}","title":"Zigbee and Hue Emulation for Alexa"},{"location":"Zigbee/#specific-device-configuration","text":"If your device pairs successfully with Zigbee2Tasmota but doesn't report on standardised endpoints you will see messages similar to: {\"ZbReceived\":{\"0x099F\":{\"0500!00\":\"010000FF0000\",\"LinkQuality\":70}}} {\"ZbReceived\":{\"0x7596\":{\"0006!01\":\"\",\"LinkQuality\":65}}} In this case you will have to use rules or an external home automation solution to parse those messages. The following section will focus only on rules to utilize the device inside Tasmota ecosystem. <!-- ### Ikea ON/OFF Switch \"ModelId\":\"TRADFRI on/off switch\",\"Manufacturer\":\"IKEA of Sweden\" Short press O - 0006!00 Short press I - 0006!01 Long press O - 0008!01 Long press I - 0008!05 Long press release O or I - 0008!07 In this example Tradfri switch reports on 0x7596 and is used to control another Tasmota light device: Rule on ZbReceived # 0x7596 # 0006 ! 00 do publish cmnd /% topic %/ POWER OFF endon on ZbReceived # 0x7596 # 0006 ! 01 do publish cmnd /% topic %/ POWER ON endon on ZbReceived # 0x7596 # 0008 ! 01 do publish cmnd /% topic %/ Dimmer - endon on ZbReceived # 0x7596 # 0008 ! 05 do publish cmnd /% topic %/ Dimmer + endon ``` --> ### Aqara Water Leak Sensor ` \"ModelId\" : \"lumi.sensor_wleak.aq1\" ` In this example sensor reports on ` 0x099F ` and sends an mqtt message to topic ` stat / leak_sensor / LEAK ` : ``` haskell Rule on ZbReceived # 0x099F # 0500 ! 00 = 010000 FF0000 do publish stat / leak_sensor / LEAK ON endon on ZbReceived # 0x099F # 0500 ! 00 = 000000 FF0000 do publish stat / leak_sensor / LEAK OFF endon","title":"Specific Device Configuration"},{"location":"Zigbee/#aqara-vibration-sensor","text":"\"ModelId\":\"lumi.vibration.aq1\" To modify sensor sensitivity use command. Replace \"device\" with your own device name: # for high sensitivity ZbSend { \"device\" : \"vibration\" , \"Endpoint\" : 1 , \"Cluster\" : 0 , \"Manuf\" : \"0x115F\" , \"Write\" : { \"0000/FF0D%20\" : \"0x01\" }} # for medium sensitivity ZbSend { \"device\" : \"vibration\" , \"Endpoint\" : 1 , \"Cluster\" : 0 , \"Manuf\" : \"0x115F\" , \"Write\" : { \"0000/FF0D%20\" : \"0x0B\" }} # for low sensitivity ZbSend { \"device\" : \"vibration\" , \"Endpoint\" : 1 , \"Cluster\" : 0 , \"Manuf\" : \"0x115F\" , \"Write\" : { \"0000/FF0D%20\" : \"0x15\" }} Command needs to be issued shortly after pressing the device button. There will be no response to the command but you can check if the new option is active by using ZbSend { \"Device\" : \"vibration\" , \"Endpoint\" : 1 , \"Cluster\" : 0 , \"Manuf\" : \"0x115F\" , \"Read\" : \"0xFF0D\" } Received response will be : { \"ZbReceived\" : { \"vibration\" : { \"Device\" : \"0x0B2D\" , \"Name\" : \"vibration\" , \"0000/FF0D\" : 1 , \"Endpoint\" : 1 , \"LinkQuality\" : 72 }}} \"0000/FF0D\" is the key, value 1 is high sensitivity, 11 medium and 21 is low.","title":"Aqara Vibration Sensor"},{"location":"Zigbee/#zigbee2tasmota-status-codes","text":"You can inspect the log output to determine whether Zigbee2Tasmota started correctly. Zigbee2Tasmota sends several status messages to inform the MQTT host about initialization. {\"ZbState\":{\"Status\":1,\"Message\":\"CC2530 booted\",\"RestartReason\":\"Watchdog\",\"MajorRel\":2,\"MinorRel\":6}} Status contains a numeric code about the status message 0 : initialization complete, Zigbee2Tasmota is running normally 1 : booting 2 : resetting CC2530 configuration 3 : starting Zigbee coordinator 20 : disabling Permit Join 21 : allowing Permit Join for 60 seconds 22 : allowing Permit Join until next boot 30 : Zigbee device connects or reconnects 31 : Received Node Descriptor information for a Zigbee device 32 : Received the list of active endpoints for a Zigbee device 33 : Received the simple Descriptor with active ZCL clusters for a Zigbee device 50 : reporting CC2530 firmware version 51 : reporting CC2530 device information and associated devices 98 : error, unsupported CC2530 firmware 99 : general error, Zigbee2Tasmota was unable to start Message (optional) a human-readable message other fields depending on the message (e.g., Status= 50 or Status= 51 )","title":"Zigbee2Tasmota Status Codes"},{"location":"Zigbee/#zigbee-internals","text":"If you want a more technical explanation on how all this works read Zigbee-Internals","title":"Zigbee Internals"},{"location":"changelog/","text":"CHANGELOG.md tracks changes after 8.5.1 Version 8.5.1 Hannah ~ Fix energy total counters #9263 , #9266 Fix crash in ZbRestore Fix reset BMP sensors when executing command SaveData and define USE_DEEPSLEEP enabled #9300 Fix status 0 message when using define USE_MQTT_TLS due to small log buffer #9305 Fix status 13 exception 9 when more than one shutter is configured Fix status 13 json message Fix Shelly 2.5 higher temperature regression from 8.2.0.1 #7991 Change replace ArduinoJson with JSMN for JSON parsing Change WakeUp uses 256 steps instead of 100 #9241 Add command SetOption110 1 to disable Zigbee auto-config when pairing new devices Add command SetOption111 1 to enable frequency output for buzzer GPIO #8994 Add command SetOption112 1 to enable friendly name in zigbee topic (use with SetOption89) Add #define USE_MQTT_AWS_IOT_LIGHT for password based AWS IoT authentication Add #define MQTT_LWT_OFFLINE and #define MQTT_LWT_ONLINE to user_config.h #9395 Add new shutter modes #9244 Add Zigbee auto-config when pairing Add support for MLX90640 IR array temperature sensor by Christian Baars Add support for VL53L1X time of flight sensor by Johann Obermeier Version 8.5.0 Hannah ~ Remove support for direct upgrade from versions before 6.6.0.11 to versions after 8.4.0.1 Change references from http://thehackbox.org/tasmota/ to http://ota.tasmota.com/tasmota/ Change triple-mode TLS via configuration in a single firmware (TLS AWS IoT, Letsencrypt and No-TLS) Change White blend mode to using command SetOption 105 instead of RGBWWTable Fix ESP32 PWM range Fix display power control #9114 Add command SetOption102 0/1 to set Baud rate for Teleinfo communication (0 = 1200 or 1 = 9600) Add command SetOption103 0/1 to set TLS mode when TLS is selected Add command SetOption104 1 to disable all MQTT retained messages Add command SetOption105 1 to enable White Blend Mode Add command SetOption106 1 to create a virtual White ColorTemp for RGBW lights Add command SetOption107 0/1 to select virtual White as (0) Warm or (1) Cold Add command SetOption108 0/1 to enable Teleinfo telemetry into Tasmota Energy MQTT (0) or Teleinfo only (1) Add command SetOption109 1 to force gen1 Alexa mode, for Echo Dot 2nd gen devices only Add command Restart 2 to halt system. Needs hardware reset or power cycle to restart #9046 Add command PowerDelta1 to PowerDelta3 to trigger on up to three phases #9134 Add Zigbee options to ZbSend Config and ReadCondig Add Zigbee better support for IKEA Motion Sensor Add Zigbee web gui widget for Battery and Temp/Humidity/Pressure sensors Add Zigbee web ui for power metering plugs Add better configuration corruption recovery #9046 Add virtual CT for 4 channels lights, emulating a 5th channel Add support for DYP ME007 ultrasonic distance sensor by Janusz Kostorz #9113 Add ESP32 Analog input support for GPIO32 to GPIO39 Add experimental support for ESP32 TTGO Watch and I2S Audio by Gerhard Mutz Version 8.4.0 George ~ BREAKING CHANGE Remove Arduino ESP8266 Core support for versions before 2.7.1 BREAKING CHANGE Change to limited support of Arduino IDE as an increasing amount of features cannot be compiled with Arduino IDE Change IRRemoteESP8266 library from v2.7.6 to v2.7.8.10, fixing Samsung and Pioneer protocols #8938 Change Adafruit_SGP30 library from v1.0.3 to v1.2.0 #8519 Change Energy JSON Total field from \"Total\":[33.736,11.717,16.978] to \"Total\":33.736,\"TotalTariff\":[11.717,16.978] Change Energy JSON ExportActive field from \"ExportActive\":[33.736,11.717,16.978] to \"ExportActive\":33.736,\"ExportTariff\":[11.717,16.978] Change ESP32 USER GPIO template representation decreasing template message size Change define USE_TASMOTA_SLAVE into USE_TASMOTA_CLIENT Change commands SlaveSend and SlaveReset into ClientSend and ClientReset Change all timer references from Arm to Enable in GUI, Timer command and JSON message BREAKING CHANGE Change Domoticz commands prefix from Domoticz to Dz Change Zigbee randomizing of parameters at first run or after Reset Fix escape of non-JSON received serial data #8329 Fix exception or watchdog on rule re-entry #8757 Add command Rule0 to change global rule parameters Add command Time 4 to display timestamp using milliseconds #8537 Add command SetOption94 0/1 to select MAX31855 or MAX6675 thermocouple support #8616 Add command SetOption97 0/1 to switch between Tuya serial speeds 9600 bps (0) or 115200 bps (1) Add command SetOption98 0/1 to provide rotary rule triggers (1) instead of controlling light (0) Add command SetOption99 0/1 to enable zero cross detection on PWM dimmer Add command SetOption100 0/1 to remove Zigbee ZbReceived value from {\"ZbReceived\":{xxx:yyy}} JSON message Add command SetOption101 0/1 to add the Zigbee source endpoint as suffix to attributes, ex Power3 instead of Power if sent from endpoint 3 Add command DzSend<type> <index>,<value1(;value2)|state> to send values or state to Domoticz Add command Module2 to configure fallback module on fast reboot #8464 Add command ( S ) SerialSend6 \\<comma seperated values> #8937 Add commands LedPwmOn 0..255 , LedPwmOff 0..255 and LedPwmMode1 0/1 to control led brightness by George #8491 Add ESP32 ethernet commands EthType 0/1 , EthAddress 0..31 and EthClockMode 0..3 Add more functionality to command Switchmode 11 and 12 #8450 Add rule trigger System#Init to allow early rule execution without wifi and mqtt initialized yet Add support for unique MQTTClient (and inherited fallback topic) by full Mac address using mqttclient DVES_%12X #8300 Add wildcard pattern ? for JSON matching in rules Add Three Phase Export Active Energy to SDM630 driver Add Zigbee options to ZbSend to write and report attributes Add Zigbee auto-responder for common attributes Add CpuFrequency to status 2 Add FlashFrequency to status 4 Add compile time interlock parameters #8759 Add compile time user template #8766 Add support for VEML6075 UVA/UVB/UVINDEX Sensor by device111 #8432 Add support for VEML7700 Ambient light intensity Sensor by device111 #8432 Add support for up to two BH1750 sensors controlled by commands BH1750Resolution and BH1750MTime #8139 Add support for up to eight MCP9808 temperature sensors by device111 #8594 Add support for BL0940 energy monitor as used in Blitzwolf BW-SHP10 #8175 Add support for Telegram bot #8619 Add support for HP303B Temperature and Pressure sensor by Robert Jaakke #8638 Add support for Energy sensor (Denky) for French Smart Metering meter provided by global Energy Providers, need a adaptater. See dedicated full blog about French teleinformation stuff Add support for ESP32 ethernet adding commands Wifi 0/1 and Ethernet 0/1 both default ON Add support for single wire LMT01 temperature Sensor by justifiably #8713 Add support for rotary encoder as light dimmer and optional color temperature if button1 still pressed #8670 Add support for switches/relays using an AC detection circuitry e.g. MOES MS-104B or BlitzWolf SS5 #8606 Add support for Schneider Electric iEM3000 series Modbus energy meter by Marius Bezuidenhout Add support for Sonoff Zigbee Bridge as module 75 #8583 Version 8.3.1 Fred ~ Change Hass discovery from using Template or Module name to new Device name #8462 Change KNX pow function to approximative pow saving 5k of code space Change Mutichannel Gas sensor pow function to approximative pow saving 5k of code space Change Quick Power Cycle detection from 4 to 7 power interrupts #4066 Fix default state of SetOption73 0 for button decoupling and send multi-press and hold MQTT messages Add command DeviceName defaults to FriendlyName1 and replaces FriendlyName1 in GUI Version 8.3.0 Fred ~ Breaking Change Device Groups multicast address and port 8270 Change PWM implementation to Arduino #7231 removing support for Core versions before 2.6.3 Change default PWM Frequency to 977 Hz from 880 Hz Change minimum PWM Frequency from 100 Hz to 40 Hz Change flash access removing support for any Core before 2.6.3 Change HM-10 sensor type detection and add features 7962 Change light scheme 2,3,4 cycle time speed from 24,48,72,... seconds to 4,6,12,24,36,48,... seconds 8034 Change remove floating point libs from IRAM Change remove MQTT Info messages on restart for DeepSleep Wake 8044 Change IRremoteESP8266 library updated to v2.7.6 Change HAss discovery by Federico Leoni 8370 Fix possible Relay toggle on (OTA) restart Fix PWM flickering during wifi connection 8046 Fix Zigbee sending wrong Sat value with Hue emulation Fix Zigbee crash with Occupancy sensor 8089 Add Zigbee command ZbRestore to restore device configuration dumped with ZbStatus 2 Add Zigbee command ZbUnbind Add Zigbee command ZbBindState and manuf attribute Add Zigbee command ZbConfig and configuration in Settings Add commands CounterDebounceLow and CounterDebounceHigh to control debouncing 8021 Add commands NrfPage , NrfIgnore , NrfScan and NrfBeacon to NRF24 Bluetooth driver 8075 Add commands GlobalTemp and GlobalHum to init sensor data 8152 Add command SO as shortcut for command SetOption Add command SetOption41 <x> to force sending gratuitous ARP every seconds Add command SetOption73 1 for button decoupling and send multi-press and hold MQTT messages by Federico Leoni 8235 Add command SetOption90 1 to disable non-json MQTT messages 8044 Add command SetOption91 1 to enable fading at startup / power on Add command SetOption92 1 to set PWM Mode from regular PWM to ColorTemp control (Xiaomi Philips ...) Add command SetOption93 1 to control caching of compressed rules Add command Sensor10 0/1/2 to control BH1750 resolution - 0 = High (default), 1 = High2, 2 = Low 8016 Add command Sensor10 31..254 to control BH1750 measurement time which defaults to 69 8016 Add command Sensor18 0..32000 to control PMS5003 sensor interval to extend lifetime by Gene Ruebsamen 8128 Add command DevGroupName to specify up to four Device Group Names 8087 Add command DevGroupSend to send an update to a Device Group 8093 Add command Ping 7176 Add command Palette to add the ability to specify a palette of colors 8150 Add support for unreachable (unplugged) Zigbee devices in Philips Hue emulation and Alexa Add support for 64x48 SSD1306 OLED 6740 Add support for Seven Segment display using HT16K33 8116 Add support for up to four MQTT GroupTopics 8014 Add support for longer template names Add support for an iAQ sensor 8107 Add support for AS3935 Lightning Sensor by device111 8130 Add console command history 7483, #8015 Add quick wifi reconnect using saved AP parameters when SetOption56 0 3189 Add more accuracy to GPS NTP server 8088 Add support for analog anemometer by Matteo Albinola 8283 Add support for OpenTherm by Yuriy Sannikov 8373 Add support for Thermostat control by arijav 8212 Add experimental basic support for Tasmota on ESP32 based on work by Joerg Schueler-Maroldt Add automatic compression of Rules to achieve ~60% compression by Stefan Hadinger Add rule trigger at root level like on loadavg<50 do power 2 endon after state command Version 8.2.0 Elliot ~ Change default my_user_config.h driver and sensor support removing most sensors and adding most drivers to tasmota.bin Change DHT driver ( 7468 , 7717 ) Change Lights: simplified gamma correction and 10 bits internal computation Change commands Prefix , Ssid , StateText , NTPServer , and FriendlyName displaying all items Change Zigbee command prefix from Zigbee* to Zb* Change MQTT message size with additional 200 characters Change display of some date and time messages from Wed Feb 19 10:45:12 2020 to 2020-02-19T10:45:12 Change IRremoteESP8266 library updated to v2.7.4 Fix PowerDelta zero power detection ( 7515 ) Fix White added to light status ( 7142 ) Fix WakeUp <x> ignores provided value ( 7473 ) Fix RGBWWTable ignored ( 7572 ) Fix commands Display and Counter from overruling command processing ( 7322 ) Fix Sonoff Bridge, Sc, L1, iFan03 and CSE7766 serial interface to forced speed, config and disable logging Fix Improved fade linearity with gamma correction Fix PWM flickering at low levels ( 7415 ) Fix LCD line and column positioning ( 7387 ) Fix Display handling of hexadecimal escape characters ( 7387 ) Fix exception 9 restart on log message in Ticker interrupt service routines NTP, Wemos and Hue emulation ( 7496 ) Fix Hass sensor discovery by Federico Leoni ( 7582 , 7548 ) Fix MaxPower functionality ( 7647 ) Fix relation between Wifi RSSI and signal strength Add command SetOption79 0/1 to enable reset of counters at teleperiod time by Andre Thomas ( 7355 ) Add command SetOption82 0/1 to limit the CT range for Alexa to 200..380 Add command SetOption84 0/1 to send AWS IoT device shadow updates (alternative to retained) Add commands SetOption85 0/1 and DevGroupShare supporting UDP Group command using GroupTopic without MQTT by Paul Diem ( 7790 ) Add command SetOption86 0/1 for PWM dimmer to turn brightness LED's off 5 seconds after last change Add command SetOption87 0/1 for PWM dimmer to turn red LED on when powered off Add command SetOption88 0/1 for PWM dimmer to let buttons control remote devices Add command SetOption89 0/1 for Zigbee distinct MQTT topics per device for SENSOR, allowing retained messages ( 7835 ) Add command ShutterButton <parameters> to control shutter(s) by to-scho ( 7403 ) Add commands SwitchMode 8 ToggleMulti, SwitchMode 9 FollowMulti and SwitchMode 10 FollowMultiInverted ( 7522 ) Add commands SwitchMode 11 PushHoldMulti and SwitchMode 12 PushHoldInverted ( 7603 ) Add commands SwitchMode 13 PushOn and SwitchMode 14 PushOnInverted ( 7912 ) Add command Buzzer -1 for infinite mode and command Buzzer -2 for following led mode ( 7623 ) Add command HumOffset -10.0 .. 10.0 to set global humidity sensor offset ( 7934 ) Add support for AdcParam parameters to control ADC0 Current Transformer Apparent Power formula by Jodi Dillon ( 7100 ) Add optional parameter <startcolor> to command Scheme <scheme>, <startcolor> to control initial start color Add web page sliders when SetOption37 128 is active allowing control of white(s) Add SerialConfig to Status 1 Add BootCount Reset Time as BCResetTime to Status 1 Add WifiPower to Status 5 Add most SetOptions as defines to my_user_config.h Add optional Wifi AccessPoint passphrase define WIFI_AP_PASSPHRASE in my_user_config.h ( 7690 ) Add SoftwareSerial to CSE7766 driver allowing different GPIOs ( 7563 ) Add rule trigger on one level deeper using syntax with two # like on zbreceived#vibration_sensor#aqaracubeside=0 do ... Add Zigbee attribute decoder for Xiaomi Aqara Cube Add ZbZNPReceived and ZbZCLReceived being published to MQTT when SetOption66 1 Add Zigbee enhanced commands decoding, added ZbPing Add Zigbee features and improvements Add Zigbee support for Hue emulation by Stefan Hadinger Add HAss Discovery support for Button and Switch triggers by Federico Leoni ( 7901 ) Add Dew Point to Temperature and Humidity sensors Add optional support for Prometheus using file xsns_91_prometheus.ino ( 7216 ) Add support for gzipped binaries Add support for Romanian language translations by Augustin Marti Add support for sensors DS18x20 and DHT family on Shelly 1 and Shelly 1PM using Shelly Add-On adapter ( 7469 ) Add support to BMP driver to enter reset state (sleep enable) when deep sleep is used in Tasmota Add support for DS1624, DS1621 Temperature sensor by Leonid Myravjev Add support for NRF24L01 as BLE-bridge for Mijia Bluetooth sensors by Christian Baars ( 7394 ) Add support for MI-BLE sensors using HM-10 Bluetooth 4.0 module by Christian Staars ( 7683 ) Add support for FiF LE-01MR energy meter by saper-2 ( 7584 ) Add support for Sensors AHT10 and AHT15 by Martin Wagner ( 7596 ) Add support for Wemos Motor Shield V1 by Denis Sborets ( 7764 ) Add support for La Crosse TX23 Anemometer by Norbert Richter ( 3146 , 7765 ) Add support for Martin Jerry/acenx/Tessan/NTONPOWER SD0x PWM dimmer switches by Paul Diem ( 7791 ) Add support for UDP Group control without MQTT by Paul Diem ( 7790 ) Add support for Jarolift rollers by Keeloq algorithm Add support for MaxBotix HRXL-MaxSonar ultrasonic range finders by Jon Little ( 7814 ) Add support for HDC1080 Temperature and Humidity sensor by Luis Teixeira ( 7888 ) Add support for ElectriQ iQ-wifiMOODL RGBW light by Ian King ( 7947 )","title":"Changelog"},{"location":"changelog/#version-851-hannah","text":"Fix energy total counters #9263 , #9266 Fix crash in ZbRestore Fix reset BMP sensors when executing command SaveData and define USE_DEEPSLEEP enabled #9300 Fix status 0 message when using define USE_MQTT_TLS due to small log buffer #9305 Fix status 13 exception 9 when more than one shutter is configured Fix status 13 json message Fix Shelly 2.5 higher temperature regression from 8.2.0.1 #7991 Change replace ArduinoJson with JSMN for JSON parsing Change WakeUp uses 256 steps instead of 100 #9241 Add command SetOption110 1 to disable Zigbee auto-config when pairing new devices Add command SetOption111 1 to enable frequency output for buzzer GPIO #8994 Add command SetOption112 1 to enable friendly name in zigbee topic (use with SetOption89) Add #define USE_MQTT_AWS_IOT_LIGHT for password based AWS IoT authentication Add #define MQTT_LWT_OFFLINE and #define MQTT_LWT_ONLINE to user_config.h #9395 Add new shutter modes #9244 Add Zigbee auto-config when pairing Add support for MLX90640 IR array temperature sensor by Christian Baars Add support for VL53L1X time of flight sensor by Johann Obermeier","title":"Version 8.5.1 Hannah"},{"location":"changelog/#version-850-hannah","text":"Remove support for direct upgrade from versions before 6.6.0.11 to versions after 8.4.0.1 Change references from http://thehackbox.org/tasmota/ to http://ota.tasmota.com/tasmota/ Change triple-mode TLS via configuration in a single firmware (TLS AWS IoT, Letsencrypt and No-TLS) Change White blend mode to using command SetOption 105 instead of RGBWWTable Fix ESP32 PWM range Fix display power control #9114 Add command SetOption102 0/1 to set Baud rate for Teleinfo communication (0 = 1200 or 1 = 9600) Add command SetOption103 0/1 to set TLS mode when TLS is selected Add command SetOption104 1 to disable all MQTT retained messages Add command SetOption105 1 to enable White Blend Mode Add command SetOption106 1 to create a virtual White ColorTemp for RGBW lights Add command SetOption107 0/1 to select virtual White as (0) Warm or (1) Cold Add command SetOption108 0/1 to enable Teleinfo telemetry into Tasmota Energy MQTT (0) or Teleinfo only (1) Add command SetOption109 1 to force gen1 Alexa mode, for Echo Dot 2nd gen devices only Add command Restart 2 to halt system. Needs hardware reset or power cycle to restart #9046 Add command PowerDelta1 to PowerDelta3 to trigger on up to three phases #9134 Add Zigbee options to ZbSend Config and ReadCondig Add Zigbee better support for IKEA Motion Sensor Add Zigbee web gui widget for Battery and Temp/Humidity/Pressure sensors Add Zigbee web ui for power metering plugs Add better configuration corruption recovery #9046 Add virtual CT for 4 channels lights, emulating a 5th channel Add support for DYP ME007 ultrasonic distance sensor by Janusz Kostorz #9113 Add ESP32 Analog input support for GPIO32 to GPIO39 Add experimental support for ESP32 TTGO Watch and I2S Audio by Gerhard Mutz","title":"Version 8.5.0 Hannah"},{"location":"changelog/#version-840-george","text":"BREAKING CHANGE Remove Arduino ESP8266 Core support for versions before 2.7.1 BREAKING CHANGE Change to limited support of Arduino IDE as an increasing amount of features cannot be compiled with Arduino IDE Change IRRemoteESP8266 library from v2.7.6 to v2.7.8.10, fixing Samsung and Pioneer protocols #8938 Change Adafruit_SGP30 library from v1.0.3 to v1.2.0 #8519 Change Energy JSON Total field from \"Total\":[33.736,11.717,16.978] to \"Total\":33.736,\"TotalTariff\":[11.717,16.978] Change Energy JSON ExportActive field from \"ExportActive\":[33.736,11.717,16.978] to \"ExportActive\":33.736,\"ExportTariff\":[11.717,16.978] Change ESP32 USER GPIO template representation decreasing template message size Change define USE_TASMOTA_SLAVE into USE_TASMOTA_CLIENT Change commands SlaveSend and SlaveReset into ClientSend and ClientReset Change all timer references from Arm to Enable in GUI, Timer command and JSON message BREAKING CHANGE Change Domoticz commands prefix from Domoticz to Dz Change Zigbee randomizing of parameters at first run or after Reset Fix escape of non-JSON received serial data #8329 Fix exception or watchdog on rule re-entry #8757 Add command Rule0 to change global rule parameters Add command Time 4 to display timestamp using milliseconds #8537 Add command SetOption94 0/1 to select MAX31855 or MAX6675 thermocouple support #8616 Add command SetOption97 0/1 to switch between Tuya serial speeds 9600 bps (0) or 115200 bps (1) Add command SetOption98 0/1 to provide rotary rule triggers (1) instead of controlling light (0) Add command SetOption99 0/1 to enable zero cross detection on PWM dimmer Add command SetOption100 0/1 to remove Zigbee ZbReceived value from {\"ZbReceived\":{xxx:yyy}} JSON message Add command SetOption101 0/1 to add the Zigbee source endpoint as suffix to attributes, ex Power3 instead of Power if sent from endpoint 3 Add command DzSend<type> <index>,<value1(;value2)|state> to send values or state to Domoticz Add command Module2 to configure fallback module on fast reboot #8464 Add command ( S ) SerialSend6 \\<comma seperated values> #8937 Add commands LedPwmOn 0..255 , LedPwmOff 0..255 and LedPwmMode1 0/1 to control led brightness by George #8491 Add ESP32 ethernet commands EthType 0/1 , EthAddress 0..31 and EthClockMode 0..3 Add more functionality to command Switchmode 11 and 12 #8450 Add rule trigger System#Init to allow early rule execution without wifi and mqtt initialized yet Add support for unique MQTTClient (and inherited fallback topic) by full Mac address using mqttclient DVES_%12X #8300 Add wildcard pattern ? for JSON matching in rules Add Three Phase Export Active Energy to SDM630 driver Add Zigbee options to ZbSend to write and report attributes Add Zigbee auto-responder for common attributes Add CpuFrequency to status 2 Add FlashFrequency to status 4 Add compile time interlock parameters #8759 Add compile time user template #8766 Add support for VEML6075 UVA/UVB/UVINDEX Sensor by device111 #8432 Add support for VEML7700 Ambient light intensity Sensor by device111 #8432 Add support for up to two BH1750 sensors controlled by commands BH1750Resolution and BH1750MTime #8139 Add support for up to eight MCP9808 temperature sensors by device111 #8594 Add support for BL0940 energy monitor as used in Blitzwolf BW-SHP10 #8175 Add support for Telegram bot #8619 Add support for HP303B Temperature and Pressure sensor by Robert Jaakke #8638 Add support for Energy sensor (Denky) for French Smart Metering meter provided by global Energy Providers, need a adaptater. See dedicated full blog about French teleinformation stuff Add support for ESP32 ethernet adding commands Wifi 0/1 and Ethernet 0/1 both default ON Add support for single wire LMT01 temperature Sensor by justifiably #8713 Add support for rotary encoder as light dimmer and optional color temperature if button1 still pressed #8670 Add support for switches/relays using an AC detection circuitry e.g. MOES MS-104B or BlitzWolf SS5 #8606 Add support for Schneider Electric iEM3000 series Modbus energy meter by Marius Bezuidenhout Add support for Sonoff Zigbee Bridge as module 75 #8583","title":"Version 8.4.0 George"},{"location":"changelog/#version-831-fred","text":"Change Hass discovery from using Template or Module name to new Device name #8462 Change KNX pow function to approximative pow saving 5k of code space Change Mutichannel Gas sensor pow function to approximative pow saving 5k of code space Change Quick Power Cycle detection from 4 to 7 power interrupts #4066 Fix default state of SetOption73 0 for button decoupling and send multi-press and hold MQTT messages Add command DeviceName defaults to FriendlyName1 and replaces FriendlyName1 in GUI","title":"Version 8.3.1 Fred"},{"location":"changelog/#version-830-fred","text":"Breaking Change Device Groups multicast address and port 8270 Change PWM implementation to Arduino #7231 removing support for Core versions before 2.6.3 Change default PWM Frequency to 977 Hz from 880 Hz Change minimum PWM Frequency from 100 Hz to 40 Hz Change flash access removing support for any Core before 2.6.3 Change HM-10 sensor type detection and add features 7962 Change light scheme 2,3,4 cycle time speed from 24,48,72,... seconds to 4,6,12,24,36,48,... seconds 8034 Change remove floating point libs from IRAM Change remove MQTT Info messages on restart for DeepSleep Wake 8044 Change IRremoteESP8266 library updated to v2.7.6 Change HAss discovery by Federico Leoni 8370 Fix possible Relay toggle on (OTA) restart Fix PWM flickering during wifi connection 8046 Fix Zigbee sending wrong Sat value with Hue emulation Fix Zigbee crash with Occupancy sensor 8089 Add Zigbee command ZbRestore to restore device configuration dumped with ZbStatus 2 Add Zigbee command ZbUnbind Add Zigbee command ZbBindState and manuf attribute Add Zigbee command ZbConfig and configuration in Settings Add commands CounterDebounceLow and CounterDebounceHigh to control debouncing 8021 Add commands NrfPage , NrfIgnore , NrfScan and NrfBeacon to NRF24 Bluetooth driver 8075 Add commands GlobalTemp and GlobalHum to init sensor data 8152 Add command SO as shortcut for command SetOption Add command SetOption41 <x> to force sending gratuitous ARP every seconds Add command SetOption73 1 for button decoupling and send multi-press and hold MQTT messages by Federico Leoni 8235 Add command SetOption90 1 to disable non-json MQTT messages 8044 Add command SetOption91 1 to enable fading at startup / power on Add command SetOption92 1 to set PWM Mode from regular PWM to ColorTemp control (Xiaomi Philips ...) Add command SetOption93 1 to control caching of compressed rules Add command Sensor10 0/1/2 to control BH1750 resolution - 0 = High (default), 1 = High2, 2 = Low 8016 Add command Sensor10 31..254 to control BH1750 measurement time which defaults to 69 8016 Add command Sensor18 0..32000 to control PMS5003 sensor interval to extend lifetime by Gene Ruebsamen 8128 Add command DevGroupName to specify up to four Device Group Names 8087 Add command DevGroupSend to send an update to a Device Group 8093 Add command Ping 7176 Add command Palette to add the ability to specify a palette of colors 8150 Add support for unreachable (unplugged) Zigbee devices in Philips Hue emulation and Alexa Add support for 64x48 SSD1306 OLED 6740 Add support for Seven Segment display using HT16K33 8116 Add support for up to four MQTT GroupTopics 8014 Add support for longer template names Add support for an iAQ sensor 8107 Add support for AS3935 Lightning Sensor by device111 8130 Add console command history 7483, #8015 Add quick wifi reconnect using saved AP parameters when SetOption56 0 3189 Add more accuracy to GPS NTP server 8088 Add support for analog anemometer by Matteo Albinola 8283 Add support for OpenTherm by Yuriy Sannikov 8373 Add support for Thermostat control by arijav 8212 Add experimental basic support for Tasmota on ESP32 based on work by Joerg Schueler-Maroldt Add automatic compression of Rules to achieve ~60% compression by Stefan Hadinger Add rule trigger at root level like on loadavg<50 do power 2 endon after state command","title":"Version 8.3.0 Fred"},{"location":"changelog/#version-820-elliot","text":"Change default my_user_config.h driver and sensor support removing most sensors and adding most drivers to tasmota.bin Change DHT driver ( 7468 , 7717 ) Change Lights: simplified gamma correction and 10 bits internal computation Change commands Prefix , Ssid , StateText , NTPServer , and FriendlyName displaying all items Change Zigbee command prefix from Zigbee* to Zb* Change MQTT message size with additional 200 characters Change display of some date and time messages from Wed Feb 19 10:45:12 2020 to 2020-02-19T10:45:12 Change IRremoteESP8266 library updated to v2.7.4 Fix PowerDelta zero power detection ( 7515 ) Fix White added to light status ( 7142 ) Fix WakeUp <x> ignores provided value ( 7473 ) Fix RGBWWTable ignored ( 7572 ) Fix commands Display and Counter from overruling command processing ( 7322 ) Fix Sonoff Bridge, Sc, L1, iFan03 and CSE7766 serial interface to forced speed, config and disable logging Fix Improved fade linearity with gamma correction Fix PWM flickering at low levels ( 7415 ) Fix LCD line and column positioning ( 7387 ) Fix Display handling of hexadecimal escape characters ( 7387 ) Fix exception 9 restart on log message in Ticker interrupt service routines NTP, Wemos and Hue emulation ( 7496 ) Fix Hass sensor discovery by Federico Leoni ( 7582 , 7548 ) Fix MaxPower functionality ( 7647 ) Fix relation between Wifi RSSI and signal strength Add command SetOption79 0/1 to enable reset of counters at teleperiod time by Andre Thomas ( 7355 ) Add command SetOption82 0/1 to limit the CT range for Alexa to 200..380 Add command SetOption84 0/1 to send AWS IoT device shadow updates (alternative to retained) Add commands SetOption85 0/1 and DevGroupShare supporting UDP Group command using GroupTopic without MQTT by Paul Diem ( 7790 ) Add command SetOption86 0/1 for PWM dimmer to turn brightness LED's off 5 seconds after last change Add command SetOption87 0/1 for PWM dimmer to turn red LED on when powered off Add command SetOption88 0/1 for PWM dimmer to let buttons control remote devices Add command SetOption89 0/1 for Zigbee distinct MQTT topics per device for SENSOR, allowing retained messages ( 7835 ) Add command ShutterButton <parameters> to control shutter(s) by to-scho ( 7403 ) Add commands SwitchMode 8 ToggleMulti, SwitchMode 9 FollowMulti and SwitchMode 10 FollowMultiInverted ( 7522 ) Add commands SwitchMode 11 PushHoldMulti and SwitchMode 12 PushHoldInverted ( 7603 ) Add commands SwitchMode 13 PushOn and SwitchMode 14 PushOnInverted ( 7912 ) Add command Buzzer -1 for infinite mode and command Buzzer -2 for following led mode ( 7623 ) Add command HumOffset -10.0 .. 10.0 to set global humidity sensor offset ( 7934 ) Add support for AdcParam parameters to control ADC0 Current Transformer Apparent Power formula by Jodi Dillon ( 7100 ) Add optional parameter <startcolor> to command Scheme <scheme>, <startcolor> to control initial start color Add web page sliders when SetOption37 128 is active allowing control of white(s) Add SerialConfig to Status 1 Add BootCount Reset Time as BCResetTime to Status 1 Add WifiPower to Status 5 Add most SetOptions as defines to my_user_config.h Add optional Wifi AccessPoint passphrase define WIFI_AP_PASSPHRASE in my_user_config.h ( 7690 ) Add SoftwareSerial to CSE7766 driver allowing different GPIOs ( 7563 ) Add rule trigger on one level deeper using syntax with two # like on zbreceived#vibration_sensor#aqaracubeside=0 do ... Add Zigbee attribute decoder for Xiaomi Aqara Cube Add ZbZNPReceived and ZbZCLReceived being published to MQTT when SetOption66 1 Add Zigbee enhanced commands decoding, added ZbPing Add Zigbee features and improvements Add Zigbee support for Hue emulation by Stefan Hadinger Add HAss Discovery support for Button and Switch triggers by Federico Leoni ( 7901 ) Add Dew Point to Temperature and Humidity sensors Add optional support for Prometheus using file xsns_91_prometheus.ino ( 7216 ) Add support for gzipped binaries Add support for Romanian language translations by Augustin Marti Add support for sensors DS18x20 and DHT family on Shelly 1 and Shelly 1PM using Shelly Add-On adapter ( 7469 ) Add support to BMP driver to enter reset state (sleep enable) when deep sleep is used in Tasmota Add support for DS1624, DS1621 Temperature sensor by Leonid Myravjev Add support for NRF24L01 as BLE-bridge for Mijia Bluetooth sensors by Christian Baars ( 7394 ) Add support for MI-BLE sensors using HM-10 Bluetooth 4.0 module by Christian Staars ( 7683 ) Add support for FiF LE-01MR energy meter by saper-2 ( 7584 ) Add support for Sensors AHT10 and AHT15 by Martin Wagner ( 7596 ) Add support for Wemos Motor Shield V1 by Denis Sborets ( 7764 ) Add support for La Crosse TX23 Anemometer by Norbert Richter ( 3146 , 7765 ) Add support for Martin Jerry/acenx/Tessan/NTONPOWER SD0x PWM dimmer switches by Paul Diem ( 7791 ) Add support for UDP Group control without MQTT by Paul Diem ( 7790 ) Add support for Jarolift rollers by Keeloq algorithm Add support for MaxBotix HRXL-MaxSonar ultrasonic range finders by Jon Little ( 7814 ) Add support for HDC1080 Temperature and Humidity sensor by Luis Teixeira ( 7888 ) Add support for ElectriQ iQ-wifiMOODL RGBW light by Ian King ( 7947 )","title":"Version 8.2.0 Elliot"},{"location":"nymea/","text":"nymea ~ nymea is an open source IoT platform. It can be used in various IoT applications such as smart home appliances, IoT technology gateways or general \"thing\" automation. nymea is technology agnostic and uses a plugin framework to extend functionality towards different device types, online services or data transports. Using nymea-plugin-tasmota it can also interact with tasmota based devices. nymea consists of three main parts: nymea:core, nymea:app and nymea:cloud. nymea:core is the core piece of nymea and is meant to be installed on a persistent node in your network or the internet. It connects to devices and services and manages them using automation rules. Typically, nymea:core is installed on a IoT \"box\", such as a raspberry Pi or the nymea:box, however, it can be installed on Desktop PCs (Linux based), cloud servers, VM's or any other machine running Linux. nymea hosts pre-built packages for Ubuntu and Debian GNU/Linux as well as Snap packages which can be installed on any major Linux Distribution. nymea:app is the frontend for nymea:core. It is used to configure the system as well as interact with it. It allows to control configured IoT devices, monitor states and logs and set up automation rules. nymea:cloud is the cloud connectivity suite. It is optional (nymea can work fully offline, not requiring any registration or online service at all) and extends nymea with features such as easy remote connection without having to fiddle with firewall ports and allows to send nymea:core push notifications to phones/tablets having nymea:app installed. More information about nymea can be found at the nymea website and the nymea wiki . Configuring Sonoff/Tasmota devices for use with nymea ~ Requirements ~ A working nymea installation (see nymea wiki for install instructions) A Tasmota device connected to the same network as nymea:core Once those above requirements are met, use nymea:app to add the sonoff device. Depending how you've set it up it will appear as a switch or light bulb in nymea. How does it work? ~ nymea:core features an internal MQTT broker. There is no need to set up an external MQTT broker. Also, during the setup, nymea will configure the Tasmota device. The only thing required is the IP address of the Tasmota device. Please note that for this to work the nymea internal MQTT broker needs to be enabled. This is the default setting so there should not be the need to manually configure anything unless you've previously disabled the internal MQTT broker. Support, troubleshooting, contributing ~ You are welcome to report issues and feature requests in the nymea bug trackers on nymea:core's github page and the nymea app github page as well as ask for help or just discuss about Tasmota and nymea in the nymea forum .","title":"nymea"},{"location":"nymea/#nymea","text":"nymea is an open source IoT platform. It can be used in various IoT applications such as smart home appliances, IoT technology gateways or general \"thing\" automation. nymea is technology agnostic and uses a plugin framework to extend functionality towards different device types, online services or data transports. Using nymea-plugin-tasmota it can also interact with tasmota based devices. nymea consists of three main parts: nymea:core, nymea:app and nymea:cloud. nymea:core is the core piece of nymea and is meant to be installed on a persistent node in your network or the internet. It connects to devices and services and manages them using automation rules. Typically, nymea:core is installed on a IoT \"box\", such as a raspberry Pi or the nymea:box, however, it can be installed on Desktop PCs (Linux based), cloud servers, VM's or any other machine running Linux. nymea hosts pre-built packages for Ubuntu and Debian GNU/Linux as well as Snap packages which can be installed on any major Linux Distribution. nymea:app is the frontend for nymea:core. It is used to configure the system as well as interact with it. It allows to control configured IoT devices, monitor states and logs and set up automation rules. nymea:cloud is the cloud connectivity suite. It is optional (nymea can work fully offline, not requiring any registration or online service at all) and extends nymea with features such as easy remote connection without having to fiddle with firewall ports and allows to send nymea:core push notifications to phones/tablets having nymea:app installed. More information about nymea can be found at the nymea website and the nymea wiki .","title":"nymea"},{"location":"nymea/#configuring-sonofftasmota-devices-for-use-with-nymea","text":"","title":"Configuring Sonoff/Tasmota devices for use with nymea"},{"location":"nymea/#requirements","text":"A working nymea installation (see nymea wiki for install instructions) A Tasmota device connected to the same network as nymea:core Once those above requirements are met, use nymea:app to add the sonoff device. Depending how you've set it up it will appear as a switch or light bulb in nymea.","title":"Requirements"},{"location":"nymea/#how-does-it-work","text":"nymea:core features an internal MQTT broker. There is no need to set up an external MQTT broker. Also, during the setup, nymea will configure the Tasmota device. The only thing required is the IP address of the Tasmota device. Please note that for this to work the nymea internal MQTT broker needs to be enabled. This is the default setting so there should not be the need to manually configure anything unless you've previously disabled the internal MQTT broker.","title":"How does it work?"},{"location":"nymea/#support-troubleshooting-contributing","text":"You are welcome to report issues and feature requests in the nymea bug trackers on nymea:core's github page and the nymea app github page as well as ask for help or just discuss about Tasmota and nymea in the nymea forum .","title":"Support, troubleshooting, contributing"},{"location":"openHAB/","text":"The \"open Home Automation Bus\" ( openHAB ) is an open source, technology agnostic home automation platform which runs as the center of your smart home. Besides more than 400 other add-ons for all kinds of technologies, openHAB provides an MQTT add-on (\"binding\") to interface with systems like Tasmota. By following the guide below you'll be able to observe, control and manage your Tasmota modules from your openHAB system. If you are new to openHAB, please learn about the basic concepts and the initial setup. The below article will not cover any basics which are out of scope to the Tasmota integration. Example Result: The screenshot of an openHAB Sitemap below features a few Sonoff modules for lighting, two modified Sonoff Basic with sensors for temperature and humidity readings and two Sonoff Pow for power measurements of a washing machine and dishwasher: Requirements ~ Working openHAB installation ( see documentation ) Configured Tasmota device (accessible from your local network) MQTT broker available (e.g. Eclipse Mosquitto via openHABian ) A basic understanding of MQTT Working and tested connection between openHAB and the MQTT broker (optional) Standalone MQTT client (e.g. MQTT Explorer ) to observe and identify messages on the MQTT broker If not done yet, you first need to install and activate the MQTT and the JsonPath transformation , e.g. via the openHAB Paper UI Add-ons section. MQTTv1 vs. MQTTv2 Binding Information Please note that since mqtt1 is a legacy binding for years now, it will no longer receive updates or fixes. See older version of this tutorial on how to integrate Tasmota using this binding if you are using mqtt1 - but be advised that it's not recommended anymore, it's better to upgrade to MQTTv2 binding. See openHAB announcement of MQTTv2 for details on how to change your configuration. MQTTv2 Integration ~ Configuration is split throughout some openHAB configuration files. First we need to set up a MQTT connection and Tasmota things - you will need a separate thing for every Tasmota device you use. In the example configuration you can see a non-default Full Topic definition. For your real world device simply set up items for all Tasmota MQTT topics you are interested in. Examples for most needed topics are given below, see section Discovering Interesting Topics below on how to watch the raw MQTT data. Some Tasmota topics are JSON encoded, the JSONPATH transformation can be used to extract this data. You'll need to replace the given example device topic name (e.g. \"Tasmota_TH\") by the one chosen for your module. .things File: Bridge mqtt : broker : myMQTTBroker \"My only one and best MQTT server\" [ host = \"IPofBroker\" , username = \"myUser\" , password = \"myPassword\" , clientID = \"myopenHABMQTTClient\" ] Thing mqtt : topic : tasmota : tasmota_TH \"Light_TH\" ( mqtt : broker : myMQTTBroker ) { Channels : // Sonoff Basic / Sonoff S20 Smart Socket (Read and switch on-state) Type switch : PowerSwitch [ stateTopic = \"stat/tasmota_TH/POWER\" , commandTopic = \"cmnd/tasmota_TH/POWER\" , on = \"ON\" , off = \"OFF\" ] // Sonoff Pow (read current wattage; for read and switch on-state see above) Type number : Power [ stateTopic = \"tele/tasmota_TH/SENSOR\" , transformationPattern = \"JSONPATH:$.ENERGY.Power\" ] // devices including AM2301 temperature sensor Type number : Temperature [ stateTopic = \"tele/tasmota_TH/SENSOR\" , transformationPattern = \"JSONPATH:$.AM2301.Temperature\" ] // Tasmota Status Type string : Version [ stateTopic = \"stat/tasmota_TH/STATUS2\" , transformationPattern = \"JSONPATH:$.StatusFWR.Version\" ] Type switch : Reachable [ stateTopic = \"tele/tasmota_TH/LWT\" , transformationPattern = \"MAP:tasmota-reachable.map\" ] // Diagnostics: Define specific for what you really need on a regular basis, use standalone MQTT client for troubleshooting Type string : RestartReason [ stateTopic = \"tele/tasmota_TH/INFO3\" , transformationPattern = \"JSONPATH:$.RestartReason\" ] // old one, have to query it Type string : Version2 [ stateTopic = \"stat/tasmota_TH/STATUS2\" , transformationPattern = \"JSONPATH:$.StatusFWR.Version\" ] // new one - comes for free at startup Type string : Version [ stateTopic = \"tele/tasmota_TH/INFO1\" , transformationPattern = \"JSONPATH:$.Version\" ] Type number : RSSI [ stateTopic = \"tele/tasmota_TH/STATE\" , transformationPattern = \"JSONPATH:$.Wifi.RSSI\" ] Type string : WifiDowntime [ stateTopic = \"tele/tasmota_TH/STATE\" , transformationPattern = \"JSONPATH:$.Wifi.Downtime\" ] Type number : LoadAvg [ stateTopic = \"tele/tasmota_TH/STATE\" , transformationPattern = \"JSONPATH:$.LoadAvg\" ] Type number : Uptime [ stateTopic = \"tele/tasmota_TH/STATE\" , transformationPattern = \"JSONPATH:$.UptimeSec\" ] Type string : Result [ stateTopic = \"stat/tasmota_TH/RESULT\" ] } .items File: For every property your device exposes, you need to define an item, linked to corresponding channel of your Tasmota thing. // device specific properties Switch Switch_TH \"Switch_TH\" { channel = \"mqtt:topic:tasmota:tasmota_TH:PowerSwitch\" } Number : Temperature Switch_TH_Temp \"Temperature [%.1f \u00b0C]\" < temperature > { channel = \"mqtt:topic:tasmota:tasmota_TH:Temperature\" } Number : Power Power \"Power [%.1f W]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:Power\" } // Tasmota Status String Tasmota_Version \"Tasmota Version [%s]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:Version\" , channel = \"mqtt:topic:tasmota:tasmota_TH:Version2\" } Switch Tasmota_Reachable \"Reachable\" { channel = \"mqtt:topic:tasmota:tasmota_TH:Reachable\" } // Diagnostics String Tasmota_RestartReason \"Restart Reason [%s]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:RestartReason\" } Number : Dimensionless Tasmota_RSSI \"Signal [%d %%]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:RSSI\" } String Tasmota_WifiDowntime \"Wifi Downtime [%s]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:WifiDowntime\" } Number : Dimensionless Tasmota_LoadAvg \"Load [%d %%]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:LoadAvg\" } String Tasmota_Result \"Result [%s]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:Result\" } Number : Time Tasmota_Uptime \"Uptime [%.1f s]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:Uptime\" } // Maintenance (described below) String Tasmota_Action \"Tasmota Action\" .sitemap File: // device specific properties Switch item = Switch_TH Text item = Switch_TH_Temp Text item = Power // Maintenance Switch item = Tasmota_Action mappings = [ restart = \"Restart\" , queryFW = \"Query FW\" , upgrade = \"Upgrade FW\" ] // Tasmota Status Text item = Tasmota_Version Text item = Tasmota_Reachable // Diagnostics Text item = Tasmota_RestartReason Text item = Tasmota_RSSI Text item = Tasmota_WifiDowntime Text item = Tasmota_LoadAvg Text item = Tasmota_Uptime label = \"Uptime [%.1f d]\" Text item = Tasmota_Result The \"LWT\" topic ( \"Last Will and Testament\" ) will receive regular \"Online\" messages by the module and an \"Offline\" message a short time after the module is disconnected, generated by the MQTT broker. These messages are transformed to a valid ON / OFF state by the MAP transformation. Of course you can implement Unreachable instead of Reachable if you prefer. The following transformation file is needed: tasmota-reachable.map F\u00edle: Online = ON Offline = OFF Maintenance Actions ~ A home automation system setup would not be complete without a certain maintenance automation! Add the following elements to your openHAB setup to be able to perform actions on your Tasmota devices by the press of a simple sitemap button. The example below includes upgrading the firmware of all devices. A shoutout to @evilgreen for the idea and a big thanks to @smadds for providing the idea of a public firmware server. tasmota_maintenance.rules File for Maintenance Actions: // Work with grouptopic, addressing ALL modules at once, easiest solution val tasmota_device_ids = newArrayList ( \"tasmotas\" ) // OR // Work with a list of selected Tasmota modules //val tasmota_device_ids = newArrayList( // \"tasmota_A00EEA\", // //\u2026 add all your modules here, don't forget some! // \"tasmota_E8A6E4\" //) rule \"Tasmota Maintenance\" when Item Tasmota_Action received command then logInfo ( \"tasmota_maintenance.rules\" , \"Tasmota Maintenance on all devices: \" + receivedCommand ) val actionsBroker = getActions ( \"mqtt\" , \"mqtt:broker:MyMQTTBroker\" ) // change to your broker name! for ( String device_id : tasmota_device_ids ) { switch ( receivedCommand ) { case \"restart\" : actionsBroker . publishMQTT ( \"cmnd/\" + device_id + \"/restart\" , \"1\" ) case \"queryFW\" : actionsBroker . publishMQTT ( \"cmnd/\" + device_id + \"/status\" , \"2\" ) case \"upgrade\" : { // one could change OTA URL using MQTT but if you use different breeds (basic, ir, sensor, ...) of Tasmota, you would lose them // it's better to configure OTA url at each device (default) and just trigger upgrade - they will use OTA URL saved in your device. //actionsBroker.publishMQTT( \"cmnd/\" + device_id + \"/otaurl\", \"http://ota.tasmota.com/tasmota/release/tasmota.bin\") actionsBroker . publishMQTT ( \"cmnd/\" + device_id + \"/upgrade\" , \"1\" ) } } } createTimer ( now . plusSeconds ( 1 ))[ | Tasmota_Action . postUpdate ( UNDEF )] end Comparing your device firmware with the current Tasmota GitHub Release ~ Knowing your devices firmware version(s) is good. Being able to compare it with the current release directly, is even better. You can archive this by combining the maintenance actions with the openHAB http binding, the JsonPath transformation and the GitHub API. Just extend the maintenance setup with the following Item and config: http.cfg: # Tasmota Release Version ( cached twice a day ) tasmotaRelease . url = https : //api.github.com/repos/arendst/Tasmota/tags tasmotaRelease . updateInterval = 43200000 tasmota.items: String Tasmota_Current_FW_Available \"Current Release [%s]\" { http = \"<[tasmotaRelease:10000:JSONPATH($[0].name)]\" } With this item in your sitemap, you will now see the latest release/tag from Tasmota repository. Discovering Interesting Topics ~ Additional or further interesting topics are easily identified by reading up on the Tasmota wiki and by subscribing to the modules topics. Subscribe to all topics of one module using MQTT wildcard topic string +/tasmota_XYZ/# (string depends on your user-configured Topic/FullTopic). Configure items for the identified topics similar to the ones below. Example: MQTT messages published by a Sonoff Pow module are shown below (using mosquitto_sub ). The module reports its device state and energy readings periodically. In the second half of the example the module relay was switched into the OFF position. $ mosquitto_sub - h localhost - t \"+/tasmota_E8A6E4/#\" - v tele / tasmota - E8A6E4 / LWT Online tele / tasmota - E8A6E4 / UPTIME { \"Time\" : \"2017-07-25T12:02:00\" , \"Uptime\" : 68 } tele / tasmota - E8A6E4 / STATE { \"Time\" : \"2017-07-25T12:06:28\" , \"Uptime\" : 68 , \"Vcc\" : 3.122 , \"POWER\" : \"POWER\" , \"Wifi\" : { \"AP\" : 1 , \"SSID\" : \"HotelZurBirke\" , \"RSSI\" : 100 , \"APMac\" : \"24:65:11:BF:12:D8\" }} tele / tasmota - E8A6E4 / ENERGY { \"Time\" : \"2017-07-25T12:06:28\" , \"Total\" : 0.640 , \"Yesterday\" : 0.007 , \"Today\" : 0.003 , \"Period\" : 0 , \"Power\" : 0 , \"Factor\" : 0.00 , \"Voltage\" : 0 , \"Current\" : 0.000 } tele / tasmota - E8A6E4 / STATE { \"Time\" : \"2017-07-25T12:11:28\" , \"Uptime\" : 68 , \"Vcc\" : 3.122 , \"POWER\" : \"POWER\" , \"Wifi\" : { \"AP\" : 1 , \"SSID\" : \"HotelZurBirke\" , \"RSSI\" : 100 , \"APMac\" : \"24:65:11:BF:12:D8\" }} tele / tasmota - E8A6E4 / ENERGY { \"Time\" : \"2017-07-25T12:11:28\" , \"Total\" : 0.640 , \"Yesterday\" : 0.007 , \"Today\" : 0.003 , \"Period\" : 0 , \"Power\" : 0 , \"Factor\" : 0.00 , \"Voltage\" : 0 , \"Current\" : 0.000 } cmnd / tasmota - E8A6E4 / POWER OFF stat / tasmota - E8A6E4 / RESULT { \"POWER\" : \"OFF\" } stat / tasmota - E8A6E4 / POWER OFF Following this method, the behavior-linked messages can be identified and bound to openHAB items. Community Forum ~ For more openHAB related details and questions, please visit the openHAB community forum thread on Sonoff and Tasmota .","title":"openHAB"},{"location":"openHAB/#requirements","text":"Working openHAB installation ( see documentation ) Configured Tasmota device (accessible from your local network) MQTT broker available (e.g. Eclipse Mosquitto via openHABian ) A basic understanding of MQTT Working and tested connection between openHAB and the MQTT broker (optional) Standalone MQTT client (e.g. MQTT Explorer ) to observe and identify messages on the MQTT broker If not done yet, you first need to install and activate the MQTT and the JsonPath transformation , e.g. via the openHAB Paper UI Add-ons section. MQTTv1 vs. MQTTv2 Binding Information Please note that since mqtt1 is a legacy binding for years now, it will no longer receive updates or fixes. See older version of this tutorial on how to integrate Tasmota using this binding if you are using mqtt1 - but be advised that it's not recommended anymore, it's better to upgrade to MQTTv2 binding. See openHAB announcement of MQTTv2 for details on how to change your configuration.","title":"Requirements"},{"location":"openHAB/#mqttv2-integration","text":"Configuration is split throughout some openHAB configuration files. First we need to set up a MQTT connection and Tasmota things - you will need a separate thing for every Tasmota device you use. In the example configuration you can see a non-default Full Topic definition. For your real world device simply set up items for all Tasmota MQTT topics you are interested in. Examples for most needed topics are given below, see section Discovering Interesting Topics below on how to watch the raw MQTT data. Some Tasmota topics are JSON encoded, the JSONPATH transformation can be used to extract this data. You'll need to replace the given example device topic name (e.g. \"Tasmota_TH\") by the one chosen for your module. .things File: Bridge mqtt : broker : myMQTTBroker \"My only one and best MQTT server\" [ host = \"IPofBroker\" , username = \"myUser\" , password = \"myPassword\" , clientID = \"myopenHABMQTTClient\" ] Thing mqtt : topic : tasmota : tasmota_TH \"Light_TH\" ( mqtt : broker : myMQTTBroker ) { Channels : // Sonoff Basic / Sonoff S20 Smart Socket (Read and switch on-state) Type switch : PowerSwitch [ stateTopic = \"stat/tasmota_TH/POWER\" , commandTopic = \"cmnd/tasmota_TH/POWER\" , on = \"ON\" , off = \"OFF\" ] // Sonoff Pow (read current wattage; for read and switch on-state see above) Type number : Power [ stateTopic = \"tele/tasmota_TH/SENSOR\" , transformationPattern = \"JSONPATH:$.ENERGY.Power\" ] // devices including AM2301 temperature sensor Type number : Temperature [ stateTopic = \"tele/tasmota_TH/SENSOR\" , transformationPattern = \"JSONPATH:$.AM2301.Temperature\" ] // Tasmota Status Type string : Version [ stateTopic = \"stat/tasmota_TH/STATUS2\" , transformationPattern = \"JSONPATH:$.StatusFWR.Version\" ] Type switch : Reachable [ stateTopic = \"tele/tasmota_TH/LWT\" , transformationPattern = \"MAP:tasmota-reachable.map\" ] // Diagnostics: Define specific for what you really need on a regular basis, use standalone MQTT client for troubleshooting Type string : RestartReason [ stateTopic = \"tele/tasmota_TH/INFO3\" , transformationPattern = \"JSONPATH:$.RestartReason\" ] // old one, have to query it Type string : Version2 [ stateTopic = \"stat/tasmota_TH/STATUS2\" , transformationPattern = \"JSONPATH:$.StatusFWR.Version\" ] // new one - comes for free at startup Type string : Version [ stateTopic = \"tele/tasmota_TH/INFO1\" , transformationPattern = \"JSONPATH:$.Version\" ] Type number : RSSI [ stateTopic = \"tele/tasmota_TH/STATE\" , transformationPattern = \"JSONPATH:$.Wifi.RSSI\" ] Type string : WifiDowntime [ stateTopic = \"tele/tasmota_TH/STATE\" , transformationPattern = \"JSONPATH:$.Wifi.Downtime\" ] Type number : LoadAvg [ stateTopic = \"tele/tasmota_TH/STATE\" , transformationPattern = \"JSONPATH:$.LoadAvg\" ] Type number : Uptime [ stateTopic = \"tele/tasmota_TH/STATE\" , transformationPattern = \"JSONPATH:$.UptimeSec\" ] Type string : Result [ stateTopic = \"stat/tasmota_TH/RESULT\" ] } .items File: For every property your device exposes, you need to define an item, linked to corresponding channel of your Tasmota thing. // device specific properties Switch Switch_TH \"Switch_TH\" { channel = \"mqtt:topic:tasmota:tasmota_TH:PowerSwitch\" } Number : Temperature Switch_TH_Temp \"Temperature [%.1f \u00b0C]\" < temperature > { channel = \"mqtt:topic:tasmota:tasmota_TH:Temperature\" } Number : Power Power \"Power [%.1f W]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:Power\" } // Tasmota Status String Tasmota_Version \"Tasmota Version [%s]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:Version\" , channel = \"mqtt:topic:tasmota:tasmota_TH:Version2\" } Switch Tasmota_Reachable \"Reachable\" { channel = \"mqtt:topic:tasmota:tasmota_TH:Reachable\" } // Diagnostics String Tasmota_RestartReason \"Restart Reason [%s]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:RestartReason\" } Number : Dimensionless Tasmota_RSSI \"Signal [%d %%]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:RSSI\" } String Tasmota_WifiDowntime \"Wifi Downtime [%s]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:WifiDowntime\" } Number : Dimensionless Tasmota_LoadAvg \"Load [%d %%]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:LoadAvg\" } String Tasmota_Result \"Result [%s]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:Result\" } Number : Time Tasmota_Uptime \"Uptime [%.1f s]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:Uptime\" } // Maintenance (described below) String Tasmota_Action \"Tasmota Action\" .sitemap File: // device specific properties Switch item = Switch_TH Text item = Switch_TH_Temp Text item = Power // Maintenance Switch item = Tasmota_Action mappings = [ restart = \"Restart\" , queryFW = \"Query FW\" , upgrade = \"Upgrade FW\" ] // Tasmota Status Text item = Tasmota_Version Text item = Tasmota_Reachable // Diagnostics Text item = Tasmota_RestartReason Text item = Tasmota_RSSI Text item = Tasmota_WifiDowntime Text item = Tasmota_LoadAvg Text item = Tasmota_Uptime label = \"Uptime [%.1f d]\" Text item = Tasmota_Result The \"LWT\" topic ( \"Last Will and Testament\" ) will receive regular \"Online\" messages by the module and an \"Offline\" message a short time after the module is disconnected, generated by the MQTT broker. These messages are transformed to a valid ON / OFF state by the MAP transformation. Of course you can implement Unreachable instead of Reachable if you prefer. The following transformation file is needed: tasmota-reachable.map F\u00edle: Online = ON Offline = OFF","title":"MQTTv2 Integration"},{"location":"openHAB/#maintenance-actions","text":"A home automation system setup would not be complete without a certain maintenance automation! Add the following elements to your openHAB setup to be able to perform actions on your Tasmota devices by the press of a simple sitemap button. The example below includes upgrading the firmware of all devices. A shoutout to @evilgreen for the idea and a big thanks to @smadds for providing the idea of a public firmware server. tasmota_maintenance.rules File for Maintenance Actions: // Work with grouptopic, addressing ALL modules at once, easiest solution val tasmota_device_ids = newArrayList ( \"tasmotas\" ) // OR // Work with a list of selected Tasmota modules //val tasmota_device_ids = newArrayList( // \"tasmota_A00EEA\", // //\u2026 add all your modules here, don't forget some! // \"tasmota_E8A6E4\" //) rule \"Tasmota Maintenance\" when Item Tasmota_Action received command then logInfo ( \"tasmota_maintenance.rules\" , \"Tasmota Maintenance on all devices: \" + receivedCommand ) val actionsBroker = getActions ( \"mqtt\" , \"mqtt:broker:MyMQTTBroker\" ) // change to your broker name! for ( String device_id : tasmota_device_ids ) { switch ( receivedCommand ) { case \"restart\" : actionsBroker . publishMQTT ( \"cmnd/\" + device_id + \"/restart\" , \"1\" ) case \"queryFW\" : actionsBroker . publishMQTT ( \"cmnd/\" + device_id + \"/status\" , \"2\" ) case \"upgrade\" : { // one could change OTA URL using MQTT but if you use different breeds (basic, ir, sensor, ...) of Tasmota, you would lose them // it's better to configure OTA url at each device (default) and just trigger upgrade - they will use OTA URL saved in your device. //actionsBroker.publishMQTT( \"cmnd/\" + device_id + \"/otaurl\", \"http://ota.tasmota.com/tasmota/release/tasmota.bin\") actionsBroker . publishMQTT ( \"cmnd/\" + device_id + \"/upgrade\" , \"1\" ) } } } createTimer ( now . plusSeconds ( 1 ))[ | Tasmota_Action . postUpdate ( UNDEF )] end","title":"Maintenance Actions"},{"location":"openHAB/#comparing-your-device-firmware-with-the-current-tasmota-github-release","text":"Knowing your devices firmware version(s) is good. Being able to compare it with the current release directly, is even better. You can archive this by combining the maintenance actions with the openHAB http binding, the JsonPath transformation and the GitHub API. Just extend the maintenance setup with the following Item and config: http.cfg: # Tasmota Release Version ( cached twice a day ) tasmotaRelease . url = https : //api.github.com/repos/arendst/Tasmota/tags tasmotaRelease . updateInterval = 43200000 tasmota.items: String Tasmota_Current_FW_Available \"Current Release [%s]\" { http = \"<[tasmotaRelease:10000:JSONPATH($[0].name)]\" } With this item in your sitemap, you will now see the latest release/tag from Tasmota repository.","title":"Comparing your device firmware with the current Tasmota GitHub Release"},{"location":"openHAB/#discovering-interesting-topics","text":"Additional or further interesting topics are easily identified by reading up on the Tasmota wiki and by subscribing to the modules topics. Subscribe to all topics of one module using MQTT wildcard topic string +/tasmota_XYZ/# (string depends on your user-configured Topic/FullTopic). Configure items for the identified topics similar to the ones below. Example: MQTT messages published by a Sonoff Pow module are shown below (using mosquitto_sub ). The module reports its device state and energy readings periodically. In the second half of the example the module relay was switched into the OFF position. $ mosquitto_sub - h localhost - t \"+/tasmota_E8A6E4/#\" - v tele / tasmota - E8A6E4 / LWT Online tele / tasmota - E8A6E4 / UPTIME { \"Time\" : \"2017-07-25T12:02:00\" , \"Uptime\" : 68 } tele / tasmota - E8A6E4 / STATE { \"Time\" : \"2017-07-25T12:06:28\" , \"Uptime\" : 68 , \"Vcc\" : 3.122 , \"POWER\" : \"POWER\" , \"Wifi\" : { \"AP\" : 1 , \"SSID\" : \"HotelZurBirke\" , \"RSSI\" : 100 , \"APMac\" : \"24:65:11:BF:12:D8\" }} tele / tasmota - E8A6E4 / ENERGY { \"Time\" : \"2017-07-25T12:06:28\" , \"Total\" : 0.640 , \"Yesterday\" : 0.007 , \"Today\" : 0.003 , \"Period\" : 0 , \"Power\" : 0 , \"Factor\" : 0.00 , \"Voltage\" : 0 , \"Current\" : 0.000 } tele / tasmota - E8A6E4 / STATE { \"Time\" : \"2017-07-25T12:11:28\" , \"Uptime\" : 68 , \"Vcc\" : 3.122 , \"POWER\" : \"POWER\" , \"Wifi\" : { \"AP\" : 1 , \"SSID\" : \"HotelZurBirke\" , \"RSSI\" : 100 , \"APMac\" : \"24:65:11:BF:12:D8\" }} tele / tasmota - E8A6E4 / ENERGY { \"Time\" : \"2017-07-25T12:11:28\" , \"Total\" : 0.640 , \"Yesterday\" : 0.007 , \"Today\" : 0.003 , \"Period\" : 0 , \"Power\" : 0 , \"Factor\" : 0.00 , \"Voltage\" : 0 , \"Current\" : 0.000 } cmnd / tasmota - E8A6E4 / POWER OFF stat / tasmota - E8A6E4 / RESULT { \"POWER\" : \"OFF\" } stat / tasmota - E8A6E4 / POWER OFF Following this method, the behavior-linked messages can be identified and bound to openHAB items.","title":"Discovering Interesting Topics"},{"location":"openHAB/#community-forum","text":"For more openHAB related details and questions, please visit the openHAB community forum thread on Sonoff and Tasmota .","title":"Community Forum"},{"location":"otto/","text":"\u0298tt\u0298 is a web interface for controlling devices, such as Tasmota enabled devices, over MQTT. See the quick-start guide and instructions for Tasmota devices .","title":"Otto"},{"location":"ble/Bluetooth-Esp32/","text":"Native Bluetooth Low Energy in Tasmota with ESP32: ESP32 native Bluetooth Low Energy support ~ This allows for the receiving of BLE advertisments from BLE devices, including \"iBeacons\" and BLE sensors, but also for the control of simple BLE devices, providing for reading, writing and receiving notifications. Native ESP32 BLE depends on: #define USE_BLE_ESP32 There is a special Tasmota build '-bluetooth' which has this turned on. If you wish to combine it with other features (e.g. sensors), then add this to yout user_config_override.h and compile your build . Be aware, enabling of the native BLE on ESP32 has an impact on wifi performance. Although later SDK helped a bit, expect more lag on the web interface and on MQTT. If only controlling BLE devices, then scanning can be disabled, which will minimise wifi impact. BLE can be enabled from the web UI menus. This is compiled by default in the Bluetooth firmware, but you still need to enable it using the web interface configure BLE button or setoption115 1. General Commands and Configuration ~ Note that the only configuration stored is the setOption115 to turn BLE on and off. All other configurations can be set at boot if necessary using Rules. (note that setoptiuon115 is the same as enable in the Web UI configuration). Available BLE Commands ~ Command Parameters BLEPeriod Set the period for publish of BLE data <value> = set interval in seconds BLEOp Setup and execute an active BLE operation (read/write/notify) see separate description in source code BLEMode Set the mode of the driver <value> 0 = Stop and Disable BLE. 1 = Enable BLE, but only scan on command. 2 = Enable BLE and scan regularly BLEDetails Display details about adverts for one or more devices. BLEDetails0 - don't show any. BLEDetails2 MAC|Alias - show all advert details for the MAC or Alias. BLEDetails3 - show ALL advert details. BLEScan Set the scan mode, or start a manual scan. BLEScan0 <value> 0 = passive scan, 1 = active scan. BLEScan1 <ss> start a manual scan for ss seconds (2-40), or 20s if ss not given. BLEAlias Set one or more aliases for device MAC addresses. MAC=Alias <mac2=Alias2> BLEName Read or Write the BLE name for a device. MAC|Alias = read. MAC|Alias name = write. BLEDebug Display more BLE related logs. BLEDebug0 = less. BLEDebug|BLEDebug1 = more. BLEDevices Display or Clear seen BLE devices. BLEDevices0 = clear device list. BLEDevices1 = publish tele mesg. BLEMaxAge Display or Set the age at which a seen BLE device will be forgotten. BLEMaxage = display. BLEMaxAge ss = set to ss seconds. BLEAddrFilter Display or Set the type od BLE addresses accepted. BLEAddrFilter = display. BLEAddrFilter value = set to value (0-default,1,2,3). Set to 1 to hear certain devices with static random addresses. BLE Command examples ~ Setup a rule to set some aliases at boot time Rule1 ON System#Boot DO BLEAlias A4C1386A1E24=fred A4C1387FC1E1=james endon Rule1 1 Enable static random mac addresses in addition to public mac addresses BLEAddrFilter 1 Check the interval between BLE tele messages BLEPeriod Set it to 40s BLEPeriod 40 iBeacon ~ Hear adverts from BLE devices, and produce MQTT messages containing RSSI and other information about them. Break out iBeacon specific data if present. Enabled by #define USE_IBEACON // Add support for bluetooth LE passive scan of ibeacon devices Available iBeacon Commands ~ Command Parameters iBeacon Show or set enable for the iBeacon driver iBeacon = Display 0 iBeaconOnlyAliased Show or set OnlyAliased for the iBeacon driver iBeaconOnlyAliased = Display 0 iBeaconClear Clear iBeacon list iBeaconPeriod Display or Set the period for publish of iBeacon data iBeaconPeriod = display interval iBeaconPeriod ss = set interval in seconds iBeaconTimeout Display or Set the timeout for iBeacon devices iBeaconTimeout = display timeout iBeaconTimeout ss = set timeout in seconds This driver reports all beacons found during a scan with its ID (derived from beacon's MAC address) prefixed with IBEACON_ and RSSI value. Every beacon report is published as an MQTT tele/%topic%/SENSOR in a separate message: tele /ibeaco n /SENSOR = { \"Time\" : \"2021-01-02T12:08:40\" , \"IBEACON\" :{ \"MAC\" : \"A4C1387FC1E1\" , \"RSSI\" : -56 , \"STATE\" : \"ON\" }} If the beacon can no longer be found during a scan and the timeout interval has passed the beacon's RSSI is set to zero (0) and it is no longer displayed in the webUI tele /ibeaco n /SENSOR = { \"Time\" : \"2021-01-02T12:08:40\" , \"IBEACON\" :{ \"MAC\" : \"A4C1387FC1E1\" , \"RSSI\" : -56 , \"STATE\" : \"OFF\" }} Additional fields will be present depending upon the beacon, e.g. NAME, UID, MAJOR, MINOR. iBeacon MQTT fields ~ Always present json meaning Time time of MQTT send IBEACON.MAC mac addr IBEACON.RSSI signal strength IBEACON.STATE ON - present, OFF - last MQTT you will get for now (device removed) Optional json meaning IBEACON.NAME name if in scan, or BLEAlias if set - only present if NAME present IBEACON.PERSEC count of adverts per sec. Useful for detecting button press IBEACON.MAJOR some iBeacon related term? - only present for some IBEACON.MINOR some iBeacon related term? - only present for some iBeacon Command examples ~ Setup a rule to set some aliases at boot time, and only allow those starting iB Rule1 ON System#Boot DO backlog iBeacon 1; BLEAlias A4C1386A1E24=iBfred A4C1387FC1E1=iBjames; iBeaconOnlyAliased 2 endon Rule1 1 Supported Devices ~ All Apple compatible iBeacon devices should be discoverable. Various nRF51822 beacons should be fully Apple compatible, programmable and their battery lasts about a year. Amazon.com Aliexpress Cheap \"iTag\" beacons with a beeper. The battery on these lasts only about a month. Aliexpress eBay Amazon.com Tip You can activate a beacon with a beeper using command IBEACON_%BEACONID%_RSSI 99 (ID is visible in webUI and SENSOR reports). This command can freeze the Bluetooth module and beacon scanning will stop. After a reboot of Tasmota the beacon will start beeping and scanning will resume. (untested on ESP32 native BLE) MI32 Bluetooth Low Energy Sensors ~ Enabled by #define USE_MI_ESP32 Different vendors offer Bluetooth solutions as part of the XIAOMI family often under the MIJIA-brand (while AQUARA is the typical name for a ZigBee sensor). The sensors supported by Tasmota use BLE (Bluetooth Low Energy) to transmit the sensor data, but they differ in their accessibilities quite substantially. Basically all of them use of so-called \u201eMiBeacons\u201c which are BLE advertisement packets with a certain data structure, which are broadcasted by the devices automatically while the device is not in an active bluetooth connection. The frequency of these messages is set by the vendor and ranges from one per 3 seconds to one per hour (for the battery status of the LYWSD03MMC). Motion sensors and BLE remote controls start to send when an event is triggered. These packets already contain the sensor data and can be passively received by other devices and will be published regardless if a user decides to read out the sensors via connections or not. Thus the battery life of a BLE sensor is not influenced by reading these advertisements and the big advantage is the power efficiency as no active bi-directional connection has to be established. The other advantage is, that scanning for BLE advertisements can happen nearly parallel (= very quick one after the other), while a direct connection must be established for at least a few seconds and will then block both involved devices for that time. This is therefore the preferred option, if technically possible (= for the supported sensors). Most of the \u201eolder\u201c BLE-sensor-devices use unencrypted messages, which can be read by all kinds of BLE-devices or even a NRF24L01. With the arrival of \"newer\" sensors came the problem of encrypted data in MiBeacons, which can be decrypted in Tasmota (not yet with the HM-1x). Meanwhile it is possible to get the needed \"bind_key\" with the help of an open-source project: https://atc1441.github.io/TelinkFlasher.html At least the LYWSD03 allows the use of a simple BLE connection without any encrypted authentication and the reading of the sensor data using normal subscription methods to GATT-services (currently used on the HM-1x). This is more power hungry than the passive reading of BLE advertisements. Other sensors like the MJYD2S are not usable without the \"bind_key\". Supported Devices ~ It can not be ruled out, that changes in the device firmware may break the functionality of this driver completely! The naming conventions in the product range of bluetooth sensors in XIAOMI-universe can be a bit confusing. The exact same sensor can be advertised under slightly different names depending on the seller (Mijia, Xiaomi, Cleargrass, ...). MJ_HT_V1 LYWSD02 CGG1 CGD1 temperature, humidity, battery temperature, humidity, battery temperature, humidity, battery temperature, humidity, battery passive for all entities, reliable battery value battery only active, thus not on the NRF24L01, set clock and unit, very frequent data sending passive for all entities, reliable battery value battery only active, thus not on the NRF24L01, no reliable battery value, no clock functions MiFlora LYWSD03MMC / ATC NLIGHT MJYD2S temperature, illuminance, soil humidity, soil fertility, battery, firmware version temperature, humidity, battery motion motion, illuminance, battery, no-motion-time passive only with newer firmware (>3.0?), battery only active, thus not on the NRF24L01 passive only with decryption or using custom ATC-firmware, no reliable battery value with stock firmware NRF24L01, ESP32 passive only with decryption, thus only NRF24L01, ESP32 YEE RC MHO-C401 MHO-C303 button press (single and long) temperature, humidity, battery temperature, humidity, battery passive equal to the LYWS03MMC, but no custom firmware yet passive for all entities, set clock and unit, no alarm functions, very frequent data sending passive: data is received via BLE advertisments active: data is received via bidrectional connection to the sensor Devices with payload encryption The LYWSD03MMC, MHO-C401 and the MJYD2S will start to send advertisements with encrypted sensor data after pairing it with the official Xiaomi app (using TelinkFlasher to get the key also acts as a trigger to start sending?). Out-of-the-box the sensors do only publish a static advertisement. It is possible to do a pairing and get the necessary decryption key (\"bind_key\") here: https://atc1441.github.io/TelinkFlasher.html - note you do not have to flash the ATC firmware! This project also provides a custom firmware for the LYWSD03MMC, which then becomes an ATC and is supported by Tasmota too. Default ATC-setting will drain the battery more than stock firmware, because of very frequent data sending. An encrypted sensor will show a link to the telelink flasher page, marked as 'NoKey' if an encrypted packet has been received and no key is present (you may wait some minutes before an encrypted packet arrives). To set the key(s) for a device(s) the key command is MI32Keys mac|alias=key mac|alias=key or MI32Key keymac where mac is a mac address. A BLEAlias may be used in place of the mac (see BLE commands). The Key is the 32 character (16 byte) key retrieved by TelelinkFlasher. MI32Key is retained for b ackward compatibility, needing a 44 character combination of key and MAC. LYWSD03MMC sends encrypted sensor data every 10 minutes. As there are no confirmed reports about correct battery presentation of the sensor (always shows 99%), this function is currently not supported. MJYD2S sends motion detection events and 2 discrete illuminance levels (1 lux or 100 lux for a dark or bright environment). Additionally battery level and contiguous time without motion in discrete growing steps (no motion time = NMT). Options to read out the LYWSD03MMC Generate a bind_key The web-tool https://atc1441.github.io/TelinkFlasher.html allows the generation of a so-called bind_key by faking a pairing with the Xiaomi cloud. You can copy-paste this key and add the MAC to use this resultig key-MAC-string with key-command (NRFkey or MI32key). Then the driver will receive the sensors data roughly every 10 minutes (in two chunks for humidity and temperature with about a minute in between) and decode the data. This is the most energy efficient way. The current way of storing these keys on the ESP32 is to use RULES like that (for the NRF24L01 you would use NRFkey): rule1 on System # Boot do backlog MI32key 00112233445566778899 AABBCCDDEEFF112233445566 ; MI32key 00112233445566778899 AABBCCDDEEFFAABBCCDDEEFF endon This option is currently not available for the HM-10 because of memory considerations as part of the standard sensor-firmware package. Note: in the latest Tasmota, a blue link will show next to a device if the device needs a key. Clicking this likn will take you to a page guiding you to create a key, and at the end, puts that key into Tasmota, leaving you on a page with the required command to add to your rule. Flash custom ATC-firmware Use the same https://atc1441.github.io/TelinkFlasher.html to flash a custom ATC-firmware on the LYWSD03MMC. This will work out of the box with all three Tasmota-drivers. There is a slight chance of bricking the sensor, which would require some soldering and compiling skills to un-brick. This firmware does send data more frequently and is a little bit more power hungry than the stock firmware. There is also another new custom firmware here https://github.com/pvvx/ATC_MiThermometer with it's own flasher/config page. The Custom mode is supported in latest Tasmota ESP32, but beware not to use 'All' mode. Use active connections By default a device without a key ,may be read using an active connection. This circumvents the data encryption, but is power hungry and drains the battery fast. Thus it is only recommended as fallback mechanism. Commands Command Parameters MI32Period Show interval in seconds between sensor read cycles for the LYWSD03. Set to TelePeriod value at boot. MI32Time <n> = set time time of a LYWSD02 only sensor to Tasmota UTC time and timezone. <n> is the sensor number in order of discovery starting with 0 (topmost sensor in the webUI list). MI32Unit <n> = toggle the displayed temperature units of a LYWSD02 only sensor. <n> is the sensor number in order of discovery starting with 0 (topmost sensor in the webUI list). Reporting of the temperature is always in Celcius, this only changes the value shown on the device. MI32Page Show the maximum number of sensors shown per page in the webUI list. <value> = set number of sensors (default = 4) MI32Battery Reads missing battery data for LYWSD02, Flora and CGD1. MI32Key (depreciated - pls use MI32Keys) Set a \"bind_key\" for a MAC-address to decrypt sensor data (LYWSD03MMC, MJYD2S). The argument is a 44 uppercase characters long string, which is the concatenation of the bind_key and the corresponding MAC. <00112233445566778899AABBCCDDEEFF> (32 characters) = bind_key <112233445566> (12 characters) = MAC of the sensor <00112233445566778899AABBCCDDEEFF112233445566> (44 characters)= final string MI32Keys Set one or more \"bind_key\" for a MAC-address to decrypt sensor data (LYWSD03MMC, MJYD2S). MI32Keys mac=key (mac=key) = set the 32 character key for <mac> (more than one mac=key may be specified). MI32Blockx Ignore Xiaomi sensors using the (fixed) MAC-address x=1 - show block list x=0 - delete block list x=1 + MAC-address - add MAC to to be blocked to the block list x=0 + MAC-address - remove MAC to to be blocked to the block list <value> (12 or 17 characters) = MAC interpreted as a string AABBCCDDEEFF (also valid: aa:BB:cc:dd:EE:FF ) MI32Optionx 0/1 Set driver options at runtime x=0 - 0 -> sends only recently received sensor data, 1 -> aggregates all recent sensors data types x=1 - 0 -> shows full sensor data at TELEPERIOD, 1 -> shows no sensor data at TELEPERIOD x=2 - 0 -> sensor data only at TELEPERIOD (default and \"usual\" Tasmota style), 1 -> direct bridging of BLE-data to mqtt-messages x=5 - 0 -> show all relevant BLE sensors, 1 -> show only sensors with a BLEAlias Tip If you really want to read battery for LYWSD02, Flora and CGD1, consider doing it once a day with a RULE: RULE1 on Time#Minute=30 do MI32Battery endon This will update every day at 00:30 AM. MI32 MQTT messages ~ Because we can have MANY sensors reporting, tele messages are chunked to have a maximum of four sensors per message. If you enable HASS discovery (setoption19 1), the ADDITIONAL MQTT messages are send. Primarily, at teleperiod or MI32period, discovery messages are sent. These inform homeassistant of the devices. Device names can be dependent upon BLEAlias, so set BLEAlias at boot.... Additional actual data messages are sent on topics includinmg the device name: tele/tasmota_ble/<name> Each message for ONE sensor. These messages can be used without homeassistant if it is a preferred format. NOTE: The topic would be the SAME from all Tasmota if they have the same BLEAlias or no BLEAlias. So if you wish to 'hear' the same device separately from different Tasmota, use different BLEAlias names.... EQ3 radiator valve driver ~ A preliminary EQ3 driver is in production Documentation","title":"Bluetooth ESP32"},{"location":"ble/Bluetooth-Esp32/#esp32-native-bluetooth-low-energy-support","text":"This allows for the receiving of BLE advertisments from BLE devices, including \"iBeacons\" and BLE sensors, but also for the control of simple BLE devices, providing for reading, writing and receiving notifications. Native ESP32 BLE depends on: #define USE_BLE_ESP32 There is a special Tasmota build '-bluetooth' which has this turned on. If you wish to combine it with other features (e.g. sensors), then add this to yout user_config_override.h and compile your build . Be aware, enabling of the native BLE on ESP32 has an impact on wifi performance. Although later SDK helped a bit, expect more lag on the web interface and on MQTT. If only controlling BLE devices, then scanning can be disabled, which will minimise wifi impact. BLE can be enabled from the web UI menus. This is compiled by default in the Bluetooth firmware, but you still need to enable it using the web interface configure BLE button or setoption115 1.","title":"ESP32 native Bluetooth Low Energy support"},{"location":"ble/Bluetooth-Esp32/#general-commands-and-configuration","text":"Note that the only configuration stored is the setOption115 to turn BLE on and off. All other configurations can be set at boot if necessary using Rules. (note that setoptiuon115 is the same as enable in the Web UI configuration).","title":"General Commands and Configuration"},{"location":"ble/Bluetooth-Esp32/#available-ble-commands","text":"Command Parameters BLEPeriod Set the period for publish of BLE data <value> = set interval in seconds BLEOp Setup and execute an active BLE operation (read/write/notify) see separate description in source code BLEMode Set the mode of the driver <value> 0 = Stop and Disable BLE. 1 = Enable BLE, but only scan on command. 2 = Enable BLE and scan regularly BLEDetails Display details about adverts for one or more devices. BLEDetails0 - don't show any. BLEDetails2 MAC|Alias - show all advert details for the MAC or Alias. BLEDetails3 - show ALL advert details. BLEScan Set the scan mode, or start a manual scan. BLEScan0 <value> 0 = passive scan, 1 = active scan. BLEScan1 <ss> start a manual scan for ss seconds (2-40), or 20s if ss not given. BLEAlias Set one or more aliases for device MAC addresses. MAC=Alias <mac2=Alias2> BLEName Read or Write the BLE name for a device. MAC|Alias = read. MAC|Alias name = write. BLEDebug Display more BLE related logs. BLEDebug0 = less. BLEDebug|BLEDebug1 = more. BLEDevices Display or Clear seen BLE devices. BLEDevices0 = clear device list. BLEDevices1 = publish tele mesg. BLEMaxAge Display or Set the age at which a seen BLE device will be forgotten. BLEMaxage = display. BLEMaxAge ss = set to ss seconds. BLEAddrFilter Display or Set the type od BLE addresses accepted. BLEAddrFilter = display. BLEAddrFilter value = set to value (0-default,1,2,3). Set to 1 to hear certain devices with static random addresses.","title":"Available BLE Commands"},{"location":"ble/Bluetooth-Esp32/#ble-command-examples","text":"","title":"BLE Command examples"},{"location":"ble/Bluetooth-Esp32/#ibeacon","text":"Hear adverts from BLE devices, and produce MQTT messages containing RSSI and other information about them. Break out iBeacon specific data if present. Enabled by #define USE_IBEACON // Add support for bluetooth LE passive scan of ibeacon devices","title":"iBeacon"},{"location":"ble/Bluetooth-Esp32/#available-ibeacon-commands","text":"Command Parameters iBeacon Show or set enable for the iBeacon driver iBeacon = Display 0 iBeaconOnlyAliased Show or set OnlyAliased for the iBeacon driver iBeaconOnlyAliased = Display 0 iBeaconClear Clear iBeacon list iBeaconPeriod Display or Set the period for publish of iBeacon data iBeaconPeriod = display interval iBeaconPeriod ss = set interval in seconds iBeaconTimeout Display or Set the timeout for iBeacon devices iBeaconTimeout = display timeout iBeaconTimeout ss = set timeout in seconds This driver reports all beacons found during a scan with its ID (derived from beacon's MAC address) prefixed with IBEACON_ and RSSI value. Every beacon report is published as an MQTT tele/%topic%/SENSOR in a separate message: tele /ibeaco n /SENSOR = { \"Time\" : \"2021-01-02T12:08:40\" , \"IBEACON\" :{ \"MAC\" : \"A4C1387FC1E1\" , \"RSSI\" : -56 , \"STATE\" : \"ON\" }} If the beacon can no longer be found during a scan and the timeout interval has passed the beacon's RSSI is set to zero (0) and it is no longer displayed in the webUI tele /ibeaco n /SENSOR = { \"Time\" : \"2021-01-02T12:08:40\" , \"IBEACON\" :{ \"MAC\" : \"A4C1387FC1E1\" , \"RSSI\" : -56 , \"STATE\" : \"OFF\" }} Additional fields will be present depending upon the beacon, e.g. NAME, UID, MAJOR, MINOR.","title":"Available iBeacon Commands"},{"location":"ble/Bluetooth-Esp32/#ibeacon-mqtt-fields","text":"","title":"iBeacon MQTT fields"},{"location":"ble/Bluetooth-Esp32/#ibeacon-command-examples","text":"","title":"iBeacon Command examples"},{"location":"ble/Bluetooth-Esp32/#supported-devices","text":"All Apple compatible iBeacon devices should be discoverable. Various nRF51822 beacons should be fully Apple compatible, programmable and their battery lasts about a year. Amazon.com Aliexpress Cheap \"iTag\" beacons with a beeper. The battery on these lasts only about a month. Aliexpress eBay Amazon.com Tip You can activate a beacon with a beeper using command IBEACON_%BEACONID%_RSSI 99 (ID is visible in webUI and SENSOR reports). This command can freeze the Bluetooth module and beacon scanning will stop. After a reboot of Tasmota the beacon will start beeping and scanning will resume. (untested on ESP32 native BLE)","title":"Supported Devices"},{"location":"ble/Bluetooth-Esp32/#mi32-bluetooth-low-energy-sensors","text":"Enabled by #define USE_MI_ESP32 Different vendors offer Bluetooth solutions as part of the XIAOMI family often under the MIJIA-brand (while AQUARA is the typical name for a ZigBee sensor). The sensors supported by Tasmota use BLE (Bluetooth Low Energy) to transmit the sensor data, but they differ in their accessibilities quite substantially. Basically all of them use of so-called \u201eMiBeacons\u201c which are BLE advertisement packets with a certain data structure, which are broadcasted by the devices automatically while the device is not in an active bluetooth connection. The frequency of these messages is set by the vendor and ranges from one per 3 seconds to one per hour (for the battery status of the LYWSD03MMC). Motion sensors and BLE remote controls start to send when an event is triggered. These packets already contain the sensor data and can be passively received by other devices and will be published regardless if a user decides to read out the sensors via connections or not. Thus the battery life of a BLE sensor is not influenced by reading these advertisements and the big advantage is the power efficiency as no active bi-directional connection has to be established. The other advantage is, that scanning for BLE advertisements can happen nearly parallel (= very quick one after the other), while a direct connection must be established for at least a few seconds and will then block both involved devices for that time. This is therefore the preferred option, if technically possible (= for the supported sensors). Most of the \u201eolder\u201c BLE-sensor-devices use unencrypted messages, which can be read by all kinds of BLE-devices or even a NRF24L01. With the arrival of \"newer\" sensors came the problem of encrypted data in MiBeacons, which can be decrypted in Tasmota (not yet with the HM-1x). Meanwhile it is possible to get the needed \"bind_key\" with the help of an open-source project: https://atc1441.github.io/TelinkFlasher.html At least the LYWSD03 allows the use of a simple BLE connection without any encrypted authentication and the reading of the sensor data using normal subscription methods to GATT-services (currently used on the HM-1x). This is more power hungry than the passive reading of BLE advertisements. Other sensors like the MJYD2S are not usable without the \"bind_key\".","title":"MI32 Bluetooth Low Energy Sensors"},{"location":"ble/Bluetooth-Esp32/#supported-devices_1","text":"It can not be ruled out, that changes in the device firmware may break the functionality of this driver completely! The naming conventions in the product range of bluetooth sensors in XIAOMI-universe can be a bit confusing. The exact same sensor can be advertised under slightly different names depending on the seller (Mijia, Xiaomi, Cleargrass, ...). MJ_HT_V1 LYWSD02 CGG1 CGD1 temperature, humidity, battery temperature, humidity, battery temperature, humidity, battery temperature, humidity, battery passive for all entities, reliable battery value battery only active, thus not on the NRF24L01, set clock and unit, very frequent data sending passive for all entities, reliable battery value battery only active, thus not on the NRF24L01, no reliable battery value, no clock functions MiFlora LYWSD03MMC / ATC NLIGHT MJYD2S temperature, illuminance, soil humidity, soil fertility, battery, firmware version temperature, humidity, battery motion motion, illuminance, battery, no-motion-time passive only with newer firmware (>3.0?), battery only active, thus not on the NRF24L01 passive only with decryption or using custom ATC-firmware, no reliable battery value with stock firmware NRF24L01, ESP32 passive only with decryption, thus only NRF24L01, ESP32 YEE RC MHO-C401 MHO-C303 button press (single and long) temperature, humidity, battery temperature, humidity, battery passive equal to the LYWS03MMC, but no custom firmware yet passive for all entities, set clock and unit, no alarm functions, very frequent data sending passive: data is received via BLE advertisments active: data is received via bidrectional connection to the sensor","title":"Supported Devices"},{"location":"ble/Bluetooth-Esp32/#mi32-mqtt-messages","text":"Because we can have MANY sensors reporting, tele messages are chunked to have a maximum of four sensors per message. If you enable HASS discovery (setoption19 1), the ADDITIONAL MQTT messages are send. Primarily, at teleperiod or MI32period, discovery messages are sent. These inform homeassistant of the devices. Device names can be dependent upon BLEAlias, so set BLEAlias at boot.... Additional actual data messages are sent on topics includinmg the device name: tele/tasmota_ble/<name> Each message for ONE sensor. These messages can be used without homeassistant if it is a preferred format. NOTE: The topic would be the SAME from all Tasmota if they have the same BLEAlias or no BLEAlias. So if you wish to 'hear' the same device separately from different Tasmota, use different BLEAlias names....","title":"MI32 MQTT messages"},{"location":"ble/Bluetooth-Esp32/#eq3-radiator-valve-driver","text":"A preliminary EQ3 driver is in production Documentation","title":"EQ3 radiator valve driver"},{"location":"ble/Bluetooth-Esp8266/","text":"Bluetooth Low Energy in Tasmota on Esp8266 consists of: ESP8266 via HM-1x or nRF24L01(+) ~ This allows for the receiving of BLE advertisments from BLE devices, including \"iBeacons\" iBeacon ~ This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : For ESP8266 via HM-1x or nRF24L01(+) ~ Tasmota uses a BLE 4.x module to scan for iBeacon devices. This driver is working with HM-10 and clones and HM16/HM17 Bluetooth modules and potentially with other HM-1x modules depending on firmware capabilities. Tip If using an extenral module, When first connected some modules will be in peripheral mode. You have to change it to central mode using commands Sensor52 1 and Sensor52 2 . Features ~ For a list of all available commands see Sensor52 command. This driver reports all beacons found during a scan with its ID (derived from beacon's MAC address) prefixed with IBEACON_ and RSSI value. Every beacon report is published as an MQTT tele/%topic%/SENSOR in a separate message: tele /ibeaco n /SENSOR = { \"Time\" : \"2021-01-02T12:08:40\" , \"IBEACON\" :{ \"MAC\" : \"A4C1387FC1E1\" , \"RSSI\" : -56 , \"STATE\" : \"ON\" }} If the beacon can no longer be found during a scan and the timeout interval has passed the beacon's RSSI is set to zero (0) and it is no longer displayed in the webUI tele /ibeaco n /SENSOR = { \"Time\" : \"2021-01-02T12:08:40\" , \"IBEACON\" :{ \"MAC\" : \"A4C1387FC1E1\" , \"RSSI\" : -56 , \"STATE\" : \"OFF\" }} Additional fields will be present depending upon the beacon, e.g. NAME, UID, MAJOR, MINOR. Supported Devices ~ All Apple compatible iBeacon devices should be discoverable. Various nRF51822 beacons should be fully Apple compatible, programmable and their battery lasts about a year. Amazon.com Aliexpress Cheap \"iTag\" beacons with a beeper. The battery on these lasts only about a month. Aliexpress eBay Amazon.com Tip You can activate a beacon with a beeper using command IBEACON_%BEACONID%_RSSI 99 (ID is visible in webUI and SENSOR reports). This command can freeze the Bluetooth module and beacon scanning will stop. After a reboot of Tasmota the beacon will start beeping and scanning will resume. (untested on ESP32 native BLE) Bluetooth Low Energy Sensors ~ Different vendors offer Bluetooth solutions as part of the XIAOMI family often under the MIJIA-brand (while AQUARA is the typical name for a ZigBee sensor). The sensors supported by Tasmota use BLE (Bluetooth Low Energy) to transmit the sensor data, but they differ in their accessibilities quite substantially. Basically all of them use of so-called \u201eMiBeacons\u201c which are BLE advertisement packets with a certain data structure, which are broadcasted by the devices automatically while the device is not in an active bluetooth connection. The frequency of these messages is set by the vendor and ranges from one per 3 seconds to one per hour (for the battery status of the LYWSD03MMC). Motion sensors and BLE remote controls start to send when an event is triggered. These packets already contain the sensor data and can be passively received by other devices and will be published regardless if a user decides to read out the sensors via connections or not. Thus the battery life of a BLE sensor is not influenced by reading these advertisements and the big advantage is the power efficiency as no active bi-directional connection has to be established. The other advantage is, that scanning for BLE advertisements can happen nearly parallel (= very quick one after the other), while a direct connection must be established for at least a few seconds and will then block both involved devices for that time. This is therefore the preferred option, if technically possible (= for the supported sensors). Most of the \u201eolder\u201c BLE-sensor-devices use unencrypted messages, which can be read by all kinds of BLE-devices or even a NRF24L01. With the arrival of \"newer\" sensors came the problem of encrypted data in MiBeacons, which can be decrypted in Tasmota (not yet with the HM-1x). Meanwhile it is possible to get the needed \"bind_key\" with the help of an open-source project: https://atc1441.github.io/TelinkFlasher.html At least the LYWSD03 allows the use of a simple BLE connection without any encrypted authentication and the reading of the sensor data using normal subscription methods to GATT-services (currently used on the HM-1x). This is more power hungry than the passive reading of BLE advertisements. Other sensors like the MJYD2S are not usable without the \"bind_key\". Supported Devices ~ It can not be ruled out, that changes in the device firmware may break the functionality of this driver completely! The naming conventions in the product range of bluetooth sensors in XIAOMI-universe can be a bit confusing. The exact same sensor can be advertised under slightly different names depending on the seller (Mijia, Xiaomi, Cleargrass, ...). MJ_HT_V1 LYWSD02 CGG1 CGD1 temperature, humidity, battery temperature, humidity, battery temperature, humidity, battery temperature, humidity, battery passive for all entities, reliable battery value battery only active, thus not on the NRF24L01, set clock and unit, very frequent data sending passive for all entities, reliable battery value battery only active, thus not on the NRF24L01, no reliable battery value, no clock functions MiFlora LYWSD03MMC / ATC NLIGHT MJYD2S temperature, illuminance, soil humidity, soil fertility, battery, firmware version temperature, humidity, battery motion motion, illuminance, battery, no-motion-time passive only with newer firmware (>3.0?), battery only active, thus not on the NRF24L01 passive only with decryption or using custom ATC-firmware, no reliable battery value with stock firmware NRF24L01, ESP32 passive only with decryption, thus only NRF24L01, ESP32 YEE RC MHO-C401 MHO-C303 button press (single and long) temperature, humidity, battery temperature, humidity, battery passive equal to the LYWS03MMC, but no custom firmware yet passive for all entities, set clock and unit, no alarm functions, very frequent data sending passive: data is received via BLE advertisments active: data is received via bidrectional connection to the sensor Devices with payload encryption The LYWSD03MMC, MHO-C401 and the MJYD2S will start to send advertisements with encrypted sensor data after pairing it with the official Xiaomi app (using TelinkFlasher to get the key also acts as a trigger to start sending?). Out-of-the-box the sensors do only publish a static advertisement. It is possible to do a pairing and get the necessary decryption key (\"bind_key\") here: https://atc1441.github.io/TelinkFlasher.html - note you do not have to flash the ATC firmware! This project also provides a custom firmware for the LYWSD03MMC, which then becomes an ATC and is supported by Tasmota too. Default ATC-setting will drain the battery more than stock firmware, because of very frequent data sending. For NRF based BLE: This key and the corresponding MAC of the sensor can be injected with the NRFKEY-command (or NRFMJYD2S). It is probably a good idea to save the whole config as RULE like that: rule1 on System # Boot do backlog NRFkey 00112233445566778899 AABBCCDDEEFF112233445566 ; NRFkey 00112233445566778899 AABBCCDDEEFF112233445566 ; NRFPage 6 ; NRFUse 0 ; NRFUse 4 endon (key for two sensors, 6 sensors per page in the WebUI, turn off all sensors, turn on LYWS03) LYWSD03MMC sends encrypted sensor data every 10 minutes. As there are no confirmed reports about correct battery presentation of the sensor (always shows 99%), this function is currently not supported. MJYD2S sends motion detection events and 2 discrete illuminance levels (1 lux or 100 lux for a dark or bright environment). Additionally battery level and contiguous time without motion in discrete growing steps (no motion time = NMT). Working principle of Tasmota BLE drivers (>8.5.) The idea is to provide drivers with as many automatic functions as possible. Besides the hardware setup, there are zero or very few things to configure. The sensor namings are based on the original sensor names and shortened if appropriate (Flower care -> Flora). A part of the MAC will be added to the name as a suffix. All sensors are treated as if they are physically connected to the ESP8266 device. For motion and remote control sensors MQTT-messages will be published in (nearly) real time. The ESP32 and the HM-1x-modules are real BLE devices whereas the NRF24L01 (+) is only a generic 2.4 GHz transceiver with very limited capabilities. Options to read out the LYWSD03MMC Generate a bind_key The web-tool https://atc1441.github.io/TelinkFlasher.html allows the generation of a so-called bind_key by faking a pairing with the Xiaomi cloud. You can copy-paste this key and add the MAC to use this resultig key-MAC-string with key-command (NRFkey or MI32key). Then the driver will receive the sensors data roughly every 10 minutes (in two chunks for humidity and temperature with about a minute in between) and decode the data. This is the most energy efficient way. The current way of storing these keys on the ESP32 is to use RULES like that (for the NRF24L01 you would use NRFkey): rule1 on System # Boot do backlog MI32key 00112233445566778899 AABBCCDDEEFF112233445566 ; MI32key 00112233445566778899 AABBCCDDEEFFAABBCCDDEEFF endon This option is currently not available for the HM-10 because of memory considerations as part of the standard sensor-firmware package. Flash custom ATC-firmware Use the same https://atc1441.github.io/TelinkFlasher.html to flash a custom ATC-firmware on the LYWSD03MMC. This will work out of the box with all three Tasmota-drivers. There is a slight chance of bricking the sensor, which would require some soldering and compiling skills to un-brick. This firmware does send data more frequently and is a little bit more power hungry than the stock firmware. There is also another new custom firmware here https://github.com/pvvx/ATC_MiThermometer with it's own flasher/config page. The Custom mode is supported in latest Tasmota ESP32, but beware not to use 'All' mode. Use active connections By default on the HM-10 (for legacy reasons) the method to connect to the sensor from time to time. This circumvents the data encryption. This is very power hungry and drains the battery fast. Thus it is only recommended as fallback mechanism. BLE Sensors using HM-1x ~ This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_HM10 #define USE_HM10 // Add support for HM-10 as a BLE-bridge (+9k3 code) #endif Features ~ Supported sensors will be connected to at a set interval (default interval equals TelePeriod). A subscription is established for 5 seconds and data (e.g. temperature, humidity and battery) is read and reported to an mqtt topic (Dew point is calculated): tele /% t opic%/SENSOR = { \"Time\" : \"2020-03-24T12:47:51\" , \"LYWSD03-52680f\" :{ \"Temperature\" : 21.1 , \"Humidity\" : 58.0 , \"DewPoint\" : 12.5 , \"Battery\" : 100 }, \"LYWSD02-a2fd09\" :{ \"Temperature\" : 21.4 , \"Humidity\" : 57.0 , \"DewPoint\" : 12.5 , \"Battery\" : 2 }, \"MJ_HT_V1-d8799d\" :{ \"Temperature\" : 21.4 , \"Humidity\" : 54.6 , \"DewPoint\" : 11.9 }, \"TempUnit\" : \"C\" } After a completed discovery scan, the driver will report the number of found sensors. As Tasmota can not know how many sensors are meant to be discovered you have to force a re-scan until the desired number of devices is found. Rule1 ON HM10 # Found < 6 DO Add1 1 ENDON ON Var1 # State <= 3 DO HM10Scan ENDON This will re-scan up to 3 times if less than 6 sensors are found. Commands Command Parameters HM10Scan Start a new device discovery scan HM10Period Show interval in seconds between sensor read cycles. Set to TelePeriod value at boot. HM10Baud Show ESP8266 serial interface baudrate ( Not HM-10 baudrate ) <value> = set baudrate HM10AT <command> = send AT commands to HM-10. See list HM10Time <n> = set time time of a LYWSD02 only sensor to Tasmota UTC time and timezone. <n> is the sensor number in order of discovery starting with 0 (topmost sensor in the webUI list). HM10Auto <value> = start an automatic discovery scan with an interval of <value> seconds to receive data in BLE advertisements periodically. This is a passive scan and does not produce a scan response from the BLE sensor. It does not increase the sensors battery drain. HM10Page Show the maximum number of sensors shown per page in the webUI list. <value> = set number of sensors (default = 4) HM10Beaconx Set a BLE device as a beacon using the (fixed) MAC-address x - set beacon 1 .. 4 x= 0 - will start a BLE scan and print result to the console <value> (12 or 17 characters) = use beacon given the MAC interpreted as a string AABBCCDDEEFF (also valid: aa:BB:cc:dd:EE:FF ) MAC of 00:00:00:00:00:00 will stop beacon x BLE Sensors using nRF24L01(+) ~ Configuration ~ You must compile your build . Change the following in my_user_config.h : // -- SPI sensors --------------------------------- #define USE_SPI // Hardware SPI using GPIO12(MISO), GPIO13(MOSI) and GPIO14(CLK) in addition to two user selectable GPIOs(CS and DC) #ifdef USE_SPI #define USE_NRF24 // Add SPI support for NRF24L01(+) (+2k6 code) #ifdef USE_NRF24 #define USE_MIBLE // BLE-bridge for some Mijia-BLE-sensors (+4k7 code) Sensors will be discriminated by using the Product-ID of the MiBeacon. A human readable short product name will be shown instead of the company-assigned ID of the BLE Public Device Address (= the \"lower\" 24 bits). A TELE message could like look this: 10 : 13 : 38 RSL : stat /tasmota/ STATUS8 = { \"StatusSNS\" :{ \"Time\" : \"2019-12-18T10:13:38\" , \"Flora-6ab577\" :{ \"Temperature\" : 21.7 , \"Illuminance\" : 21 , \"Humidity\" : 0 , \"Fertility\" : 0 }, \"MJ_HT_V1-3108be\" :{ \"Temperature\" : 22.3 , \"Humidity\" : 56.1 }, \"TempUnit\" : \"C\" }} As the NRF24L01 can only read BLE-advertisements, only the data in these advertisements is accessible. All sensors have an additional GATT-interface with more data in it, but it can not be read with a NRF24l01. As we can not use a checksum to test data integrity of the packet, only data of sensors whose adresses showed up more than once (default = 3 times) will be published. Internally from time to time \"fake\" sensors will be created, when there was data corruption in the address bytes. These will be removed automatically. Commands Command Parameters NRFPage Show the maximum number of sensors shown per page in the webUI list. <value> = set number of sensors (default = 4) NRFIgnore 0 = all known sensor types active_(default)_ <value> = ignore certain sensor type ( 1 = Flora, 2 = MJ_HT_V1, 3 = LYWSD02, 4 = LYWSD03, 5 = CGG1, 6 = CGD1, 7 = NLIGHT, 8 = MJYD2S, 9 = YEERC (DEPRECATED, please switch to NRFUSE) NRFUse 0 = all known sensor types inactive <value> = ignore certain sensor type ( 1 = Flora, 2 = MJ_HT_V1, 3 = LYWSD02, 4 = LYWSD03, 5 = CGG1, 6 = CGD1, 7 = NLIGHT, 8 = MJYD2S, 9 = YEERC NRFScan Scan for regular BLE-advertisements and show a list in the console 0 = start a new scan list 1 = append to the scan list 2 = stop running scan NRFBeacon Set a BLE device as a beacon using the (fixed) MAC-address <value> (1-3 digits) = use beacon from scan list <value> (12 characters) = use beacon given the MAC interpreted as an uppercase string AABBCCDDEEFF NRFKey Set a \"bind_key\" for a MAC-address to decrypt (LYWSD03MMC & MHO-C401). The argument is a 44 uppercase characters long string, which is the concatenation of the bind_key and the corresponding MAC. <00112233445566778899AABBCCDDEEFF> (32 characters) = bind_key <112233445566> (12 characters) = MAC of the sensor <00112233445566778899AABBCCDDEEFF112233445566> (44 characters)= final string NRFMjyd2s Set a \"bind_key\" for a MAC-address to decrypt sensor data of the MJYD2S. The argument is a 44 characters long string, which is the concatenation of the bind_key and the corresponding MAC. <00112233445566778899AABBCCDDEEFF> (32 characters) = bind_key <112233445566> (12 characters) = MAC of the sensor <00112233445566778899AABBCCDDEEFF112233445566> (44 characters)= final string NRFNlight Set the MAC of an NLIGHT <value> (12 characters) = MAC interpreted as an uppercase string AABBCCDDEEFF Beacon ~ A simplified presence dection will scan for regular BLE advertisements of a given BT-device defined by its MAC-address. It is important to know, that many new devices (nearly every Apple-device) will change its MAC every few minutes to prevent tracking. If the driver receives a packet from the \"beacon\" a counter will be (re-)started with an increment every second. This timer is published in the TELE-message, presented in the webUI and processed as a RULE. The stability of regular readings will be strongly influenced by the local environment (many BLE-devices nearby or general noise in the 2.4-GHz-band).","title":"Bluetooth ESP8266"},{"location":"ble/Bluetooth-Esp8266/#esp8266-via-hm-1x-or-nrf24l01","text":"This allows for the receiving of BLE advertisments from BLE devices, including \"iBeacons\"","title":"ESP8266 via HM-1x or nRF24L01(+)"},{"location":"ble/Bluetooth-Esp8266/#ibeacon","text":"This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h :","title":"iBeacon"},{"location":"ble/Bluetooth-Esp8266/#for-esp8266-via-hm-1x-or-nrf24l01","text":"Tasmota uses a BLE 4.x module to scan for iBeacon devices. This driver is working with HM-10 and clones and HM16/HM17 Bluetooth modules and potentially with other HM-1x modules depending on firmware capabilities. Tip If using an extenral module, When first connected some modules will be in peripheral mode. You have to change it to central mode using commands Sensor52 1 and Sensor52 2 .","title":"For ESP8266 via HM-1x or nRF24L01(+)"},{"location":"ble/Bluetooth-Esp8266/#features","text":"For a list of all available commands see Sensor52 command. This driver reports all beacons found during a scan with its ID (derived from beacon's MAC address) prefixed with IBEACON_ and RSSI value. Every beacon report is published as an MQTT tele/%topic%/SENSOR in a separate message: tele /ibeaco n /SENSOR = { \"Time\" : \"2021-01-02T12:08:40\" , \"IBEACON\" :{ \"MAC\" : \"A4C1387FC1E1\" , \"RSSI\" : -56 , \"STATE\" : \"ON\" }} If the beacon can no longer be found during a scan and the timeout interval has passed the beacon's RSSI is set to zero (0) and it is no longer displayed in the webUI tele /ibeaco n /SENSOR = { \"Time\" : \"2021-01-02T12:08:40\" , \"IBEACON\" :{ \"MAC\" : \"A4C1387FC1E1\" , \"RSSI\" : -56 , \"STATE\" : \"OFF\" }} Additional fields will be present depending upon the beacon, e.g. NAME, UID, MAJOR, MINOR.","title":"Features"},{"location":"ble/Bluetooth-Esp8266/#supported-devices","text":"All Apple compatible iBeacon devices should be discoverable. Various nRF51822 beacons should be fully Apple compatible, programmable and their battery lasts about a year. Amazon.com Aliexpress Cheap \"iTag\" beacons with a beeper. The battery on these lasts only about a month. Aliexpress eBay Amazon.com Tip You can activate a beacon with a beeper using command IBEACON_%BEACONID%_RSSI 99 (ID is visible in webUI and SENSOR reports). This command can freeze the Bluetooth module and beacon scanning will stop. After a reboot of Tasmota the beacon will start beeping and scanning will resume. (untested on ESP32 native BLE)","title":"Supported Devices"},{"location":"ble/Bluetooth-Esp8266/#bluetooth-low-energy-sensors","text":"Different vendors offer Bluetooth solutions as part of the XIAOMI family often under the MIJIA-brand (while AQUARA is the typical name for a ZigBee sensor). The sensors supported by Tasmota use BLE (Bluetooth Low Energy) to transmit the sensor data, but they differ in their accessibilities quite substantially. Basically all of them use of so-called \u201eMiBeacons\u201c which are BLE advertisement packets with a certain data structure, which are broadcasted by the devices automatically while the device is not in an active bluetooth connection. The frequency of these messages is set by the vendor and ranges from one per 3 seconds to one per hour (for the battery status of the LYWSD03MMC). Motion sensors and BLE remote controls start to send when an event is triggered. These packets already contain the sensor data and can be passively received by other devices and will be published regardless if a user decides to read out the sensors via connections or not. Thus the battery life of a BLE sensor is not influenced by reading these advertisements and the big advantage is the power efficiency as no active bi-directional connection has to be established. The other advantage is, that scanning for BLE advertisements can happen nearly parallel (= very quick one after the other), while a direct connection must be established for at least a few seconds and will then block both involved devices for that time. This is therefore the preferred option, if technically possible (= for the supported sensors). Most of the \u201eolder\u201c BLE-sensor-devices use unencrypted messages, which can be read by all kinds of BLE-devices or even a NRF24L01. With the arrival of \"newer\" sensors came the problem of encrypted data in MiBeacons, which can be decrypted in Tasmota (not yet with the HM-1x). Meanwhile it is possible to get the needed \"bind_key\" with the help of an open-source project: https://atc1441.github.io/TelinkFlasher.html At least the LYWSD03 allows the use of a simple BLE connection without any encrypted authentication and the reading of the sensor data using normal subscription methods to GATT-services (currently used on the HM-1x). This is more power hungry than the passive reading of BLE advertisements. Other sensors like the MJYD2S are not usable without the \"bind_key\".","title":"Bluetooth Low Energy Sensors"},{"location":"ble/Bluetooth-Esp8266/#supported-devices_1","text":"It can not be ruled out, that changes in the device firmware may break the functionality of this driver completely! The naming conventions in the product range of bluetooth sensors in XIAOMI-universe can be a bit confusing. The exact same sensor can be advertised under slightly different names depending on the seller (Mijia, Xiaomi, Cleargrass, ...). MJ_HT_V1 LYWSD02 CGG1 CGD1 temperature, humidity, battery temperature, humidity, battery temperature, humidity, battery temperature, humidity, battery passive for all entities, reliable battery value battery only active, thus not on the NRF24L01, set clock and unit, very frequent data sending passive for all entities, reliable battery value battery only active, thus not on the NRF24L01, no reliable battery value, no clock functions MiFlora LYWSD03MMC / ATC NLIGHT MJYD2S temperature, illuminance, soil humidity, soil fertility, battery, firmware version temperature, humidity, battery motion motion, illuminance, battery, no-motion-time passive only with newer firmware (>3.0?), battery only active, thus not on the NRF24L01 passive only with decryption or using custom ATC-firmware, no reliable battery value with stock firmware NRF24L01, ESP32 passive only with decryption, thus only NRF24L01, ESP32 YEE RC MHO-C401 MHO-C303 button press (single and long) temperature, humidity, battery temperature, humidity, battery passive equal to the LYWS03MMC, but no custom firmware yet passive for all entities, set clock and unit, no alarm functions, very frequent data sending passive: data is received via BLE advertisments active: data is received via bidrectional connection to the sensor","title":"Supported Devices"},{"location":"ble/Bluetooth-Esp8266/#ble-sensors-using-hm-1x","text":"This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_HM10 #define USE_HM10 // Add support for HM-10 as a BLE-bridge (+9k3 code) #endif","title":"BLE Sensors using HM-1x"},{"location":"ble/Bluetooth-Esp8266/#features_1","text":"Supported sensors will be connected to at a set interval (default interval equals TelePeriod). A subscription is established for 5 seconds and data (e.g. temperature, humidity and battery) is read and reported to an mqtt topic (Dew point is calculated): tele /% t opic%/SENSOR = { \"Time\" : \"2020-03-24T12:47:51\" , \"LYWSD03-52680f\" :{ \"Temperature\" : 21.1 , \"Humidity\" : 58.0 , \"DewPoint\" : 12.5 , \"Battery\" : 100 }, \"LYWSD02-a2fd09\" :{ \"Temperature\" : 21.4 , \"Humidity\" : 57.0 , \"DewPoint\" : 12.5 , \"Battery\" : 2 }, \"MJ_HT_V1-d8799d\" :{ \"Temperature\" : 21.4 , \"Humidity\" : 54.6 , \"DewPoint\" : 11.9 }, \"TempUnit\" : \"C\" } After a completed discovery scan, the driver will report the number of found sensors. As Tasmota can not know how many sensors are meant to be discovered you have to force a re-scan until the desired number of devices is found. Rule1 ON HM10 # Found < 6 DO Add1 1 ENDON ON Var1 # State <= 3 DO HM10Scan ENDON This will re-scan up to 3 times if less than 6 sensors are found.","title":"Features"},{"location":"ble/Bluetooth-Esp8266/#ble-sensors-using-nrf24l01","text":"","title":"BLE Sensors using nRF24L01(+)"},{"location":"ble/Bluetooth-Esp8266/#configuration","text":"You must compile your build . Change the following in my_user_config.h : // -- SPI sensors --------------------------------- #define USE_SPI // Hardware SPI using GPIO12(MISO), GPIO13(MOSI) and GPIO14(CLK) in addition to two user selectable GPIOs(CS and DC) #ifdef USE_SPI #define USE_NRF24 // Add SPI support for NRF24L01(+) (+2k6 code) #ifdef USE_NRF24 #define USE_MIBLE // BLE-bridge for some Mijia-BLE-sensors (+4k7 code) Sensors will be discriminated by using the Product-ID of the MiBeacon. A human readable short product name will be shown instead of the company-assigned ID of the BLE Public Device Address (= the \"lower\" 24 bits). A TELE message could like look this: 10 : 13 : 38 RSL : stat /tasmota/ STATUS8 = { \"StatusSNS\" :{ \"Time\" : \"2019-12-18T10:13:38\" , \"Flora-6ab577\" :{ \"Temperature\" : 21.7 , \"Illuminance\" : 21 , \"Humidity\" : 0 , \"Fertility\" : 0 }, \"MJ_HT_V1-3108be\" :{ \"Temperature\" : 22.3 , \"Humidity\" : 56.1 }, \"TempUnit\" : \"C\" }} As the NRF24L01 can only read BLE-advertisements, only the data in these advertisements is accessible. All sensors have an additional GATT-interface with more data in it, but it can not be read with a NRF24l01. As we can not use a checksum to test data integrity of the packet, only data of sensors whose adresses showed up more than once (default = 3 times) will be published. Internally from time to time \"fake\" sensors will be created, when there was data corruption in the address bytes. These will be removed automatically.","title":"Configuration"},{"location":"ble/Bluetooth-Esp8266/#beacon","text":"A simplified presence dection will scan for regular BLE advertisements of a given BT-device defined by its MAC-address. It is important to know, that many new devices (nearly every Apple-device) will change its MAC every few minutes to prevent tracking. If the driver receives a packet from the \"beacon\" a counter will be (re-)started with an increment every second. This timer is published in the TELE-message, presented in the webUI and processed as a RULE. The stability of regular readings will be strongly influenced by the local environment (many BLE-devices nearby or general noise in the 2.4-GHz-band).","title":"Beacon"},{"location":"ble/EQ3-TRV_with_BLE-ESP32/","text":"This driver alows the control of Eqiva TRV's (i.e. Thermostat Radiator Valve). Compatible models are: not in Tasmota source yet see here Eqiva eQ-3 Bluetooth Smart (141771E0/141771E0A) Eqiva eQ-3 Bluetooth Smart(UK Version) (142461D0) Other Eqiva EQ3 models should work as well, but make sure you select a bluetooth model as there are also non-bluetooth models. Setup ~ Before you can use the TRV you will need to enable bluetooth on the TRV: Press the Mode/Menu button for at least 3 seconds. Select the menu item bLE with the control wheel and confirm by pressing the control wheel shortly. The display will show OFF to deactivate the function or On to activate the function. Confirm by pressing the control wheel shortly. Note: No need to pair the TRV Next you will need to make sure that BLE is enabled in Tasmota: Configuration Configure BLE Enable Bluetooth To determine the mac adresses of a trv: Go to the BLE menu in Tasmota Enable active scan In to the tasmota console: trv devlist This will give you the mac adress of each valve. Note Enable 1 valve at a time as this makes it easier to identify You might need to wait a minute or so or repeat the \"trv devlist\" command a few times before the devices have been properly identified Keep in mind that the TRV does NOT report the current temperature, only the requested, target, temperature. The Xiaomi Thermometer LYWSD03MMC makes a perfect combo for measuring the room temperature (~USD 4) Operating your trv ~ There are 2 ways to control your TRV: The Tasmota Console (convenient for setup) syntax: trv <MAC Address> <command> [options] example: trv 001A2216A458 settemp 21.5 MQTT: syntax: cmnd/<tasmota_topic>/EQ3/<MAC Address>/command [options] example: cmnd/ble_esp32/EQ3/001A2216A458/settemp 22.5 As you can see from the example the MQTT topic is made of: Standard Tasmota %prefix% : cmnd , stat %topic% of the BLE_ESP32 gateway device, here ble_esp32 An EQ3 element to specifiy this command is specifc to the EQ3 driver The MAC address of the EQ3 The command to the EQ3 or result from the EQ3 After submitting a command you will see one or more of the possible results. Status Description queued Command has been accepted by the BLE driver DONENOTIFIED Command has been successfully processed by the trv and the results are send in a json format ignoredbusy Currently we can only accept a single command in the queue, during the processing of a trv command subsequent commands will be rejected. Please resubmit. FAILCONNECT After 3 automatic retries we were not able to contact the trv and we give up. Please resubmit Under normal circumstance you will get a response from the valve (blestate DONENOTIFIED). { \"trv\" : \"00:1a:22:16:a4:58\" , \"blestate\" : \"DONENOTIFIED\" , \"raw\" : \"02010900041C000000001803201707\" , \"temp\" : 14.0 , \"posn\" : 0 , \"mode\" : \"manual\" , \"boost\" : \"inactive\" , \"dst\" : \"set\" , \"window\" : \"closed\" , \"state\" : \"unlocked\" , \"battery\" : \"GOOD\" , \"holidayend\" : \"00-00-00 00:00\" } Field Description trv mac address (should be the same as in the topic) blestate ble driver status queued/DONENOTIFIED/ignoredbusy/FAILCONNECT raw raw data as received from the device temp target temperature posn valve position (0=closed / 100=fully opened) mode manual / auto (auto follows the week program, manual keeps the current requested temperature) boost boost mode (valve opened 80 % for 5 minutes) active/inactive dst Daylight savings time active active window status of the window open functionality (activated when the temperature suddenly drops) state child lock enabled (disables the buttons on the TRV) battery battery status of the TRV holidayend end of holiday mode Available commands ~ Base commands Command Parameters trvperiod Display/Set the EQ3 poll interval in seconds trvonlyaliased Display/Set the EQ3 OnlyAliased parameter set to 1 for any aliased BLE devices set to 2 for only aliases starting with EQ3 TrvMatchPrefix Display/Set the EQ3 MatchPrefix parameter set to 1 to not require active scan to identify EQ3 - identify from MAC (default) Set to 0 to disbale this matching TRV subcommands Command Parameters devlist Display all trv's which have been found in BLE scan mode. No parameters. scan Alias of devlist. No parameters. state Current valve state without changing anything. No parameters. settemp Set the desired target temperature. Temperature . valve Control the valve state. off Disable the trv and enable frost protection on Disable the trv and open the valve completely (saves potentially battery in summer while the central heating is not working). mode Define the current operating mode. auto run the week program as stored in the TRV. day Comfort temperature. night Reduction temperature. Manual disable the weekprogram and keep the temperature as selected (settemp/day/night). Note: When setting a temperature, switch to day or night mode, the TRV will switch back to the program at the next programmed timeslot. setdaynight Change the comfort and reduction temperature. daytemp nighttemp . boost Activate boost mode (valve 80% open for 5 minutes). 1 Note: once activated, boost mode cannot be stopped until end of the 5 minutes. lock Enable or disable TRV buttons. 0 Unlocks buttons 1 Locks buttons. settime Synchronize current tasmota time to the TRV: No parameters. Send an alternate time to the TRV: yyMMddhhmmss (byte by byte conversion from decimal to hexadecimal). Examples Request the current status without changing anything: cmnd/tasmota/EQ3/001A2216A458/state set a target temperature (21.5 c) cmnd/tasmota/EQ3/001A2216A458/settemp 21.5 Select TRV mode auto: run the week program as stored in the TRV cmnd/tasmota/EQ3/001A2216A458/mode auto Select TRV mode Day: Switch to comfort temperature cmnd/tasmota/EQ3/001A2216A458/mode day Select TRV mode Night: Switch to reduction temperature cmnd/tasmota/EQ3/001A2216A458/mode night Select TRV mode Manual: disable the weekprogram and keep the temperature as selected (settemp/day/night) cmnd/tasmota/EQ3/001A2216A458/mode manual Note When setting a temperature, switch to day or night mode, the TRV will switch back to the progarm at the next programmed timeslot. Disable the trv and enable frost protection: cmnd/tasmota/EQ3/001A2216A458/valve off Disable the trv and open the valve completely (saves potentially battery in summer while the central heating is not working): cmnd/tasmota/EQ3/001A2216A458/valve on Change the comfort and reduction temperature to 22C and 17.5C cmnd/tasmota/EQ3/001A2216A458/setdaynight 22 17.5 Enable boost mode (valve 80% open for 5 minutes) cmnd/tasmota/EQ3/001A2216A458/boost 1 Disable TRV buttons cmnd/tasmota/EQ3/001A2216A458/lock 1 Synchronize current tasmota time with the TRV cmnd/tasmota/EQ3/001A2216A458/settime Set the time and date (byte by byte conversion from decimal to hexadecimal) Date: 2021 - jan - 04 - 13:00:00 In hex: 15 - 01 - 04 - 0d:00:00 (yyMMddhhmmss) Concatenate: 1501040d0000 cmnd/tasmota/EQ3/001A2216A458/settime 1501040d0000","title":"EQ3 TRV with BLE ESP32"},{"location":"ble/EQ3-TRV_with_BLE-ESP32/#setup","text":"Before you can use the TRV you will need to enable bluetooth on the TRV: Press the Mode/Menu button for at least 3 seconds. Select the menu item bLE with the control wheel and confirm by pressing the control wheel shortly. The display will show OFF to deactivate the function or On to activate the function. Confirm by pressing the control wheel shortly. Note: No need to pair the TRV Next you will need to make sure that BLE is enabled in Tasmota: Configuration Configure BLE Enable Bluetooth To determine the mac adresses of a trv: Go to the BLE menu in Tasmota Enable active scan In to the tasmota console: trv devlist This will give you the mac adress of each valve. Note Enable 1 valve at a time as this makes it easier to identify You might need to wait a minute or so or repeat the \"trv devlist\" command a few times before the devices have been properly identified Keep in mind that the TRV does NOT report the current temperature, only the requested, target, temperature. The Xiaomi Thermometer LYWSD03MMC makes a perfect combo for measuring the room temperature (~USD 4)","title":"Setup"},{"location":"ble/EQ3-TRV_with_BLE-ESP32/#operating-your-trv","text":"There are 2 ways to control your TRV: The Tasmota Console (convenient for setup) syntax: trv <MAC Address> <command> [options] example: trv 001A2216A458 settemp 21.5 MQTT: syntax: cmnd/<tasmota_topic>/EQ3/<MAC Address>/command [options] example: cmnd/ble_esp32/EQ3/001A2216A458/settemp 22.5 As you can see from the example the MQTT topic is made of: Standard Tasmota %prefix% : cmnd , stat %topic% of the BLE_ESP32 gateway device, here ble_esp32 An EQ3 element to specifiy this command is specifc to the EQ3 driver The MAC address of the EQ3 The command to the EQ3 or result from the EQ3 After submitting a command you will see one or more of the possible results. Status Description queued Command has been accepted by the BLE driver DONENOTIFIED Command has been successfully processed by the trv and the results are send in a json format ignoredbusy Currently we can only accept a single command in the queue, during the processing of a trv command subsequent commands will be rejected. Please resubmit. FAILCONNECT After 3 automatic retries we were not able to contact the trv and we give up. Please resubmit Under normal circumstance you will get a response from the valve (blestate DONENOTIFIED). { \"trv\" : \"00:1a:22:16:a4:58\" , \"blestate\" : \"DONENOTIFIED\" , \"raw\" : \"02010900041C000000001803201707\" , \"temp\" : 14.0 , \"posn\" : 0 , \"mode\" : \"manual\" , \"boost\" : \"inactive\" , \"dst\" : \"set\" , \"window\" : \"closed\" , \"state\" : \"unlocked\" , \"battery\" : \"GOOD\" , \"holidayend\" : \"00-00-00 00:00\" } Field Description trv mac address (should be the same as in the topic) blestate ble driver status queued/DONENOTIFIED/ignoredbusy/FAILCONNECT raw raw data as received from the device temp target temperature posn valve position (0=closed / 100=fully opened) mode manual / auto (auto follows the week program, manual keeps the current requested temperature) boost boost mode (valve opened 80 % for 5 minutes) active/inactive dst Daylight savings time active active window status of the window open functionality (activated when the temperature suddenly drops) state child lock enabled (disables the buttons on the TRV) battery battery status of the TRV holidayend end of holiday mode","title":"Operating your trv"},{"location":"ble/EQ3-TRV_with_BLE-ESP32/#available-commands","text":"","title":"Available commands"},{"location":"changelogs/changelog-7.2/","text":"Version 7.2.0 Constance ~ Change Exception reporting removing exception details from Status 1 and consolidated in Status 12 if available Change HTTP CORS from command SetOption73 0/1 to Cors <cors_domain> allowing user control of specific CORS domain by Shantur Rathore (#7066) Change GUI Shutter button text to Up and Down Arrows based on PR by Xavier Muller (#7166) Change amount of supported DHT sensors from 3 to 4 by Xavier Muller (#7167) Change some Settings locations freeing up space for future single char allowing variable length text Change tasmota-basic.bin and FIRMWARE_BASIC to tasmota-lite.bin and FIRMWARE_LITE Fix flashing H801 led at boot by Stefan Hadinger (#7165, #649) Fix duplicated Backlog when using Event inside a Backlog by Adrian Scillato (#7178, #7147) Fix Gui Timer when using a negative zero offset of -00:00 by Peter Ooms (#7174) Fix DeepSleep in case there is no wifi by Stefan Bode (#7213) Fix Fade would ignore savedata 0 and store to flash anyways (#7262) Fix Arduino IDE compile error (#7277) Fix no AP on initial install (#7282) Add command SerialConfig 0..23 or SerialConfig 8N1 to select Serial Config based in PR by Luis Teixeira (#7108) Add command Sensor34 9 <weight code> to set minimum delta to trigger JSON message by @tobox (#7188) Add rule var %topic% by Adrian Scillato (#5522) Add rule triggers tele-wifi1#xxx by Adrian Scillato (#7093) Add SML bus decoder syntax support for byte order by Gerhard Mutz (#7112) Add experimental support for stepper motor shutter control by Stefan Bode Add optional USE_MQTT_TLS to tasmota-minimal.bin by Bohdan Kmit (#7115) Add save call stack in RTC memory in case of crash, command Status 12 to dump the stack by Stefan Hadinger Add Home Assistant force update by Frederico Leoni (#7140, #7074) Add Wifi Signal Strength in dBm in addition to RSSI Wifi Experience by Andreas Schultz (#7145) Add Yaw, Pitch and Roll support for MPU6050 by Philip Barclay (#7058) Add reporting of raw weight to JSON from HX711 to overcome auto-tare functionality by @tobox (#7171) Add Zigbee support for Xiaomi Aqara Vibration Sensor and Presence Sensor by Stefan Hadinger Add Shutter functions ramp up/down and MQTT reporting by Stefan Bode Add fallback support from version 8.x Add restriction if fallback firmware is incompatible with settings resulting in unreachable device Add support for DHT12 Temperature and Humidity sensor by Stefan Oskamp","title":"Changelog 7.2"},{"location":"changelogs/changelog-7.2/#version-720-constance","text":"Change Exception reporting removing exception details from Status 1 and consolidated in Status 12 if available Change HTTP CORS from command SetOption73 0/1 to Cors <cors_domain> allowing user control of specific CORS domain by Shantur Rathore (#7066) Change GUI Shutter button text to Up and Down Arrows based on PR by Xavier Muller (#7166) Change amount of supported DHT sensors from 3 to 4 by Xavier Muller (#7167) Change some Settings locations freeing up space for future single char allowing variable length text Change tasmota-basic.bin and FIRMWARE_BASIC to tasmota-lite.bin and FIRMWARE_LITE Fix flashing H801 led at boot by Stefan Hadinger (#7165, #649) Fix duplicated Backlog when using Event inside a Backlog by Adrian Scillato (#7178, #7147) Fix Gui Timer when using a negative zero offset of -00:00 by Peter Ooms (#7174) Fix DeepSleep in case there is no wifi by Stefan Bode (#7213) Fix Fade would ignore savedata 0 and store to flash anyways (#7262) Fix Arduino IDE compile error (#7277) Fix no AP on initial install (#7282) Add command SerialConfig 0..23 or SerialConfig 8N1 to select Serial Config based in PR by Luis Teixeira (#7108) Add command Sensor34 9 <weight code> to set minimum delta to trigger JSON message by @tobox (#7188) Add rule var %topic% by Adrian Scillato (#5522) Add rule triggers tele-wifi1#xxx by Adrian Scillato (#7093) Add SML bus decoder syntax support for byte order by Gerhard Mutz (#7112) Add experimental support for stepper motor shutter control by Stefan Bode Add optional USE_MQTT_TLS to tasmota-minimal.bin by Bohdan Kmit (#7115) Add save call stack in RTC memory in case of crash, command Status 12 to dump the stack by Stefan Hadinger Add Home Assistant force update by Frederico Leoni (#7140, #7074) Add Wifi Signal Strength in dBm in addition to RSSI Wifi Experience by Andreas Schultz (#7145) Add Yaw, Pitch and Roll support for MPU6050 by Philip Barclay (#7058) Add reporting of raw weight to JSON from HX711 to overcome auto-tare functionality by @tobox (#7171) Add Zigbee support for Xiaomi Aqara Vibration Sensor and Presence Sensor by Stefan Hadinger Add Shutter functions ramp up/down and MQTT reporting by Stefan Bode Add fallback support from version 8.x Add restriction if fallback firmware is incompatible with settings resulting in unreachable device Add support for DHT12 Temperature and Humidity sensor by Stefan Oskamp","title":"Version 7.2.0 Constance"},{"location":"changelogs/changelog-8.1/","text":"Version 8.1.0 Doris ~ Change Settings text handling allowing variable length text within a total text pool of 699 characters Change Smoother Fade using 100Hz instead of 20Hz animation (#7179) Change number of rule Var s and Mem s from 5 to 16 (#4933) Change number of FriendlyName s from 4 to 8 Add commands WebButton1 until WebButton16 to support user defined GUI button text (#7166) Add support for max 150 characters in most command parameter strings (#3686, #4754) Add support for GPS as NTP server by Christian Baars and Adrian Scillato Add support for AdcParam parameters to control ADC0 Moisture formula by Federico Leoni (#7309) Add Zigbee coalesce sensor attributes into a single message Add Zigbee better support for Xiaomi Double Switch and Xiaomi Vibration sensor Add Deepsleep start delay based on Teleperiod if Teleperiod differs from 10 or 300","title":"Changelog 8.1"},{"location":"changelogs/changelog-8.1/#version-810-doris","text":"Change Settings text handling allowing variable length text within a total text pool of 699 characters Change Smoother Fade using 100Hz instead of 20Hz animation (#7179) Change number of rule Var s and Mem s from 5 to 16 (#4933) Change number of FriendlyName s from 4 to 8 Add commands WebButton1 until WebButton16 to support user defined GUI button text (#7166) Add support for max 150 characters in most command parameter strings (#3686, #4754) Add support for GPS as NTP server by Christian Baars and Adrian Scillato Add support for AdcParam parameters to control ADC0 Moisture formula by Federico Leoni (#7309) Add Zigbee coalesce sensor attributes into a single message Add Zigbee better support for Xiaomi Double Switch and Xiaomi Vibration sensor Add Deepsleep start delay based on Teleperiod if Teleperiod differs from 10 or 300","title":"Version 8.1.0 Doris"},{"location":"changelogs/changelog-8.2/","text":"Version 8.2.0 Elliot ~ Change default my_user_config.h driver and sensor support removing most sensors and adding most drivers to tasmota.bin Change DHT driver ( 7468 , 7717 ) Change Lights: simplified gamma correction and 10 bits internal computation Change commands Prefix , Ssid , StateText , NTPServer , and FriendlyName displaying all items Change Zigbee command prefix from Zigbee* to Zb* Change MQTT message size with additional 200 characters Change display of some date and time messages from Wed Feb 19 10:45:12 2020 to 2020-02-19T10:45:12 Change IRremoteESP8266 library updated to v2.7.4 Fix PowerDelta zero power detection ( 7515 ) Fix White added to light status ( 7142 ) Fix WakeUp <x> ignores provided value ( 7473 ) Fix RGBWWTable ignored ( 7572 ) Fix commands Display and Counter from overruling command processing ( 7322 ) Fix Sonoff Bridge, Sc, L1, iFan03 and CSE7766 serial interface to forced speed, config and disable logging Fix Improved fade linearity with gamma correction Fix PWM flickering at low levels ( 7415 ) Fix LCD line and column positioning ( 7387 ) Fix Display handling of hexadecimal escape characters ( 7387 ) Fix exception 9 restart on log message in Ticker interrupt service routines NTP, Wemos and Hue emulation ( 7496 ) Fix Hass sensor discovery by Federico Leoni ( 7582 , 7548 ) Fix MaxPower functionality ( 7647 ) Fix relation between Wifi RSSI and signal strength Add command SetOption79 0/1 to enable reset of counters at teleperiod time by Andre Thomas ( 7355 ) Add command SetOption82 0/1 to limit the CT range for Alexa to 200..380 Add command SetOption84 0/1 to send AWS IoT device shadow updates (alternative to retained) Add commands SetOption85 0/1 and DevGroupShare supporting UDP Group command using GroupTopic without MQTT by Paul Diem ( 7790 ) Add command SetOption86 0/1 for PWM dimmer to turn brightness LED's off 5 seconds after last change Add command SetOption87 0/1 for PWM dimmer to turn red LED on when powered off Add command SetOption88 0/1 for PWM dimmer to let buttons control remote devices Add command SetOption89 0/1 for Zigbee distinct MQTT topics per device for SENSOR, allowing retained messages ( 7835 ) Add command ShutterButton <parameters> to control shutter(s) by to-scho ( 7403 ) Add commands SwitchMode 8 ToggleMulti, SwitchMode 9 FollowMulti and SwitchMode 10 FollowMultiInverted ( 7522 ) Add commands SwitchMode 11 PushHoldMulti and SwitchMode 12 PushHoldInverted ( 7603 ) Add commands SwitchMode 13 PushOn and SwitchMode 14 PushOnInverted ( 7912 ) Add command Buzzer -1 for infinite mode and command Buzzer -2 for following led mode ( 7623 ) Add command HumOffset -10.0 .. 10.0 to set global humidity sensor offset ( 7934 ) Add support for AdcParam parameters to control ADC0 Current Transformer Apparent Power formula by Jodi Dillon ( 7100 ) Add optional parameter <startcolor> to command Scheme <scheme>, <startcolor> to control initial start color Add web page sliders when SetOption37 128 is active allowing control of white(s) Add SerialConfig to Status 1 Add BootCount Reset Time as BCResetTime to Status 1 Add WifiPower to Status 5 Add most SetOptions as defines to my_user_config.h Add optional Wifi AccessPoint passphrase define WIFI_AP_PASSPHRASE in my_user_config.h ( 7690 ) Add SoftwareSerial to CSE7766 driver allowing different GPIOs ( 7563 ) Add rule trigger on one level deeper using syntax with two # like on zbreceived#vibration_sensor#aqaracubeside=0 do ... Add Zigbee attribute decoder for Xiaomi Aqara Cube Add ZbZNPReceived and ZbZCLReceived being published to MQTT when SetOption66 1 Add Zigbee enhanced commands decoding, added ZbPing Add Zigbee features and improvements Add Zigbee support for Hue emulation by Stefan Hadinger Add HAss Discovery support for Button and Switch triggers by Federico Leoni ( 7901 ) Add Dew Point to Temperature and Humidity sensors Add optional support for Prometheus using file xsns_91_prometheus.ino ( 7216 ) Add support for gzipped binaries Add support for Romanian language translations by Augustin Marti Add support for sensors DS18x20 and DHT family on Shelly 1 and Shelly 1PM using Shelly Add-On adapter ( 7469 ) Add support to BMP driver to enter reset state (sleep enable) when deep sleep is used in Tasmota Add support for DS1624, DS1621 Temperature sensor by Leonid Myravjev Add support for NRF24L01 as BLE-bridge for Mijia Bluetooth sensors by Christian Baars ( 7394 ) Add support for MI-BLE sensors using HM-10 Bluetooth 4.0 module by Christian Staars ( 7683 ) Add support for FiF LE-01MR energy meter by saper-2 ( 7584 ) Add support for Sensors AHT10 and AHT15 by Martin Wagner ( 7596 ) Add support for Wemos Motor Shield V1 by Denis Sborets ( 7764 ) Add support for La Crosse TX23 Anemometer by Norbert Richter ( 3146 , 7765 ) Add support for Martin Jerry/acenx/Tessan/NTONPOWER SD0x PWM dimmer switches by Paul Diem ( 7791 ) Add support for UDP Group control without MQTT by Paul Diem ( 7790 ) Add support for Jarolift rollers by Keeloq algorithm Add support for MaxBotix HRXL-MaxSonar ultrasonic range finders by Jon Little ( 7814 ) Add support for HDC1080 Temperature and Humidity sensor by Luis Teixeira ( 7888 ) Add support for ElectriQ iQ-wifiMOODL RGBW light by Ian King ( 7947 )","title":"Changelog 8.2"},{"location":"changelogs/changelog-8.2/#version-820-elliot","text":"Change default my_user_config.h driver and sensor support removing most sensors and adding most drivers to tasmota.bin Change DHT driver ( 7468 , 7717 ) Change Lights: simplified gamma correction and 10 bits internal computation Change commands Prefix , Ssid , StateText , NTPServer , and FriendlyName displaying all items Change Zigbee command prefix from Zigbee* to Zb* Change MQTT message size with additional 200 characters Change display of some date and time messages from Wed Feb 19 10:45:12 2020 to 2020-02-19T10:45:12 Change IRremoteESP8266 library updated to v2.7.4 Fix PowerDelta zero power detection ( 7515 ) Fix White added to light status ( 7142 ) Fix WakeUp <x> ignores provided value ( 7473 ) Fix RGBWWTable ignored ( 7572 ) Fix commands Display and Counter from overruling command processing ( 7322 ) Fix Sonoff Bridge, Sc, L1, iFan03 and CSE7766 serial interface to forced speed, config and disable logging Fix Improved fade linearity with gamma correction Fix PWM flickering at low levels ( 7415 ) Fix LCD line and column positioning ( 7387 ) Fix Display handling of hexadecimal escape characters ( 7387 ) Fix exception 9 restart on log message in Ticker interrupt service routines NTP, Wemos and Hue emulation ( 7496 ) Fix Hass sensor discovery by Federico Leoni ( 7582 , 7548 ) Fix MaxPower functionality ( 7647 ) Fix relation between Wifi RSSI and signal strength Add command SetOption79 0/1 to enable reset of counters at teleperiod time by Andre Thomas ( 7355 ) Add command SetOption82 0/1 to limit the CT range for Alexa to 200..380 Add command SetOption84 0/1 to send AWS IoT device shadow updates (alternative to retained) Add commands SetOption85 0/1 and DevGroupShare supporting UDP Group command using GroupTopic without MQTT by Paul Diem ( 7790 ) Add command SetOption86 0/1 for PWM dimmer to turn brightness LED's off 5 seconds after last change Add command SetOption87 0/1 for PWM dimmer to turn red LED on when powered off Add command SetOption88 0/1 for PWM dimmer to let buttons control remote devices Add command SetOption89 0/1 for Zigbee distinct MQTT topics per device for SENSOR, allowing retained messages ( 7835 ) Add command ShutterButton <parameters> to control shutter(s) by to-scho ( 7403 ) Add commands SwitchMode 8 ToggleMulti, SwitchMode 9 FollowMulti and SwitchMode 10 FollowMultiInverted ( 7522 ) Add commands SwitchMode 11 PushHoldMulti and SwitchMode 12 PushHoldInverted ( 7603 ) Add commands SwitchMode 13 PushOn and SwitchMode 14 PushOnInverted ( 7912 ) Add command Buzzer -1 for infinite mode and command Buzzer -2 for following led mode ( 7623 ) Add command HumOffset -10.0 .. 10.0 to set global humidity sensor offset ( 7934 ) Add support for AdcParam parameters to control ADC0 Current Transformer Apparent Power formula by Jodi Dillon ( 7100 ) Add optional parameter <startcolor> to command Scheme <scheme>, <startcolor> to control initial start color Add web page sliders when SetOption37 128 is active allowing control of white(s) Add SerialConfig to Status 1 Add BootCount Reset Time as BCResetTime to Status 1 Add WifiPower to Status 5 Add most SetOptions as defines to my_user_config.h Add optional Wifi AccessPoint passphrase define WIFI_AP_PASSPHRASE in my_user_config.h ( 7690 ) Add SoftwareSerial to CSE7766 driver allowing different GPIOs ( 7563 ) Add rule trigger on one level deeper using syntax with two # like on zbreceived#vibration_sensor#aqaracubeside=0 do ... Add Zigbee attribute decoder for Xiaomi Aqara Cube Add ZbZNPReceived and ZbZCLReceived being published to MQTT when SetOption66 1 Add Zigbee enhanced commands decoding, added ZbPing Add Zigbee features and improvements Add Zigbee support for Hue emulation by Stefan Hadinger Add HAss Discovery support for Button and Switch triggers by Federico Leoni ( 7901 ) Add Dew Point to Temperature and Humidity sensors Add optional support for Prometheus using file xsns_91_prometheus.ino ( 7216 ) Add support for gzipped binaries Add support for Romanian language translations by Augustin Marti Add support for sensors DS18x20 and DHT family on Shelly 1 and Shelly 1PM using Shelly Add-On adapter ( 7469 ) Add support to BMP driver to enter reset state (sleep enable) when deep sleep is used in Tasmota Add support for DS1624, DS1621 Temperature sensor by Leonid Myravjev Add support for NRF24L01 as BLE-bridge for Mijia Bluetooth sensors by Christian Baars ( 7394 ) Add support for MI-BLE sensors using HM-10 Bluetooth 4.0 module by Christian Staars ( 7683 ) Add support for FiF LE-01MR energy meter by saper-2 ( 7584 ) Add support for Sensors AHT10 and AHT15 by Martin Wagner ( 7596 ) Add support for Wemos Motor Shield V1 by Denis Sborets ( 7764 ) Add support for La Crosse TX23 Anemometer by Norbert Richter ( 3146 , 7765 ) Add support for Martin Jerry/acenx/Tessan/NTONPOWER SD0x PWM dimmer switches by Paul Diem ( 7791 ) Add support for UDP Group control without MQTT by Paul Diem ( 7790 ) Add support for Jarolift rollers by Keeloq algorithm Add support for MaxBotix HRXL-MaxSonar ultrasonic range finders by Jon Little ( 7814 ) Add support for HDC1080 Temperature and Humidity sensor by Luis Teixeira ( 7888 ) Add support for ElectriQ iQ-wifiMOODL RGBW light by Ian King ( 7947 )","title":"Version 8.2.0 Elliot"},{"location":"devices/","text":"Visit Tasmota Device Templates Repository for a complete list of devices working with Tasmota. Devices listed here are the ones existing as modules in Tasmota.","title":"Index"},{"location":"devices/4CH-Wifi-Socket-with-USB-Charger-SA-P402A/","text":"Products ~ WiFi-Socket-Smart-Power-Strip at aliexpress AKA: SA-P402A BY-V1.1. 180823 Wifi Smart Power Strip 4 EU Outlets Plug with 4 USBCharging Port at aliexpress also at Amazon.de as AOFO ZLD-44EU-W Koogeek Wifi Smart USB Power Strip Socket at aliexpress AKA: 0710033644644 / KLOE4 Woox R4028 EU Smart Power Strip with 3 EU Plug and 4 USB charging Ports Opening ~ To open take a very small screwdrive to pull out the six feets. Don't remove the rubber plates, it won't help. Flashing ~ You'll have to connect GPIO0 manually, the switch is connected to GPIO1. It marked the pin in the picture. Because the TYWE2S has 2mm pitch, I made a little adapter to 2,54mm pitch. Then it can easy soldered to the first four pins. From left to right 3,3V, Gnd, Rx, Tx. Configuration ~ Configure the USB-Charger as number five, then the next socket as number one and so on. This is the configuration: For the other model (Koogeek and AOFO) the GPIO connections are a bit different: LED: GPIO1 Switch: GPIO3 Socket 1: GPIO5 Socket 2: GPIO4 Socket 3: GPIO12 Socket 4: GPIO13 USB: GPIO14 For the model Woox R4028 the GPIO connections are a bit different ( only 3 EU Plugs): LED: GPIO1 Switch: GPIO3 Socket 1: GPIO5 Socket 2: GPIO4 Socket 3: GPIO13 USB: GPIO14","title":"4CH Wifi Socket with USB Charger SA P402A"},{"location":"devices/4CH-Wifi-Socket-with-USB-Charger-SA-P402A/#products","text":"WiFi-Socket-Smart-Power-Strip at aliexpress AKA: SA-P402A BY-V1.1. 180823 Wifi Smart Power Strip 4 EU Outlets Plug with 4 USBCharging Port at aliexpress also at Amazon.de as AOFO ZLD-44EU-W Koogeek Wifi Smart USB Power Strip Socket at aliexpress AKA: 0710033644644 / KLOE4 Woox R4028 EU Smart Power Strip with 3 EU Plug and 4 USB charging Ports","title":"Products"},{"location":"devices/4CH-Wifi-Socket-with-USB-Charger-SA-P402A/#opening","text":"To open take a very small screwdrive to pull out the six feets. Don't remove the rubber plates, it won't help.","title":"Opening"},{"location":"devices/4CH-Wifi-Socket-with-USB-Charger-SA-P402A/#flashing","text":"You'll have to connect GPIO0 manually, the switch is connected to GPIO1. It marked the pin in the picture. Because the TYWE2S has 2mm pitch, I made a little adapter to 2,54mm pitch. Then it can easy soldered to the first four pins. From left to right 3,3V, Gnd, Rx, Tx.","title":"Flashing"},{"location":"devices/4CH-Wifi-Socket-with-USB-Charger-SA-P402A/#configuration","text":"Configure the USB-Charger as number five, then the next socket as number one and so on. This is the configuration: For the other model (Koogeek and AOFO) the GPIO connections are a bit different: LED: GPIO1 Switch: GPIO3 Socket 1: GPIO5 Socket 2: GPIO4 Socket 3: GPIO12 Socket 4: GPIO13 USB: GPIO14 For the model Woox R4028 the GPIO connections are a bit different ( only 3 EU Plugs): LED: GPIO1 Switch: GPIO3 Socket 1: GPIO5 Socket 2: GPIO4 Socket 3: GPIO13 USB: GPIO14","title":"Configuration"},{"location":"devices/Arilux-LC02/","text":"This device is a RGBW led controller and need a different setup against the ex Arilux LC01 You can configure it as a \"generic module\" And set the GPIO as follow: Red: * D1 GPIO5 = 33 PWM1 Blue: * D6 GPIO12 = 35 PWM3 White: * D7 GPIO13 = 36 PWM4 Green: * D5 GPIO14 = 34 PWM2 Learn more about Arilux devices","title":"Arilux LC02"},{"location":"devices/Arilux-LC04/","text":"Arilux AL-LC04 ~ (WIFI Smart RGBW Controller With 24-key IR Remote, Working Voltage: DC 9-12V, Output Current: RGBW, 4*4A) These devices can be configured as \"generic module\" with this GPIO configuration: GPIO04 = [51] IRrecv GPIO05 = [38] PWM2 (G) GPIO12 = [39] PWM3 (R) GPIO14 = [37] PWM1 (B) GPIO13 = [40] PWM4 (W) [Only for RGBW-Stripe] A later version has been found to use the following configuration: GPIO04 = [51] IRrecv GPIO05 = [38] PWM2 (G) GPIO13 = [39] PWM3 (R) GPIO12 = [37] PWM1 (B) GPIO15 = [40] PWM4 (W) [Only for RGBW-Stripe] Note: as of #5523 IRCodes are now 64 bits. Copy this Code to your console to use the 24 Button IR Remote rule1 on IrReceived#Data=0x00FFB04F do power1 on endon on IrReceived#Data=0x00FFF807 do power1 off endon on IrReceived#Data=0x00FF906F do dimmer + endon on IrReceived#Data=0x00FFB847 do dimmer - endon on IrReceived#Data=0x00FFB24D do scheme 0 endon on IrReceived#Data=0x00FF00FF do scheme 4 endon on IrReceived#Data=0x00FF58A7 do scheme 2 endon on IrReceived#Data=0x00FF30CF do scheme 3 endon rule2 on IrReceived#Data=0x00FF9867 do color2 #FF0000 endon on IrReceived#Data=0x00FFE817 do color2 #470D00 endon on IrReceived#Data=0x00FF02FD do color2 #381600 endon on IrReceived#Data=0x00FF50AF do color2 #331E00 endon on IrReceived#Data=0x00FF38C7 do color2 #332800 endon on IrReceived#Data=0x00FFD827 do color2 #00FF00 endon on IrReceived#Data=0x00FF48B7 do color2 #00330A endon on IrReceived#Data=0x00FF32CD do color2 #003314 endon on IrReceived#Data=0x00FF7887 do color2 #00331E endon rule3 on IrReceived#Data=0x00FF28D7 do color2 #003328 endon on IrReceived#Data=0x00FF8877 do color2 #0000FF endon on IrReceived#Data=0x00FF6897 do color2 #0A0033 endon on IrReceived#Data=0x00FF20DF do color2 #140033 endon on IrReceived#Data=0x00FF708F do color2 #140033 endon on IrReceived#Data=0x00FFF00F do color2 #280033 endon on IrReceived#Data=0x00FFA857 do color2 #FFFFFF endon and then activate the rules Backlog rule1 1; rule2 1; rule3 1 Learn more about Arilux devices","title":"Arilux AL-LC04"},{"location":"devices/Arilux-LC04/#arilux-al-lc04","text":"(WIFI Smart RGBW Controller With 24-key IR Remote, Working Voltage: DC 9-12V, Output Current: RGBW, 4*4A) These devices can be configured as \"generic module\" with this GPIO configuration: GPIO04 = [51] IRrecv GPIO05 = [38] PWM2 (G) GPIO12 = [39] PWM3 (R) GPIO14 = [37] PWM1 (B) GPIO13 = [40] PWM4 (W) [Only for RGBW-Stripe] A later version has been found to use the following configuration: GPIO04 = [51] IRrecv GPIO05 = [38] PWM2 (G) GPIO13 = [39] PWM3 (R) GPIO12 = [37] PWM1 (B) GPIO15 = [40] PWM4 (W) [Only for RGBW-Stripe] Note: as of #5523 IRCodes are now 64 bits. Copy this Code to your console to use the 24 Button IR Remote rule1 on IrReceived#Data=0x00FFB04F do power1 on endon on IrReceived#Data=0x00FFF807 do power1 off endon on IrReceived#Data=0x00FF906F do dimmer + endon on IrReceived#Data=0x00FFB847 do dimmer - endon on IrReceived#Data=0x00FFB24D do scheme 0 endon on IrReceived#Data=0x00FF00FF do scheme 4 endon on IrReceived#Data=0x00FF58A7 do scheme 2 endon on IrReceived#Data=0x00FF30CF do scheme 3 endon rule2 on IrReceived#Data=0x00FF9867 do color2 #FF0000 endon on IrReceived#Data=0x00FFE817 do color2 #470D00 endon on IrReceived#Data=0x00FF02FD do color2 #381600 endon on IrReceived#Data=0x00FF50AF do color2 #331E00 endon on IrReceived#Data=0x00FF38C7 do color2 #332800 endon on IrReceived#Data=0x00FFD827 do color2 #00FF00 endon on IrReceived#Data=0x00FF48B7 do color2 #00330A endon on IrReceived#Data=0x00FF32CD do color2 #003314 endon on IrReceived#Data=0x00FF7887 do color2 #00331E endon rule3 on IrReceived#Data=0x00FF28D7 do color2 #003328 endon on IrReceived#Data=0x00FF8877 do color2 #0000FF endon on IrReceived#Data=0x00FF6897 do color2 #0A0033 endon on IrReceived#Data=0x00FF20DF do color2 #140033 endon on IrReceived#Data=0x00FF708F do color2 #140033 endon on IrReceived#Data=0x00FFF00F do color2 #280033 endon on IrReceived#Data=0x00FFA857 do color2 #FFFFFF endon and then activate the rules Backlog rule1 1; rule2 1; rule3 1 Learn more about Arilux devices","title":"Arilux AL-LC04"},{"location":"devices/Armtronix-Dimmers/","text":"There is a small company making dimmers in about the same formfactor as a sonoff dual and single. These Single and Dual dimmer boards have open source firmware. Supported since version 6.4.0 as ARMTR Dimmer (56) Hardware ~ The dimmers contain an ESP8266 for the wifi connection and an Atmega328 which monitors the mains frequency and dimm the lights using a triac and phase controlled dimming. Communication between the two is done using the serial port at 115200 baud. The dimmers contain extra connections (pin headers) for a 10K potentiometer. When this one is connected you get 10 step dimming of the lights which overrides the tasmota dimm level. This feature also works when the Tasmota firmware is non-functional, so it is nice as a fail safe feature. The setting of the potentiometer is fed back to the Tasmota firmware, so when the potentiometer dimmer is turned and the Tasmota setting overridden, the value in the Tasmota channel is representable of the dimmer value. WARNINGS ~ Phase dimming is not for all lights. Most incandescent bulbs will work, but for LED and CCFL bulbs you will need the special dimmable versions of these lights. The large Blue/Yellow Swedish furniture store has some nice ones. Because these dimmers come in a small package, they lack a bit on the safety and interference side. A good idea would be to add a 1A fuse in the AC line and a R/C Snubber on the output. I also read somewhere that they work less well on 110VAC but this could probably be solved using a firmware update. The ESP8266 and Atmega are isolated from Mains. The used 220v-5V converter is the tried and tested HiLink 5V 0.6A PM01, but without the case. Software ~ For now, to use these dimmers you need to take it apart and flash new firmware to the ESP8266 and the Atmega328p using the Arduino IDE. The whole process is quite well documented for the single and dual dimmers. But you do need a USB to serial bridge, at best one with the DTR and RTS signals broken out as well. The software can be found in two Github repositories, for the single and dual dimmer. The Armtronix dimmer can be used in the Tasmota firmware by uncommenting the line #define USE_ARMTRONIX_DIMMERS in my_user_config.h and setting the module to ARMTR Dimmer. The Dual dimmer has a dual color led, which for now shows the wifi status of the Tasmota firmware. But this can be changed in the Tasmota firmware.","title":"Armtronix Dimmers"},{"location":"devices/Armtronix-Dimmers/#hardware","text":"The dimmers contain an ESP8266 for the wifi connection and an Atmega328 which monitors the mains frequency and dimm the lights using a triac and phase controlled dimming. Communication between the two is done using the serial port at 115200 baud. The dimmers contain extra connections (pin headers) for a 10K potentiometer. When this one is connected you get 10 step dimming of the lights which overrides the tasmota dimm level. This feature also works when the Tasmota firmware is non-functional, so it is nice as a fail safe feature. The setting of the potentiometer is fed back to the Tasmota firmware, so when the potentiometer dimmer is turned and the Tasmota setting overridden, the value in the Tasmota channel is representable of the dimmer value.","title":"Hardware"},{"location":"devices/Armtronix-Dimmers/#warnings","text":"Phase dimming is not for all lights. Most incandescent bulbs will work, but for LED and CCFL bulbs you will need the special dimmable versions of these lights. The large Blue/Yellow Swedish furniture store has some nice ones. Because these dimmers come in a small package, they lack a bit on the safety and interference side. A good idea would be to add a 1A fuse in the AC line and a R/C Snubber on the output. I also read somewhere that they work less well on 110VAC but this could probably be solved using a firmware update. The ESP8266 and Atmega are isolated from Mains. The used 220v-5V converter is the tried and tested HiLink 5V 0.6A PM01, but without the case.","title":"WARNINGS"},{"location":"devices/Armtronix-Dimmers/#software","text":"For now, to use these dimmers you need to take it apart and flash new firmware to the ESP8266 and the Atmega328p using the Arduino IDE. The whole process is quite well documented for the single and dual dimmers. But you do need a USB to serial bridge, at best one with the DTR and RTS signals broken out as well. The software can be found in two Github repositories, for the single and dual dimmer. The Armtronix dimmer can be used in the Tasmota firmware by uncommenting the line #define USE_ARMTRONIX_DIMMERS in my_user_config.h and setting the module to ARMTR Dimmer. The Dual dimmer has a dual color led, which for now shows the wifi status of the Tasmota firmware. But this can be changed in the Tasmota firmware.","title":"Software"},{"location":"devices/BlitzWolf-BW-SHP4-UK-Version/","text":"Product Page: https://www.amazon.co.uk/gp/product/B07GJ26TCQ Serial Connection ~ Please see the Hardware Preparation page for general instructions. MAKE SURE YOU DON'T HAVE IT PLUGGED IN WHEN DOING ANY OF THIS INCLUDING FLASHING - YOU HAVE BEEN WARNED. AS ALWAYS, YOU DO ANY OF THIS AT YOUR OWN RISK. Overview ~ The UK version of the BW SHP works perfectly as module number 45 (BlitzWolf SHP) but is challenging to flash with Tasmota firmware for two reasons: The case is glued; this is relatively easy to overcome as you can insert a very thin screwdriver into the case then simply slide it all the way around the perimeter to free off the glue. A much bigger issue is that the programming pins for the esp8266 are underneath the PCB very close to the case, so there's no way to get to them easily. This is the biggest challenge to installing Tasmota. There are three choices here: Open the case, unsolder the main PCB from the live and neutral pins. This is very difficult to do without deforming the plastic protection on the pins themselves and needs a powerful soldering iron. Open the case, bend the main PCB up from the case. I've done one this way and it's possible, but not ideal as the copper live and neutral bars could crack from fatigue. In either of these two methods, you also have to glue the case back together before the plug is safe to use, otherwise if you try and pull it out of a socket the cover simply comes off, exposing all the mains potentials. Make a slot in the bottom of the case, exposing the programming pins. This is my recommended way of doing it because it doesn't risk damaging the case or having it come apart from improper gluing, nor does it potentially fatigue the power pins or deform their safety plastic. However it does leave a big hole in the bottom of the case! That said, the hole is only accessible when the plug is not in a socket and you can always cover it with more plastic later. Holes in the base method ~ If you want to go for method 3 ie hole in the base, this is where they should be. There's a better picture of this area of the PCB further down this page on a version I removed from its case. Opening the case ~ If you really feel a need to open the case - not recommended - get something very thin and fairly strong, push it into the base and pry a little until it goes in 3-4 millimetres. Then slowly rotate the plug with the wedge held in the opening so you end up pushing the top of the case away from the base all the way around. Once you're done, this is what you'll find inside. Gently pull the white shutter mechanism upwards and off the copper pins - it comes away very smoothly and easily but be careful to hold upright so the little spring doesn't pop out and disappear. To get at the programming pins you then either have to desolder the live and neutral from the PCB and lift the whole thing off - strongly recommend you don't do this as you will almost certainly deform the plastic protecting the pins - or you will need to bend the PCB gently upwards so you can get at the underside. If you do that it will look like this..... It's then pretty easy to flash using the pin connections I've annotated on the drawing - make sure you power it from low voltage though - DON'T EVER CONNECT TO THE MAINS TO FLASH OR WHEN CASE IS OPEN. Once done, bend the PCB back into place, pop the white shutter assembly back on top and put the two case halves together with strong glue. MAKE SURE THE GLUE IS WELL HELD AS OTHERWISE WHEN YOU PULL THE PLUG OUT OF A SOCKET THE TOP COULD COME OFF, EXPOSING ALL THE LIVE CONNECTIONS. This is why I DON'T recommend opening the case to flash the firmware but instead suggest cutting a slot in the base and cover it afterwards.","title":"BlitzWolf BW SHP4 UK Version"},{"location":"devices/BlitzWolf-BW-SHP4-UK-Version/#serial-connection","text":"Please see the Hardware Preparation page for general instructions. MAKE SURE YOU DON'T HAVE IT PLUGGED IN WHEN DOING ANY OF THIS INCLUDING FLASHING - YOU HAVE BEEN WARNED. AS ALWAYS, YOU DO ANY OF THIS AT YOUR OWN RISK.","title":"Serial Connection"},{"location":"devices/BlitzWolf-BW-SHP4-UK-Version/#overview","text":"The UK version of the BW SHP works perfectly as module number 45 (BlitzWolf SHP) but is challenging to flash with Tasmota firmware for two reasons: The case is glued; this is relatively easy to overcome as you can insert a very thin screwdriver into the case then simply slide it all the way around the perimeter to free off the glue. A much bigger issue is that the programming pins for the esp8266 are underneath the PCB very close to the case, so there's no way to get to them easily. This is the biggest challenge to installing Tasmota. There are three choices here: Open the case, unsolder the main PCB from the live and neutral pins. This is very difficult to do without deforming the plastic protection on the pins themselves and needs a powerful soldering iron. Open the case, bend the main PCB up from the case. I've done one this way and it's possible, but not ideal as the copper live and neutral bars could crack from fatigue. In either of these two methods, you also have to glue the case back together before the plug is safe to use, otherwise if you try and pull it out of a socket the cover simply comes off, exposing all the mains potentials. Make a slot in the bottom of the case, exposing the programming pins. This is my recommended way of doing it because it doesn't risk damaging the case or having it come apart from improper gluing, nor does it potentially fatigue the power pins or deform their safety plastic. However it does leave a big hole in the bottom of the case! That said, the hole is only accessible when the plug is not in a socket and you can always cover it with more plastic later.","title":"Overview"},{"location":"devices/BlitzWolf-BW-SHP4-UK-Version/#holes-in-the-base-method","text":"If you want to go for method 3 ie hole in the base, this is where they should be. There's a better picture of this area of the PCB further down this page on a version I removed from its case.","title":"Holes in the base method"},{"location":"devices/BlitzWolf-BW-SHP4-UK-Version/#opening-the-case","text":"If you really feel a need to open the case - not recommended - get something very thin and fairly strong, push it into the base and pry a little until it goes in 3-4 millimetres. Then slowly rotate the plug with the wedge held in the opening so you end up pushing the top of the case away from the base all the way around. Once you're done, this is what you'll find inside. Gently pull the white shutter mechanism upwards and off the copper pins - it comes away very smoothly and easily but be careful to hold upright so the little spring doesn't pop out and disappear. To get at the programming pins you then either have to desolder the live and neutral from the PCB and lift the whole thing off - strongly recommend you don't do this as you will almost certainly deform the plastic protecting the pins - or you will need to bend the PCB gently upwards so you can get at the underside. If you do that it will look like this..... It's then pretty easy to flash using the pin connections I've annotated on the drawing - make sure you power it from low voltage though - DON'T EVER CONNECT TO THE MAINS TO FLASH OR WHEN CASE IS OPEN. Once done, bend the PCB back into place, pop the white shutter assembly back on top and put the two case halves together with strong glue. MAKE SURE THE GLUE IS WELL HELD AS OTHERWISE WHEN YOU PULL THE PLUG OUT OF A SOCKET THE TOP COULD COME OFF, EXPOSING ALL THE LIVE CONNECTIONS. This is why I DON'T recommend opening the case to flash the firmware but instead suggest cutting a slot in the base and cover it afterwards.","title":"Opening the case"},{"location":"devices/BlitzWolf-SHP2/","text":"The BlitzWolf BW-SHP2, HomeCube SP1, and Teckin SP22 are basically the same device barring the branding. September 2019 - Recent versions of the Teckin SP22 have been redesigned with a Tuya WR2 Wi-Fi module based on the Realtek RTL8710BN. Since these are not ESP82xx based, Tasmota will not function on this newer version of the device. Product Page: - BlitzWolf BW-SHP2 - Gosund-SP1 OTA install ~ October 2019 - As far as the newer firmware versions and shipments are delivered, the devices possibly won't work with this method. Try it at your own discretion. Since SHP2 is one of those Tuya based devices this OTA Tasmota installation method works just fine: https://github.com/ct-Open-Source/tuya-convert The Tuya-convert has a built in Tasmota v6.5.0 basic(but you can define any firmware during the install), remember, that basic version doesn't come with homeassistant auto discovery support, but Tasmota OTA works as expected. This method does't need any wiring. Serial Connection ~ Please see the Hardware Preparation page for general instructions. Step 1. ~ Be sure it is NOT plugged in! Remove the 4 triangle screws. Triangular 2.3mm Screwdriver required (a Torx T6 works well too)! Step 2. ~ Solder cables to the ESP Pins Step 3. ~ For version 2.3 and 2.4, see: devices/Gosund-SP1 . Connect serial adapter and make a shortwire between Pin IO0 and GND during startup. (For entering flashmode) RX and TX must be crossed. Step 4. ~ Flash Tasmota OpenHab configuration ~ sonoff.items: Switch BlitzwoIFSHP2 \"Switch\" { mqtt=\">[broker:cmnd/BlitzwoIFSHP2/POWER:command:*:default],<[broker:stat/BlitzwoIFSHP2/POWER:state:default]\" } Number Power_Total \"Total: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Total)]\" } Number Power_Today \"Today: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Today)]\" } Number Power_Yesterday \"Yesterday: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Yesterday)]\" } Number Power \"Power: [%.1f Watt]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Power)]\" } Number Voltage \"Voltage: [%.0f V]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Voltage)]\" } Number Current \"Current: [%.3f A]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Current)]\" } Number Factor \"Factor: [%.2f]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Factor)]\" } default.sitemap: Switch item=BlitzwoIFSHP2 label=\"BlitzWoIF SHP2\" icon=\"socket\" mappings=[OFF=\"Off\",ON=\"On\"] Text item=Power label=\"Power: [%.1f Watt]\" icon=\"energy\" Text item=Voltage label=\"Voltage: [%.0f V]\" icon=\"energy\" Text item=Current label=\"Current: [%.3f A]\" icon=\"energy\" Text item=Factor label=\"Factor: [%.2f]\" icon=\"energy\" Text item=Power_Total label=\"Power Total: [%.3f kWh]\" icon=\"energy\" Text item=Power_Today label=\"Power Today: [%.3f kWh]\" icon=\"energy\" Text item=Power_Yesterday label=\"Power Yesterday: [%.3f kWh]\" icon=\"energy\" Home Assistant configuration ~ configuration.yaml switch : - platform : mqtt name : \"Blitzwolf\" state_topic : \"stat/blitzwolf/POWER\" command_topic : \"cmnd/blitzwolf/POWER\" payload_on : \"ON\" payload_off : \"OFF\" retain : false sensor : - platform : mqtt name : \"Blitzwolf Energy Today\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Today\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Yesterday\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Yesterday\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Total\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Total\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Power\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Power\"] }}' unit_of_measurement : \"W\" - platform : mqtt name : \"Blitzwolf Voltage\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Voltage\"] }}' unit_of_measurement : \"V\" - platform : mqtt name : \"Blitzwolf Power Factor\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Factor\"] }}' Attention ~ There is a newer hardware revision (v2.3) which is supported too. Use latest release. See also devices/Gosund-SP1","title":"BlitzWolf SHP2"},{"location":"devices/BlitzWolf-SHP2/#ota-install","text":"October 2019 - As far as the newer firmware versions and shipments are delivered, the devices possibly won't work with this method. Try it at your own discretion. Since SHP2 is one of those Tuya based devices this OTA Tasmota installation method works just fine: https://github.com/ct-Open-Source/tuya-convert The Tuya-convert has a built in Tasmota v6.5.0 basic(but you can define any firmware during the install), remember, that basic version doesn't come with homeassistant auto discovery support, but Tasmota OTA works as expected. This method does't need any wiring.","title":"OTA install"},{"location":"devices/BlitzWolf-SHP2/#serial-connection","text":"Please see the Hardware Preparation page for general instructions.","title":"Serial Connection"},{"location":"devices/BlitzWolf-SHP2/#step-1","text":"Be sure it is NOT plugged in! Remove the 4 triangle screws. Triangular 2.3mm Screwdriver required (a Torx T6 works well too)!","title":"Step 1."},{"location":"devices/BlitzWolf-SHP2/#step-2","text":"Solder cables to the ESP Pins","title":"Step 2."},{"location":"devices/BlitzWolf-SHP2/#step-3","text":"For version 2.3 and 2.4, see: devices/Gosund-SP1 . Connect serial adapter and make a shortwire between Pin IO0 and GND during startup. (For entering flashmode) RX and TX must be crossed.","title":"Step 3."},{"location":"devices/BlitzWolf-SHP2/#step-4","text":"Flash Tasmota","title":"Step 4."},{"location":"devices/BlitzWolf-SHP2/#openhab-configuration","text":"sonoff.items: Switch BlitzwoIFSHP2 \"Switch\" { mqtt=\">[broker:cmnd/BlitzwoIFSHP2/POWER:command:*:default],<[broker:stat/BlitzwoIFSHP2/POWER:state:default]\" } Number Power_Total \"Total: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Total)]\" } Number Power_Today \"Today: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Today)]\" } Number Power_Yesterday \"Yesterday: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Yesterday)]\" } Number Power \"Power: [%.1f Watt]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Power)]\" } Number Voltage \"Voltage: [%.0f V]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Voltage)]\" } Number Current \"Current: [%.3f A]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Current)]\" } Number Factor \"Factor: [%.2f]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Factor)]\" } default.sitemap: Switch item=BlitzwoIFSHP2 label=\"BlitzWoIF SHP2\" icon=\"socket\" mappings=[OFF=\"Off\",ON=\"On\"] Text item=Power label=\"Power: [%.1f Watt]\" icon=\"energy\" Text item=Voltage label=\"Voltage: [%.0f V]\" icon=\"energy\" Text item=Current label=\"Current: [%.3f A]\" icon=\"energy\" Text item=Factor label=\"Factor: [%.2f]\" icon=\"energy\" Text item=Power_Total label=\"Power Total: [%.3f kWh]\" icon=\"energy\" Text item=Power_Today label=\"Power Today: [%.3f kWh]\" icon=\"energy\" Text item=Power_Yesterday label=\"Power Yesterday: [%.3f kWh]\" icon=\"energy\"","title":"OpenHab configuration"},{"location":"devices/BlitzWolf-SHP2/#home-assistant-configuration","text":"configuration.yaml switch : - platform : mqtt name : \"Blitzwolf\" state_topic : \"stat/blitzwolf/POWER\" command_topic : \"cmnd/blitzwolf/POWER\" payload_on : \"ON\" payload_off : \"OFF\" retain : false sensor : - platform : mqtt name : \"Blitzwolf Energy Today\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Today\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Yesterday\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Yesterday\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Total\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Total\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Power\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Power\"] }}' unit_of_measurement : \"W\" - platform : mqtt name : \"Blitzwolf Voltage\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Voltage\"] }}' unit_of_measurement : \"V\" - platform : mqtt name : \"Blitzwolf Power Factor\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Factor\"] }}'","title":"Home Assistant configuration"},{"location":"devices/BlitzWolf-SHP2/#attention","text":"There is a newer hardware revision (v2.3) which is supported too. Use latest release. See also devices/Gosund-SP1","title":"Attention"},{"location":"devices/BlitzWolf-SHP6/","text":"The BlitzWolf BW-SHP6 and the Gosund SP111 are basically the same device, barring the branding. Product page: - BlitzWolf\u00ae BW-SHP6 - 2300W EU WIFI Smart Socket - Gosund SP111 Device needs exact calibration with a load >=60 Watt to gain good results! For further infos see Issue #4727 Serial Connection ~ Please see the Hardware Preparation page for general instructions. There are currently at least two versions of this device. The (newer) Version has exposed contacts with holes for all connections necessary to flash tasmota, while the old requires soldering of cables to some points. For the older Version: Step 1 ~ Disconnect device from power source! Step 2 ~ Remove one screw on the back of the device. PH1 screwdriver required. Step 3 ~ Undo 2 screws. PH1 screwdriver required. Disconnect antenna. Step 4 ~ Carefully remove PCB from casing for easier soldering. * Don't stress antenna cable too much. * Don't lose metal tube. Step 5 ~ Solder cables to the ESP Pins. SHP6 10A model: SHP6 15A model: If you do not want to solder you can try using crocodile clips and manually push a jumper cable first to IO0 (enter flash mode while booting, i.e. connect IO0 to ground) and then during flashing push a jumper to TX. Just be careful to not cause any short-circuit with the clips on the other side of the pads. Crocodile clips Step 6 ~ Connect serial adapter and make a shortwire between Pin IO0 and GND during startup (for entering flashmode). Step 7 ~ Erase flash to avoid issues with dropping WiFi connection. Example using esptool: esptool . py -- port COM3 erase_flash Step 8 ~ Flash Tasmota. Step 9 ~ Select the correct configuration under Configuration -> Configure Module or apply correct template: SHP6 10A model SHP6 15A model As an alternative for steps 3 to 5: ~ The following programming adapter could be an option, which requires no soldering or significant disassembly on the SHP-6. It significantly reduces the effort of reflashing multiple SHP-6 units. Thingiverse link For Version 2 for steps 3 to 5: ~ The new Version has exposed pads with holes for Ground, Reset, TX, RX, Vcc 3.3.V and GPIO0. YOu can use small jumper cables to directly connect a programmer, so no further disassembly is required. Other photos ~ Power monitoring calibration ~ Approach the calibration using the Method 2. If not satisfied with the results, you could mod the SMD direct measure resistor or mitigate this using a Tasmota set of rules (values valid only for the 10A model): Rule1 ON energy#power<=100 DO Currentcal 2500 BREAK ON energy#power<=500 DO Currentcal 2635 BREAK ON energy#power<=1000 DO Currentcal 2788 BREAK ON energy#power<=1500 DO Currentcal 2942 BREAK ON energy#power<=2000 DO Currentcal 3095 BREAK ON energy#power<=2500 DO Currentcal 3249 BREAK ON energy#power>2500 DO Currentcal 3402 BREAK Rule1 1 Take the CurrentCal values above as a first approach and should be corrected through the Tasmota Method 2 calibration procedure: [[devices/Power-Monitoring-Calibration]] Home Assistant configuration ~ switch : - platform : mqtt name : \"Blitzwolf\" state_topic : \"stat/blitzwolf/POWER\" command_topic : \"cmnd/blitzwolf/POWER\" payload_on : \"ON\" payload_off : \"OFF\" retain : false sensor : - platform : mqtt name : \"Blitzwolf Energy Today\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Today\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Yesterday\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Yesterday\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Total\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Total\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Power\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Power\"] }}' unit_of_measurement : \"W\" - platform : mqtt name : \"Blitzwolf Voltage\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Voltage\"] }}' unit_of_measurement : \"V\" - platform : mqtt name : \"Blitzwolf Power Factor\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Factor\"] }}'","title":"BlitzWolf SHP6"},{"location":"devices/BlitzWolf-SHP6/#serial-connection","text":"Please see the Hardware Preparation page for general instructions. There are currently at least two versions of this device. The (newer) Version has exposed contacts with holes for all connections necessary to flash tasmota, while the old requires soldering of cables to some points. For the older Version:","title":"Serial Connection"},{"location":"devices/BlitzWolf-SHP6/#step-1","text":"Disconnect device from power source!","title":"Step 1"},{"location":"devices/BlitzWolf-SHP6/#step-2","text":"Remove one screw on the back of the device. PH1 screwdriver required.","title":"Step 2"},{"location":"devices/BlitzWolf-SHP6/#step-3","text":"Undo 2 screws. PH1 screwdriver required. Disconnect antenna.","title":"Step 3"},{"location":"devices/BlitzWolf-SHP6/#step-4","text":"Carefully remove PCB from casing for easier soldering. * Don't stress antenna cable too much. * Don't lose metal tube.","title":"Step 4"},{"location":"devices/BlitzWolf-SHP6/#step-5","text":"Solder cables to the ESP Pins. SHP6 10A model: SHP6 15A model: If you do not want to solder you can try using crocodile clips and manually push a jumper cable first to IO0 (enter flash mode while booting, i.e. connect IO0 to ground) and then during flashing push a jumper to TX. Just be careful to not cause any short-circuit with the clips on the other side of the pads. Crocodile clips","title":"Step 5"},{"location":"devices/BlitzWolf-SHP6/#step-6","text":"Connect serial adapter and make a shortwire between Pin IO0 and GND during startup (for entering flashmode).","title":"Step 6"},{"location":"devices/BlitzWolf-SHP6/#step-7","text":"Erase flash to avoid issues with dropping WiFi connection. Example using esptool: esptool . py -- port COM3 erase_flash","title":"Step 7"},{"location":"devices/BlitzWolf-SHP6/#step-8","text":"Flash Tasmota.","title":"Step 8"},{"location":"devices/BlitzWolf-SHP6/#step-9","text":"Select the correct configuration under Configuration -> Configure Module or apply correct template: SHP6 10A model SHP6 15A model","title":"Step 9"},{"location":"devices/BlitzWolf-SHP6/#as-an-alternative-for-steps-3-to-5","text":"The following programming adapter could be an option, which requires no soldering or significant disassembly on the SHP-6. It significantly reduces the effort of reflashing multiple SHP-6 units. Thingiverse link","title":"As an alternative for steps 3 to 5:"},{"location":"devices/BlitzWolf-SHP6/#for-version-2-for-steps-3-to-5","text":"The new Version has exposed pads with holes for Ground, Reset, TX, RX, Vcc 3.3.V and GPIO0. YOu can use small jumper cables to directly connect a programmer, so no further disassembly is required.","title":"For Version 2 for steps 3 to 5:"},{"location":"devices/BlitzWolf-SHP6/#other-photos","text":"","title":"Other photos"},{"location":"devices/BlitzWolf-SHP6/#power-monitoring-calibration","text":"Approach the calibration using the Method 2. If not satisfied with the results, you could mod the SMD direct measure resistor or mitigate this using a Tasmota set of rules (values valid only for the 10A model): Rule1 ON energy#power<=100 DO Currentcal 2500 BREAK ON energy#power<=500 DO Currentcal 2635 BREAK ON energy#power<=1000 DO Currentcal 2788 BREAK ON energy#power<=1500 DO Currentcal 2942 BREAK ON energy#power<=2000 DO Currentcal 3095 BREAK ON energy#power<=2500 DO Currentcal 3249 BREAK ON energy#power>2500 DO Currentcal 3402 BREAK Rule1 1 Take the CurrentCal values above as a first approach and should be corrected through the Tasmota Method 2 calibration procedure: [[devices/Power-Monitoring-Calibration]]","title":"Power monitoring calibration"},{"location":"devices/BlitzWolf-SHP6/#home-assistant-configuration","text":"switch : - platform : mqtt name : \"Blitzwolf\" state_topic : \"stat/blitzwolf/POWER\" command_topic : \"cmnd/blitzwolf/POWER\" payload_on : \"ON\" payload_off : \"OFF\" retain : false sensor : - platform : mqtt name : \"Blitzwolf Energy Today\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Today\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Yesterday\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Yesterday\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Total\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Total\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Power\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Power\"] }}' unit_of_measurement : \"W\" - platform : mqtt name : \"Blitzwolf Voltage\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Voltage\"] }}' unit_of_measurement : \"V\" - platform : mqtt name : \"Blitzwolf Power Factor\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Factor\"] }}'","title":"Home Assistant configuration"},{"location":"devices/BlitzWolf-SHP7/","text":"Serial Connection ~ Please see the Hardware Preparation page for general instructions. Step 1 ~ Disconnect device from power source! Step 2 ~ Remove the two stickers on the front. Step 3 ~ Undo 2 screws. PH1 screwdriver required. Step 4 ~ Remove back with screwdriver Step 4 ~ Undo 2 screws at the back. PH1 screwdriver required. Step 5 ~ Remove PCB from casing for easier soldering. Step 6 ~ Solder cables to the ESP pins. Because GND is hard to solder/access, I recommend to use the other side for GND: Result: Step 7 ~ Connect serial adapter and make a shortwire between Pin IO0 and GND during startup (for entering flashmode). Step 8 ~ Flash Tasmota. Step 9 ~ Setup Tasmota (wifi settings). Go to Configuration -> Configure Other and enter this template: {\"NAME\":\"SHP7 v2\",\"GPIO\":[18,158,56,131,134,132,0,0,17,57,21,0,22],\"FLAG\":0,\"BASE\":45} (I had to use v2 from https://templates.blakadder.com/blitzwolf_SHP7.html) Done !","title":"BlitzWolf SHP7"},{"location":"devices/BlitzWolf-SHP7/#serial-connection","text":"Please see the Hardware Preparation page for general instructions.","title":"Serial Connection"},{"location":"devices/BlitzWolf-SHP7/#step-1","text":"Disconnect device from power source!","title":"Step 1"},{"location":"devices/BlitzWolf-SHP7/#step-2","text":"Remove the two stickers on the front.","title":"Step 2"},{"location":"devices/BlitzWolf-SHP7/#step-3","text":"Undo 2 screws. PH1 screwdriver required.","title":"Step 3"},{"location":"devices/BlitzWolf-SHP7/#step-4","text":"Remove back with screwdriver","title":"Step 4"},{"location":"devices/BlitzWolf-SHP7/#step-4_1","text":"Undo 2 screws at the back. PH1 screwdriver required.","title":"Step 4"},{"location":"devices/BlitzWolf-SHP7/#step-5","text":"Remove PCB from casing for easier soldering.","title":"Step 5"},{"location":"devices/BlitzWolf-SHP7/#step-6","text":"Solder cables to the ESP pins. Because GND is hard to solder/access, I recommend to use the other side for GND: Result:","title":"Step 6"},{"location":"devices/BlitzWolf-SHP7/#step-7","text":"Connect serial adapter and make a shortwire between Pin IO0 and GND during startup (for entering flashmode).","title":"Step 7"},{"location":"devices/BlitzWolf-SHP7/#step-8","text":"Flash Tasmota.","title":"Step 8"},{"location":"devices/BlitzWolf-SHP7/#step-9","text":"Setup Tasmota (wifi settings). Go to Configuration -> Configure Other and enter this template: {\"NAME\":\"SHP7 v2\",\"GPIO\":[18,158,56,131,134,132,0,0,17,57,21,0,22],\"FLAG\":0,\"BASE\":45} (I had to use v2 from https://templates.blakadder.com/blitzwolf_SHP7.html) Done !","title":"Step 9"},{"location":"devices/Burnett-BN-K01/","text":"The Burnett Smart Socket. ~ Introduction ~ The Burnett Smart Socket BN-K01 is a smart socket that is small in size. The body is only 58mm * 48mm 34mm which can fit into smaller places. It is equipped with an ESP8285 which makes it possible to flash sonoff-tasmota. However, * you need to manually wire the Tx and Rx from the chip for flashing**. This guide provides details on how to prepare the socket for the initial flashing with sonoff-tasmota code. What is it? ~ As the other Sonoff's do, this smart socket uses EWeLink app to control. It\u2019s pretty well made and there is a shutter to close off the live socket holes when a plug is removed. Besides, it is pretty cheap in Taobao (it costs no more than USD 6). \ufffc Disassembly ~ * WARNING - Opening the unit potentially exposes mains voltages that can kill. You proceed beyond here entirely at your own risk. * There are no screws. And unfortunately it is precisely glued, so to disassemble you need to find a thin yet strong tool to pull it open. \ufffcInside there is a main board with most of the components on the top. The Wi-Fi and control comes from a small daughter board, soldered on the left of the main board.\ufffc Unfortunately I cannot tear down the plastic around the main board, so I don't have a clear look for the back of the daughter board. Hookup ~ Unless you are just curious, there\u2019s no real need to unsolder the main board. You can get at everything you need to re-flash it on the top side of the daughter board. For flashing you need to solder the VCC and GND from the back. As shown in the picture, the GND is the top right pad while the VCC is the bottom left pad. While unfortunately, the Rx and Tx is not connected, so you have to wire directly to the ESP8285. It can be very hard if you are not familiar with soldering. The GPIO0 is connected to the button so no wiring is needed. Building Firmware ~ The process for building the firmware for the Burnett BN-K01 is basically the same as for the Sonoff with a few additional changes. You need to set the board to \"Generic ESP8285 Module\" The crystal frequency is 26MHz. Flash the Firmware ~ Hold the button when you connect the VCC and GND to make the ESP8285 boot into flash mode. After it boots, you no longer need to hold it. Configure ~ After you flashed and booted the Burnett BN-K01, just set config it as Sonoff S2x, then it will work.","title":"The Burnett Smart Socket."},{"location":"devices/Burnett-BN-K01/#the-burnett-smart-socket","text":"","title":"The Burnett Smart Socket."},{"location":"devices/Burnett-BN-K01/#introduction","text":"The Burnett Smart Socket BN-K01 is a smart socket that is small in size. The body is only 58mm * 48mm 34mm which can fit into smaller places. It is equipped with an ESP8285 which makes it possible to flash sonoff-tasmota. However, * you need to manually wire the Tx and Rx from the chip for flashing**. This guide provides details on how to prepare the socket for the initial flashing with sonoff-tasmota code.","title":"Introduction"},{"location":"devices/Burnett-BN-K01/#what-is-it","text":"As the other Sonoff's do, this smart socket uses EWeLink app to control. It\u2019s pretty well made and there is a shutter to close off the live socket holes when a plug is removed. Besides, it is pretty cheap in Taobao (it costs no more than USD 6). \ufffc","title":"What is it?"},{"location":"devices/Burnett-BN-K01/#disassembly","text":"* WARNING - Opening the unit potentially exposes mains voltages that can kill. You proceed beyond here entirely at your own risk. * There are no screws. And unfortunately it is precisely glued, so to disassemble you need to find a thin yet strong tool to pull it open. \ufffcInside there is a main board with most of the components on the top. The Wi-Fi and control comes from a small daughter board, soldered on the left of the main board.\ufffc Unfortunately I cannot tear down the plastic around the main board, so I don't have a clear look for the back of the daughter board.","title":"Disassembly"},{"location":"devices/Burnett-BN-K01/#hookup","text":"Unless you are just curious, there\u2019s no real need to unsolder the main board. You can get at everything you need to re-flash it on the top side of the daughter board. For flashing you need to solder the VCC and GND from the back. As shown in the picture, the GND is the top right pad while the VCC is the bottom left pad. While unfortunately, the Rx and Tx is not connected, so you have to wire directly to the ESP8285. It can be very hard if you are not familiar with soldering. The GPIO0 is connected to the button so no wiring is needed.","title":"Hookup"},{"location":"devices/Burnett-BN-K01/#building-firmware","text":"The process for building the firmware for the Burnett BN-K01 is basically the same as for the Sonoff with a few additional changes. You need to set the board to \"Generic ESP8285 Module\" The crystal frequency is 26MHz.","title":"Building Firmware"},{"location":"devices/Burnett-BN-K01/#flash-the-firmware","text":"Hold the button when you connect the VCC and GND to make the ESP8285 boot into flash mode. After it boots, you no longer need to hold it.","title":"Flash the Firmware"},{"location":"devices/Burnett-BN-K01/#configure","text":"After you flashed and booted the Burnett BN-K01, just set config it as Sonoff S2x, then it will work.","title":"Configure"},{"location":"devices/CE-Smart-Home---LA-WF3-Wifi-Plug/","text":"CE Smart Home - LA-WF3 Wifi Plug (TYWE2S) ~ Simple and compact Wifi Plug, based in ESP8266, internal module Tuya TYWE2S esptool log: Wifi module is an: TYWE2S: Detecting chip type... ESP8266 Chip is ESP8285 Features: WiFi, Embedded. Model purchased: https://www.costco.ca/Wi-Fi-Smart-Plug%2C-2-pack.product.100417575.html 24.99 CAD$ Product ~ Flashing ~ GPIO0 Needs to be grounded in order to get into flashing mode. 1. erase_flash 2. flash tasmota_minimal 3. flash tasmota_full Module Configuration ~","title":"CE Smart Home   LA WF3 Wifi Plug"},{"location":"devices/CE-Smart-Home---LA-WF3-Wifi-Plug/#ce-smart-home-la-wf3-wifi-plug-tywe2s","text":"Simple and compact Wifi Plug, based in ESP8266, internal module Tuya TYWE2S esptool log: Wifi module is an: TYWE2S: Detecting chip type... ESP8266 Chip is ESP8285 Features: WiFi, Embedded. Model purchased: https://www.costco.ca/Wi-Fi-Smart-Plug%2C-2-pack.product.100417575.html 24.99 CAD$","title":"CE Smart Home - LA-WF3 Wifi Plug (TYWE2S)"},{"location":"devices/CE-Smart-Home---LA-WF3-Wifi-Plug/#product","text":"","title":"Product"},{"location":"devices/CE-Smart-Home---LA-WF3-Wifi-Plug/#flashing","text":"GPIO0 Needs to be grounded in order to get into flashing mode. 1. erase_flash 2. flash tasmota_minimal 3. flash tasmota_full","title":"Flashing"},{"location":"devices/CE-Smart-Home---LA-WF3-Wifi-Plug/#module-configuration","text":"","title":"Module Configuration"},{"location":"devices/CE-Smart-Home%E2%84%A2-Garden-Power-Stake/","text":"Device Template ~ {\"NAME\":\"CE Power Stake\",\"GPIO\":[255,255,255,255,56,57,255,255,21,17,255,255,255],\"FLAG\":0,\"BASE\":18} Connection ~ This 6-outlet outdoor garden power stake is controlled by a standard ESP-12 chip connected to a single relay, meaning that all 6 outlets are on or off simultaneously. It also has a mains switch, a manual relay trigger button, and an LED indicator. Programmer Power Stake 3V3 VCC TX RX RX TX GND GND The button is not connected to D0 , so you will need to shunt D0 / GPIO0 to GND to enable programming mode. You may need to briefly shunt RESET to GND in order to initiate connections to the device. Internal Device Image ~ [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_esp12s.jpg|alt=PowerStake Pinout]] Generic Module Config ~ [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_tasmota_config.jpg|alt=Generic Module Config]] Additional Information ~ This device was found at Costco, and in fact appears to be made for Costco (see image below). The regular price was $13.97 USD, but was on sale for Christmas for $9.99 USD. [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_front.jpg|alt=PowerStake Box Front]] [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_rear.jpg|alt=PowerStake Box Rear]] [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_side1.jpg|alt=PowerStake Box Side 1]] [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_side2.jpg|alt=PowerStake Box Side 2]] [[https://github.com/untergeek/shared_images/blob/master/devices/esp12-pinout.png|alt=ESP12]]","title":"CE Smart Home\u2122 Garden Power Stake"},{"location":"devices/CE-Smart-Home%E2%84%A2-Garden-Power-Stake/#device-template","text":"{\"NAME\":\"CE Power Stake\",\"GPIO\":[255,255,255,255,56,57,255,255,21,17,255,255,255],\"FLAG\":0,\"BASE\":18}","title":"Device Template"},{"location":"devices/CE-Smart-Home%E2%84%A2-Garden-Power-Stake/#connection","text":"This 6-outlet outdoor garden power stake is controlled by a standard ESP-12 chip connected to a single relay, meaning that all 6 outlets are on or off simultaneously. It also has a mains switch, a manual relay trigger button, and an LED indicator. Programmer Power Stake 3V3 VCC TX RX RX TX GND GND The button is not connected to D0 , so you will need to shunt D0 / GPIO0 to GND to enable programming mode. You may need to briefly shunt RESET to GND in order to initiate connections to the device.","title":"Connection"},{"location":"devices/CE-Smart-Home%E2%84%A2-Garden-Power-Stake/#internal-device-image","text":"[[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_esp12s.jpg|alt=PowerStake Pinout]]","title":"Internal Device Image"},{"location":"devices/CE-Smart-Home%E2%84%A2-Garden-Power-Stake/#generic-module-config","text":"[[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_tasmota_config.jpg|alt=Generic Module Config]]","title":"Generic Module Config"},{"location":"devices/CE-Smart-Home%E2%84%A2-Garden-Power-Stake/#additional-information","text":"This device was found at Costco, and in fact appears to be made for Costco (see image below). The regular price was $13.97 USD, but was on sale for Christmas for $9.99 USD. [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_front.jpg|alt=PowerStake Box Front]] [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_rear.jpg|alt=PowerStake Box Rear]] [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_side1.jpg|alt=PowerStake Box Side 1]] [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_side2.jpg|alt=PowerStake Box Side 2]] [[https://github.com/untergeek/shared_images/blob/master/devices/esp12-pinout.png|alt=ESP12]]","title":"Additional Information"},{"location":"devices/CNSKOU---CNSANKOU-wall-switches/","text":"General ~ These CNSKOU / CNSANKOU wall switches (Chinese Sonoff clones) are sold on AliExpress and have a neutral design. They come in 1, 2 and 3 circuits and are easily mounted replacing your old wall switches. It measures 118mm wide by 72mm high, irrespective of the number of buttons, although it is also available in 86x86mm. The tempered glass front plate is available in white, black and gold colors. Despite it being advertised as a 'US' device, it will handle 90-250V AC input at 50/60Hz and is said to switch up to 10A per circuit. The same design is also available for use with a RF-remote, or as a traditional wall switch. There is a backlight indicator behind each button, which subtly shows green when the circuit is live and red when it is not. When physically pushing the button, there is an audio feedback. See here to view a video of the audio feedback. The one interesting for Tasmota is of course the WiFi version, which connects to 2.4GHz networks, up to 802.11n. The switch comes pre-loaded with ITEAD software and works well with the EWeLink app. Inside ~ When opening the package, easily done by turning a screwdriver under the two plastic lips at the lower side of the switch, the first thing we see are the capacitive touch sensors mounted on the back of the low-voltage board. The low-voltage board is connected through a 14-pin connector to the mains board, and contains an ESP8285 , piezo buzzer (should you wish to remove that audio feedback!) and a number of additional components. The ESP8285 is of course compatible with the ESP8266 albeit with only 1MB flash storage. The mains-voltage board contains the mains connection points, a TI ULN2003A relay driver and 1-3 relays and a tiny little board containing a power supply for the low-voltage bits. Flashing ~ The most interesting part is of course how we flash this device with Tasmota. To do this, do not connect the device to mains power and carefully remove the low-voltage board as this is all you'll need. Notice the 4 connection points just above the ESP8285, which is where you'll connect (from square pad up) 3v3, RX, TX and GND. I found that normal DuPont jumper wires provide a secure enough connection, but you may wish to solder on a few header pins. In order to get the ESP8285 into programming mode, you'll also need to connect GPIO0 to GND. There is no easily accessible connection point for GPIO0 and no buttons are provided on the board. I found the easiest way is to just use a normal jumper cable and manually hold it up against pin 10 (GPIO0) for a few seconds while the power is connected to the chip. Pin 10 is the second pin of the 'pin 9-16' row, on the right hand side of the chip in the image above. Use the usual method for flashing, undoubtedly documented better elsewhere than I ever could. Once Tasmota was up and running, I used the Sonoff T1 US module type.","title":"CNSKOU   CNSANKOU wall switches"},{"location":"devices/CNSKOU---CNSANKOU-wall-switches/#general","text":"These CNSKOU / CNSANKOU wall switches (Chinese Sonoff clones) are sold on AliExpress and have a neutral design. They come in 1, 2 and 3 circuits and are easily mounted replacing your old wall switches. It measures 118mm wide by 72mm high, irrespective of the number of buttons, although it is also available in 86x86mm. The tempered glass front plate is available in white, black and gold colors. Despite it being advertised as a 'US' device, it will handle 90-250V AC input at 50/60Hz and is said to switch up to 10A per circuit. The same design is also available for use with a RF-remote, or as a traditional wall switch. There is a backlight indicator behind each button, which subtly shows green when the circuit is live and red when it is not. When physically pushing the button, there is an audio feedback. See here to view a video of the audio feedback. The one interesting for Tasmota is of course the WiFi version, which connects to 2.4GHz networks, up to 802.11n. The switch comes pre-loaded with ITEAD software and works well with the EWeLink app.","title":"General"},{"location":"devices/CNSKOU---CNSANKOU-wall-switches/#inside","text":"When opening the package, easily done by turning a screwdriver under the two plastic lips at the lower side of the switch, the first thing we see are the capacitive touch sensors mounted on the back of the low-voltage board. The low-voltage board is connected through a 14-pin connector to the mains board, and contains an ESP8285 , piezo buzzer (should you wish to remove that audio feedback!) and a number of additional components. The ESP8285 is of course compatible with the ESP8266 albeit with only 1MB flash storage. The mains-voltage board contains the mains connection points, a TI ULN2003A relay driver and 1-3 relays and a tiny little board containing a power supply for the low-voltage bits.","title":"Inside"},{"location":"devices/CNSKOU---CNSANKOU-wall-switches/#flashing","text":"The most interesting part is of course how we flash this device with Tasmota. To do this, do not connect the device to mains power and carefully remove the low-voltage board as this is all you'll need. Notice the 4 connection points just above the ESP8285, which is where you'll connect (from square pad up) 3v3, RX, TX and GND. I found that normal DuPont jumper wires provide a secure enough connection, but you may wish to solder on a few header pins. In order to get the ESP8285 into programming mode, you'll also need to connect GPIO0 to GND. There is no easily accessible connection point for GPIO0 and no buttons are provided on the board. I found the easiest way is to just use a normal jumper cable and manually hold it up against pin 10 (GPIO0) for a few seconds while the power is connected to the chip. Pin 10 is the second pin of the 'pin 9-16' row, on the right hand side of the chip in the image above. Use the usual method for flashing, undoubtedly documented better elsewhere than I ever could. Once Tasmota was up and running, I used the Sonoff T1 US module type.","title":"Flashing"},{"location":"devices/CSL-aplic-WDP-303075/","text":"Connection ~ Vcc - 3,3V TX - RX RX - TX GND - GND For flashing you need to connect GPIO0 to GND Additional Information ~ Hardware details ~ ESP8266 - on TYWE2S Module HLW8012 - Power Monitor Chip SRU 5VDC SDA - Relais GPIO0 ~ You need to solder a wire to the test-point on the TYWE2S Module to be able to enter the flashmode. The Resest Pin has no function for that purpose. Device Images ~ GPIO Config ~ Power Monitoring will not work with that configuration... wait for software update in case you want to use it UPDATE: with Tasmota 6.3.0 you have fully monitoring support (Add support for CSL Aplic WDP 303075 Power Socket with Energy Monitoring (#3991, #3996))","title":"CSL aplic WDP 303075"},{"location":"devices/CSL-aplic-WDP-303075/#connection","text":"Vcc - 3,3V TX - RX RX - TX GND - GND For flashing you need to connect GPIO0 to GND","title":"Connection"},{"location":"devices/CSL-aplic-WDP-303075/#additional-information","text":"","title":"Additional Information"},{"location":"devices/CSL-aplic-WDP-303075/#hardware-details","text":"ESP8266 - on TYWE2S Module HLW8012 - Power Monitor Chip SRU 5VDC SDA - Relais","title":"Hardware details"},{"location":"devices/CSL-aplic-WDP-303075/#gpio0","text":"You need to solder a wire to the test-point on the TYWE2S Module to be able to enter the flashmode. The Resest Pin has no function for that purpose.","title":"GPIO0"},{"location":"devices/CSL-aplic-WDP-303075/#device-images","text":"","title":"Device Images"},{"location":"devices/CSL-aplic-WDP-303075/#gpio-config","text":"Power Monitoring will not work with that configuration... wait for software update in case you want to use it UPDATE: with Tasmota 6.3.0 you have fully monitoring support (Add support for CSL Aplic WDP 303075 Power Socket with Energy Monitoring (#3991, #3996))","title":"GPIO Config"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/","text":"General: ~ Nice size and form factor - can be used as Sonoff Basic R2 There seems to be no unique name for the device in the market. The one I ordered for testing Tasmota was packaged by brand / model Canwing CW-001 . Let's use this naming for all similar devices. Operating the device under the original firmware by use of eWeLink-App shows \"Coolkit 0185\" as brand / model supported by ESP8285 . Source of supply was \"ebay.de\", seller \"globewin\", ordered 2019-01-12 for a price of 6,89 Euro , received in 14 calendar days. Additionally by name \u201eASHATA Intelligente WLAN Schalter\u201c this device is proposed by \"amazon.de\", seller \"Richer-R123\" for a price of 9,39 Euro. Aliexpress: Wi-Fi Smart Switch 5A Features of original device / firmware: ~ Remote control domestic appliances - a phone with 2.4G WiFi can remote control all domestic appliances through phone app. 1000W large power - adopting a 1000 W power to make operation powerful. Suitable for higher than Android 4.0. Flame retardant ABS shell ensures the safety. PCB equipped with serial standard interface (4 pins RX, TX, GND, Vcc / 3.3 V) and button / momentary switch dedicated to GPIO0. Specification: ~ Product type: WiFi Switch Module Wireless standard: WIFI 2.4 GHz IEEE 802.11 b/g/n Remote control mode: eWeLink phone app for Android/iOS or Tasmota Chip ESP 8266 / 8285 Maximum power: 1000 W / 5 A Package size: approx. 57 * 41 * 21 mm / 2.4 * 1.6 * 1.1 in Package weight: 35 g / 1.2 oz Package List: ~ 1 x WiFi Switch Controller 1 x User Manual (see end of this page) Photos of the case: ~ Photos of the PCB: ~ Magic moment \u2013 eWeLink slips away \u2013 Tasmota appears: ~ Result: ~ \u2003 Original users manual for eWeLink: ~","title":"Canwing CW001 WiFi Smart Switch"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#general","text":"Nice size and form factor - can be used as Sonoff Basic R2 There seems to be no unique name for the device in the market. The one I ordered for testing Tasmota was packaged by brand / model Canwing CW-001 . Let's use this naming for all similar devices. Operating the device under the original firmware by use of eWeLink-App shows \"Coolkit 0185\" as brand / model supported by ESP8285 . Source of supply was \"ebay.de\", seller \"globewin\", ordered 2019-01-12 for a price of 6,89 Euro , received in 14 calendar days. Additionally by name \u201eASHATA Intelligente WLAN Schalter\u201c this device is proposed by \"amazon.de\", seller \"Richer-R123\" for a price of 9,39 Euro. Aliexpress: Wi-Fi Smart Switch 5A","title":"General:"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#features-of-original-device-firmware","text":"Remote control domestic appliances - a phone with 2.4G WiFi can remote control all domestic appliances through phone app. 1000W large power - adopting a 1000 W power to make operation powerful. Suitable for higher than Android 4.0. Flame retardant ABS shell ensures the safety. PCB equipped with serial standard interface (4 pins RX, TX, GND, Vcc / 3.3 V) and button / momentary switch dedicated to GPIO0.","title":"Features of original device / firmware:"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#specification","text":"Product type: WiFi Switch Module Wireless standard: WIFI 2.4 GHz IEEE 802.11 b/g/n Remote control mode: eWeLink phone app for Android/iOS or Tasmota Chip ESP 8266 / 8285 Maximum power: 1000 W / 5 A Package size: approx. 57 * 41 * 21 mm / 2.4 * 1.6 * 1.1 in Package weight: 35 g / 1.2 oz","title":"Specification:"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#package-list","text":"1 x WiFi Switch Controller 1 x User Manual (see end of this page)","title":"Package List:"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#photos-of-the-case","text":"","title":"Photos of the case:"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#photos-of-the-pcb","text":"","title":"Photos of the PCB:"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#magic-moment-ewelink-slips-away-tasmota-appears","text":"","title":"Magic moment \u2013 eWeLink slips away \u2013 Tasmota appears:"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#result","text":"","title":"Result:"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#original-users-manual-for-ewelink","text":"","title":"Original users manual for eWeLink:"},{"location":"devices/Century-Aoke---Festnight-%28Sonoff-Basic-clone%29/","text":"Connection ~ Vcc - 3,3V TX - RX RX - TX GND - GND Additional Information ~ SmartHome is a cheap Sonoff Basic clone, but they still work with Tasmota. More Infos can be found here: #343 . Device Images ~ I'll try to upload the images later. Generic Module Config ~","title":"Century Aoke   Festnight (Sonoff Basic clone)"},{"location":"devices/Century-Aoke---Festnight-%28Sonoff-Basic-clone%29/#connection","text":"Vcc - 3,3V TX - RX RX - TX GND - GND","title":"Connection"},{"location":"devices/Century-Aoke---Festnight-%28Sonoff-Basic-clone%29/#additional-information","text":"SmartHome is a cheap Sonoff Basic clone, but they still work with Tasmota. More Infos can be found here: #343 .","title":"Additional Information"},{"location":"devices/Century-Aoke---Festnight-%28Sonoff-Basic-clone%29/#device-images","text":"I'll try to upload the images later.","title":"Device Images"},{"location":"devices/Century-Aoke---Festnight-%28Sonoff-Basic-clone%29/#generic-module-config","text":"","title":"Generic Module Config"},{"location":"devices/Digoo-DG-SP202/","text":"","title":"Digoo DG SP202"},{"location":"devices/Dimmer-switch-with-Nuvoton-chip/","text":"A generic touch dimmer flashed with Tasmota . On AliExpress you can buy a wifi dimmer for mains voltage (110 or 220V) It's a brandles dimmer, but can be found here: AliExpress page It comes in a couple of forms, but sinds I live in Holland, I chose the EU style, single gang, 220V, White edition. It has a glass front plate with 3 proximity/touch switches (On/Off, dimm up & dimm down) and a wifi indicator LED. The inside houses 2 PCB's; a power board and a control board: The control board: There are two main chips on board: An ESP8266 and a Nuvoton n76e003at20 The Nuvoton will do the switch side of it all, the ESP communication. The mains board: For flashing, we only need the control board. Solder small wires to the pads as marked on the picture: 3.3V GND RX TX Sw (gpio0) Solder 'Res1' to GND Note that the silkscreen on this board has TX and RX wrong. Now use a USB to serial adapter to connect the wires. Use a 3.3V board, NOT 5V, this will destroy the ESP chip on the board! Connect: GND to GND 3.3V to 3.3V RX to RX (due to the fact the silkscreen is wrong, otherwise, RX connects to TX and vice versa) TX to TX SW to GND -- only during power up, to put the ESP in programming mode. From here the upload is the same as for all other Tasmota devices. See the upload page for detailed info. Note: sonoff basic and classic variants do not support the serial bridge. To get this working you should use the standard tasmota.bin - NOT basic or classic. After the upload was successful, unplug the device from the serial adapter. You can now desolder all the connections you have made earlier. Also remove the wire between RES1 and GND. Then plug the board back in its housing. Be careful with the connector on the underside of the board. Line up the pins with te header and lightly press it in its place. Connecting to mains installation: ~ WARNING! THIS PROJECT INVOLVES WORKING WITH HIGH VOLTAGE AND YOU COULD KILL YOURSELF AND/OR SET YOUR HOUSE ON FIRE. Connect your light to the dimmer according the manual. Keep in mind, the dimmer itself needs a Neutral wire as well. If you replace an existing switch or dimmer, it can be that you need to run an extra neutral wire. First connection ~ When you first power up the dimmer switch, it comes up in AccessPoint mode. Follow the instructions here Set correct module type ~ Once you have all connected, you should go to the configuration page of the Tasmota Dimmer. Go to your browser and fill in the IP address. Then go to 'Configuration' and then to 'Configure Module'. From the drop down menu select module 58: PS-16-DZ. Then hit Save. The module will restart and you are done! You can now toggle the light and use the slider to dim the lights from the tasmota webpage. Or better, use your favorite domotica software to control it via MQTT.","title":"Dimmer switch with Nuvoton chip"},{"location":"devices/Dimmer-switch-with-Nuvoton-chip/#connecting-to-mains-installation","text":"WARNING! THIS PROJECT INVOLVES WORKING WITH HIGH VOLTAGE AND YOU COULD KILL YOURSELF AND/OR SET YOUR HOUSE ON FIRE. Connect your light to the dimmer according the manual. Keep in mind, the dimmer itself needs a Neutral wire as well. If you replace an existing switch or dimmer, it can be that you need to run an extra neutral wire.","title":"Connecting to mains installation:"},{"location":"devices/Dimmer-switch-with-Nuvoton-chip/#first-connection","text":"When you first power up the dimmer switch, it comes up in AccessPoint mode. Follow the instructions here","title":"First connection"},{"location":"devices/Dimmer-switch-with-Nuvoton-chip/#set-correct-module-type","text":"Once you have all connected, you should go to the configuration page of the Tasmota Dimmer. Go to your browser and fill in the IP address. Then go to 'Configuration' and then to 'Configure Module'. From the drop down menu select module 58: PS-16-DZ. Then hit Save. The module will restart and you are done! You can now toggle the light and use the slider to dim the lights from the tasmota webpage. Or better, use your favorite domotica software to control it via MQTT.","title":"Set correct module type"},{"location":"devices/ERC309-Kinetic-Switch/","text":"Discussed here Configuration Configure as a Tuya Dimmer (54) (support as a BASE module was introduced in 6.2.1.16). GPIO13 - Tuya Rx (108) GPIO15 - Tuya Tx (107) Template: {\"NAME\":\"Kinetic Switch\",\"GPIO\":[255,255,255,255,255,255,0,0,255,108,255,107,255],\"FLAG\":0,\"BASE\":54} Module Flashing This device uses a Tuya TYWE3S Wi-Fi PCB module. An easy soldering method is to take several Dupont style jumper wires, cut one end off, and apply a bit of solder to each stripped end. This will keep the wire flexible and prevent any circuit board pads from ripping off. Apply a bit of solder to each pad necessary to flash (double check your pin-outs). Once the wire and pad have solder simply put the two together and apply a bit of heat and they will join together. Attach the GPIO0 wire to ground during initial boot to flash. A 3-pin header bridged together works great with GPIO0, GND and the GND from the USB flasher attached (TX pin to RX pin and RX pin to TX pin on USB flash adapter). Verify that you are using 3.3volts to flash, NOT 5V! Two options: Remove the ESP PCB by desoldering. This makes it easier to get to the pins of the TYWE3S board. No PCB desoldering. You will have to connect the RESET pin of the MCU chip to GND. This requires a soldering iron with a thin tip. Product Link","title":"ERC309 Kinetic Switch"},{"location":"devices/EXS-2-Channel-Wifi-Dimmer-V4/","text":"Disclaimer ~ DANGER OF ELECTROCUTION You must de-solder ESP8266 pins from the PCB in order to flash Tasmota! You can't flash Tasmota over firmware from ex-store.de At the moment I can see no way to flash minimal.bin over the original firmware. How flash on assembled PCB Line TX and RX is directly wired from the dimmer to the MCU. Cut this 2 lines. For example desolder pin2 and pin3 from MCU. Solder cable on GPIO0, TX, RX (ESP8266) VCC and GND (See description on pcb). Connect cables with your USB adapter. Before you flash firmware connect the module with 230V (Solderpads \"230V IN\" and \"NULL\") since some USB adapters do not have enough power. Das Modul sollte nur geflasht werden wenn es sich nicht auf der Leiterplatte befindet! Die Firmware \"Tasmota\" kann nicht \u00fcber die Firmware von ex-store.de geflasht werden (OTA) Versuchen Sie es trotzdem ist das Modul unbrauchbar und muss ausgebaut werden und neu geflasht werden. Aufspielen der Tasmota Firmware mit dem Modul auf der Platine Die Leitungen TX und RX sind direkt mit der Dimm-MCU verdrahtet. Diese Leitungen m\u00fcssen getrennt werden. Zum Beispiel Pin2 und Pin3 von der MCU abl\u00f6ten (hochbiegen). L\u00f6ten Sie Kabel an GPIO0, TX, RX (ESP8266), VCC und GND (siehe Beschreibung auf der Platine). Verbinden Sie diese Kabel mit Ihrem USB Adapter. Bevor Sie die Firmware flashen, muss das Modul mit 230V (L\u00f6tpads \"230V IN\" und \"NULL\") verbunden werden. Einige USB-Adapter haben nicht gen\u00fcgend Strom um die Platine zu versorgen. 230V sind f\u00fcr Lebewesen Lebensgef\u00e4hrlich. Ein Stromschlag kann unter anderem Ihren Herzrythmus st\u00f6ren und zum Tode f\u00fchren. Dessen sollten Sie sich bewust sein wenn Sie an diesem Modul arbeiten. Schematic ~ Menu ~ Example setup with DHT22 ~ DHT wiring VCC - header VCC Ground - header GND Data line - to GPIO14","title":"EXS 2 Channel Wifi Dimmer V4"},{"location":"devices/EXS-2-Channel-Wifi-Dimmer-V4/#disclaimer","text":"DANGER OF ELECTROCUTION You must de-solder ESP8266 pins from the PCB in order to flash Tasmota! You can't flash Tasmota over firmware from ex-store.de At the moment I can see no way to flash minimal.bin over the original firmware. How flash on assembled PCB Line TX and RX is directly wired from the dimmer to the MCU. Cut this 2 lines. For example desolder pin2 and pin3 from MCU. Solder cable on GPIO0, TX, RX (ESP8266) VCC and GND (See description on pcb). Connect cables with your USB adapter. Before you flash firmware connect the module with 230V (Solderpads \"230V IN\" and \"NULL\") since some USB adapters do not have enough power. Das Modul sollte nur geflasht werden wenn es sich nicht auf der Leiterplatte befindet! Die Firmware \"Tasmota\" kann nicht \u00fcber die Firmware von ex-store.de geflasht werden (OTA) Versuchen Sie es trotzdem ist das Modul unbrauchbar und muss ausgebaut werden und neu geflasht werden. Aufspielen der Tasmota Firmware mit dem Modul auf der Platine Die Leitungen TX und RX sind direkt mit der Dimm-MCU verdrahtet. Diese Leitungen m\u00fcssen getrennt werden. Zum Beispiel Pin2 und Pin3 von der MCU abl\u00f6ten (hochbiegen). L\u00f6ten Sie Kabel an GPIO0, TX, RX (ESP8266), VCC und GND (siehe Beschreibung auf der Platine). Verbinden Sie diese Kabel mit Ihrem USB Adapter. Bevor Sie die Firmware flashen, muss das Modul mit 230V (L\u00f6tpads \"230V IN\" und \"NULL\") verbunden werden. Einige USB-Adapter haben nicht gen\u00fcgend Strom um die Platine zu versorgen. 230V sind f\u00fcr Lebewesen Lebensgef\u00e4hrlich. Ein Stromschlag kann unter anderem Ihren Herzrythmus st\u00f6ren und zum Tode f\u00fchren. Dessen sollten Sie sich bewust sein wenn Sie an diesem Modul arbeiten.","title":"Disclaimer"},{"location":"devices/EXS-2-Channel-Wifi-Dimmer-V4/#schematic","text":"","title":"Schematic"},{"location":"devices/EXS-2-Channel-Wifi-Dimmer-V4/#menu","text":"","title":"Menu"},{"location":"devices/EXS-2-Channel-Wifi-Dimmer-V4/#example-setup-with-dht22","text":"DHT wiring VCC - header VCC Ground - header GND Data line - to GPIO14","title":"Example setup with DHT22"},{"location":"devices/EXS-Relay-V3.1-%26-V5.1/","text":"Flush Wifi Moduls with latching Relays ~ V3.1 Relay ~ V5.0 Relay ~ V5.0 Relay (PCB Backside) ~ Pinouts: ~ V3.1 GPIO00 Module Pin 8 GPIO01 UART0_TXD Pin 2 GPIO02 Module Pin 7 GPIO03 UART0_RXD Pin 3 GPIO04 Module Pin 10 GPIO05 Module Pin 9 GPIO12 Relay1 (High = off) GPIO13 Relay1 (High = on ) V5.0 GPIO00 Module Pin 4 GPIO02 Module Pin 3 GPIO04 Module Pin 2 GPIO05 Module Pin 1 GPIO12 Relay1 ( High = Off) GPIO13 Relay1 ( High = On) GPIO14 Relay2 ( High = Off) GPIO15 LED1 GPIO16 Relay2 ( High = On) Serial Connection ~ The only way to flashing the moduls you must soldering 4 wires to the RX/TX/3V3/GND pins from the ESP. The PCB have no serial pinout connector. For connecting the ground (GND) on a V5.0 Modul you can use one of the 2 GND pinout connectors from the PCB. For flashing the moduls enable the flashmode of the ESP, connect PIN4 (GPIO00) to GND. !!! Don't flashing the modul when it connected to the main power. You brick the device and your computer or USB Port. Use only a 3.3V USB Adapter for flashing!!! Notes ~ For use the V5.0 Modul with the \"EXS Relay(s)\" profile you must change the \"Module parameters\" (see picture below) Now you see in device setup The output pins of the V5.0 are reversed on the PCB. You must use \"out1\" for Relay2 and \"out2\" for Relay1 !!! This is the only way for support both Moduls with Tasmota. (thanks for this Note to Theo Arends)","title":"EXS Relay V3.1 & V5.1"},{"location":"devices/EXS-Relay-V3.1-%26-V5.1/#flush-wifi-moduls-with-latching-relays","text":"","title":"Flush Wifi Moduls with latching Relays"},{"location":"devices/EXS-Relay-V3.1-%26-V5.1/#v31-relay","text":"","title":"V3.1 Relay"},{"location":"devices/EXS-Relay-V3.1-%26-V5.1/#v50-relay","text":"","title":"V5.0 Relay"},{"location":"devices/EXS-Relay-V3.1-%26-V5.1/#v50-relay-pcb-backside","text":"","title":"V5.0 Relay (PCB Backside)"},{"location":"devices/EXS-Relay-V3.1-%26-V5.1/#pinouts","text":"V3.1 GPIO00 Module Pin 8 GPIO01 UART0_TXD Pin 2 GPIO02 Module Pin 7 GPIO03 UART0_RXD Pin 3 GPIO04 Module Pin 10 GPIO05 Module Pin 9 GPIO12 Relay1 (High = off) GPIO13 Relay1 (High = on ) V5.0 GPIO00 Module Pin 4 GPIO02 Module Pin 3 GPIO04 Module Pin 2 GPIO05 Module Pin 1 GPIO12 Relay1 ( High = Off) GPIO13 Relay1 ( High = On) GPIO14 Relay2 ( High = Off) GPIO15 LED1 GPIO16 Relay2 ( High = On)","title":"Pinouts:"},{"location":"devices/EXS-Relay-V3.1-%26-V5.1/#serial-connection","text":"The only way to flashing the moduls you must soldering 4 wires to the RX/TX/3V3/GND pins from the ESP. The PCB have no serial pinout connector. For connecting the ground (GND) on a V5.0 Modul you can use one of the 2 GND pinout connectors from the PCB. For flashing the moduls enable the flashmode of the ESP, connect PIN4 (GPIO00) to GND. !!! Don't flashing the modul when it connected to the main power. You brick the device and your computer or USB Port. Use only a 3.3V USB Adapter for flashing!!!","title":"Serial Connection"},{"location":"devices/EXS-Relay-V3.1-%26-V5.1/#notes","text":"For use the V5.0 Modul with the \"EXS Relay(s)\" profile you must change the \"Module parameters\" (see picture below) Now you see in device setup The output pins of the V5.0 are reversed on the PCB. You must use \"out1\" for Relay2 and \"out2\" for Relay1 !!! This is the only way for support both Moduls with Tasmota. (thanks for this Note to Theo Arends)","title":"Notes"},{"location":"devices/Etekcity-Smart-WiFi-Light-Switch-ESWL01/","text":"Generic Config\\ GPIO5 Led1\\ GPIO13 Relay1\\ GPIO14 Switch1\\ Execute switchmode1 3 in console. To put unit into flashing mode, short GPIO0 with GND","title":"Etekcity Smart WiFi Light Switch ESWL01"},{"location":"devices/Geekcreit-Sonoff-2-Channel-Relay/","text":"Geekcreit \"Sonoff\" 2 Channel Relay Bare PCB version: https://www.aliexpress.com/item/Sonoff-2CH-AC85-250V-Wireless-Switch-Timer-Smart-Wifi-Switch-Universal-Automation-Module-Remote-Control-for/32948157608.html Version with enclosure: https://www.banggood.com/Geekcreit-2-Channel-AC-85V-250V-APP-Remote-Control-WIFI-Wireless-Switch-Socket-For-Smart-Home-p-1114958.html?rmmds=search&cur_warehouse=CN The Geekcreit/\"Sonoff\" 2CH is based on the ESP8285 via the Itead PSF-B04. It is very similar to 4CH DIY, so this wiki page is based on the page for that device. More info here: https://github.com/arendst/Tasmota/issues/1970 Serial Connection ~ Geekcreit/\"Sonoff\" 2CH ~ Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) can be seen in the picture. Unless you have a very steady hand soldering will be required for the TX and RX on the ESP chip. Programming the Geekcreit/\"Sonoff\" 2CH is easy. The bottom left on-board-button is connected to GPIO0 and as with all ESP8266/ESP8285 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to hold this button when booting the device for flashing. Module parameters ~ Enable GPIO9 & GPIO10 ~ To use GPIO9 and GPIO10 of the ESP8285, open the console and enter => \"SetOption51 on\". Restart the module. Assign inputs and outputs ~ * Note: * The third button on this device is not connected to a GPIO. Instead it is used to cycle through some relay modes that are supported by the two external ICs. Only one of these modes works with Tasmota, so it is necessary to continue to press this button 3 until the relays can be controlled from the toggle buttons in the Tasmota web UI. Module Type => Generic (18) GPIO 1 => Button 1 (17) GPIO 9 => Button 2 (18) GPIO 10 => Button 3 (19) GPIO 14 => Button 4 (20) GPIO 12 => relay 1 (21) GPIO 5 => relay 2 (22) GPIO 13 => LED 1 (52) Restart the module.","title":"Geekcreit Sonoff 2 Channel Relay"},{"location":"devices/Geekcreit-Sonoff-2-Channel-Relay/#serial-connection","text":"","title":"Serial Connection"},{"location":"devices/Geekcreit-Sonoff-2-Channel-Relay/#geekcreitsonoff-2ch","text":"Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) can be seen in the picture. Unless you have a very steady hand soldering will be required for the TX and RX on the ESP chip. Programming the Geekcreit/\"Sonoff\" 2CH is easy. The bottom left on-board-button is connected to GPIO0 and as with all ESP8266/ESP8285 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to hold this button when booting the device for flashing.","title":"Geekcreit/\"Sonoff\" 2CH"},{"location":"devices/Geekcreit-Sonoff-2-Channel-Relay/#module-parameters","text":"","title":"Module parameters"},{"location":"devices/Geekcreit-Sonoff-2-Channel-Relay/#enable-gpio9-gpio10","text":"To use GPIO9 and GPIO10 of the ESP8285, open the console and enter => \"SetOption51 on\". Restart the module.","title":"Enable GPIO9 &amp; GPIO10"},{"location":"devices/Geekcreit-Sonoff-2-Channel-Relay/#assign-inputs-and-outputs","text":"* Note: * The third button on this device is not connected to a GPIO. Instead it is used to cycle through some relay modes that are supported by the two external ICs. Only one of these modes works with Tasmota, so it is necessary to continue to press this button 3 until the relays can be controlled from the toggle buttons in the Tasmota web UI. Module Type => Generic (18) GPIO 1 => Button 1 (17) GPIO 9 => Button 2 (18) GPIO 10 => Button 3 (19) GPIO 14 => Button 4 (20) GPIO 12 => relay 1 (21) GPIO 5 => relay 2 (22) GPIO 13 => LED 1 (52) Restart the module.","title":"Assign inputs and outputs"},{"location":"devices/Gosund-SP1/","text":"Purchase There are several clones of this device -- use the Teckin device: Gosund SP1 (Version 2.3 and 2.4) To configure select Gosund SP1 v23 (55) or console command Module 55 BlitzWolf SHP2 (Version 2.3 and 2.4) Calibration ~ If you have another (better) volt and power meter, this procedure should increase the precision. Use an incandescent bulb or an iron. In the web UI Console, enter the (correct) readings using the following commands: Backlog VoltageSet <voltage>; CurrentSet <current>; PowerSet <wattage> Details ~ More pictures","title":"Gosund SP1"},{"location":"devices/Gosund-SP1/#calibration","text":"If you have another (better) volt and power meter, this procedure should increase the precision. Use an incandescent bulb or an iron. In the web UI Console, enter the (correct) readings using the following commands: Backlog VoltageSet <voltage>; CurrentSet <current>; PowerSet <wattage>","title":"Calibration"},{"location":"devices/Gosund-SP1/#details","text":"More pictures","title":"Details"},{"location":"devices/H801/","text":"It's not entirely clear where these devices come from originally, but they are available from AliExpress and eBay. AliExpress: https://www.aliexpress.com/wholesale?catId=0&SearchText=H801 eBay: https://www.ebay.co.uk/sch/items/?_nkw=h801 Hardware ~ The chip used on this board is the ESP8266EX . 5 PWM outputs are connected to DTU35N06 MOSFETs to drive the 5 output channels (RGB + W1 + W2). Function ESP8266 Pin Channel R GPIO 15 PWM1 G GPIO 13 PWM2 B GPIO 12 PWM3 W1 GPIO 14 PWM4 W2 GPIO 04 PWM5 LED D1(red) GPIO 05 LED D2 (green) GPIO 01 Serial Connection ~ Please see the Hardware Preparation page for general instructions. You need to access the serial interface. The unpopulated serial header (3V3, RX, TX, GND) are available in the middle of the PCB, right next to J3. Note: the RX and TX pins are labelled from the terminal's perspective, not from the perspective of the ESP chip. This means you should connect the RX and TX pins from your computer's UART to the RX and TX pins on the board respectively, not crossing them over! To place the board into flashing mode, you will need to short J3. This can remain shorted while flashing is in progress, but you will need to remove the short in order to boot the Tasmota firmware. First Boot ~ Most boards supported by the Tasmota firmware use GPIO 1 for serial TX. The H801, as shown in the image above, uses GPIO 2. As the serial RX is still the same as for other boards, it is possible for Tasmota to read from the serial connection but anything written will not be sent to your terminal. Blindly type the following command to set Tasmota to the H801 module type, and it will automatically switch to using GPIO 2 for serial TX allowing setup to proceed: module 20 See #2155 for more details. Please be aware that some of the H801 modules were sold with only 512kB of flash. You can check whether yours is affected by using esptool, with the flash_id command. If you only have 512kB of flash, you can still build your own firmware, but will have to remove components that you do not need, in order to reduce the size of the firmware binary. You will also have to use a linker script for the smaller flash. For an example, see this issue Known Issue ~ While powering up there is a short but bright light flash emitted from the strip.","title":"H801"},{"location":"devices/H801/#hardware","text":"The chip used on this board is the ESP8266EX . 5 PWM outputs are connected to DTU35N06 MOSFETs to drive the 5 output channels (RGB + W1 + W2). Function ESP8266 Pin Channel R GPIO 15 PWM1 G GPIO 13 PWM2 B GPIO 12 PWM3 W1 GPIO 14 PWM4 W2 GPIO 04 PWM5 LED D1(red) GPIO 05 LED D2 (green) GPIO 01","title":"Hardware"},{"location":"devices/H801/#serial-connection","text":"Please see the Hardware Preparation page for general instructions. You need to access the serial interface. The unpopulated serial header (3V3, RX, TX, GND) are available in the middle of the PCB, right next to J3. Note: the RX and TX pins are labelled from the terminal's perspective, not from the perspective of the ESP chip. This means you should connect the RX and TX pins from your computer's UART to the RX and TX pins on the board respectively, not crossing them over! To place the board into flashing mode, you will need to short J3. This can remain shorted while flashing is in progress, but you will need to remove the short in order to boot the Tasmota firmware.","title":"Serial Connection"},{"location":"devices/H801/#first-boot","text":"Most boards supported by the Tasmota firmware use GPIO 1 for serial TX. The H801, as shown in the image above, uses GPIO 2. As the serial RX is still the same as for other boards, it is possible for Tasmota to read from the serial connection but anything written will not be sent to your terminal. Blindly type the following command to set Tasmota to the H801 module type, and it will automatically switch to using GPIO 2 for serial TX allowing setup to proceed: module 20 See #2155 for more details. Please be aware that some of the H801 modules were sold with only 512kB of flash. You can check whether yours is affected by using esptool, with the flash_id command. If you only have 512kB of flash, you can still build your own firmware, but will have to remove components that you do not need, in order to reduce the size of the firmware binary. You will also have to use a linker script for the smaller flash. For an example, see this issue","title":"First Boot"},{"location":"devices/H801/#known-issue","text":"While powering up there is a short but bright light flash emitted from the strip.","title":"Known Issue"},{"location":"devices/Home-Awesome-Breathing-Light-Smart-Plug-Mini-TMRLIFE-%5B2-PACK%5D-WiFi-Smart-Plug/","text":"TMRLife Plug https://smile.amazon.com/gp/product/B0786L8TC1/ref=oh_aui_search_asin_title?ie=UTF8&psc=1 Home Awesome Plug https://smile.amazon.com/gp/product/B07HH29XNS/ref=ppx_yo_dt_b_asin_title_o02__o00_s00?ie=UTF8&psc=1 These are the same device. Easily flashed with OTA GPIO is as follows Io0=pwm1 Io2=pwm2 Io5=pwm3 Io13=button1n Io15=relay1 These make great night lights","title":"Home Awesome Breathing Light Smart Plug Mini TMRLIFE [2 PACK] WiFi Smart Plug"},{"location":"devices/Hompie-SWS1/","text":"Very cheap outlet with USB-charger functionality (supposed to deliver 2A, have to test this though) and real 16A relay: Device Images 3.3V, GND and GPI00 are accessible on the main board. The used TYWE3S board unfortunately does not have easily reachable solderpads for TX/RX, but I managed to solder with a normal 60W iron between main board and TYWE3S board: Works perfectly with Tasmota 6.2.1 and the same configuration like SM-PW701E Socket Board: TYWE3S","title":"Hompie SWS1"},{"location":"devices/HuaFan-Smart-Socket/","text":"The Huafan Wi-Fi Wireless Smart Socket/Plug. ~ Introduction ~ The HuaFan Wireless Wifi Smart Plug/Socket is a useful bit of kit that allows you to introduce home automation without getting into any mains re-wiring. As an added bonus, the device also provides energy monitoring functions (voltage, current, power) in much the same way as the Sonoff Pow module does. As you may have guessed, its 'smarts' come from an embedded ESP8266, which makes it a potential target for the excellent sonoff-tasmota code. This guide provides details on how to prepare the socket for the initial flashing with sonoff-tasmota code. What is it? ~ This smart socket comes with its own iPhone/Android App and is controllable from the HF Smart cloud service. As well as allowing on/off control, the plug/socket also measures current, voltage and power. It\u2019s pretty well made but almost certainly doesn\u2019t meet the full British electrical standards, as it doesn\u2019t have a shutter to close off the live socket holes when a plug is removed. This a rather a shame and would not be too tricky to implement and would only marginally increase the cost of these pretty cheap (~\u00a3UK 10) units. The provided software/service all seemed rather closed and proprietary and not able to talk to other stuff. So something had to change! The Name ~ I'm mostly calling this a 'Smart Socket' but it also is called a 'Smart Plug' in some places. As it's got both, I guess both are right. \ufffc Disassembly ~ * WARNING - Opening the unit potentially exposes mains voltages that can kill. You proceed beyond here entirely at your own risk. * There are no screws; to disassemble you need to prise it open on each side. \ufffcInside there is a main board with most of the components on the reverse. The Wi-Fi and control comes from a small daughter board, soldered to the main board.\ufffc There\u2019s not a lot to see on the top apart from the mains relay, the button and the red/blue LEDs that illuminate it.\ufffc The main item of interest on the top is the daughter board. This has our trusty ESP8266EX and a 8Mbit SPI flash memory. You can also see the 40MHz crystal - more on this later\u2026 \ufffc The reverse of the daughter board is pretty bare - only the Vcc (3.3V) and GND are marked. In this view you can also see the red and blue LEDs and the push button. In its original configuration the red LED normally is set to the same state as the relay and the blue LED provides information on the state of connectivity. Another warning... What is marked as GND IS NOT GROUNDED , it\u2019s not even floating, GND IS CONNECTED TO THE NEUTRAL LINE OF THE MAINS . Do not connect any equipment or yourself to the board whilst it is plugged onto a mains socket - EVEN IF THAT SOCKET APPEARS TO BE SWITCHED OFF. Neutral is not 0V or Ground and should be treated as live (just in case it really is). Always completely disconnect your programming / serial interface before plugging the device into a mains socket. You need a hefty soldering iron to unsolder the board from the plug pins and on the reverse you see the main circuitry. Next door to the AMS1117 3.3V regulator for the ESP is a HLW8012 chip that does the current/voltage/power measurement. Conveniently, this is the same chip that's used in the Sonoff Pow module, so all the code to drive it is already in place. Below the two ICs is R12 it's R002 i.e. a 2mOhm resistor. This may be different to the one in the Sonoff, so expect to use different calibration settings. Hookup ~ Unless you are just curious, there\u2019s no real need to unsolder the main board. You can get at everything you need to re-flash it on the top side of the main board. \ufffc For programming you need to unplug the unit for any mains and make connections to GND, Vcc and Rx. That\u2019s 1, 2 and 4 on the back of the daughter board, counting from the right. The connection for Tx should have been on the back of the daughter board (all the circuit board tracks are in place on the daughter board). However, for some reason they didn\u2019t populate R5 (or removed it after programming) so the Tx signal does not appear on the rear of the board like it was clearly designed to do. Instead you have two options, either re-instate R5 with a very small piece of wire (or a teeny resistor if you have one) or solder a wire directly to the resistor pad/chip pin. As the connection should be temporary (subsequent flashes will be Over the Air) I initially went for the simpler but more fragile direct connection, mechanically secured with some insulating tape. If you do prefer to solder a small wire across R5 then you will need to cut the small links on the main board around pad 5, as the designers of the main board have connected this pad to the GND plane with two small links, one at the end and to the left side of the pad. Again, all this is on the top of the main board, you don\u2019t need to go delving underneath. On the front of the daughter board there is the GPIO0 pin (pad number 4, reading from the left). This needs to be manually connected to ground and then the power applied to the ESP8266 to put it in programming mode. You can solder something onto this, as shown, or pick it up where it connects to the blue LED with a small clip probe. Daughter board pinout ~ Viewed from above the main board Front Back GPIO14 - HLW8012 P pulse 1 |B| 1 0V (marked GND) GPIO12 - HLW8012 I/V pulse 2 |O| 2 3.3V (marked VCC) GPIO13 - HLW8012 I/V select 3 |A| 3 GPIO05 - Relay- GPIO00 - Blue LED- 4 |R| 4 GPIO03 (U0RxD) - Red LED- GPIO04 - Button- 5 |D| 5 Initially GND but ready for GPIO01 (U0TxD) Hookup - Solder Free Option ~ Adding to the great guide above ... So if soldering isn't your bag, there are a few connection points that you can get at with clip probes. There is a +5V and GND contact on the left side of the board and the right LED legs give access to the ESP's GPIO0 and RXD. The tricky bit is the ESP's TXD line which, as stated before, is only accessible on the daughter board via the chip's pin or an smd pad above and to the right. @jwrw, I am in awe of anyone that can solder onto this pad! As an alternative, try connecting an alligator clip to a sewing pin 8) to make a probe and holding it in place with your finger during firmware programming (hey, it only has to work once as from then on you use OTA). Powering via the pcb contacts requires more current than my FTDI was able to source so a seperate 5V power supply is required (a Raspberry Pi can provide the +5V/GND via it's GPIO header if you haven't got a dedicated power supply at hand). Building Firmware ~ The process for building the firmware for the HuaFan is basically the same as for the Sonoff but with a few additional steps. Firstly, make sure that you have installed release 5.5.0 of Tasmota or later and that you have completed all of the standard preparation tasks mentioned in the Wiki. Next, you should ensure that you have installed version 2.4.0-rc1 or later of ESP8266/Arduino core that includes support for the 40MHz crystal used by the HuaFan. Installation instructions can be found here but are essentially as follows: - Start Arduino and open Preferences window. - Swap the existing link for the stable ESP8266/Arduino core release with https://github.com/esp8266/Arduino/releases/download/2.4.0-rc1/package_esp8266com_index.json in Additional Board Manager URLs field.. - Open Boards Manager from Tools > Board menu and update esp8266 platform (check that it is using the RC version). Lastly, you need to edit the boards.txt file to allow selection of the 40MHz Crystal via the Arduino IDE Tools menu. Add the following lines into the section for the \"Generic ESP8266 Module\" and immediately after the \"generic.menu.CpuFrequency\" items: generic.menu.CrystalFreq.26=26 MHz` generic.menu.CrystalFreq.40=40 MHz` generic.menu.CrystalFreq.40.build.extra_flags=-DF_CRYSTAL=40000000","title":"The Huafan Wi-Fi Wireless Smart Socket/Plug."},{"location":"devices/HuaFan-Smart-Socket/#the-huafan-wi-fi-wireless-smart-socketplug","text":"","title":"The Huafan Wi-Fi Wireless Smart Socket/Plug."},{"location":"devices/HuaFan-Smart-Socket/#introduction","text":"The HuaFan Wireless Wifi Smart Plug/Socket is a useful bit of kit that allows you to introduce home automation without getting into any mains re-wiring. As an added bonus, the device also provides energy monitoring functions (voltage, current, power) in much the same way as the Sonoff Pow module does. As you may have guessed, its 'smarts' come from an embedded ESP8266, which makes it a potential target for the excellent sonoff-tasmota code. This guide provides details on how to prepare the socket for the initial flashing with sonoff-tasmota code.","title":"Introduction"},{"location":"devices/HuaFan-Smart-Socket/#what-is-it","text":"This smart socket comes with its own iPhone/Android App and is controllable from the HF Smart cloud service. As well as allowing on/off control, the plug/socket also measures current, voltage and power. It\u2019s pretty well made but almost certainly doesn\u2019t meet the full British electrical standards, as it doesn\u2019t have a shutter to close off the live socket holes when a plug is removed. This a rather a shame and would not be too tricky to implement and would only marginally increase the cost of these pretty cheap (~\u00a3UK 10) units. The provided software/service all seemed rather closed and proprietary and not able to talk to other stuff. So something had to change!","title":"What is it?"},{"location":"devices/HuaFan-Smart-Socket/#the-name","text":"I'm mostly calling this a 'Smart Socket' but it also is called a 'Smart Plug' in some places. As it's got both, I guess both are right. \ufffc","title":"The Name"},{"location":"devices/HuaFan-Smart-Socket/#disassembly","text":"* WARNING - Opening the unit potentially exposes mains voltages that can kill. You proceed beyond here entirely at your own risk. * There are no screws; to disassemble you need to prise it open on each side. \ufffcInside there is a main board with most of the components on the reverse. The Wi-Fi and control comes from a small daughter board, soldered to the main board.\ufffc There\u2019s not a lot to see on the top apart from the mains relay, the button and the red/blue LEDs that illuminate it.\ufffc The main item of interest on the top is the daughter board. This has our trusty ESP8266EX and a 8Mbit SPI flash memory. You can also see the 40MHz crystal - more on this later\u2026 \ufffc The reverse of the daughter board is pretty bare - only the Vcc (3.3V) and GND are marked. In this view you can also see the red and blue LEDs and the push button. In its original configuration the red LED normally is set to the same state as the relay and the blue LED provides information on the state of connectivity. Another warning... What is marked as GND IS NOT GROUNDED , it\u2019s not even floating, GND IS CONNECTED TO THE NEUTRAL LINE OF THE MAINS . Do not connect any equipment or yourself to the board whilst it is plugged onto a mains socket - EVEN IF THAT SOCKET APPEARS TO BE SWITCHED OFF. Neutral is not 0V or Ground and should be treated as live (just in case it really is). Always completely disconnect your programming / serial interface before plugging the device into a mains socket. You need a hefty soldering iron to unsolder the board from the plug pins and on the reverse you see the main circuitry. Next door to the AMS1117 3.3V regulator for the ESP is a HLW8012 chip that does the current/voltage/power measurement. Conveniently, this is the same chip that's used in the Sonoff Pow module, so all the code to drive it is already in place. Below the two ICs is R12 it's R002 i.e. a 2mOhm resistor. This may be different to the one in the Sonoff, so expect to use different calibration settings.","title":"Disassembly"},{"location":"devices/HuaFan-Smart-Socket/#hookup","text":"Unless you are just curious, there\u2019s no real need to unsolder the main board. You can get at everything you need to re-flash it on the top side of the main board. \ufffc For programming you need to unplug the unit for any mains and make connections to GND, Vcc and Rx. That\u2019s 1, 2 and 4 on the back of the daughter board, counting from the right. The connection for Tx should have been on the back of the daughter board (all the circuit board tracks are in place on the daughter board). However, for some reason they didn\u2019t populate R5 (or removed it after programming) so the Tx signal does not appear on the rear of the board like it was clearly designed to do. Instead you have two options, either re-instate R5 with a very small piece of wire (or a teeny resistor if you have one) or solder a wire directly to the resistor pad/chip pin. As the connection should be temporary (subsequent flashes will be Over the Air) I initially went for the simpler but more fragile direct connection, mechanically secured with some insulating tape. If you do prefer to solder a small wire across R5 then you will need to cut the small links on the main board around pad 5, as the designers of the main board have connected this pad to the GND plane with two small links, one at the end and to the left side of the pad. Again, all this is on the top of the main board, you don\u2019t need to go delving underneath. On the front of the daughter board there is the GPIO0 pin (pad number 4, reading from the left). This needs to be manually connected to ground and then the power applied to the ESP8266 to put it in programming mode. You can solder something onto this, as shown, or pick it up where it connects to the blue LED with a small clip probe.","title":"Hookup"},{"location":"devices/HuaFan-Smart-Socket/#daughter-board-pinout","text":"Viewed from above the main board Front Back GPIO14 - HLW8012 P pulse 1 |B| 1 0V (marked GND) GPIO12 - HLW8012 I/V pulse 2 |O| 2 3.3V (marked VCC) GPIO13 - HLW8012 I/V select 3 |A| 3 GPIO05 - Relay- GPIO00 - Blue LED- 4 |R| 4 GPIO03 (U0RxD) - Red LED- GPIO04 - Button- 5 |D| 5 Initially GND but ready for GPIO01 (U0TxD)","title":"Daughter board pinout"},{"location":"devices/HuaFan-Smart-Socket/#hookup-solder-free-option","text":"Adding to the great guide above ... So if soldering isn't your bag, there are a few connection points that you can get at with clip probes. There is a +5V and GND contact on the left side of the board and the right LED legs give access to the ESP's GPIO0 and RXD. The tricky bit is the ESP's TXD line which, as stated before, is only accessible on the daughter board via the chip's pin or an smd pad above and to the right. @jwrw, I am in awe of anyone that can solder onto this pad! As an alternative, try connecting an alligator clip to a sewing pin 8) to make a probe and holding it in place with your finger during firmware programming (hey, it only has to work once as from then on you use OTA). Powering via the pcb contacts requires more current than my FTDI was able to source so a seperate 5V power supply is required (a Raspberry Pi can provide the +5V/GND via it's GPIO header if you haven't got a dedicated power supply at hand).","title":"Hookup - Solder Free Option"},{"location":"devices/HuaFan-Smart-Socket/#building-firmware","text":"The process for building the firmware for the HuaFan is basically the same as for the Sonoff but with a few additional steps. Firstly, make sure that you have installed release 5.5.0 of Tasmota or later and that you have completed all of the standard preparation tasks mentioned in the Wiki. Next, you should ensure that you have installed version 2.4.0-rc1 or later of ESP8266/Arduino core that includes support for the 40MHz crystal used by the HuaFan. Installation instructions can be found here but are essentially as follows: - Start Arduino and open Preferences window. - Swap the existing link for the stable ESP8266/Arduino core release with https://github.com/esp8266/Arduino/releases/download/2.4.0-rc1/package_esp8266com_index.json in Additional Board Manager URLs field.. - Open Boards Manager from Tools > Board menu and update esp8266 platform (check that it is using the RC version). Lastly, you need to edit the boards.txt file to allow selection of the 40MHz Crystal via the Arduino IDE Tools menu. Add the following lines into the section for the \"Generic ESP8266 Module\" and immediately after the \"generic.menu.CpuFrequency\" items: generic.menu.CrystalFreq.26=26 MHz` generic.menu.CrystalFreq.40=40 MHz` generic.menu.CrystalFreq.40.build.extra_flags=-DF_CRYSTAL=40000000","title":"Building Firmware"},{"location":"devices/Hyleton-313-Smart-Plug/","text":"Intro ~ Recently I bought a very nice and compact Smart Plug (UK variant) from Aliexpress - a Hyleton 313 . This was in fact the smallest smart plug device with UK plug I've ever seen - it is no bigger than an average USB/phone charger: Another good thing is that it is built around a ESP8266 module, which gives us the possibility to change its firmware and install Tasmota. Open the case ~ There are no visible screws, however it is not that difficult to open the case using some sharp plastic or metal pry tool and a heat gun (or hair dryer on max setting also works - hold on each side for about 20-30 seconds). Heat the edge of the plug a bit, then work your way slowly and pry from the middle of side with the button, slowly moving the tool towards the corners. Alternatively if you don't have a heat gun or hair dryer you can use a pry tool or something else thin to slowly \"saw\" away at the middle of the side with the button until you are through (about 2-3mm) . With or without a heat gun/hair drier it can be quite tough - be careful and keep your fingers away from the tool you are using! Once you have got through the layer of adhesive you can lever the case open to dislodge the adhesive on the other sides. Be careful not to accidentally knock off the PCB supports in each corner as these are crucial to safety. Once the case is open, the top side of the PCB will be exposed: The WiFi module is soldered vertically to the main PCB and sits right next to the relay. In order to get access to its pins, remove the screw from the centre of the PCB. After that the bottom plastic plate, which holds the three mains connector prongs, can be moved a bit to the side without desoldering anything (it is attached with short cables to the PCB, but cables' length is just enough to move it out of the way of the WiFi module's pins). Here's a view of the bottom side of the PCB: You can see the product labels (product code, date and board revision), as well as the UL number. WiFi module pins ~ Here is a close-up view of the module's pins as seen from the bottom of the main PCB: And this is how module pins numbers are mapped (I had to desolder the module looking for labels when I tried to identify it): Failed to identify the module, I had remove the metal shielding cap to find the routing of the ESP8266's pins, so I grabbed the multimeter and soon I had the following table: Module pin ESP8266 pin Pin name Pin name ESP8266 pin Module pin 1 7 Chip Enable Tout (ADC) 6 2 3 9 MTMS / GPIO14 MTDI / GPIO12 10 4 5 12 MTCK / GPIO13 MTDO / GPIO15 13 6 7 15 GPIO0 GPIO2 14 8 9 16 GPIO4 GPIO5 24 10 11 25 U0RXD U0TXD 26 12 13 Vdd - - GND 14 Serial Connection ~ For programming you need to solder 4 jumper wires to pins 11 , 12 , 13 and 14 : Pin Function 11 Rx 12 Tx 13 Vdd 14 Ground In this picture Yellow is Tx, Orange is Ground, Grey is Rx and White is Vdd: Connect the other end of the wires to your USB-to-serial adapter and make sure the supply voltage selected is 3.3V. Shorting pin 7 (GPIO0) to ground while plugging the serial adapter into the computer's USB port will bring the module into UART firmware upload mode. See devices/Esptool for details of how to flash the firmware when in firmware upload mode. Once you have flashed the firmware, leave the jumpers soldered to the pins and unplug & reinsert your USB-to-serial adapter - this will reset the unit and provide voltage to the ESP8266 which will then boot the new Tasmota firmware - you'll see a Wifi network called \"sonof-xxxx\" if it has flashed successfully worked (if you do not see the wifi, the flashing process might not have worked correctly and you'll need to try again). If you see the wifi network come up ok, you can de-solder the jumpers and reassemble the unit. Reassembly ~ Screw the PCB back to the housing, and place the PCB back into the other half of the socket. Apply a small 1mm bead of super glue around the edges and firmly clip the two halves back together again, and hold firmly for about 30 seconds to allow the glue to cure. Dangerous Failure Mode To Avoid ~ When reassembling the plug, be extremely careful to ensure that the resistor next to the PCB screw is not leaning towards the earth (top) pin! It is very easy to slightly bend it towards the earth pin when unscrewing. If the resistor is too close to the earth pin, the plastic shield for the earth pin on the upper-half of the case will press the resistor down onto the earth pin and when a plug is inserted it can short-out and trigger a small explosion: This will kill the socket, and maybe you too. Take extreme caution - mains electricity is dangerous. If you cannot neatly clip everything back into place (i.e. the two halves of the shell don't neatly sit together again, or there is a springiness) then you may have caught the resistor. If you accidentally broke off the PCB standoffs when opening the case, this is harder to detect (as the PCB may be pushed further down than usual) so be especially careful. Double & triple check. If you've done everything right you should have a fairly clean looking plug still with just a small amount of cosmetic scratches on the bottom side of the unit where you used the pry tool. Configuration ~ Enroll your plug back onto your wifi as usual for Tasmota (i.e. join the wifi network started by the plug, give it your wifi details, then restart it). Once Tasmota 's WebUI configuration interface is loaded in the browser, you need to configure the template type: Go to \"Configuration\" Go to \"Configure template\" Create a new template that looks like this one and save it: Once you have saved the template: Wait for the device to restart Go to \"Configuration\" Go to \"Configure module\" Select the new template you just created and save. Note on LEDs ~ Sonoff devices usually have a bi-colour LED, but just one of the colours can be controlled directly. The other colour is usually tied together with the relay, so it cannot be controlled independently. I think that is the reason why the Tasmota firmware by default controls just Led1 when a single relay is configured. In the configuration above, only the blue LED will be used (tied to GPIO2 ). But if you prefer the red LED, just change the values for Led1i and Led2i (select Led1i for GPIO0 and Led2i for GPIO2 ). Additional Details ~ If you want to read a detailed project log that uses this plug, you can do so at GitHub Blog page , although some of the information is now out of date.","title":"Hyleton 313 Smart Plug"},{"location":"devices/Hyleton-313-Smart-Plug/#intro","text":"Recently I bought a very nice and compact Smart Plug (UK variant) from Aliexpress - a Hyleton 313 . This was in fact the smallest smart plug device with UK plug I've ever seen - it is no bigger than an average USB/phone charger: Another good thing is that it is built around a ESP8266 module, which gives us the possibility to change its firmware and install Tasmota.","title":"Intro"},{"location":"devices/Hyleton-313-Smart-Plug/#open-the-case","text":"There are no visible screws, however it is not that difficult to open the case using some sharp plastic or metal pry tool and a heat gun (or hair dryer on max setting also works - hold on each side for about 20-30 seconds). Heat the edge of the plug a bit, then work your way slowly and pry from the middle of side with the button, slowly moving the tool towards the corners. Alternatively if you don't have a heat gun or hair dryer you can use a pry tool or something else thin to slowly \"saw\" away at the middle of the side with the button until you are through (about 2-3mm) . With or without a heat gun/hair drier it can be quite tough - be careful and keep your fingers away from the tool you are using! Once you have got through the layer of adhesive you can lever the case open to dislodge the adhesive on the other sides. Be careful not to accidentally knock off the PCB supports in each corner as these are crucial to safety. Once the case is open, the top side of the PCB will be exposed: The WiFi module is soldered vertically to the main PCB and sits right next to the relay. In order to get access to its pins, remove the screw from the centre of the PCB. After that the bottom plastic plate, which holds the three mains connector prongs, can be moved a bit to the side without desoldering anything (it is attached with short cables to the PCB, but cables' length is just enough to move it out of the way of the WiFi module's pins). Here's a view of the bottom side of the PCB: You can see the product labels (product code, date and board revision), as well as the UL number.","title":"Open the case"},{"location":"devices/Hyleton-313-Smart-Plug/#wifi-module-pins","text":"Here is a close-up view of the module's pins as seen from the bottom of the main PCB: And this is how module pins numbers are mapped (I had to desolder the module looking for labels when I tried to identify it): Failed to identify the module, I had remove the metal shielding cap to find the routing of the ESP8266's pins, so I grabbed the multimeter and soon I had the following table: Module pin ESP8266 pin Pin name Pin name ESP8266 pin Module pin 1 7 Chip Enable Tout (ADC) 6 2 3 9 MTMS / GPIO14 MTDI / GPIO12 10 4 5 12 MTCK / GPIO13 MTDO / GPIO15 13 6 7 15 GPIO0 GPIO2 14 8 9 16 GPIO4 GPIO5 24 10 11 25 U0RXD U0TXD 26 12 13 Vdd - - GND 14","title":"WiFi module pins"},{"location":"devices/Hyleton-313-Smart-Plug/#serial-connection","text":"For programming you need to solder 4 jumper wires to pins 11 , 12 , 13 and 14 : Pin Function 11 Rx 12 Tx 13 Vdd 14 Ground In this picture Yellow is Tx, Orange is Ground, Grey is Rx and White is Vdd: Connect the other end of the wires to your USB-to-serial adapter and make sure the supply voltage selected is 3.3V. Shorting pin 7 (GPIO0) to ground while plugging the serial adapter into the computer's USB port will bring the module into UART firmware upload mode. See devices/Esptool for details of how to flash the firmware when in firmware upload mode. Once you have flashed the firmware, leave the jumpers soldered to the pins and unplug & reinsert your USB-to-serial adapter - this will reset the unit and provide voltage to the ESP8266 which will then boot the new Tasmota firmware - you'll see a Wifi network called \"sonof-xxxx\" if it has flashed successfully worked (if you do not see the wifi, the flashing process might not have worked correctly and you'll need to try again). If you see the wifi network come up ok, you can de-solder the jumpers and reassemble the unit.","title":"Serial Connection"},{"location":"devices/Hyleton-313-Smart-Plug/#reassembly","text":"Screw the PCB back to the housing, and place the PCB back into the other half of the socket. Apply a small 1mm bead of super glue around the edges and firmly clip the two halves back together again, and hold firmly for about 30 seconds to allow the glue to cure.","title":"Reassembly"},{"location":"devices/Hyleton-313-Smart-Plug/#dangerous-failure-mode-to-avoid","text":"When reassembling the plug, be extremely careful to ensure that the resistor next to the PCB screw is not leaning towards the earth (top) pin! It is very easy to slightly bend it towards the earth pin when unscrewing. If the resistor is too close to the earth pin, the plastic shield for the earth pin on the upper-half of the case will press the resistor down onto the earth pin and when a plug is inserted it can short-out and trigger a small explosion: This will kill the socket, and maybe you too. Take extreme caution - mains electricity is dangerous. If you cannot neatly clip everything back into place (i.e. the two halves of the shell don't neatly sit together again, or there is a springiness) then you may have caught the resistor. If you accidentally broke off the PCB standoffs when opening the case, this is harder to detect (as the PCB may be pushed further down than usual) so be especially careful. Double & triple check. If you've done everything right you should have a fairly clean looking plug still with just a small amount of cosmetic scratches on the bottom side of the unit where you used the pry tool.","title":"Dangerous Failure Mode To Avoid"},{"location":"devices/Hyleton-313-Smart-Plug/#configuration","text":"Enroll your plug back onto your wifi as usual for Tasmota (i.e. join the wifi network started by the plug, give it your wifi details, then restart it). Once Tasmota 's WebUI configuration interface is loaded in the browser, you need to configure the template type: Go to \"Configuration\" Go to \"Configure template\" Create a new template that looks like this one and save it: Once you have saved the template: Wait for the device to restart Go to \"Configuration\" Go to \"Configure module\" Select the new template you just created and save.","title":"Configuration"},{"location":"devices/Hyleton-313-Smart-Plug/#note-on-leds","text":"Sonoff devices usually have a bi-colour LED, but just one of the colours can be controlled directly. The other colour is usually tied together with the relay, so it cannot be controlled independently. I think that is the reason why the Tasmota firmware by default controls just Led1 when a single relay is configured. In the configuration above, only the blue LED will be used (tied to GPIO2 ). But if you prefer the red LED, just change the values for Led1i and Led2i (select Led1i for GPIO0 and Led2i for GPIO2 ).","title":"Note on LEDs"},{"location":"devices/Hyleton-313-Smart-Plug/#additional-details","text":"If you want to read a detailed project log that uses this plug, you can do so at GitHub Blog page , although some of the information is now out of date.","title":"Additional Details"},{"location":"devices/KMC-70008-light-switch/","text":"Shopping Depending on the version of the firmware shipped on the device, you may be able to flash it using the Tuya-Convert OTA flashing tool . This tutorial shows how that tool works. If the OTA flash method does not work, you will have to solder leads to flash the device. Except for GPIO0, the programming pins are not broken out on the PCB. The module has the usual ESP-12 pin layout, so carefully solder right to the chip's pins. The device button is connected to GPIO0. You do not need to solder onto GPIO0. Just hold the button down when booting the device to get it into flash mode. Once you get the device flashed, set up the Wi-Fi configuration and connect to the device using a browser using its IP address. To keep the device from constantly rebooting, the first configuration step you should perform is to set the module type to Generic (18). Configuration: * Digiblur's Tasmota forked firmware * Generic (18) * GPIO0: Button1 * GPIO13: Led1i * GPIO14: Relay1 When the blue LED on GPIO 13 is set to LED1i the white light shines when the relay is off and the blue light illuminates then the relay is on. Further configuration and setup may be required as the blue LED constantly flashes.","title":"KMC 70008 light switch"},{"location":"devices/KS-602S-Switch/","text":"These Wi-Fi Smart Light Switches are essentially a sonoff basic in a decora wall switch. GPIO Map ~ GPIO 0 - Button1 - Button GPIO 12 - Relay1 - Red LED and Relay GPIO 13 - Led1 (not Led1i like the Sonoff Basic) Green LED * As of May 2019 there may be a modified version. This is the pinout. * * GPIO 0 - Button1 - Button * GPIO 14 - Relay1 - Relay * GPIO 16 - Led1/Led1i - Red LED * I couldn't find the green LED but it exists. Product Links ~ Amazon Link of KULED Branded Switches Unboxing ~ Some revisions of the switch have the header marked GND, RXD, TXD, 3V3. Some revisions do not. It has been reported that some boxes have mixed revisions. If you are ever in doubt, double check with a meter to determine your pins. Flashing process and hardware revision without the labels can be seen on the following video link . RXD is connected to Transmit on your programmer TXD is connected to Receive on your programmer Ground and 3.3vdc to power unit during flash. You do not need to solder a header to flash the board, an empty 4 pin header connected to 4 dupont jumper wires held into the empty header location works fine with a little pressure to ensure connectivity. Hold the button(GPIO0) and plug in programmer. Device works perfectly as a Sonoff Basic but the LED will be backwards as designed. The Red LED is hardwired to the relay and the green is controllable over GPIO pins. If you wish to change the functionality to have the green LED when the device is off, you can utilize or change the template to a generic device type and map the suggested names except you will choose Led1 instead of Led1i.","title":"KS 602S Switch"},{"location":"devices/KS-602S-Switch/#gpio-map","text":"GPIO 0 - Button1 - Button GPIO 12 - Relay1 - Red LED and Relay GPIO 13 - Led1 (not Led1i like the Sonoff Basic) Green LED * As of May 2019 there may be a modified version. This is the pinout. * * GPIO 0 - Button1 - Button * GPIO 14 - Relay1 - Relay * GPIO 16 - Led1/Led1i - Red LED * I couldn't find the green LED but it exists.","title":"GPIO Map"},{"location":"devices/KS-602S-Switch/#product-links","text":"Amazon Link of KULED Branded Switches","title":"Product Links"},{"location":"devices/KS-602S-Switch/#unboxing","text":"Some revisions of the switch have the header marked GND, RXD, TXD, 3V3. Some revisions do not. It has been reported that some boxes have mixed revisions. If you are ever in doubt, double check with a meter to determine your pins. Flashing process and hardware revision without the labels can be seen on the following video link . RXD is connected to Transmit on your programmer TXD is connected to Receive on your programmer Ground and 3.3vdc to power unit during flash. You do not need to solder a header to flash the board, an empty 4 pin header connected to 4 dupont jumper wires held into the empty header location works fine with a little pressure to ensure connectivity. Hold the button(GPIO0) and plug in programmer. Device works perfectly as a Sonoff Basic but the LED will be backwards as designed. The Red LED is hardwired to the relay and the green is controllable over GPIO pins. If you wish to change the functionality to have the green LED when the device is off, you can utilize or change the template to a generic device type and map the suggested names except you will choose Led1 instead of Led1i.","title":"Unboxing"},{"location":"devices/Kesen-KS-604S/","text":"This Tuya Wi-Fi module ESP8266 based device has a really attractive form factor and functionality (in-wall, single gang, dual outlet, USB port, each individually controllable). This device can be most easily flashed using using Tuya-Convert . Others have reported that flashing this device by attaching leads to the serial interface requires disassembling and unsoldering the internal AC components to get access to the needed contacts, however an AliBaba device was successfully flashed by connecting to the four terminals at the bottom of the back circuit board (3v3, Tx, Rx, G) and connecting pin D3 in block J7 to ground while booting and during the flashing process. Shopping ~ Amazon Alibaba (10 minimum) Configuration ~ It appears that there are different versions of the KS-604S. The device that @DavinKD flashed (likely purchased from Amazon in early to mid March 2019) has a different GPIO configuration than devices purchased from Alibaba in late March. Rear Amazon Device ~ {\"NAME\":\"KS-604S\",\"GPIO\":[255,255,56,255,255,17,255,255,22,21,255,255,18],\"FLAG\":1,\"BASE\":18} GPIO Function Configuration 2 Device Status (Green) LED1i (56) 5 Top Button Button1 (17) 12 Bottom Receptacle Relay2 (22) 13 Top Receptacle Relay1 (21) 16 Bottom Button Button2 (18) The USB port on this variant is not switchable. Alibaba Device ~ {\"NAME\":\"KS-604S\",\"GPIO\":[158,255,255,17,56,18,255,255,22,21,57,23,255],\"FLAG\":0,\"BASE\":18} GPIO Function Configuration 0 Device Status (Green) LEDLinki (158) 3 Top Button Button1 (17) 4 Top LED (Orange) LED1i (56) 5 Bottom Button Button2 (18) 12 Bottom Receptacle Relay2 (22) 13 Top Receptacle Relay1 (21) 14 Bottom LED (Orange) LED2i (57) 15 USB Port Relay3 (23) This configuration requires the LedLinki Component (introduced in 6.5.0.12) to associate the GPIO to the status LED indicator. In order for the LED power indicators to follow the state of each receptacle relay, LedState must be set to show the power state on the LEDs. Select the desired power on state for the device's relays using PowerOnState and/or a System#Boot triggered rule. This device also requires SetOption63 (introduced in 6.5.0.9) in order to disable relay power feedback state scanning at restart. The following Console statements define the necessary settings and rules as described above. Backlog SerialLog 0; PowerOnState 0; SetOption63 1; LEDState 1 Rule1 ON System#Boot DO Power3 On ENDON # Turn the USB port on Rule1 1","title":"Kesen KS 604S"},{"location":"devices/Kesen-KS-604S/#shopping","text":"Amazon Alibaba (10 minimum)","title":"Shopping"},{"location":"devices/Kesen-KS-604S/#configuration","text":"It appears that there are different versions of the KS-604S. The device that @DavinKD flashed (likely purchased from Amazon in early to mid March 2019) has a different GPIO configuration than devices purchased from Alibaba in late March. Rear","title":"Configuration"},{"location":"devices/Kesen-KS-604S/#amazon-device","text":"{\"NAME\":\"KS-604S\",\"GPIO\":[255,255,56,255,255,17,255,255,22,21,255,255,18],\"FLAG\":1,\"BASE\":18} GPIO Function Configuration 2 Device Status (Green) LED1i (56) 5 Top Button Button1 (17) 12 Bottom Receptacle Relay2 (22) 13 Top Receptacle Relay1 (21) 16 Bottom Button Button2 (18) The USB port on this variant is not switchable.","title":"Amazon Device"},{"location":"devices/Kesen-KS-604S/#alibaba-device","text":"{\"NAME\":\"KS-604S\",\"GPIO\":[158,255,255,17,56,18,255,255,22,21,57,23,255],\"FLAG\":0,\"BASE\":18} GPIO Function Configuration 0 Device Status (Green) LEDLinki (158) 3 Top Button Button1 (17) 4 Top LED (Orange) LED1i (56) 5 Bottom Button Button2 (18) 12 Bottom Receptacle Relay2 (22) 13 Top Receptacle Relay1 (21) 14 Bottom LED (Orange) LED2i (57) 15 USB Port Relay3 (23) This configuration requires the LedLinki Component (introduced in 6.5.0.12) to associate the GPIO to the status LED indicator. In order for the LED power indicators to follow the state of each receptacle relay, LedState must be set to show the power state on the LEDs. Select the desired power on state for the device's relays using PowerOnState and/or a System#Boot triggered rule. This device also requires SetOption63 (introduced in 6.5.0.9) in order to disable relay power feedback state scanning at restart. The following Console statements define the necessary settings and rules as described above. Backlog SerialLog 0; PowerOnState 0; SetOption63 1; LEDState 1 Rule1 ON System#Boot DO Power3 On ENDON # Turn the USB port on Rule1 1","title":"Alibaba Device"},{"location":"devices/KingArt/","text":"KingArt-N1 - Touch Light Light Switch ~ This is a relatively cheap Premium glass fronted touch panel, looks clean and minimal when installed too. Table Of Contents: * Device Features * * Breakdown * * Capacitive Touch IC * Re-Programming * * Tools * * Setup * * Programming Mode * Reference Device Features ~ ESP8285 micro Blue status LED (micro controlled) Separate touch IC controlled switch status indicators (blue and red) Confirmed 10A/250VAC mains relay -- Image: The 1 Gang Touch Panel, featuring the glass front (protective plastic film still on) Breakdown ~ Whats in the package... This looks like a reasonably simple setup. Removing the front glass panel you have access to the main control PCB. This holds the ESP8285 micro-controller and accompanying guff. I've worked through mapping most of the pins of interest - notes are in the images below. The control board runs off a 5V fed from the Power-Relay board at the read of the unit - a 3v3 reg is the control board for all the logic. The back of the control board has the touch controller and the 8way header to the Power-Relay board. There are only touch pads on the back of the control board as a means to interface with the microcontroller. There is no SonOff type programming header arrangement. , see Re-Programming . Control and Interface PCB Sorry for the horrible pics.. will replace Some Application-Interesting Pin Allocations *Trace for the King Art Switch with 2 (Touch-)Button is confirmed - works well with this Parameters The Power-Relay board is reasonably simple as well. This board, being a 1-gang switch, only has a single relay - but the PCB is set out for 3 (again, see images for trace and pin notes ). Power-Relay PCB Capacitive Touch IC ~ This board uses a dedicated capacitive touch control IC. Something interesting, that this IC manages touch switching as well a red and blue touch status LEDs for each of the touch pads that it services as the buttons. The IC illuminates a diffuser block over a 'button', indicating: * Blue : when Idle - button state is 'OFF' * Red+Blue : when Active - button state is 'ON' The TW8001 is also linked to a red error indicator led on the front of the Control Board - it is co-located above the EPS8285 microcontroller's Blue status indicator. This appears to be used by the Touch IC to indicate its own state information * eg, if the touch is held for +30s the touch shows an error state (red LED) and resets - useful if you replace the front panel and it needs to recalibrate. With regard to interfacing with the microcontroller, this device seems function with GPIO-friendly pin state for the capacitive button state reporting. Here is the only information I have been able to find on this device at the time of this investigation : TechWave - TW8001 . It does have much (or: any) in way of public datasheets. If anyone finds a datasheet please link it here! Re-Programming ~ Tools ~ You shall need something in way of the following: (or whatever works for you, this is just my setup) * A USB-TTL adapter (TTL, 3V3.. something also with a 3V3 source) * Some leads * A soldering iron (solder, bits.. etc) - I'm going to assume you know how/what to do with this. Setup ~ (This is my setup) USB-TTL | Lead | Board 3V3 Red 3v3 TXD White RX RXD Grey TX GND Black GND NNB : DO NOT USE or CONNECT THE 5V ever.. Programming Mode ~ Before you can program the board you have to start the ESP8285 micro in Programming Mode. This is important. Remember we soldered the blue lead to the board at (SW) - you will use this to force the micro to the required mode on startup. (you can only do this on startup) Entering Programming Mode: * Remove power from the board * Short the blue lead (SW) to ground (use a ground pad on the board or on your programmer) * NOW: Apply power. You can remove the short to ground after a second or two. So, Are we in Programming Mode? ... Test Failed - try again If the board has its factory firmware installed still it usually flashes the status LED on startup.. (ie: not in programming mode) Test Success If you have successfully put the micro into programming mode the ONLY the blue status illumination of the touch pad will be ON. -> Now you can access and upload to the device using your preferred tool (Atom IDE, ESPtool, Arduino.. etc) Remember that the flashing mode MUST BE DOUT as it is for ALL devices on which Tasmota is flashed! Reference ~ https://github.com/EphemeralPersistence/Sonoff-Tasmota/wiki","title":"KingArt-N1 - Touch Light Light Switch"},{"location":"devices/KingArt/#kingart-n1-touch-light-light-switch","text":"This is a relatively cheap Premium glass fronted touch panel, looks clean and minimal when installed too. Table Of Contents: * Device Features * * Breakdown * * Capacitive Touch IC * Re-Programming * * Tools * * Setup * * Programming Mode * Reference","title":"KingArt-N1 - Touch Light Light Switch"},{"location":"devices/KingArt/#device-features","text":"ESP8285 micro Blue status LED (micro controlled) Separate touch IC controlled switch status indicators (blue and red) Confirmed 10A/250VAC mains relay -- Image: The 1 Gang Touch Panel, featuring the glass front (protective plastic film still on)","title":"Device Features"},{"location":"devices/KingArt/#breakdown","text":"Whats in the package... This looks like a reasonably simple setup. Removing the front glass panel you have access to the main control PCB. This holds the ESP8285 micro-controller and accompanying guff. I've worked through mapping most of the pins of interest - notes are in the images below. The control board runs off a 5V fed from the Power-Relay board at the read of the unit - a 3v3 reg is the control board for all the logic. The back of the control board has the touch controller and the 8way header to the Power-Relay board. There are only touch pads on the back of the control board as a means to interface with the microcontroller. There is no SonOff type programming header arrangement. , see Re-Programming . Control and Interface PCB Sorry for the horrible pics.. will replace Some Application-Interesting Pin Allocations *Trace for the King Art Switch with 2 (Touch-)Button is confirmed - works well with this Parameters The Power-Relay board is reasonably simple as well. This board, being a 1-gang switch, only has a single relay - but the PCB is set out for 3 (again, see images for trace and pin notes ). Power-Relay PCB","title":"Breakdown"},{"location":"devices/KingArt/#capacitive-touch-ic","text":"This board uses a dedicated capacitive touch control IC. Something interesting, that this IC manages touch switching as well a red and blue touch status LEDs for each of the touch pads that it services as the buttons. The IC illuminates a diffuser block over a 'button', indicating: * Blue : when Idle - button state is 'OFF' * Red+Blue : when Active - button state is 'ON' The TW8001 is also linked to a red error indicator led on the front of the Control Board - it is co-located above the EPS8285 microcontroller's Blue status indicator. This appears to be used by the Touch IC to indicate its own state information * eg, if the touch is held for +30s the touch shows an error state (red LED) and resets - useful if you replace the front panel and it needs to recalibrate. With regard to interfacing with the microcontroller, this device seems function with GPIO-friendly pin state for the capacitive button state reporting. Here is the only information I have been able to find on this device at the time of this investigation : TechWave - TW8001 . It does have much (or: any) in way of public datasheets. If anyone finds a datasheet please link it here!","title":"Capacitive Touch IC"},{"location":"devices/KingArt/#re-programming","text":"","title":"Re-Programming"},{"location":"devices/KingArt/#tools","text":"You shall need something in way of the following: (or whatever works for you, this is just my setup) * A USB-TTL adapter (TTL, 3V3.. something also with a 3V3 source) * Some leads * A soldering iron (solder, bits.. etc) - I'm going to assume you know how/what to do with this.","title":"Tools"},{"location":"devices/KingArt/#setup","text":"(This is my setup) USB-TTL | Lead | Board 3V3 Red 3v3 TXD White RX RXD Grey TX GND Black GND NNB : DO NOT USE or CONNECT THE 5V ever..","title":"Setup"},{"location":"devices/KingArt/#programming-mode","text":"Before you can program the board you have to start the ESP8285 micro in Programming Mode. This is important. Remember we soldered the blue lead to the board at (SW) - you will use this to force the micro to the required mode on startup. (you can only do this on startup) Entering Programming Mode: * Remove power from the board * Short the blue lead (SW) to ground (use a ground pad on the board or on your programmer) * NOW: Apply power. You can remove the short to ground after a second or two.","title":"Programming Mode"},{"location":"devices/KingArt/#reference","text":"https://github.com/EphemeralPersistence/Sonoff-Tasmota/wiki","title":"Reference"},{"location":"devices/KingArts-touch-Dimmer/","text":"On AliExpress you can buy a wifi dimmer for mains voltage (110 or 220V) It's a brandles dimmer, but can be found here: AliExpress page It comes in a couple of forms, but sinds I live in Holland, I chose the EU style, single gang, 220V, White edition. It has a glass front plate with 3 proximity/touch switches (On/Off, dimm up & dimm down) and a wifi indicator LED. The inside houses 2 PCB's; a power board and a control board: The control board: There are two main chips on board: An ESP8266 and a Nuvoton n76e003at20 The Nuvoton will do the switch side of it all, the ESP communication. The mains board: For flashing, we only need the control board. Solder small wires to the pads as marked on the picture: 3.3V GND RX TX Sw (gpio0) Solder 'Res1' to GND Note that the silkscreen on this board has TX and RX wrong. Now use a USB to serial adapter to connect the wires. Use a 3.3V board, NOT 5V, this will destroy the ESP chip on the board! Connect: GND to GND 3.3V to 3.3V RX to RX (due to the fact the silkscreen is wrong, otherwise, RX connects to TX and vice versa) TX to TX SW to GND -- only durning power up, to put the ESP in programming mode. From here the upload is the same as for all other Tasmota devices. See the upload page for detailed info. After the upload was successful, unplug the device from the serial adapter. You can now desolder all the connections you have made earlier. Also remove the wire between RES1 and GND. Then plug the board back in its housing. Be careful with the connector on the underside of the board. Line up the pins with te header and lightly press it in its place. Connecting to mains installation: ~ WARNING! THIS PROJECT INVOLVES WORKING WITH HIGH VOLTAGE AND YOU COULD KILL YOURSELF AND/OR SET YOUR HOUSE ON FIRE. Connect your light to the dimmer according the manual. Keep in mind, the dimmer itself needs a Neutral wire as well. If you replace an existing switch or dimmer, it can be that you need to run an extra neutral wire. First connection ~ When you first power up the dimmer switch, it comes up in AccesPoint mode. Follow the instructions here Set correct module type ~ Once you have all connected, you should go to the configuration page of the Tasmota Dimmer. Go to your browser and fill in the IP address. Then go to 'Configuration' and then to 'Configure Module'. From the drop down menu select module 58: PS-16-DZ. Then hit Save. The module will restart and you are done! You can now toggle the light and use the slider to dimm the lights from the tasmota webpage. Or better, use your favorite domotica software to control it via MQTT.","title":"KingArts touch Dimmer"},{"location":"devices/KingArts-touch-Dimmer/#connecting-to-mains-installation","text":"WARNING! THIS PROJECT INVOLVES WORKING WITH HIGH VOLTAGE AND YOU COULD KILL YOURSELF AND/OR SET YOUR HOUSE ON FIRE. Connect your light to the dimmer according the manual. Keep in mind, the dimmer itself needs a Neutral wire as well. If you replace an existing switch or dimmer, it can be that you need to run an extra neutral wire.","title":"Connecting to mains installation:"},{"location":"devices/KingArts-touch-Dimmer/#first-connection","text":"When you first power up the dimmer switch, it comes up in AccesPoint mode. Follow the instructions here","title":"First connection"},{"location":"devices/KingArts-touch-Dimmer/#set-correct-module-type","text":"Once you have all connected, you should go to the configuration page of the Tasmota Dimmer. Go to your browser and fill in the IP address. Then go to 'Configuration' and then to 'Configure Module'. From the drop down menu select module 58: PS-16-DZ. Then hit Save. The module will restart and you are done! You can now toggle the light and use the slider to dimm the lights from the tasmota webpage. Or better, use your favorite domotica software to control it via MQTT.","title":"Set correct module type"},{"location":"devices/Kohree-VHP560-Smart-Light-Compatible%2C-RGBCW-Wi-Fi-LED-Bulb-A19/","text":"Kohree VHP560 Smart Light - A19 RGBCW Wi-Fi LED Bulb Easily flashed OTA using Tuya-Convert (OTA flashable as of Sept. 29, 2019, recent purchase). GPIO4 = PWM1 GPIO5 = PWM5 GPIO12 = PWM2 GPIO13 = PWM4 GPIO14 = PWM3","title":"Kohree VHP560 Smart Light Compatible, RGBCW Wi Fi LED Bulb A19"},{"location":"devices/LC-Technology-WiFi-Relay/","text":"LC Technology WiFi Relay - Single Relay ~ The LC Technology relay devices use GPIO1 and GPIO3 for the serial communications used to control the relays. You do not need to specify these in the template. SerialSend uses these standard serial communications GPIO by default. In order to use LC Technology WiFi Relay for 1 relay version: Set module to Generic (18) (in module configuration and click save) Set D3 GPIO0 as Relay1 (21) (in module configuration and click save) Disable SerialLog (type seriallog 0 in the Tasmota console) Add the following rules typing in the console: Rule1 on System#Boot do Backlog Baudrate 9600; SerialSend5 0 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon Enable the rule (type rule1 1 in the Tasmota console) Note: If you use LC Technology v1.2 and this rule does not work, try to use 115200 baudrate Note: If that doesn't work for you, you may find that using Power1#Boot as the event to trigger the baud rate setting (instead of System#Boot ) works, as it did for me. So the alternate rule is: on Power1#Boot do Backlog Baudrate 9600; SerialSend5 0 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon LC Technology WiFi Relay - Dual Relay (note, older versions of this board used a baud rate of 9600, so if 115200 doesn't work, try 9600) ~ To configure an LC Technology ESP8266 Relay X2, use the following settings... Set module to Generic (in module configuration and click save) Set GPIO0 and GPIO2 as Relay1 and Relay 2 (in module configuration and click save) Disable SerialLog (type seriallog 0 in the Tasmota console) Add the following rules typing in the Tasmota console: Rule1 on System#Boot do Backlog Baudrate 9600; SerialSend5 0 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon on Power2#State=1 do SerialSend5 A00201A3 endon on Power2#State=0 do SerialSend5 A00200A2 endon Enable the rule (type rule1 1 in the Tasmota console) LC Technology WiFi Relay - Quad Relay (note, older versions of this board used a baud rate of 9600, so if 115200 doesn't work, try 9600) ~ Note: The template provided below did not work on an ESP-01 running Tasmota 8.1.0. It was necessary to manually enter the template in the Configure Template menu. In configuration open Configure Other paste this template and select activate {\"NAME\":\"LC Technology 4CH Relay\",\"GPIO\":[52,255,17,255,255,255,255,255,21,22,23,24,255],\"FLAG\":0,\"BASE\":18} Open Configure Module and set GPIO0, GPIO2, GPIO4 and GPIO5 as Relay1, Relay2, Relay3 and Relay4. Click Save. Disable SerialLog (type seriallog 0 in the Tasmota console) Enter this command in console (configure the 1st rule) Rule1 on System#Boot do Backlog Baudrate 9600; SerialSend5 0 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon on Power2#State=1 do SerialSend5 A00201A3 endon on Power2#State=0 do SerialSend5 A00200A2 endon on Power3#State=1 do SerialSend5 A00301A4 endon on Power3#State=0 do SerialSend5 A00300A3 endon on Power4#State=1 do SerialSend5 A00401A5 endon on Power4#State=0 do SerialSend5 A00400A4 endon Enable the rule (type rule1 1 in the Tasmota console) LC Technology WiFi Relay X2 with Nuvoton N76E003AT20 ~ Note: This version of the board has the Nuvoton N76E003AT20 as its host microcontroller instead of STC15F104W. This device requires a special configuration for it to start listening to serial commands. Use the following device template, configureable in Configure Other : {\"NAME\":\"LC-ESP01-2R-5V\",\"GPIO\":[0,148,0,149,0,0,0,0,21,22,0,0,0],\"FLAG\":0,\"BASE\":18} Add the following rules: on System#Boot do Backlog Baudrate 115200 on SerialReceived#Data=41542B5253540D0A do SerialSend5 5749464920434f4e4e45435445440a5749464920474f542049500a41542b4349504d55583d310a41542b4349505345525645523d312c383038300a41542b43495053544f3d333630 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon on Power2#State=1 do SerialSend5 A00201A3 endon on Power2#State=0 do SerialSend5 A00200A2 endon Here's what the above code does line per line: Sets the serial baud rate to 115200 (this seems to be the default for the Nuvoton LCTech Relay) This sends a certain stream of serial messages (in hex) below after receiving AT+RST (41542B5253540D0A in hex) from the NUVOTON devices. This message seems to make the NUVOTON enter listening mode. The long stream of hex messages for sending is equivalent to the ff. key in ASCII: ```WIFI CONNECTED WIFI GOT IP AT+CIPMUX=1 AT+CIPSERVER=1,8080 AT+CIPSTO=360 * The PowerX # State = xxx ... messages are triggers to send serial messages to the NUVOTON chip . Do not forget to enable the rule . After the device receives the bypass key , it wouldn ' t immediately respond to commands . The ESP has to wait for the following return messages echoed back to Serial first : AT+CIPMUX=1 AT+CIPSERVER=1,8080 AT+CIPSTO=360 After these messages are sent back by Nuvoton to the ESP , the green LED beside the green LED will start blinking once a second . From here you can verify that the relay indeed starts to receive commands from the ESP . ## LC Technology WiFi Relay X4 with Nuvoton N76E003AT20 Note : This version of the board has the Nuvoton N76E003AT20 as its host microcontroller instead of STC15F104W . Becareful , not working with Nuvoton MS51FB9AE . Same special configuration than with X2 relay version with Nuvoton N76E003AT20 . Use the following device template , configureable in ` Configure Other ` : {\"NAME\":\"LC-ESP01-4R-12V\",\"GPIO\":[0,148,0,149,0,0,0,0,21,22,23,24,0],\"FLAG\":0,\"BASE\":18} Add the following rules: Rule1 on System#Boot do Backlog Baudrate 115200 on SerialReceived#Data=41542B5253540D0A do SerialSend5 5749464920434f4e4e45435445440a5749464920474f542049500a41542b4349504d55583d310a41542b4349505345525645523d312c383038300a41542b43495053544f3d333630 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon on Power2#State=1 do SerialSend5 A00201A3 endon on Power2#State=0 do SerialSend5 A00200A2 endon on Power3#State=1 do SerialSend5 A00301A4 endon on Power3#State=0 do SerialSend5 A00300A3 endon on Power4#State=1 do SerialSend5 A00401A5 endon on Power4#State=0 do SerialSend5 A00400A4 endon Rule1 1 Activate the rules: Rule1 1 ``` Beware of counterfeit modules ~ If your board just continuously flashes its led when powered on and no esp-01 is entered, the onboard STC15F104W needs to be programmed! For more details ( link ) Additionally, once programmed, you may also have to remove r4. Some issues exist where r3 and r4 are swapped, but just removing r4 works. ESP-01S 5V Relay Module V1.0 Relay ~ This board will not boot unless R2 is removed or the easier hardware fix below is carried out. A template is available ([here] (https://templates.blakadder.com/ESP-01S-Relay-v1.html)) Easier hardware fix ~ This is an easier fix for the ESP-01S relay v1.0 board, which does not require pcb cuts or resistor desoldering, just a 10K resistor soldered as in image: this mod prevents the relay flicker, and connects ch_pd, too How to use with up to 12V power supply ~ LC Technology WiFi Relay use CJT1117B linear regulator which support input power up to 12V. It is ok for ESP-01 and N76E003, but not for relay. Relay connected without any voltage regulator to input power directly. The easier way to replace existing relay. Part number for 12V relay is SRD-12VDC-SLC. You can use similar analogs for 6V and 9V.","title":"LC Technology WiFi Relay"},{"location":"devices/LC-Technology-WiFi-Relay/#lc-technology-wifi-relay-single-relay","text":"The LC Technology relay devices use GPIO1 and GPIO3 for the serial communications used to control the relays. You do not need to specify these in the template. SerialSend uses these standard serial communications GPIO by default. In order to use LC Technology WiFi Relay for 1 relay version: Set module to Generic (18) (in module configuration and click save) Set D3 GPIO0 as Relay1 (21) (in module configuration and click save) Disable SerialLog (type seriallog 0 in the Tasmota console) Add the following rules typing in the console: Rule1 on System#Boot do Backlog Baudrate 9600; SerialSend5 0 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon Enable the rule (type rule1 1 in the Tasmota console) Note: If you use LC Technology v1.2 and this rule does not work, try to use 115200 baudrate Note: If that doesn't work for you, you may find that using Power1#Boot as the event to trigger the baud rate setting (instead of System#Boot ) works, as it did for me. So the alternate rule is: on Power1#Boot do Backlog Baudrate 9600; SerialSend5 0 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon","title":"LC Technology WiFi Relay - Single Relay"},{"location":"devices/LC-Technology-WiFi-Relay/#lc-technology-wifi-relay-dual-relay-note-older-versions-of-this-board-used-a-baud-rate-of-9600-so-if-115200-doesnt-work-try-9600","text":"To configure an LC Technology ESP8266 Relay X2, use the following settings... Set module to Generic (in module configuration and click save) Set GPIO0 and GPIO2 as Relay1 and Relay 2 (in module configuration and click save) Disable SerialLog (type seriallog 0 in the Tasmota console) Add the following rules typing in the Tasmota console: Rule1 on System#Boot do Backlog Baudrate 9600; SerialSend5 0 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon on Power2#State=1 do SerialSend5 A00201A3 endon on Power2#State=0 do SerialSend5 A00200A2 endon Enable the rule (type rule1 1 in the Tasmota console)","title":"LC Technology WiFi Relay - Dual Relay (note, older versions of this board used a baud rate of 9600, so if 115200 doesn't work, try 9600)"},{"location":"devices/LC-Technology-WiFi-Relay/#lc-technology-wifi-relay-quad-relay-note-older-versions-of-this-board-used-a-baud-rate-of-9600-so-if-115200-doesnt-work-try-9600","text":"Note: The template provided below did not work on an ESP-01 running Tasmota 8.1.0. It was necessary to manually enter the template in the Configure Template menu. In configuration open Configure Other paste this template and select activate {\"NAME\":\"LC Technology 4CH Relay\",\"GPIO\":[52,255,17,255,255,255,255,255,21,22,23,24,255],\"FLAG\":0,\"BASE\":18} Open Configure Module and set GPIO0, GPIO2, GPIO4 and GPIO5 as Relay1, Relay2, Relay3 and Relay4. Click Save. Disable SerialLog (type seriallog 0 in the Tasmota console) Enter this command in console (configure the 1st rule) Rule1 on System#Boot do Backlog Baudrate 9600; SerialSend5 0 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon on Power2#State=1 do SerialSend5 A00201A3 endon on Power2#State=0 do SerialSend5 A00200A2 endon on Power3#State=1 do SerialSend5 A00301A4 endon on Power3#State=0 do SerialSend5 A00300A3 endon on Power4#State=1 do SerialSend5 A00401A5 endon on Power4#State=0 do SerialSend5 A00400A4 endon Enable the rule (type rule1 1 in the Tasmota console)","title":"LC Technology WiFi Relay - Quad Relay (note, older versions of this board used a baud rate of 9600, so if 115200 doesn't work, try 9600)"},{"location":"devices/LC-Technology-WiFi-Relay/#lc-technology-wifi-relay-x2-with-nuvoton-n76e003at20","text":"Note: This version of the board has the Nuvoton N76E003AT20 as its host microcontroller instead of STC15F104W. This device requires a special configuration for it to start listening to serial commands. Use the following device template, configureable in Configure Other : {\"NAME\":\"LC-ESP01-2R-5V\",\"GPIO\":[0,148,0,149,0,0,0,0,21,22,0,0,0],\"FLAG\":0,\"BASE\":18} Add the following rules: on System#Boot do Backlog Baudrate 115200 on SerialReceived#Data=41542B5253540D0A do SerialSend5 5749464920434f4e4e45435445440a5749464920474f542049500a41542b4349504d55583d310a41542b4349505345525645523d312c383038300a41542b43495053544f3d333630 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon on Power2#State=1 do SerialSend5 A00201A3 endon on Power2#State=0 do SerialSend5 A00200A2 endon Here's what the above code does line per line: Sets the serial baud rate to 115200 (this seems to be the default for the Nuvoton LCTech Relay) This sends a certain stream of serial messages (in hex) below after receiving AT+RST (41542B5253540D0A in hex) from the NUVOTON devices. This message seems to make the NUVOTON enter listening mode. The long stream of hex messages for sending is equivalent to the ff. key in ASCII: ```WIFI CONNECTED WIFI GOT IP AT+CIPMUX=1 AT+CIPSERVER=1,8080 AT+CIPSTO=360 * The PowerX # State = xxx ... messages are triggers to send serial messages to the NUVOTON chip . Do not forget to enable the rule . After the device receives the bypass key , it wouldn ' t immediately respond to commands . The ESP has to wait for the following return messages echoed back to Serial first : AT+CIPMUX=1 AT+CIPSERVER=1,8080 AT+CIPSTO=360 After these messages are sent back by Nuvoton to the ESP , the green LED beside the green LED will start blinking once a second . From here you can verify that the relay indeed starts to receive commands from the ESP . ## LC Technology WiFi Relay X4 with Nuvoton N76E003AT20 Note : This version of the board has the Nuvoton N76E003AT20 as its host microcontroller instead of STC15F104W . Becareful , not working with Nuvoton MS51FB9AE . Same special configuration than with X2 relay version with Nuvoton N76E003AT20 . Use the following device template , configureable in ` Configure Other ` : {\"NAME\":\"LC-ESP01-4R-12V\",\"GPIO\":[0,148,0,149,0,0,0,0,21,22,23,24,0],\"FLAG\":0,\"BASE\":18} Add the following rules: Rule1 on System#Boot do Backlog Baudrate 115200 on SerialReceived#Data=41542B5253540D0A do SerialSend5 5749464920434f4e4e45435445440a5749464920474f542049500a41542b4349504d55583d310a41542b4349505345525645523d312c383038300a41542b43495053544f3d333630 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon on Power2#State=1 do SerialSend5 A00201A3 endon on Power2#State=0 do SerialSend5 A00200A2 endon on Power3#State=1 do SerialSend5 A00301A4 endon on Power3#State=0 do SerialSend5 A00300A3 endon on Power4#State=1 do SerialSend5 A00401A5 endon on Power4#State=0 do SerialSend5 A00400A4 endon Rule1 1 Activate the rules: Rule1 1 ```","title":"LC Technology WiFi Relay X2 with Nuvoton N76E003AT20"},{"location":"devices/LC-Technology-WiFi-Relay/#beware-of-counterfeit-modules","text":"If your board just continuously flashes its led when powered on and no esp-01 is entered, the onboard STC15F104W needs to be programmed! For more details ( link ) Additionally, once programmed, you may also have to remove r4. Some issues exist where r3 and r4 are swapped, but just removing r4 works.","title":"Beware of counterfeit modules"},{"location":"devices/LC-Technology-WiFi-Relay/#esp-01s-5v-relay-module-v10-relay","text":"This board will not boot unless R2 is removed or the easier hardware fix below is carried out. A template is available ([here] (https://templates.blakadder.com/ESP-01S-Relay-v1.html))","title":"ESP-01S 5V Relay Module V1.0 Relay"},{"location":"devices/LC-Technology-WiFi-Relay/#easier-hardware-fix","text":"This is an easier fix for the ESP-01S relay v1.0 board, which does not require pcb cuts or resistor desoldering, just a 10K resistor soldered as in image: this mod prevents the relay flicker, and connects ch_pd, too","title":"Easier hardware fix"},{"location":"devices/LC-Technology-WiFi-Relay/#how-to-use-with-up-to-12v-power-supply","text":"LC Technology WiFi Relay use CJT1117B linear regulator which support input power up to 12V. It is ok for ESP-01 and N76E003, but not for relay. Relay connected without any voltage regulator to input power directly. The easier way to replace existing relay. Part number for 12V relay is SRD-12VDC-SLC. You can use similar analogs for 6V and 9V.","title":"How to use with up to 12V power supply"},{"location":"devices/LSC-Smart-Connect-Smart-Power-Plug/","text":"Simple somewhat compact WiFi controllable EU plug socket. Sold in the Netherlands by Action. Product ~ Internals ~ Inside the device is a Tuya TYWE2S. This device can be flashed using a software OTA hack using tuya-convert Flashing ~ Simply connect the (clearly labeled) 3v3, GND, TX, RX pins of the TYWE2S to the appropriate pins on your serial adapter and connect IO0 to GND to enter flashing mode. With the device connected and in flashing mode, create a backup of the factory firmware, erase the flash, and flash a tasmota firmware approximately as follows: esptool . py read_flash 0x000000 0x100000 image1M . bin esptool . py erase_flash esptool . py write_flash - fs 1 MB - fm dout 0x0 tasmota - lite . bin ` Configuration ~ \u26a0\ufe0f Warning! While the below configuration is correct and working, configuring a button on GPIO14 will make the device reset itself to the default Tasmota configuration after a number of seconds.","title":"LSC Smart Connect Smart Power Plug"},{"location":"devices/LSC-Smart-Connect-Smart-Power-Plug/#product","text":"","title":"Product"},{"location":"devices/LSC-Smart-Connect-Smart-Power-Plug/#internals","text":"Inside the device is a Tuya TYWE2S. This device can be flashed using a software OTA hack using tuya-convert","title":"Internals"},{"location":"devices/LSC-Smart-Connect-Smart-Power-Plug/#flashing","text":"Simply connect the (clearly labeled) 3v3, GND, TX, RX pins of the TYWE2S to the appropriate pins on your serial adapter and connect IO0 to GND to enter flashing mode. With the device connected and in flashing mode, create a backup of the factory firmware, erase the flash, and flash a tasmota firmware approximately as follows: esptool . py read_flash 0x000000 0x100000 image1M . bin esptool . py erase_flash esptool . py write_flash - fs 1 MB - fm dout 0x0 tasmota - lite . bin `","title":"Flashing"},{"location":"devices/LSC-Smart-Connect-Smart-Power-Plug/#configuration","text":"\u26a0\ufe0f Warning! While the below configuration is correct and working, configuring a button on GPIO14 will make the device reset itself to the default Tasmota configuration after a number of seconds.","title":"Configuration"},{"location":"devices/LeFun-SK2-Smart-Power-Strip/","text":"The LeFun SK2 has 4 mains power and 4 USB ports. Each mains power is independently controlled and the USB group is controllable via a solid state relay. The ESP8266 module inside is likely a TYWE3S by Tuya but I didn't open the case and use the tuya-convert tool to flash.","title":"LeFun SK2 Smart Power Strip"},{"location":"devices/Lingan-SWA1/","text":"Connection ~ Vcc - 3,3V TX - RX RX - TX GND - GND Additional Information ~ More Infos can be found here: Lingan SWA1 Plug in Wi-Fi Socket with MQTT (ESP8266) . Device Images ~ GPIO Config ~","title":"Lingan SWA1"},{"location":"devices/Lingan-SWA1/#connection","text":"Vcc - 3,3V TX - RX RX - TX GND - GND","title":"Connection"},{"location":"devices/Lingan-SWA1/#additional-information","text":"More Infos can be found here: Lingan SWA1 Plug in Wi-Fi Socket with MQTT (ESP8266) .","title":"Additional Information"},{"location":"devices/Lingan-SWA1/#device-images","text":"","title":"Device Images"},{"location":"devices/Lingan-SWA1/#gpio-config","text":"","title":"GPIO Config"},{"location":"devices/Luminea-ZX-2844-675/","text":"Luminea ZX-2844-* ~ also known as: * XS-RGBW-LedControl-V2.0.2 * JCD XS-RGBW sold by PEARL and amazon (i know know if they are available outside D-A-CH) * https://www.pearl.de/a-ZX2844-3103.shtml * https://www.amazon.de/Luminea-Zubeh%C3%B6r-Smarthome-LED-Strips-WLAN-Controller-spritzwassergesch%C3%BCtzt/dp/B074T11793 Hardware ~ There is a ESP8266EX sitting on the backside. 4 PWM outputs are connected to drive the 4 output channels (RGB + W). Red is on GPIO14 Green is on GPIO12 Blue is on GPIO5 White is on GPIO13 The pushbutton is GPIO13. Assign it to Button1 for local on/off control. You can configure it as a \"generic module\" And set the GPIO as follow: Function ESP8266 Pin Channel R GPIO 14 PWM1 G GPIO 12 PWM2 B GPIO 5 PWM3 W GPIO 0 PWM4 PushButton GPIO 13 Button1 There is an second version with a green PCB and different pinout: Function ESP8266 Pin Channel R GPIO 4 PWM1 G GPIO 12 PWM2 B GPIO 14 PWM3 W GPIO 5 PWM4 PushButton GPIO 0 Button1 Serial Connection ~ See the Hardware Preparation page for general instructions. The serial header (3.3V, RXD, TXD, GND) as well as GPIO0, GPIO2 and RESET (IO0, IO2, RST) are populated as test pads on the frontside of the PCB. You can easily add some solder to fix the wires during the flash process. To place the board into flashing mode, you will need to short IO0 to GND. This can remain shorted while flashing is in progress, but you will need to remove the short in order to boot the Tasmota firmware.","title":"Luminea ZX-2844-*"},{"location":"devices/Luminea-ZX-2844-675/#luminea-zx-2844-","text":"also known as: * XS-RGBW-LedControl-V2.0.2 * JCD XS-RGBW sold by PEARL and amazon (i know know if they are available outside D-A-CH) * https://www.pearl.de/a-ZX2844-3103.shtml * https://www.amazon.de/Luminea-Zubeh%C3%B6r-Smarthome-LED-Strips-WLAN-Controller-spritzwassergesch%C3%BCtzt/dp/B074T11793","title":"Luminea ZX-2844-*"},{"location":"devices/Luminea-ZX-2844-675/#hardware","text":"There is a ESP8266EX sitting on the backside. 4 PWM outputs are connected to drive the 4 output channels (RGB + W). Red is on GPIO14 Green is on GPIO12 Blue is on GPIO5 White is on GPIO13 The pushbutton is GPIO13. Assign it to Button1 for local on/off control. You can configure it as a \"generic module\" And set the GPIO as follow: Function ESP8266 Pin Channel R GPIO 14 PWM1 G GPIO 12 PWM2 B GPIO 5 PWM3 W GPIO 0 PWM4 PushButton GPIO 13 Button1 There is an second version with a green PCB and different pinout: Function ESP8266 Pin Channel R GPIO 4 PWM1 G GPIO 12 PWM2 B GPIO 14 PWM3 W GPIO 5 PWM4 PushButton GPIO 0 Button1","title":"Hardware"},{"location":"devices/Luminea-ZX-2844-675/#serial-connection","text":"See the Hardware Preparation page for general instructions. The serial header (3.3V, RXD, TXD, GND) as well as GPIO0, GPIO2 and RESET (IO0, IO2, RST) are populated as test pads on the frontside of the PCB. You can easily add some solder to fix the wires during the flash process. To place the board into flashing mode, you will need to short IO0 to GND. This can remain shorted while flashing is in progress, but you will need to remove the short in order to boot the Tasmota firmware.","title":"Serial Connection"},{"location":"devices/MagicHome-LED-strip-controller/","text":"MagicHome LED controllers (aka Flux-Led, aka Arilux AL-LC01) ~ Shopping Board is essentially a ESP-12S (or ESP-2M) with necessary voltage converters, little bit of flash, 3 or 4 MOSFETs to drive LED strip (depending on the model), connector for LED strip and optional IR receiver. Module is powered by 12V that is used to power LED strip as well. RGB models are declared as 144W, RGBW models as 192W. Module comes in (at least) 3 variants: - LC01: RGB, - LC02: RGBW and - LC03: RGB with IR receiver. - LC04: RGBW with IR receiver. - LC05: RGB with Screw-Headers. - LC06: RGBW/WW with Screw-Headers A different version of this controller with an ESP8285 is documented here Serial Connection ~ Board has RX, TX, GND and GPIO00 pads exposed on the bottom side of the PCB. You need to solder temporary wires those pads. You need to power the board while keeping it connected to the programmer. With all Sonoff boards that work with AC, this is a big no-no that will fry your programmer, your Sonoff and might even get you killed. In this case, you'd be dealing with 12V, so the only thing that matters is to connect the GND of your programmer to GND of the board before you supply the 12V. Not doing so might fry your board and/or programmer, but would definitely not hurt you. Steps used: 1. Connect your programmer to a breadboard and notice the locations of GND, TX and RX columns. 1. Open the MagicHome controller box and expose bottom side of PCB 1. Solder 4 jumper wires to 4 exposed pads. 1. FIRST connect GND to your programmer (and make sure they are connected well!) 1. Connect RX from the MagicHome to TX on the programmer. TX from the board goes to RX on the programmer. 1. Connect GPIO00 to GND (best to use same column on the breadboard) 1. Connect the 12V power supply to MagicHome. As GPIO00 is connected to GND, board will go into flash mode. Disconnect GPIO00 after few seconds. 1. Upload Tasmota like it would be any other board. 1. Once upload is complete, disconnect power from the MagicHome controller 1. Disconnect RX and TX and then only then GND. GND gets disconnected LAST. You can then connect the power back to the board and Tasmota should be running on it. Once you verify that board is up and you can access it over the Web, you can unsolder temporary wires and update subsequent firmware versions using OTA. Configuration ~ Some GPIO are preconfigured with the board: - GPIO05 - (PWM2) Green color on the led strip, first pin from the GND - GPIO14 - (PWM1) Red color on the LED strip, second pin from the GND - GPIO12 - (PWM3) Blue color on the LED strip, third pin from the GND For instructions to setup the 24 Button Remote visit the AL-LC04 device page Check this for Board Version 2.3 : #1867 Due to variants, you can configure: - GPIO04 - on non-IR boards, it's an open pin you can use for Onewire, button or something else. It might have pull-down resistor and/or bypass capacitor, so please take that into consideration. On IR-enabled boards, IR receiver is connected to this pin, so you can use IRRecv as functionality. - GPIO13 - This pin is not used on RGB board (so you'll leave it as \"None\"), but on RGBW, it's driving another channel (cold white or warm white) for LED strip. Variant without Rx/Tx pads: ~ - Using the IRrecv (IR Remote) feature ~ If you have a variant with an IR Remote (as per the opening picture), you can use the new rule command to make the remote buttons change the light levels. For example, this rule allows me to turn it on and off, change the brightness, and turn it on to full white: rule1 on IrReceived#Data=0xFFF807 do power OFF endon on IrReceived#Data=0xFFB04F do WAKEUP endon on IrReceived#Data=0xFF906F do dimmer + endon on IrReceived#Data=0xFFB847 do dimmer - endon on IrReceived#Data=0xFFA857 do color #000000ff endon Full Set of rules for IR remote ~ Each rule can only be 511 characters long, some of the colors below use the built in predefined shortcut color numbers. rule1 on IrReceived # Data = 0 xFFF807 do power OFF endon on IrReceived # Data = 0 xFFB04F do WAKEUP endon on IrReceived # Data = 0 xFF906F do dimmer + endon on IrReceived # Data = 0 xFFB847 do dimmer - endon on IrReceived # Data = 0 xFFA857 do color 12 endon on IrReceived # Data = 0 xFF9867 do color 1 endon on IrReceived # Data = 0 xFFD827 do color 2 endon on IrReceived # Data = 0 xFF8877 do color 3 endon on IrReceived # Data = 0 xFF28D7 do color # 007 FFF endon on IrReceived # Data = 0 xFF38C7 do color 4 endon rule2 on IrReceived # Data = 0 xFFE817 do color # FF3F00 endon on IrReceived # Data = 0 xFF48B7 do color # 00 FF3F endon on IrReceived # Data = 0 xFF6897 do color # 3 F00FF endon on IrReceived # Data = 0 xFF02FD do color 4 endon on IrReceived # Data = 0 xFF32CD do color # 00 FFBF endon on IrReceived # Data = 0 xFF20DF do color # 7 F00FF endon on IrReceived # Data = 0 xFF50AF do color # FF7F00 endon on IrReceived # Data = 0 xFF7887 do color # 00 BFFF endon on IrReceived # Data = 0 xFF708F do color # FF00FF endon on IrReceived # Data = 0 xFFF00F do color # FF003F endon rule3 on IrReceived # Data = 0 xFF00FF do scheme 4 endon on IrReceived # Data = 0 xFF58A7 do scheme 3 endon on IrReceived # Data = 0 xFF30CF do scheme 2 endon on IrReceived # Data = 0 xFFB24D do backlog BlinkCount 600 ; Power 3 endon After setting the rules you need to activate them with the following: rule1 1 rule2 1 rule3 1 The hex codes for the \"Data\" value come from the data tag when looking at the JSON sent via MQTT. You can also view this data on the Tasmota console screen. From here you can program it to do what ever you want. See here for more details: devices/Rules","title":"MagicHome LED strip controller"},{"location":"devices/MagicHome-LED-strip-controller/#magichome-led-controllers-aka-flux-led-aka-arilux-al-lc01","text":"Shopping Board is essentially a ESP-12S (or ESP-2M) with necessary voltage converters, little bit of flash, 3 or 4 MOSFETs to drive LED strip (depending on the model), connector for LED strip and optional IR receiver. Module is powered by 12V that is used to power LED strip as well. RGB models are declared as 144W, RGBW models as 192W. Module comes in (at least) 3 variants: - LC01: RGB, - LC02: RGBW and - LC03: RGB with IR receiver. - LC04: RGBW with IR receiver. - LC05: RGB with Screw-Headers. - LC06: RGBW/WW with Screw-Headers A different version of this controller with an ESP8285 is documented here","title":"MagicHome LED controllers (aka Flux-Led, aka Arilux AL-LC01)"},{"location":"devices/MagicHome-LED-strip-controller/#serial-connection","text":"Board has RX, TX, GND and GPIO00 pads exposed on the bottom side of the PCB. You need to solder temporary wires those pads. You need to power the board while keeping it connected to the programmer. With all Sonoff boards that work with AC, this is a big no-no that will fry your programmer, your Sonoff and might even get you killed. In this case, you'd be dealing with 12V, so the only thing that matters is to connect the GND of your programmer to GND of the board before you supply the 12V. Not doing so might fry your board and/or programmer, but would definitely not hurt you. Steps used: 1. Connect your programmer to a breadboard and notice the locations of GND, TX and RX columns. 1. Open the MagicHome controller box and expose bottom side of PCB 1. Solder 4 jumper wires to 4 exposed pads. 1. FIRST connect GND to your programmer (and make sure they are connected well!) 1. Connect RX from the MagicHome to TX on the programmer. TX from the board goes to RX on the programmer. 1. Connect GPIO00 to GND (best to use same column on the breadboard) 1. Connect the 12V power supply to MagicHome. As GPIO00 is connected to GND, board will go into flash mode. Disconnect GPIO00 after few seconds. 1. Upload Tasmota like it would be any other board. 1. Once upload is complete, disconnect power from the MagicHome controller 1. Disconnect RX and TX and then only then GND. GND gets disconnected LAST. You can then connect the power back to the board and Tasmota should be running on it. Once you verify that board is up and you can access it over the Web, you can unsolder temporary wires and update subsequent firmware versions using OTA.","title":"Serial Connection"},{"location":"devices/MagicHome-LED-strip-controller/#configuration","text":"Some GPIO are preconfigured with the board: - GPIO05 - (PWM2) Green color on the led strip, first pin from the GND - GPIO14 - (PWM1) Red color on the LED strip, second pin from the GND - GPIO12 - (PWM3) Blue color on the LED strip, third pin from the GND For instructions to setup the 24 Button Remote visit the AL-LC04 device page Check this for Board Version 2.3 : #1867 Due to variants, you can configure: - GPIO04 - on non-IR boards, it's an open pin you can use for Onewire, button or something else. It might have pull-down resistor and/or bypass capacitor, so please take that into consideration. On IR-enabled boards, IR receiver is connected to this pin, so you can use IRRecv as functionality. - GPIO13 - This pin is not used on RGB board (so you'll leave it as \"None\"), but on RGBW, it's driving another channel (cold white or warm white) for LED strip.","title":"Configuration"},{"location":"devices/MagicHome-LED-strip-controller/#variant-without-rxtx-pads","text":"-","title":"Variant without Rx/Tx pads:"},{"location":"devices/MagicHome-LED-strip-controller/#using-the-irrecv-ir-remote-feature","text":"If you have a variant with an IR Remote (as per the opening picture), you can use the new rule command to make the remote buttons change the light levels. For example, this rule allows me to turn it on and off, change the brightness, and turn it on to full white: rule1 on IrReceived#Data=0xFFF807 do power OFF endon on IrReceived#Data=0xFFB04F do WAKEUP endon on IrReceived#Data=0xFF906F do dimmer + endon on IrReceived#Data=0xFFB847 do dimmer - endon on IrReceived#Data=0xFFA857 do color #000000ff endon","title":"Using the IRrecv (IR Remote) feature"},{"location":"devices/MagicHome-LED-strip-controller/#full-set-of-rules-for-ir-remote","text":"Each rule can only be 511 characters long, some of the colors below use the built in predefined shortcut color numbers. rule1 on IrReceived # Data = 0 xFFF807 do power OFF endon on IrReceived # Data = 0 xFFB04F do WAKEUP endon on IrReceived # Data = 0 xFF906F do dimmer + endon on IrReceived # Data = 0 xFFB847 do dimmer - endon on IrReceived # Data = 0 xFFA857 do color 12 endon on IrReceived # Data = 0 xFF9867 do color 1 endon on IrReceived # Data = 0 xFFD827 do color 2 endon on IrReceived # Data = 0 xFF8877 do color 3 endon on IrReceived # Data = 0 xFF28D7 do color # 007 FFF endon on IrReceived # Data = 0 xFF38C7 do color 4 endon rule2 on IrReceived # Data = 0 xFFE817 do color # FF3F00 endon on IrReceived # Data = 0 xFF48B7 do color # 00 FF3F endon on IrReceived # Data = 0 xFF6897 do color # 3 F00FF endon on IrReceived # Data = 0 xFF02FD do color 4 endon on IrReceived # Data = 0 xFF32CD do color # 00 FFBF endon on IrReceived # Data = 0 xFF20DF do color # 7 F00FF endon on IrReceived # Data = 0 xFF50AF do color # FF7F00 endon on IrReceived # Data = 0 xFF7887 do color # 00 BFFF endon on IrReceived # Data = 0 xFF708F do color # FF00FF endon on IrReceived # Data = 0 xFFF00F do color # FF003F endon rule3 on IrReceived # Data = 0 xFF00FF do scheme 4 endon on IrReceived # Data = 0 xFF58A7 do scheme 3 endon on IrReceived # Data = 0 xFF30CF do scheme 2 endon on IrReceived # Data = 0 xFFB24D do backlog BlinkCount 600 ; Power 3 endon After setting the rules you need to activate them with the following: rule1 1 rule2 1 rule3 1 The hex codes for the \"Data\" value come from the data tag when looking at the JSON sent via MQTT. You can also view this data on the Tasmota console screen. From here you can program it to do what ever you want. See here for more details: devices/Rules","title":"Full Set of rules for IR remote"},{"location":"devices/MagicHome-with-ESP8285/","text":"Yet another MagicHome RGB controller. I specifically had this one . Aside from it going 9-28V, there are no other external model numbers etc, however opening it up revealed a very different configuration inside, using an ESP8285 chip directly on the board. (Right click and view the original image to see the full size image for all images below) Identifying this board ~ Looking closely you can see it's an ESP8285, on the main board, it has the part number: ZJ-WFMN-A V1.1 , ZJ-WFMN-B V1.1 , ZJ-WFMN-C V1.1 , or ZJ-WFMN-D V1.0 Arilux devices ~ The devices are similar to the Arilux devices. Here is an overview: Model Color Support Voltages (sometimes) Remote PCB part number Link LC01 RGB 5-28V None ZJ-WFMN-A V1.1 [Banggood][LC01-banggood] LC02 RGBW 9-12V (5-28V) None ZJ-WFMN-B V1.1 [Banggood][LC02-banggood] LC03 RGB 5-28V IR ZJ-WFMN-A V1.1 [Banggood][LC03-banggood] LC04 RGBW 9-12V (5-28V) IR ZJ-WFMN-A V1.1 [Banggood][LC04-banggood] LC08 RGBWW/RGBWC 5-28V None [Banggood][LC08-banggood] LC09 RGB 5-28V RF [Banggood][LC09-banggood] LC10 RGBW 9-28V RF [Banggood][LC10-banggood] LC11 RGBWW/RGBWC 9-28V RF ZJ-WFMN-D V1.0 [Banggood][LC11-banggood] Flashing ~ I found that on the back it has pads to solder to so you can flash it. The IO0 port is GPIO0 that needs to be pulled to ground when powered on for flashing (as per all ESP devices). I soldered cables to each of these. Note that some are very close to other pads, so be careful. If you want to avoid soldering, also pogo pins work well with the pads. Template configuration ~ Arilux LC01 (ZJ-WFMN-A V1.1) Automatic configuration: Field Value Function Module type 37 Arilux LC01 Module type Manual configuration: Field Value Function Module type 18 Generic Module type GPIO5 37 PWM1 RED GPIO12 38 PWM2 GREEN GPIO13 39 PWM3 BLUE Arilux LC02 (ZJ-WFMN-B V1.1) Field Value Function Module type 18 Generic Module type GPIO5 38 PWM2 GREEN GPIO12 39 PWM3 BLUE GPIO13 40 PWM4 WHITE GPIO14 37 PWM1 RED Arilux LC03 (ZJ-WFMN-A V1.1) Field Value Function Module type 18 Generic Module type GPIO4 51 IRRecv IR Remote GPIO5 37 PWM1 RED GPIO12 38 PWM2 GREEN GPIO13 39 PWM3 BLUE Arilux LC04 (ZJ-WFMN-A V1.1) Field Value Function Module type 18 Generic Module type GPIO4 51 IRRecv IR Remote (optional, view console for debugging!) GPIO5 38 PWM2 BLUE GPIO12 37 PWM1 RED GPIO13 39 PWM3 GREEN GPIO15 40 PWM4 WHITE Arilux LC11 (ZJ-WFMN-D V1.0) Field Value Function Module type 18 Generic Module type GPIO4 147 ALux IrRcv GPIO5 40 PWM4 COLD WHITE GPIO12 38 PWM2 GREEN GPIO13 39 PWM3 BLUE GPIO14 37 PWM1 RED GPIO15 41 PWM5 WARM WHITE GPIO16 159 ALux IrSel With all that done, one of the critical things I needed to do so I could set the colors was to run the command to set SetOption15 1 . After that it is possible to test the lights functionality, e.g. with the command Color #ff0000ff . RF control ~ If you have an RF variant, you will want to configure the GPIOs like this: { \"MagicHome RF\", // Magic Home RF (ESP8266) - (Arilux LC10) GPIO_USER, // GPIO00 Optional Button GPIO_USER, // GPIO01 Serial RXD and Optional sensor GPIO_LED1_INV, // GPIO02 Blue onboard LED (optional) GPIO_USER, // GPIO03 Serial TXD and Optional sensor0 GPIO_ARIRFRCV, // GPIO04 RF receiver input (New Tasmota ALux IrRcv 147) GPIO_PWM2, // GPIO05 RGB LED Green 0, 0, 0, 0, 0, 0, // Flash connection GPIO_PWM3, // GPIO12 RGB LED Blue GPIO_PWM4, // GPIO13 RGBW LED White GPIO_PWM1, // GPIO14 RGB LED Red GPIO_LED2_INV, // GPIO15 RF receiver control (New Tasmota ALuxIrSel 159) 0, 0 }, Tasmota template '{\"NAME\":\"MagicHome RGBW RF\",\"GPIO\":[0,0,56,0,147,38,0,0,39,40,37,159,0],\"FLAG\":0,\"BASE\":18}' or like this: { \"MagicHome RF\", // Magic Home RF (ESP8285) - (IRrecv) GPIO_USER, // GPIO00 Optional Button GPIO_USER, // GPIO01 Serial RXD and Optional sensor GPIO_LED1_INV, // GPIO02 Blue onboard LED (not soldered) GPIO_USER, // GPIO03 Serial TXD and Optional sensor0 GPIO_IRRECV, // GPIO04 IR receiver input GPIO_PWM1, // GPIO05 RGB LED Green 0, 0, 0, 0, 0, 0, // Flash connection GPIO_PWM2, // GPIO12 RGB LED Blue GPIO_PWM3, // GPIO13 RGBW LED White 0, 0, 0 }, After choosing the correct module type in your Tasmota configuration, press a key on the remote after boot for the device to learn your code. No need for the below rules for the RF varient Full Set of rules for IR remote ~ Each rule can only be 511 characters long, some of the colors below use the built in predefined shortcut color numbers. Rule1 On IrReceived # Data = 0 x00FF906F Do Dimmer + EndOn On IrReceived # Data = 0 x00FF9867 Do Color2 1 EndOn On IrReceived # Data = 0 x00FFE817 Do HSBColor1 13 EndOn On IrReceived # Data = 0 x00FF02FD Do HSBColor1 23 EndOn On IrReceived # Data = 0 x00FF50AF Do HSBColor1 33 EndOn On IrReceived # Data = 0 x00FF38C7 Do HSBColor1 43 EndOn On IrReceived # Data = 0 x00FFB847 Do Dimmer - EndOn On IrReceived # Data = 0 x00FFD827 Do Color2 2 EndOn On IrReceived # Data = 0 x00FF48B7 Do HSBColor1 140 EndOn On IrReceived # Data = 0 x00FF32CD Do HSBColor1 160 EndOn Rule2 On IrReceived # Data = 0 x00FF7887 Do HSBColor1 180 EndOn On IrReceived # Data = 0 x00FF28D7 Do HSBColor1 200 EndOn On IrReceived # Data = 0 x00FFF807 Do Power 0 EndOn On IrReceived # Data = 0 x00FF8877 Do Color2 3 EndOn On IrReceived # Data = 0 x00FF6897 Do HSBColor1 260 EndOn On IrReceived # Data = 0 x00FF20DF Do HSBColor1 280 EndOn On IrReceived # Data = 0 x00FF708F Do HSBColor1 300 EndOn On IrReceived # Data = 0 x00FFF00F Do HSBColor1 320 EndOn Rule3 On IrReceived # Data = 0 x00FFB04F Do Power 1 EndOn On IrReceived # Data = 0 x00FFA857 Do Color2 12 EndOn On IrReceived # Data = 0 x00FFB24D Do Backlog Power 0 ; WakeupDuration 1 ; Dimmer 100 ; Wakeup EndOn On IrReceived # Data = 0 x00FF00FF Do Backlog Power 0 ; WakeupDuration 5 ; Wakeup EndOn On IrReceived # Data = 0 x00FF58A7 Do Backlog Scheme 2 ; Speed 1 EndOn On IrReceived # Data = 0 x00FF30CF Do Backlog Scheme 3 ; Speed 5 EndOn A Google Sheets Document to edit the desired actions and create the three needed rules is linked here . Don't forget to activate the rules Backlog Rule1 1; Rule2 1; Rule3 1 The hex codes for the \"Data\" value come from the data tag when looking at the JSON sent via MQTT. You can also view this data on the Tasmota console screen. From here you can program it to do whatever you want using Rules . LC01-banggood LC02-banggood LC03-banggood LC04-banggood LC08-banggood LC09-banggood LC10-banggood LC11-banggood","title":"MagicHome with ESP8285"},{"location":"devices/MagicHome-with-ESP8285/#identifying-this-board","text":"Looking closely you can see it's an ESP8285, on the main board, it has the part number: ZJ-WFMN-A V1.1 , ZJ-WFMN-B V1.1 , ZJ-WFMN-C V1.1 , or ZJ-WFMN-D V1.0","title":"Identifying this board"},{"location":"devices/MagicHome-with-ESP8285/#arilux-devices","text":"The devices are similar to the Arilux devices. Here is an overview: Model Color Support Voltages (sometimes) Remote PCB part number Link LC01 RGB 5-28V None ZJ-WFMN-A V1.1 [Banggood][LC01-banggood] LC02 RGBW 9-12V (5-28V) None ZJ-WFMN-B V1.1 [Banggood][LC02-banggood] LC03 RGB 5-28V IR ZJ-WFMN-A V1.1 [Banggood][LC03-banggood] LC04 RGBW 9-12V (5-28V) IR ZJ-WFMN-A V1.1 [Banggood][LC04-banggood] LC08 RGBWW/RGBWC 5-28V None [Banggood][LC08-banggood] LC09 RGB 5-28V RF [Banggood][LC09-banggood] LC10 RGBW 9-28V RF [Banggood][LC10-banggood] LC11 RGBWW/RGBWC 9-28V RF ZJ-WFMN-D V1.0 [Banggood][LC11-banggood]","title":"Arilux devices"},{"location":"devices/MagicHome-with-ESP8285/#flashing","text":"I found that on the back it has pads to solder to so you can flash it. The IO0 port is GPIO0 that needs to be pulled to ground when powered on for flashing (as per all ESP devices). I soldered cables to each of these. Note that some are very close to other pads, so be careful. If you want to avoid soldering, also pogo pins work well with the pads.","title":"Flashing"},{"location":"devices/MagicHome-with-ESP8285/#template-configuration","text":"Arilux LC01 (ZJ-WFMN-A V1.1) Automatic configuration: Field Value Function Module type 37 Arilux LC01 Module type Manual configuration: Field Value Function Module type 18 Generic Module type GPIO5 37 PWM1 RED GPIO12 38 PWM2 GREEN GPIO13 39 PWM3 BLUE Arilux LC02 (ZJ-WFMN-B V1.1) Field Value Function Module type 18 Generic Module type GPIO5 38 PWM2 GREEN GPIO12 39 PWM3 BLUE GPIO13 40 PWM4 WHITE GPIO14 37 PWM1 RED Arilux LC03 (ZJ-WFMN-A V1.1) Field Value Function Module type 18 Generic Module type GPIO4 51 IRRecv IR Remote GPIO5 37 PWM1 RED GPIO12 38 PWM2 GREEN GPIO13 39 PWM3 BLUE Arilux LC04 (ZJ-WFMN-A V1.1) Field Value Function Module type 18 Generic Module type GPIO4 51 IRRecv IR Remote (optional, view console for debugging!) GPIO5 38 PWM2 BLUE GPIO12 37 PWM1 RED GPIO13 39 PWM3 GREEN GPIO15 40 PWM4 WHITE Arilux LC11 (ZJ-WFMN-D V1.0) Field Value Function Module type 18 Generic Module type GPIO4 147 ALux IrRcv GPIO5 40 PWM4 COLD WHITE GPIO12 38 PWM2 GREEN GPIO13 39 PWM3 BLUE GPIO14 37 PWM1 RED GPIO15 41 PWM5 WARM WHITE GPIO16 159 ALux IrSel With all that done, one of the critical things I needed to do so I could set the colors was to run the command to set SetOption15 1 . After that it is possible to test the lights functionality, e.g. with the command Color #ff0000ff .","title":"Template configuration"},{"location":"devices/MagicHome-with-ESP8285/#rf-control","text":"If you have an RF variant, you will want to configure the GPIOs like this: { \"MagicHome RF\", // Magic Home RF (ESP8266) - (Arilux LC10) GPIO_USER, // GPIO00 Optional Button GPIO_USER, // GPIO01 Serial RXD and Optional sensor GPIO_LED1_INV, // GPIO02 Blue onboard LED (optional) GPIO_USER, // GPIO03 Serial TXD and Optional sensor0 GPIO_ARIRFRCV, // GPIO04 RF receiver input (New Tasmota ALux IrRcv 147) GPIO_PWM2, // GPIO05 RGB LED Green 0, 0, 0, 0, 0, 0, // Flash connection GPIO_PWM3, // GPIO12 RGB LED Blue GPIO_PWM4, // GPIO13 RGBW LED White GPIO_PWM1, // GPIO14 RGB LED Red GPIO_LED2_INV, // GPIO15 RF receiver control (New Tasmota ALuxIrSel 159) 0, 0 }, Tasmota template '{\"NAME\":\"MagicHome RGBW RF\",\"GPIO\":[0,0,56,0,147,38,0,0,39,40,37,159,0],\"FLAG\":0,\"BASE\":18}' or like this: { \"MagicHome RF\", // Magic Home RF (ESP8285) - (IRrecv) GPIO_USER, // GPIO00 Optional Button GPIO_USER, // GPIO01 Serial RXD and Optional sensor GPIO_LED1_INV, // GPIO02 Blue onboard LED (not soldered) GPIO_USER, // GPIO03 Serial TXD and Optional sensor0 GPIO_IRRECV, // GPIO04 IR receiver input GPIO_PWM1, // GPIO05 RGB LED Green 0, 0, 0, 0, 0, 0, // Flash connection GPIO_PWM2, // GPIO12 RGB LED Blue GPIO_PWM3, // GPIO13 RGBW LED White 0, 0, 0 }, After choosing the correct module type in your Tasmota configuration, press a key on the remote after boot for the device to learn your code. No need for the below rules for the RF varient","title":"RF control"},{"location":"devices/MagicHome-with-ESP8285/#full-set-of-rules-for-ir-remote","text":"Each rule can only be 511 characters long, some of the colors below use the built in predefined shortcut color numbers. Rule1 On IrReceived # Data = 0 x00FF906F Do Dimmer + EndOn On IrReceived # Data = 0 x00FF9867 Do Color2 1 EndOn On IrReceived # Data = 0 x00FFE817 Do HSBColor1 13 EndOn On IrReceived # Data = 0 x00FF02FD Do HSBColor1 23 EndOn On IrReceived # Data = 0 x00FF50AF Do HSBColor1 33 EndOn On IrReceived # Data = 0 x00FF38C7 Do HSBColor1 43 EndOn On IrReceived # Data = 0 x00FFB847 Do Dimmer - EndOn On IrReceived # Data = 0 x00FFD827 Do Color2 2 EndOn On IrReceived # Data = 0 x00FF48B7 Do HSBColor1 140 EndOn On IrReceived # Data = 0 x00FF32CD Do HSBColor1 160 EndOn Rule2 On IrReceived # Data = 0 x00FF7887 Do HSBColor1 180 EndOn On IrReceived # Data = 0 x00FF28D7 Do HSBColor1 200 EndOn On IrReceived # Data = 0 x00FFF807 Do Power 0 EndOn On IrReceived # Data = 0 x00FF8877 Do Color2 3 EndOn On IrReceived # Data = 0 x00FF6897 Do HSBColor1 260 EndOn On IrReceived # Data = 0 x00FF20DF Do HSBColor1 280 EndOn On IrReceived # Data = 0 x00FF708F Do HSBColor1 300 EndOn On IrReceived # Data = 0 x00FFF00F Do HSBColor1 320 EndOn Rule3 On IrReceived # Data = 0 x00FFB04F Do Power 1 EndOn On IrReceived # Data = 0 x00FFA857 Do Color2 12 EndOn On IrReceived # Data = 0 x00FFB24D Do Backlog Power 0 ; WakeupDuration 1 ; Dimmer 100 ; Wakeup EndOn On IrReceived # Data = 0 x00FF00FF Do Backlog Power 0 ; WakeupDuration 5 ; Wakeup EndOn On IrReceived # Data = 0 x00FF58A7 Do Backlog Scheme 2 ; Speed 1 EndOn On IrReceived # Data = 0 x00FF30CF Do Backlog Scheme 3 ; Speed 5 EndOn A Google Sheets Document to edit the desired actions and create the three needed rules is linked here . Don't forget to activate the rules Backlog Rule1 1; Rule2 1; Rule3 1 The hex codes for the \"Data\" value come from the data tag when looking at the JSON sent via MQTT. You can also view this data on the Tasmota console screen. From here you can program it to do whatever you want using Rules . LC01-banggood LC02-banggood LC03-banggood LC04-banggood LC08-banggood LC09-banggood LC10-banggood LC11-banggood","title":"Full Set of rules for IR remote"},{"location":"devices/Martin-Jerry-MJ-S01/","text":"The chip inside is a Tuya TYWE3S which is based on the ESP8266. Template GPIO Pin Selection 4 D2 Led1i (56) 5 D1 Led2i (57) 12 D6 Relay1 (21) 13 D7 Button1 (17) All other component assignments should be set to None (0)","title":"Martin Jerry MJ S01"},{"location":"devices/Martin-Jerry-MJ-SD01/","text":"This model sells for about $20 on Amazon . Info on the Tuya ~ The chip inside is a Tuya TYWE3S. It replicates the capabilities of an ESP8266 plus some other functionality. NOTE: THE RIGHT SIDE IS THE BACK OF THE BOARD. RST IS ON THE TOP LEFT OF THE LEFT PICTURE, AS WELL AS THE TOP LEFT OF THE PICTURE BELOW. Here\u2019s a picture of the chip inside the switch: Pin 1 is labeled M1 in the silkscreen of the switch board. Here\u2019s the back, I desoldered it with my Quick 861DW: On the other side of the board is an apparent test/programming header labeled CN1: From top to bottom on CN1 above, they are: Pin Signal CN1-1 TXD CN1-2 RXD CN1-3 GPIO2 CN1-4 GPIO0 CN1-5 GROUND CN1-6 VCC See Tasmota Hardware Prep for more details I removed all the crappy lead-free solder and put on a little strip of female pin header: Now I can easily hook it all up to the breadboard! I erased the firmware using the instructions using a Raspberry Pi 3 Model B. I couldn\u2019t get the board into programming mode by grounding the reset pin through the breadboard, so I just held the UP1 button while connecting 3V3 and it worked fine. There\u2019s another 4-wire connector that goes to the AC board. The wires are as follows: Wire Description Black 3.3v consistent, probably to power the other side Purple Variable voltage tied to dimmer. Low to high it\u2019s: 360mV, 680mV, 1.32V, 1.94V, 2.57V, 3.20V White GPIO16 Red Ground The other side features an STC15W404AS chip. This is the closest information sheet I\u2019ve found so far. It\u2019s likely there\u2019s an ADC receiver on the other side receiving our variable voltage on the purple wire above and converting that to the AC dimmer signal. When probing with the oscilloscope I noticed a 3.3v 1Khz square wave on GPIO13. It turns out this is the PWM that controls the output of the purple wire. This is done using the positive duty cycle of the wave. Here\u2019s a state table: Setting Duty 1 (Min Setting) 20% Duty 2 40% Duty 3 60% Duty 4 80% Duty 5 (Max Setting) 100% Duty, constant 3.3v We should be able to generate this same wave with whatever duty cycle we want in Tasmota to get much better dimming resolution than the default firmware provides. The buttons are tied as follows: Button Description UP1 GPIO0 to GROUND when pushed DOWN1 TXD to GROUND when pushed ON/OFF 3.3v to GPIO15 when pushed RESET Wired through an LED and resistor to GPIO16, also goes to white wire (RESET for the STC?), ties to GROUND The LEDs are wired as follows: LED Description LED1 Passthrough to RESET, GPIO16, see above. LED2 GPIO14 LED3 GPIO12 LED4 GPIO5 LED5 RXD FADE ON: Makes the PWM movements smooth DIMMER +/-: Moves dimmer up and down SPEED 3: Slows down fade a little SETOPTION15 1: Sets DIMMER mode rather than PWM Now that you can have rules set on dimmer actions, changing the LEDs with dimmer settings should be easy. I tried to do this before that existed, and it wasn't possible.","title":"Martin Jerry MJ SD01"},{"location":"devices/Martin-Jerry-MJ-SD01/#info-on-the-tuya","text":"The chip inside is a Tuya TYWE3S. It replicates the capabilities of an ESP8266 plus some other functionality. NOTE: THE RIGHT SIDE IS THE BACK OF THE BOARD. RST IS ON THE TOP LEFT OF THE LEFT PICTURE, AS WELL AS THE TOP LEFT OF THE PICTURE BELOW. Here\u2019s a picture of the chip inside the switch: Pin 1 is labeled M1 in the silkscreen of the switch board. Here\u2019s the back, I desoldered it with my Quick 861DW: On the other side of the board is an apparent test/programming header labeled CN1: From top to bottom on CN1 above, they are: Pin Signal CN1-1 TXD CN1-2 RXD CN1-3 GPIO2 CN1-4 GPIO0 CN1-5 GROUND CN1-6 VCC See Tasmota Hardware Prep for more details I removed all the crappy lead-free solder and put on a little strip of female pin header: Now I can easily hook it all up to the breadboard! I erased the firmware using the instructions using a Raspberry Pi 3 Model B. I couldn\u2019t get the board into programming mode by grounding the reset pin through the breadboard, so I just held the UP1 button while connecting 3V3 and it worked fine. There\u2019s another 4-wire connector that goes to the AC board. The wires are as follows: Wire Description Black 3.3v consistent, probably to power the other side Purple Variable voltage tied to dimmer. Low to high it\u2019s: 360mV, 680mV, 1.32V, 1.94V, 2.57V, 3.20V White GPIO16 Red Ground The other side features an STC15W404AS chip. This is the closest information sheet I\u2019ve found so far. It\u2019s likely there\u2019s an ADC receiver on the other side receiving our variable voltage on the purple wire above and converting that to the AC dimmer signal. When probing with the oscilloscope I noticed a 3.3v 1Khz square wave on GPIO13. It turns out this is the PWM that controls the output of the purple wire. This is done using the positive duty cycle of the wave. Here\u2019s a state table: Setting Duty 1 (Min Setting) 20% Duty 2 40% Duty 3 60% Duty 4 80% Duty 5 (Max Setting) 100% Duty, constant 3.3v We should be able to generate this same wave with whatever duty cycle we want in Tasmota to get much better dimming resolution than the default firmware provides. The buttons are tied as follows: Button Description UP1 GPIO0 to GROUND when pushed DOWN1 TXD to GROUND when pushed ON/OFF 3.3v to GPIO15 when pushed RESET Wired through an LED and resistor to GPIO16, also goes to white wire (RESET for the STC?), ties to GROUND The LEDs are wired as follows: LED Description LED1 Passthrough to RESET, GPIO16, see above. LED2 GPIO14 LED3 GPIO12 LED4 GPIO5 LED5 RXD FADE ON: Makes the PWM movements smooth DIMMER +/-: Moves dimmer up and down SPEED 3: Slows down fade a little SETOPTION15 1: Sets DIMMER mode rather than PWM Now that you can have rules set on dimmer actions, changing the LEDs with dimmer settings should be easy. I tried to do this before that existed, and it wasn't possible.","title":"Info on the Tuya"},{"location":"devices/Mirabella-Genio-Bulb/","text":"Mirabella Genio Bulb ~ Mirabella have released a few smart bulbs. Here is a bit of a guide on how to flash them with Tasmota. There are two ways: Over the Air (OTA) or via Serial. Flashing Over the Air ~ Flashing over the air requires running a linux shell script called tuya-convert and hence requires a computer (I used a Raspberry PI 3) with a wifi adaptor that supports AP mode. There are options if you run Windows to use either a virtual machine (it is reported that KALI Linux running on VMWare has worked) or potentially a live usb (I haven't tested it). Follow this procedure . To get the bulb into config mode, have the bulb on for at least 10 seconds, then cycle it off and on 3 times via a physical light switch. The bulb should flash rapidly when its in config mode. Tasmota v6.4.1 basic build is included as part of the tuya-convert script. It will open an WiFi access point named sonoff-XXX on the bulb once flashed correctly. Flashing via Serial ~ Flashing via Serial requires disassembling the bulb and soldiering wires to the board. Note: modifying these bulbs is dangerous if you do not understand what you are doing, please do so at your own risk! Mirabella Bulbs Disassembling bulb ~ The 2 main outer parts of the bulb are stuck together with high temp silicone or something similar. Squeeze the outer of the bulb (the bit that looks like glass) as near to the join as possible, you can use a tool like a spudger or something if that helps to break the seal, being careful not to damage any internal parts or cut yourself! Once the outer (fake glass) is removed you will see this: Carefully cut / scrape away as much of the sealent on the outer edge of the round circut board then using some needle nose pliers and your spudger pry the round board out. If you are really good at soldering and have a fine tip on your iron you could possibly skip this step and jump straight to the next one. B22 Stand the bulb up and de-solder the 2 pads, and straighten the wires to remove the board. E27 Using a sharp strong blade carefully pry out the small terminal on the end of the bulb then straighten the wire in side This will allow you to pull the board out a little and get enough angle on it to make soldering easier. You should now have these parts (E27 bulb will be still partly assembled): B22 E27 (with wires added) Connect FTDI ~ Connect your FTDI up to these pins: Flash with your preferred method I use this one (remember to connect GPIO0 to GND when plugging in your FTDI this will force the ESP into firmware write mode, you may need to try it a couple of times. Module Settings ~ Once flashed I use termite (or you could use any serial command tool) to send my settings: Note: Change these to match your environment Backlog SSID1 YOUR_SSID_NAME; Password1 YOUR_WIFI_PASSWORD; MqttHost MQTT_INTERNAL_IP_ADDRESS; MqttUser MQTT_USER_NAME; MqttPassword MQTT_PASSWORD; module 38;topic bulb1; FriendlyName Bulb1 Or set manually from the web interface: Dimmable warm white or cool white bulbs ~ Tunable warm/cool white bulbs ~ I based these settings on the RGBW settings. I would have thought PWM1-3 were redundant, but have only had it work with all of these assigned as per below. The bulb is then tunable, with a brightness slider and a cool/warm slider. Module type => Generic D2 GPIO4 => PWM1 (37) D1 GPIO5 => PWM4 (40) D6 GPIO12 => PWM2\ufffc (38) D7 GPIO13 => PWM5 (41) D5 GPIO14 => PWM3\ufffc (39) RGBW colour bulbs ~ Module type = Generic D2 GPIO4 = PWM1 37 = Red D6 GPIO12 = PWM2 38 = Green D5 GPIO14 = PWM3 39 = Blue D1 GPIO5 = PWM4 = White Re-assembly ~ Re-assembly procedure is the reverse of the disassemble procedure!","title":"Mirabella Genio Bulb"},{"location":"devices/Mirabella-Genio-Bulb/#mirabella-genio-bulb","text":"Mirabella have released a few smart bulbs. Here is a bit of a guide on how to flash them with Tasmota. There are two ways: Over the Air (OTA) or via Serial.","title":"Mirabella Genio Bulb"},{"location":"devices/Mirabella-Genio-Bulb/#flashing-over-the-air","text":"Flashing over the air requires running a linux shell script called tuya-convert and hence requires a computer (I used a Raspberry PI 3) with a wifi adaptor that supports AP mode. There are options if you run Windows to use either a virtual machine (it is reported that KALI Linux running on VMWare has worked) or potentially a live usb (I haven't tested it). Follow this procedure . To get the bulb into config mode, have the bulb on for at least 10 seconds, then cycle it off and on 3 times via a physical light switch. The bulb should flash rapidly when its in config mode. Tasmota v6.4.1 basic build is included as part of the tuya-convert script. It will open an WiFi access point named sonoff-XXX on the bulb once flashed correctly.","title":"Flashing Over the Air"},{"location":"devices/Mirabella-Genio-Bulb/#flashing-via-serial","text":"Flashing via Serial requires disassembling the bulb and soldiering wires to the board. Note: modifying these bulbs is dangerous if you do not understand what you are doing, please do so at your own risk! Mirabella Bulbs","title":"Flashing via Serial"},{"location":"devices/Mirabella-Genio-Bulb/#disassembling-bulb","text":"The 2 main outer parts of the bulb are stuck together with high temp silicone or something similar. Squeeze the outer of the bulb (the bit that looks like glass) as near to the join as possible, you can use a tool like a spudger or something if that helps to break the seal, being careful not to damage any internal parts or cut yourself! Once the outer (fake glass) is removed you will see this: Carefully cut / scrape away as much of the sealent on the outer edge of the round circut board then using some needle nose pliers and your spudger pry the round board out. If you are really good at soldering and have a fine tip on your iron you could possibly skip this step and jump straight to the next one.","title":"Disassembling bulb"},{"location":"devices/Mirabella-Genio-Bulb/#connect-ftdi","text":"Connect your FTDI up to these pins: Flash with your preferred method I use this one (remember to connect GPIO0 to GND when plugging in your FTDI this will force the ESP into firmware write mode, you may need to try it a couple of times.","title":"Connect FTDI"},{"location":"devices/Mirabella-Genio-Bulb/#module-settings","text":"Once flashed I use termite (or you could use any serial command tool) to send my settings: Note: Change these to match your environment Backlog SSID1 YOUR_SSID_NAME; Password1 YOUR_WIFI_PASSWORD; MqttHost MQTT_INTERNAL_IP_ADDRESS; MqttUser MQTT_USER_NAME; MqttPassword MQTT_PASSWORD; module 38;topic bulb1; FriendlyName Bulb1 Or set manually from the web interface:","title":"Module Settings"},{"location":"devices/Mirabella-Genio-Bulb/#dimmable-warm-white-or-cool-white-bulbs","text":"","title":"Dimmable warm white or cool white bulbs"},{"location":"devices/Mirabella-Genio-Bulb/#tunable-warmcool-white-bulbs","text":"I based these settings on the RGBW settings. I would have thought PWM1-3 were redundant, but have only had it work with all of these assigned as per below. The bulb is then tunable, with a brightness slider and a cool/warm slider. Module type => Generic D2 GPIO4 => PWM1 (37) D1 GPIO5 => PWM4 (40) D6 GPIO12 => PWM2\ufffc (38) D7 GPIO13 => PWM5 (41) D5 GPIO14 => PWM3\ufffc (39)","title":"Tunable warm/cool white bulbs"},{"location":"devices/Mirabella-Genio-Bulb/#rgbw-colour-bulbs","text":"Module type = Generic D2 GPIO4 = PWM1 37 = Red D6 GPIO12 = PWM2 38 = Green D5 GPIO14 = PWM3 39 = Blue D1 GPIO5 = PWM4 = White","title":"RGBW colour bulbs"},{"location":"devices/Mirabella-Genio-Bulb/#re-assembly","text":"Re-assembly procedure is the reverse of the disassemble procedure!","title":"Re-assembly"},{"location":"devices/Mirabella-Genio-Smart-Plug/","text":"Mirabella Genio Smart Plug ~ This is a simple smart plug with the addition of a USB port, as far as I can see the USB port is 'always on' and is not access this from the ESP module. Opening up the device was easy, 2 screws then a small amount of gentle prying exposed the components, 2 more screws had it fully deconstructed. The ESP module is mounted on a pcb with all of the required pins exposed. I was able to flash by connecting GPIO0 to GND while connecting my Serial Adaptor and flashing as per any other ESP device Use the string below from the console of the device to configure everything (replace required data with your own SSID, Password, MQTT Settings etc.): Backlog SSID1 YOUR_SSID_NAME; Password1 YOUR_WIFI_PASSWORD; MqttHost MQTT_INTERNAL_IP_ADDRESS; MqttUser MQTT_USER_NAME; MqttPassword MQTT_PASSWORD; GPIO2 56; GPIO12 21; GPIO13 17;topic genio1; FriendlyName Genio1 my prefered flashing method Once flashed, the config should look like:","title":"Mirabella Genio Smart Plug"},{"location":"devices/Mirabella-Genio-Smart-Plug/#mirabella-genio-smart-plug","text":"This is a simple smart plug with the addition of a USB port, as far as I can see the USB port is 'always on' and is not access this from the ESP module. Opening up the device was easy, 2 screws then a small amount of gentle prying exposed the components, 2 more screws had it fully deconstructed. The ESP module is mounted on a pcb with all of the required pins exposed. I was able to flash by connecting GPIO0 to GND while connecting my Serial Adaptor and flashing as per any other ESP device Use the string below from the console of the device to configure everything (replace required data with your own SSID, Password, MQTT Settings etc.): Backlog SSID1 YOUR_SSID_NAME; Password1 YOUR_WIFI_PASSWORD; MqttHost MQTT_INTERNAL_IP_ADDRESS; MqttUser MQTT_USER_NAME; MqttPassword MQTT_PASSWORD; GPIO2 56; GPIO12 21; GPIO13 17;topic genio1; FriendlyName Genio1 my prefered flashing method Once flashed, the config should look like:","title":"Mirabella Genio Smart Plug"},{"location":"devices/Modify-KaKu-to-WKaKu-Power-Socket/","text":"The Dutch Klik Aan Klik Uit PAR-1000 434MHz Power socket might suffer from Capacitor degeneration. In effect the power needed to engage the relay is too low. Replacing the Yellow Capacitor often solves the problem. I have several of these lying around and they can be used very well with sonoff functionality. As the sonoff PCA is a bit too large I decided to design my own PCA using kicad. During Proof of Concept I used 5V power supplies from itead. After three units were built one crashed caused by debris on the PS PCA resulting in an AC short which in turn blew the large resistor. As the selected Songle relay has the control leads close to the AC leads I also changed the relay. I decided to select the HiLink 5V power supply as it was also favourable on other sites. The relay now has the same connections as the one used in sonoff. The parts used are: = HiLink 5V power supply HLK-PM01 (aliexpress) = 5V to 3V3 step down (aliexpress) = 5V relay OJE-SH-105DM (ebay) = ESP12-F (aliexpress) = Capacitors and led from kaku PCA = 2 x 1k and 1 x 10k Resistors The image on the right shows how I mounted the ESP12-F vertically. Notice the 10k resistor from GPIO15 to the board. The firmware used is sonoff without modification!","title":"Modify KaKu to WKaKu Power Socket"},{"location":"devices/NEO-COOLCAM-NAS-WR01W/","text":"I got NEO and managed install tasmota on it. https://www.amazon.de/dp/B07KJGHXCQ * IMPORTANT: * I checked PCB and it is not solid for long use and high power. All contact are very cheap, also there is no POW. I can recommend user other SmartPlug AISIRER, AVATAR (see on tasmota main page), 2 euro difference, but much more solid + onboard POW. All details are into Espurna page https://github.com/xoseperez/espurna/wiki/Hardware-NEO-COOLCAM-NAS-WR01W","title":"NEO COOLCAM NAS WR01W"},{"location":"devices/Nedis-WIFIP310FWT/","text":"ATTENTION! Verifying/updating this currently. This setup is not 100% accurate. 20190327 Template: {\"NAME\":\"Nedis WIFIP310\",\"GPIO\":[0,56,0,17,22,21,0,0,0,23,24,0,0],\"FLAG\":1,\"BASE\":18} Description: 3 port AC outlets (European Schucko Type F) + 4 USB power outlets Power input: 16 A - 230 VAC Max. Power: 3680 W Power output: USB: 5 VDC /2.4 A each Product page - Swedish Product page - English","title":"Nedis WIFIP310FWT"},{"location":"devices/Novostella-B22-RGB-LED-Colour-WiFi-Smart-Bulb/","text":"Novostella B22 RGB LED Colour WiFi Smart Bulb https://www.amazon.co.uk/gp/product/B07DN4NLKM?ref_=oh_aui_search_asin_title&psc=1&pldnSite=1 Easily flashed OTA. GPIO is as follows. GPIO4 = PWM1 GPIO5 = PWM5 GPIO12 = PWM2 GPIO13 = PWM4 GPIO14 = PWM3","title":"Novostella B22 RGB LED Colour WiFi Smart Bulb"},{"location":"devices/OBI-Socket-2/","text":"OBI Socket 2 ~ Supported since version 6.4.1.8 as OBI Socket 2 (61) Another cheap socket from the German Hardware Store, based on ESP-WROOM-02 with 2MB Flash. Smaller form factor as the first OBI Socket. \u26a0\ufe0f\ufe0f Special Attention \u26a0\ufe0f\ufe0f ~ DO NOT try to flash the module when it is connected to mains AC power. You WILL brick or destroy the device and your computer or USB Port and get electrocutes! Use only a 3.3V USB adapter for flashing DO NOT CONNECT ANYTHING TO THESE DEVICES!!! (No sensors, no switches, nothing) The OBI Socket 2 has no transformer to isolate the mains voltage. The entire circuit is at mains-level voltage! Only use the device as designed. One way to flash the module is soldering 4 wires to the RX/TX/3V3/GND pins from the ESP. The PCB has no serial pinout connector. For flashing the module enable the flash mode of the ESP, connect GPIO 0 to GND. Another way to flash is soldering 4 wires to the bottom side of the PCB as described on https://github.com/mattzzw/obi_socket/wiki/OBI-socket. If you follow that approach of powering the socket with 5V (which enables the relay coil allowing for acoustic feedback) you need to make sure to nevertheless use 3V3 for the actual serial interface to the module!!! This happens to work out very nicely with the popular cheap CH340 USB to Serial TTL adapters which come with a jumper to select between 5V and 3.3V. Setting the adapter to 3.3V by putting the jumper on the 3V3 and VCC pins leaves the 5V pin free. That pin is directly connected to the USB port. So you can just connect the four wires from the socket to the four free pins of the CH340 adapter :-) If you want the green Wi-Fi LED to work, please use version 6.4.1.8+. You can either use \"Obi Socket 2 Type (61)\" (with default behaviour \"Wi-Fi LED = off\" when connected) or use \"Generic (18)\" for manually override. See issue 4567 for details. PCB serial pinouts ~ PCB serial pinouts (back) ~ ( Note: Same PCB as OBI Socket IP44 (Black) )","title":"OBI Socket 2"},{"location":"devices/OBI-Socket-2/#obi-socket-2","text":"Supported since version 6.4.1.8 as OBI Socket 2 (61) Another cheap socket from the German Hardware Store, based on ESP-WROOM-02 with 2MB Flash. Smaller form factor as the first OBI Socket.","title":"OBI Socket 2"},{"location":"devices/OBI-Socket-2/#special-attention","text":"DO NOT try to flash the module when it is connected to mains AC power. You WILL brick or destroy the device and your computer or USB Port and get electrocutes! Use only a 3.3V USB adapter for flashing DO NOT CONNECT ANYTHING TO THESE DEVICES!!! (No sensors, no switches, nothing) The OBI Socket 2 has no transformer to isolate the mains voltage. The entire circuit is at mains-level voltage! Only use the device as designed. One way to flash the module is soldering 4 wires to the RX/TX/3V3/GND pins from the ESP. The PCB has no serial pinout connector. For flashing the module enable the flash mode of the ESP, connect GPIO 0 to GND. Another way to flash is soldering 4 wires to the bottom side of the PCB as described on https://github.com/mattzzw/obi_socket/wiki/OBI-socket. If you follow that approach of powering the socket with 5V (which enables the relay coil allowing for acoustic feedback) you need to make sure to nevertheless use 3V3 for the actual serial interface to the module!!! This happens to work out very nicely with the popular cheap CH340 USB to Serial TTL adapters which come with a jumper to select between 5V and 3.3V. Setting the adapter to 3.3V by putting the jumper on the 3V3 and VCC pins leaves the 5V pin free. That pin is directly connected to the USB port. So you can just connect the four wires from the socket to the four free pins of the CH340 adapter :-) If you want the green Wi-Fi LED to work, please use version 6.4.1.8+. You can either use \"Obi Socket 2 Type (61)\" (with default behaviour \"Wi-Fi LED = off\" when connected) or use \"Generic (18)\" for manually override. See issue 4567 for details.","title":"\u26a0\ufe0f\ufe0f  Special Attention   \u26a0\ufe0f\ufe0f"},{"location":"devices/OBI-Socket-2/#pcb-serial-pinouts","text":"","title":"PCB serial pinouts"},{"location":"devices/OBI-Socket-2/#pcb-serial-pinouts-back","text":"( Note: Same PCB as OBI Socket IP44 (Black) )","title":"PCB serial pinouts (back)"},{"location":"devices/OBI-WiFi-Socket-IP44/","text":"Overview ~ This WiFi socket is a cheap outdoor alternative to the popular low-cost indoor WiFi socket \"Wifi Stecker Schuko Wei\u00df\" from the German Diy-warehouse OBI. It is equipped with a ESP-WROOM-02 module. Sadly, there is no programming pin header and it can be kind of tricky to get the module into programming state (see below). You'll need some soldering skills to attach the programming wires. Where to buy ~ The Outdoor Wifi Socket is only available in the OBI Diy-Warehouse. It's \"official name\" is \"Wifi Stecker Schuko Schwarz\". It can also be bought in the OBI online-store Open the socket ~ Opening the socket is kind of difficult. The case is held together by two Tri-Wing screws, two tiny cross-head/PH screws, some sealing grease in the screw holes and some glue. First, you can remove the sealing grease out of the screw holes by using a matching drill. Drill out the sealing grease by turning it by hand, until you reach the screw head. After this, you can use the matching screw driver. The eventually remaining sealing grease will move aside. Tipp: Afterwards use normal cross screws to close the casing. After this its getting tricky: use a stable knife or a flat screw driver to carefully crack up the two halfs of the case. In any case, try to NOT cut up your hands! Connection ~ For convenient access to the programming pins, you can solder jump wires to the corresponding pads of the WROOM module. After successfully reprogramming the module, you can fold the wires into the socket in case of further tinkering. ( Note: Same PCB as OBI Socket 2 ! ) Entering programming mode ~ Connect GPIO0 to GND before connecting power to enable flash mode! GPIO Config ~","title":"OBI WiFi Socket IP44"},{"location":"devices/OBI-WiFi-Socket-IP44/#overview","text":"This WiFi socket is a cheap outdoor alternative to the popular low-cost indoor WiFi socket \"Wifi Stecker Schuko Wei\u00df\" from the German Diy-warehouse OBI. It is equipped with a ESP-WROOM-02 module. Sadly, there is no programming pin header and it can be kind of tricky to get the module into programming state (see below). You'll need some soldering skills to attach the programming wires.","title":"Overview"},{"location":"devices/OBI-WiFi-Socket-IP44/#where-to-buy","text":"The Outdoor Wifi Socket is only available in the OBI Diy-Warehouse. It's \"official name\" is \"Wifi Stecker Schuko Schwarz\". It can also be bought in the OBI online-store","title":"Where to buy"},{"location":"devices/OBI-WiFi-Socket-IP44/#open-the-socket","text":"Opening the socket is kind of difficult. The case is held together by two Tri-Wing screws, two tiny cross-head/PH screws, some sealing grease in the screw holes and some glue. First, you can remove the sealing grease out of the screw holes by using a matching drill. Drill out the sealing grease by turning it by hand, until you reach the screw head. After this, you can use the matching screw driver. The eventually remaining sealing grease will move aside. Tipp: Afterwards use normal cross screws to close the casing. After this its getting tricky: use a stable knife or a flat screw driver to carefully crack up the two halfs of the case. In any case, try to NOT cut up your hands!","title":"Open the socket"},{"location":"devices/OBI-WiFi-Socket-IP44/#connection","text":"For convenient access to the programming pins, you can solder jump wires to the corresponding pads of the WROOM module. After successfully reprogramming the module, you can fold the wires into the socket in case of further tinkering. ( Note: Same PCB as OBI Socket 2 ! )","title":"Connection"},{"location":"devices/OBI-WiFi-Socket-IP44/#entering-programming-mode","text":"Connect GPIO0 to GND before connecting power to enable flash mode!","title":"Entering programming mode"},{"location":"devices/OBI-WiFi-Socket-IP44/#gpio-config","text":"","title":"GPIO Config"},{"location":"devices/OBI-Wifi-Socket/","text":"Where to buy ~ As shown in the name the Wifi Socket is only available in the OBI Diy-Warehouse. It can also be bought in the OBI online-store Open the socket ~ Opening the socket is kind of difficult. If you have one of the Tri-Wing screwdrivers it is much more easier. If you haven't got use a normal head screwdriver. Be careful not damaging your hand with it. Tipp: Afterwards use normal cross screws to close the casing. Connection ~ ESP Programmer VCC 3V3 TX RX RX TX GND GND Connect GPIO0 to GND before connecting power to enable flash mode! Additional Information ~ A low pulse on GPIO12 switches the relay on, a low pulse on GPIO5 switches it off. I have solved the 'pulse issue' by setting GPIO12 to always 0 (as LED) and works fine. More Infos can be found here: #1988 . Initial Configuration ~ In the default configuration GPIO0 (which is also used to enable flash-mode) is setup as a Button. To enable AP-Mode and setup the correct GPIOs as described below, You can short GPIO0 to GND 4 times as if it was a button (see [[Button-usage]]) Using this method allows you to flash a precompiled binary Device Images ~ (images from https://github.com/martin-ger/ESP8266-WiFi-Socket) GPIO Config ~ UPDATE: with Tasmota 6.3.0 you have fully monitoring support (Add support for OBI Power Socket (#1988, #3944)) ** Beginning 6.3.0, no need to choose type 18 anymore, use type 51 Obi Socket *","title":"OBI Wifi Socket"},{"location":"devices/OBI-Wifi-Socket/#where-to-buy","text":"As shown in the name the Wifi Socket is only available in the OBI Diy-Warehouse. It can also be bought in the OBI online-store","title":"Where to buy"},{"location":"devices/OBI-Wifi-Socket/#open-the-socket","text":"Opening the socket is kind of difficult. If you have one of the Tri-Wing screwdrivers it is much more easier. If you haven't got use a normal head screwdriver. Be careful not damaging your hand with it. Tipp: Afterwards use normal cross screws to close the casing.","title":"Open the socket"},{"location":"devices/OBI-Wifi-Socket/#connection","text":"ESP Programmer VCC 3V3 TX RX RX TX GND GND Connect GPIO0 to GND before connecting power to enable flash mode!","title":"Connection"},{"location":"devices/OBI-Wifi-Socket/#additional-information","text":"A low pulse on GPIO12 switches the relay on, a low pulse on GPIO5 switches it off. I have solved the 'pulse issue' by setting GPIO12 to always 0 (as LED) and works fine. More Infos can be found here: #1988 .","title":"Additional Information"},{"location":"devices/OBI-Wifi-Socket/#initial-configuration","text":"In the default configuration GPIO0 (which is also used to enable flash-mode) is setup as a Button. To enable AP-Mode and setup the correct GPIOs as described below, You can short GPIO0 to GND 4 times as if it was a button (see [[Button-usage]]) Using this method allows you to flash a precompiled binary","title":"Initial Configuration"},{"location":"devices/OBI-Wifi-Socket/#device-images","text":"(images from https://github.com/martin-ger/ESP8266-WiFi-Socket)","title":"Device Images"},{"location":"devices/OBI-Wifi-Socket/#gpio-config","text":"UPDATE: with Tasmota 6.3.0 you have fully monitoring support (Add support for OBI Power Socket (#1988, #3944)) ** Beginning 6.3.0, no need to choose type 18 anymore, use type 51 Obi Socket *","title":"GPIO Config"},{"location":"devices/Oittm-Smart-Plug/","text":"Oittm Smart Plug ~ Oittm provides a relatively cheap Wifi smart plug with an ESP8266, too. To enable the flash mode of the ESP connect GPIO 0 to GND. The wires have to be soldered directly onto the ESP chip itself, it won't work otherwise. Opening the device ~ Remove the small plastics caps on the back and unscrew the first two screws and then again the next ones PCB layout ~ !!Make sure to flash with 3.3V and disconnect the power plug from the power outlet before!! Web configuration ~ If you want the blue LED instead of the red one, use Led2i","title":"Oittm Smart Plug"},{"location":"devices/Oittm-Smart-Plug/#oittm-smart-plug","text":"Oittm provides a relatively cheap Wifi smart plug with an ESP8266, too. To enable the flash mode of the ESP connect GPIO 0 to GND. The wires have to be soldered directly onto the ESP chip itself, it won't work otherwise.","title":"Oittm Smart Plug"},{"location":"devices/Oittm-Smart-Plug/#opening-the-device","text":"Remove the small plastics caps on the back and unscrew the first two screws and then again the next ones","title":"Opening the device"},{"location":"devices/Oittm-Smart-Plug/#pcb-layout","text":"!!Make sure to flash with 3.3V and disconnect the power plug from the power outlet before!!","title":"PCB layout"},{"location":"devices/Oittm-Smart-Plug/#web-configuration","text":"","title":"Web configuration"},{"location":"devices/Other-Devices/","text":"This page is here for archival purposes. For new devices use Tasmota Device Templates Repository ! New submissions here will not be approved. ~ Relays/Sonoff Basic Clones ~ WL-SW01_10 WiFi Smart Switch - Sonoff Basic in a different form factor Canwing CW001 5A LC Technology WiFi Relay EXS Relay V3.1 & V5.1 Ledunia and NodeMcu Plugs/Sockets ~ Lingan SWA1 Hyleton 313 Smart Plug Teckin SP23 LA-WF3 Wifi Plug (Tuya TYWE2S) - Costco No-Brand Smart Plug with Tuya-based ESP8266MOD and ESP-12F modules WiOn 50055 Indoor Wi-Fi Switch With USB (support for relay and switch only - no power monitoring yet. See status here #82 .) SM-SO301 4 mains Power Strip with 4 USB ports LeFun SK2 Smart Power Strip with 4 Mains + 4 USB meross MSS425 Smart Power Strip Gosund SP1 SWB1 Wi-Fi Smart Power Strip Kesen KS-604S Dual Outlet Oittm Smart Plug Mirabella Genio Smart Plug CE Smart Home\u2122 Garden Power Stake 4CH-Wifi-Socket-with-USB-Charger (Tuya TYWE2S) Anoopsyche JH-G01B1 RGB Smart Socket with Power Monitor 16A EU Supernight Dual Wifi Plug TMRLife Plug or Home Awesome Plug SmartPlug AISIRER, AVATAR with POW SmartPlug NEO COOLCAM NAS WR01W Slitinto NX SP202 Wall Switches/Dimmers ~ KS-602 based switches like GresaTek, Jesiya, NewRice, Lyasi etc Smart Light Switch - SS118-01K1 KMC 70008 Light Switch KS-602S Smart Wifi Light Switch Xenon SM-SW102-2 two-relay light switch Martin Jerry MJ-SD01 Smart Dimmer KingArt N1 - Other Sonoff T1 clone, flash works also on KingArt N2 (2 gangs) KingArt Dimmer Same as above, but a dimmer Lights/LED Controllers ~ SP108E LED strip controller WS03 LED Controller Luminea-ZX-2844-675 Mirabella Genio Smart Bulb Kohree VHP560 Smart Light Compatible, RGBCW Wi-Fi LED Bulb A19 Novostella B22 RGBW Smart Light Xiaomi Mi Desk Lamp Out of production devices ~ ITead Motor Clockwise/ Anticlockwise Running WiFi Wireless Switch PowStro - Sonoff Basic clone SmartHome - Sonoff Basic clone YUNTONG Smart - Sonoff Basic clone CSL (aplic WDP 303075) SM-PW701E Socket Board: (Tuya TYWE3S) WK30 (Tuya TYWE3S) Hompie-SWS1 (Tuya TYWE3S) Burnett BN K01 Smart Socket CNSKOU / CNSANKOU wall switches - Chinese Sonoff T1 clones","title":"Other Devices"},{"location":"devices/Other-Devices/#this-page-is-here-for-archival-purposes-for-new-devices-use-tasmota-device-templates-repository-new-submissions-here-will-not-be-approved","text":"","title":"This page is here for archival purposes. For new devices use Tasmota Device Templates Repository! New submissions here will not be approved."},{"location":"devices/Other-Devices/#relayssonoff-basic-clones","text":"WL-SW01_10 WiFi Smart Switch - Sonoff Basic in a different form factor Canwing CW001 5A LC Technology WiFi Relay EXS Relay V3.1 & V5.1 Ledunia and NodeMcu","title":"Relays/Sonoff Basic Clones"},{"location":"devices/Other-Devices/#plugssockets","text":"Lingan SWA1 Hyleton 313 Smart Plug Teckin SP23 LA-WF3 Wifi Plug (Tuya TYWE2S) - Costco No-Brand Smart Plug with Tuya-based ESP8266MOD and ESP-12F modules WiOn 50055 Indoor Wi-Fi Switch With USB (support for relay and switch only - no power monitoring yet. See status here #82 .) SM-SO301 4 mains Power Strip with 4 USB ports LeFun SK2 Smart Power Strip with 4 Mains + 4 USB meross MSS425 Smart Power Strip Gosund SP1 SWB1 Wi-Fi Smart Power Strip Kesen KS-604S Dual Outlet Oittm Smart Plug Mirabella Genio Smart Plug CE Smart Home\u2122 Garden Power Stake 4CH-Wifi-Socket-with-USB-Charger (Tuya TYWE2S) Anoopsyche JH-G01B1 RGB Smart Socket with Power Monitor 16A EU Supernight Dual Wifi Plug TMRLife Plug or Home Awesome Plug SmartPlug AISIRER, AVATAR with POW SmartPlug NEO COOLCAM NAS WR01W Slitinto NX SP202","title":"Plugs/Sockets"},{"location":"devices/Other-Devices/#wall-switchesdimmers","text":"KS-602 based switches like GresaTek, Jesiya, NewRice, Lyasi etc Smart Light Switch - SS118-01K1 KMC 70008 Light Switch KS-602S Smart Wifi Light Switch Xenon SM-SW102-2 two-relay light switch Martin Jerry MJ-SD01 Smart Dimmer KingArt N1 - Other Sonoff T1 clone, flash works also on KingArt N2 (2 gangs) KingArt Dimmer Same as above, but a dimmer","title":"Wall Switches/Dimmers"},{"location":"devices/Other-Devices/#lightsled-controllers","text":"SP108E LED strip controller WS03 LED Controller Luminea-ZX-2844-675 Mirabella Genio Smart Bulb Kohree VHP560 Smart Light Compatible, RGBCW Wi-Fi LED Bulb A19 Novostella B22 RGBW Smart Light Xiaomi Mi Desk Lamp","title":"Lights/LED Controllers"},{"location":"devices/Other-Devices/#out-of-production-devices","text":"ITead Motor Clockwise/ Anticlockwise Running WiFi Wireless Switch PowStro - Sonoff Basic clone SmartHome - Sonoff Basic clone YUNTONG Smart - Sonoff Basic clone CSL (aplic WDP 303075) SM-PW701E Socket Board: (Tuya TYWE3S) WK30 (Tuya TYWE3S) Hompie-SWS1 (Tuya TYWE3S) Burnett BN K01 Smart Socket CNSKOU / CNSANKOU wall switches - Chinese Sonoff T1 clones","title":"Out of production devices"},{"location":"devices/PS-16-DZ-Dimmer/","text":"PS-16-DZ Dimmer ~ The PS-16-DZ dimmer uses eWeLink app same as Sonoff devices. It's available from Amazon and Aliexpress . It may under different name, but the model number is PS-16-DZ. Pics ~ Opened it up, found a ESP8285 and a Nuvoton N76E003. Flash and GPIO pins ~ Remove the ESP8285 daughter card DLX-MKCK01 from the main board and flash Tasmota. pin1 RST -> N76E003 P0.5/PWM2 pin2 TXD -> N76E003 P0.7/RXD pin3 RXD -> N76E003 P0.6/TXD pin4 GPIO13/MTCK -> LED pin5 3.3V pin6 GND Communication between ESP8285 and N76E003 ~ It uses AT command to communicate between ESP8285 and N76E003 over UART at 19200 baud. Turn on the switch from ESP8266 : Send from ESP8266 AT + UPDATE = \"sequence\" : \"1528335040032\" , \"switch\" : \"on\" Receive from MCU AT + RESULT = \"sequence\" : 1528335040032 \" Send from ESP8266 : AT + SEND = ok After 0.7 s Receive from MCU AT + UPDATE = \"switch\" : \"on\" , \"bright\" : 44 Send from ESP8266 : AT + SEND = ok Turn off the switch from ESP8266 : Send from ESP8266 AT + UPDATE = \"sequence\" : \"1528335118327\" , \"switch\" : \"off\" Receive from MCU AT + RESULT = \"sequence\" : 1528335118327 \" Send from ESP8266 : AT + SEND = ok After 0.7 s Receive from MCU AT + UPDATE = \"switch\" : \"on\" , \"bright\" : 44 Send from ESP8266 : AT + SEND = ok Change brightness to 44 from ESP8266 : Send from ESP8266 : AT + UPDATE = \"sequence\" : \"1528335181502\" , \"bright\" : 44 Receive from MCU AT + RESULT = \"sequence\" : 1528335181502 \" Send from ESP8266 : AT + SEND = ok After 0.7 s Receive from MCU AT + UPDATE = \"switch\" : \"on\" , \"bright\" : 44 Send from ESP8266 : AT + SEND = ok Turn on the switch with faceplate button : Received from MCU AT + UPDATE = \"switch\" : \"on\" , \"bright\" : 44 Send from ESP8266 : AT + SEND = ok Turn off the switch with faceplate button : Received from MCU AT + UPDATE = \"switch\" : \"off\" , \"bright\" : 44 Send from ESP8266 : AT + SEND = ok Change the brightness to 52 with faceplate button : Received from MCU AT + UPDATE = \"switch\" : \"on\" , \"bright\" : 52 Send from ESP8266 : AT + SEND = ok Holding the middle button on faceplate to reset the device : Received from MCU AT + SETTING = enterESPTOUCH Send from ESP8266 : AT + SETTING = enterESPTOUCH The sequence number is a 13 digits unix timestamp (in milliseconds). The data after \"bright\" is the brightness. The maximum of the brightness is 100 and the minimum is 10. There is one byte 0x1B at the end of each AT command.","title":"PS-16-DZ Dimmer"},{"location":"devices/PS-16-DZ-Dimmer/#ps-16-dz-dimmer","text":"The PS-16-DZ dimmer uses eWeLink app same as Sonoff devices. It's available from Amazon and Aliexpress . It may under different name, but the model number is PS-16-DZ.","title":"PS-16-DZ Dimmer"},{"location":"devices/PS-16-DZ-Dimmer/#pics","text":"Opened it up, found a ESP8285 and a Nuvoton N76E003.","title":"Pics"},{"location":"devices/PS-16-DZ-Dimmer/#flash-and-gpio-pins","text":"Remove the ESP8285 daughter card DLX-MKCK01 from the main board and flash Tasmota. pin1 RST -> N76E003 P0.5/PWM2 pin2 TXD -> N76E003 P0.7/RXD pin3 RXD -> N76E003 P0.6/TXD pin4 GPIO13/MTCK -> LED pin5 3.3V pin6 GND","title":"Flash and GPIO pins"},{"location":"devices/PS-16-DZ-Dimmer/#communication-between-esp8285-and-n76e003","text":"It uses AT command to communicate between ESP8285 and N76E003 over UART at 19200 baud. Turn on the switch from ESP8266 : Send from ESP8266 AT + UPDATE = \"sequence\" : \"1528335040032\" , \"switch\" : \"on\" Receive from MCU AT + RESULT = \"sequence\" : 1528335040032 \" Send from ESP8266 : AT + SEND = ok After 0.7 s Receive from MCU AT + UPDATE = \"switch\" : \"on\" , \"bright\" : 44 Send from ESP8266 : AT + SEND = ok Turn off the switch from ESP8266 : Send from ESP8266 AT + UPDATE = \"sequence\" : \"1528335118327\" , \"switch\" : \"off\" Receive from MCU AT + RESULT = \"sequence\" : 1528335118327 \" Send from ESP8266 : AT + SEND = ok After 0.7 s Receive from MCU AT + UPDATE = \"switch\" : \"on\" , \"bright\" : 44 Send from ESP8266 : AT + SEND = ok Change brightness to 44 from ESP8266 : Send from ESP8266 : AT + UPDATE = \"sequence\" : \"1528335181502\" , \"bright\" : 44 Receive from MCU AT + RESULT = \"sequence\" : 1528335181502 \" Send from ESP8266 : AT + SEND = ok After 0.7 s Receive from MCU AT + UPDATE = \"switch\" : \"on\" , \"bright\" : 44 Send from ESP8266 : AT + SEND = ok Turn on the switch with faceplate button : Received from MCU AT + UPDATE = \"switch\" : \"on\" , \"bright\" : 44 Send from ESP8266 : AT + SEND = ok Turn off the switch with faceplate button : Received from MCU AT + UPDATE = \"switch\" : \"off\" , \"bright\" : 44 Send from ESP8266 : AT + SEND = ok Change the brightness to 52 with faceplate button : Received from MCU AT + UPDATE = \"switch\" : \"on\" , \"bright\" : 52 Send from ESP8266 : AT + SEND = ok Holding the middle button on faceplate to reset the device : Received from MCU AT + SETTING = enterESPTOUCH Send from ESP8266 : AT + SETTING = enterESPTOUCH The sequence number is a 13 digits unix timestamp (in milliseconds). The data after \"bright\" is the brightness. The maximum of the brightness is 100 and the minimum is 10. There is one byte 0x1B at the end of each AT command.","title":"Communication between ESP8285 and N76E003"},{"location":"devices/PowStro/","text":"Connection ~ Vcc - 3,3V TX - RX RX - TX GND - GND Additional Information ~ PowStro are fake Sonoff Basic, but they still work with Tasmota. More Infos can be found here: #1419 . Device Images ~ GPIO Config ~","title":"PowStro"},{"location":"devices/PowStro/#connection","text":"Vcc - 3,3V TX - RX RX - TX GND - GND","title":"Connection"},{"location":"devices/PowStro/#additional-information","text":"PowStro are fake Sonoff Basic, but they still work with Tasmota. More Infos can be found here: #1419 .","title":"Additional Information"},{"location":"devices/PowStro/#device-images","text":"","title":"Device Images"},{"location":"devices/PowStro/#gpio-config","text":"","title":"GPIO Config"},{"location":"devices/RGB-Smart-Plug-16A/","text":"* Aliexpress: Lonsonho Wifi Smart Socket Power Monitor EU 2 Pin * Aliexpress: RGB Smart Plug * amazon.de: Smart Steckdose, Wechsellicht 16A, WLAN Steckdose Wifi Stecker fernbedienbar, Stromverbrauch messen, funktioniert mit Alexa [Echo, Echo Dot] und Google Home, 4 Packs OTA flashing ~ DEVICE IS DIFFICULT TO DISASSEMBLE SO ANY ERRORS WITH FLASHING OR CONFIGURATION CAN EASILY BRICK IT. DO NOT CONNECT ANY SENSOR TO THESE DEVICES. Only use them as designed. AS ALWAYS, YOU DO ANY OF THIS AT YOUR OWN RISK. Device case is glued so recommended way to flash it is using tuya-convert This method worked for 3 devices that were shipped before December 2019, never paired with Tuya apps and never powered on near open WiFi APs. So they had no chance to download Tuya-Convert updates. It may not work for devices with newer firmware. Prerequisites ~ You'll need a Linux device with both WiFi capable of running in AP mode and ethernet connection Clone/download tuya-convert Run install_prereq.sh Ubuntu only On Ubuntu, it's also necessary to temporary disable WiFi from Network Manager and stop/disable systemd-resolved. Edit /etc/NetworkManager/NetworkManager.conf and add [keyfile] unmanaged-devices = interface-name:wlp2s0 Replace wlp2s0 with your WiFi interface name if neccessary. Then run sudo systemctl restart network-manager.service sudo systemctl disable systemd-resolved.service sudo systemctl stop systemd-resolved.service Don't forget to undo everything after flashing, DNS and WiFi won't work otherwise. Start flashing ~ Run start_flash.sh and follow the instructions Connect any WiFi device to vtrust-flash AP when it asks to and make sure that it gets an IP address. If it doesn't stop and check logs in scripts folder for clues Connect socket to mains and long-press the button to enter pairing mode Tasmota is included with tuya-convert, follow script's instruction to flash it After flashing device should reboot and you should see Tasmota's WiFi AP (Sonoff-xxx). Run stop_flash.sh to shutdown vtrust-flash AP on a machine you used for OTA. Configuration ~ Connect to Tasmota's AP It's extremely important to enter correct WiFi configuration. Button is not on GPIO0 so won't do anything for default Sonoff Basic device profile. It's recommended to temporary enter second WiFi with something easy like SSID: TEST Password: testtest so you could start that AP and re-configure the device if there are any issues with main WiFi connection. After it reboots and successfully connects to WiFi configure it as Blizwolf SHP module Now button and relay should work. Red and Blue LEDs will be used as status LEDs. RGB Light ~ Use this template to configure the device: {\"NAME\":\"RGB Smart Plug\",\"GPIO\":[37,0,39,0,38,134,0,0,131,17,132,21,0],\"FLAG\":0,\"BASE\":45} For older versions: Complete RGB support requires building slightly custom Tasmota. Edit sonoff/sonoff_template.h and replace \"BlitzWolf SHP\" configuration with the following: { \"BlitzWolf SHP\", // BlitzWolf BW-SHP2 and BW-SHP6 (ESP8285 - BL0937 or HJL-01 Energy Monitoring) // https://www.banggood.com/BlitzWolf-BW-SHP2-Smart-WIFI-Socket-EU-Plug-220V-16A-Work-with-Amazon-Alexa-Google-Assistant-p-1292899.html // https://www.amazon.de/Steckdose-Homecube-intelligente-Verbrauchsanzeige-funktioniert/dp/B076Q2LKHG/ref=sr_1_fkmr0_1 // https://www.amazon.de/Intelligente-Stromverbrauch-Fernsteurung-Schaltbare-Energieklasse/dp/B076WZQS4S/ref=sr_1_1 // https://www.aliexpress.com/store/product/BlitzWolf-BW-SHP6-EU-Plug-Metering-Version-WIFI-Smart-Socket-220V-240V-10A-Work-with-Amazon/1965360_32945504669.html GPIO_USER, // GPIO00 Red Led (1 = On, 0 = Off) GPIO_USER, // GPIO01 Serial RXD and Optional sensor GPIO_USER, // GPIO02 Blue Led (1 = On, 0 = Off) GPIO_USER, // GPIO03 Serial TXD and Optional sensor GPIO_USER, // GPIO04 GPIO_HJL_CF, // GPIO05 BL0937 or HJL-01 CF power 0, 0, 0, 0, 0, 0, // Flash connection GPIO_NRG_SEL_INV, // GPIO12 BL0937 or HJL-01 Sel output (0 = Voltage) GPIO_KEY1, // GPIO13 Button GPIO_NRG_CF1, // GPIO14 BL0937 or HJL-01 CF1 current / voltage GPIO_REL1, // GPIO15 Relay (0 = Off, 1 = On) 0, 0 }, Make sure that you don't have wrong WiFi configuration in user_config_override.h. Build and OTA flash it to the device using Tasmota. After it reboots configure as following: [[https://raw.githubusercontent.com/wiki/Astr0/Sonoff-Tasmota/images/lonsonho16a/config.png|Configuration]] RGB and dimming should work now. Disassembling the device ~ This is not recommended. Do it only if you have to or just buy a new one. The device is hard to open and may be damaged. Components inside may have mains charge and electrocute you even if powered off. Do it at your own risk. One of my devices had a hardware issue - constantly losing WiFi, rebooted when wiggled in power socket, rebooted every few seconds on 1250W load, sometimes just hanged and not responded even to the button. Since it wasn't usable at all I tried to fix it. The reason was broken steel input pole inside(what?? how?? WTF??) that was making weak contact, couldn't fix it reliably. Unbend earth connections on the bottom to make them straight. Use a sharp knife to slice through glue between RGB ring and the case. Requires quite a lot of force and time. RGB ring may break in places where glue is stronger than the plastic. Use a screwdriver to pry the case open. Remove button cap Desolder output connections, try not to melt any plastic. Remove support plastic with a screwdriver, it's held to the PCB by two clips. Desolder input poles. This is tricky since there's a lot of solder. I've removed as much of it as possible with desoldering pump, then melted the solder and rotated the poles with pliers while it cooled. Poles are made of steel and steel don't accept solder well. Remove the PCB by lifting it up. It's glued to the case on the bottom by the relay and held tight with input poles so it requires some force. Also, it's not easy to grab the PCB. I've used dip removing tweezers, holding PCB by holes for the earth connectors. I figured out the pinout for flashing the device: Before assembling it back remove as much solder as possible from input and output pole pads. The device fits together very tight, so everything should be perfectly in place. Don't forget to glue the case back. Alternative to disasselmy: Drilling two holes. ~ _With all this information at hand it is also possible to drill two simple holes into the case to get to the necesarry contact pads. I recommend a 6mm drill, carfully drill trough the case at he center of the ledge from the high power side opposite the power button. See pictures. Now you can solder on a few temporary flash cables. Don't forget to pull IO0 to GND to get into flash mode. Few observations: * It has ESP8266EX with FM25F08 8Mbit flash. The module has lots of connections, some of them have only pads without tracks on the main board. High chances to find RX and TX there. Obviously, there should be VCC and GND to power up the module. * Uses HJL-01 with a shunt for power monitoring, so every mains power track that looks like it should be covered with solder but is not, probably should be covered with solder :) * It has 4 RGB LEDs. GPIO00-Red, GPIO02-Blue, GPIO04-Green * AFE BPD-SS-105DM 16A 250VAC relay * 16A SMD fuse for mains input * Something that's probably another fuse marked F1 for low-voltage circuitry power * Low-voltage part is not galvanically insulated from mains * There's \"QC Passed\" sticker on the relay","title":"RGB Smart Plug 16A"},{"location":"devices/RGB-Smart-Plug-16A/#ota-flashing","text":"DEVICE IS DIFFICULT TO DISASSEMBLE SO ANY ERRORS WITH FLASHING OR CONFIGURATION CAN EASILY BRICK IT. DO NOT CONNECT ANY SENSOR TO THESE DEVICES. Only use them as designed. AS ALWAYS, YOU DO ANY OF THIS AT YOUR OWN RISK. Device case is glued so recommended way to flash it is using tuya-convert This method worked for 3 devices that were shipped before December 2019, never paired with Tuya apps and never powered on near open WiFi APs. So they had no chance to download Tuya-Convert updates. It may not work for devices with newer firmware.","title":"OTA flashing"},{"location":"devices/RGB-Smart-Plug-16A/#prerequisites","text":"You'll need a Linux device with both WiFi capable of running in AP mode and ethernet connection Clone/download tuya-convert Run install_prereq.sh","title":"Prerequisites"},{"location":"devices/RGB-Smart-Plug-16A/#start-flashing","text":"Run start_flash.sh and follow the instructions Connect any WiFi device to vtrust-flash AP when it asks to and make sure that it gets an IP address. If it doesn't stop and check logs in scripts folder for clues Connect socket to mains and long-press the button to enter pairing mode Tasmota is included with tuya-convert, follow script's instruction to flash it After flashing device should reboot and you should see Tasmota's WiFi AP (Sonoff-xxx). Run stop_flash.sh to shutdown vtrust-flash AP on a machine you used for OTA.","title":"Start flashing"},{"location":"devices/RGB-Smart-Plug-16A/#configuration","text":"Connect to Tasmota's AP It's extremely important to enter correct WiFi configuration. Button is not on GPIO0 so won't do anything for default Sonoff Basic device profile. It's recommended to temporary enter second WiFi with something easy like SSID: TEST Password: testtest so you could start that AP and re-configure the device if there are any issues with main WiFi connection. After it reboots and successfully connects to WiFi configure it as Blizwolf SHP module Now button and relay should work. Red and Blue LEDs will be used as status LEDs.","title":"Configuration"},{"location":"devices/RGB-Smart-Plug-16A/#rgb-light","text":"Use this template to configure the device: {\"NAME\":\"RGB Smart Plug\",\"GPIO\":[37,0,39,0,38,134,0,0,131,17,132,21,0],\"FLAG\":0,\"BASE\":45} For older versions: Complete RGB support requires building slightly custom Tasmota. Edit sonoff/sonoff_template.h and replace \"BlitzWolf SHP\" configuration with the following: { \"BlitzWolf SHP\", // BlitzWolf BW-SHP2 and BW-SHP6 (ESP8285 - BL0937 or HJL-01 Energy Monitoring) // https://www.banggood.com/BlitzWolf-BW-SHP2-Smart-WIFI-Socket-EU-Plug-220V-16A-Work-with-Amazon-Alexa-Google-Assistant-p-1292899.html // https://www.amazon.de/Steckdose-Homecube-intelligente-Verbrauchsanzeige-funktioniert/dp/B076Q2LKHG/ref=sr_1_fkmr0_1 // https://www.amazon.de/Intelligente-Stromverbrauch-Fernsteurung-Schaltbare-Energieklasse/dp/B076WZQS4S/ref=sr_1_1 // https://www.aliexpress.com/store/product/BlitzWolf-BW-SHP6-EU-Plug-Metering-Version-WIFI-Smart-Socket-220V-240V-10A-Work-with-Amazon/1965360_32945504669.html GPIO_USER, // GPIO00 Red Led (1 = On, 0 = Off) GPIO_USER, // GPIO01 Serial RXD and Optional sensor GPIO_USER, // GPIO02 Blue Led (1 = On, 0 = Off) GPIO_USER, // GPIO03 Serial TXD and Optional sensor GPIO_USER, // GPIO04 GPIO_HJL_CF, // GPIO05 BL0937 or HJL-01 CF power 0, 0, 0, 0, 0, 0, // Flash connection GPIO_NRG_SEL_INV, // GPIO12 BL0937 or HJL-01 Sel output (0 = Voltage) GPIO_KEY1, // GPIO13 Button GPIO_NRG_CF1, // GPIO14 BL0937 or HJL-01 CF1 current / voltage GPIO_REL1, // GPIO15 Relay (0 = Off, 1 = On) 0, 0 }, Make sure that you don't have wrong WiFi configuration in user_config_override.h. Build and OTA flash it to the device using Tasmota. After it reboots configure as following: [[https://raw.githubusercontent.com/wiki/Astr0/Sonoff-Tasmota/images/lonsonho16a/config.png|Configuration]] RGB and dimming should work now.","title":"RGB Light"},{"location":"devices/RGB-Smart-Plug-16A/#disassembling-the-device","text":"This is not recommended. Do it only if you have to or just buy a new one. The device is hard to open and may be damaged. Components inside may have mains charge and electrocute you even if powered off. Do it at your own risk. One of my devices had a hardware issue - constantly losing WiFi, rebooted when wiggled in power socket, rebooted every few seconds on 1250W load, sometimes just hanged and not responded even to the button. Since it wasn't usable at all I tried to fix it. The reason was broken steel input pole inside(what?? how?? WTF??) that was making weak contact, couldn't fix it reliably. Unbend earth connections on the bottom to make them straight. Use a sharp knife to slice through glue between RGB ring and the case. Requires quite a lot of force and time. RGB ring may break in places where glue is stronger than the plastic. Use a screwdriver to pry the case open. Remove button cap Desolder output connections, try not to melt any plastic. Remove support plastic with a screwdriver, it's held to the PCB by two clips. Desolder input poles. This is tricky since there's a lot of solder. I've removed as much of it as possible with desoldering pump, then melted the solder and rotated the poles with pliers while it cooled. Poles are made of steel and steel don't accept solder well. Remove the PCB by lifting it up. It's glued to the case on the bottom by the relay and held tight with input poles so it requires some force. Also, it's not easy to grab the PCB. I've used dip removing tweezers, holding PCB by holes for the earth connectors. I figured out the pinout for flashing the device: Before assembling it back remove as much solder as possible from input and output pole pads. The device fits together very tight, so everything should be perfectly in place. Don't forget to glue the case back.","title":"Disassembling the device"},{"location":"devices/RGB-Smart-Plug-16A/#alternative-to-disasselmy-drilling-two-holes","text":"_With all this information at hand it is also possible to drill two simple holes into the case to get to the necesarry contact pads. I recommend a 6mm drill, carfully drill trough the case at he center of the ledge from the high power side opposite the power button. See pictures. Now you can solder on a few temporary flash cables. Don't forget to pull IO0 to GND to get into flash mode. Few observations: * It has ESP8266EX with FM25F08 8Mbit flash. The module has lots of connections, some of them have only pads without tracks on the main board. High chances to find RX and TX there. Obviously, there should be VCC and GND to power up the module. * Uses HJL-01 with a shunt for power monitoring, so every mains power track that looks like it should be covered with solder but is not, probably should be covered with solder :) * It has 4 RGB LEDs. GPIO00-Red, GPIO02-Blue, GPIO04-Green * AFE BPD-SS-105DM 16A 250VAC relay * 16A SMD fuse for mains input * Something that's probably another fuse marked F1 for low-voltage circuitry power * Low-voltage part is not galvanically insulated from mains * There's \"QC Passed\" sticker on the relay","title":"Alternative to disasselmy: Drilling two holes."},{"location":"devices/S1-Series---Wifi-Socket-S120-%28EU-model%29-chipset-TYWE2S/","text":"Model ~ There's no brand on this one, I got it for 11\u20ac on ebay as \"Wifi Smart Sans Fil T\u00e9l\u00e9commande Prise de Courant Pour T\u00e9l\u00e9phone Prise EU Plug\" from this seller . Flashing ~ As chipset is a TYWE2S , you'll have to connect GPIO0 (marked IO0) manually to the ground. There's better images than mines here and here on the wiki. Configuration ~ GPIO5: Relay1 (21) GPIO12: Led1 (52) GPIO14: Button1 (17)","title":"S1 Series   Wifi Socket S120 (EU model) chipset TYWE2S"},{"location":"devices/S1-Series---Wifi-Socket-S120-%28EU-model%29-chipset-TYWE2S/#model","text":"There's no brand on this one, I got it for 11\u20ac on ebay as \"Wifi Smart Sans Fil T\u00e9l\u00e9commande Prise de Courant Pour T\u00e9l\u00e9phone Prise EU Plug\" from this seller .","title":"Model"},{"location":"devices/S1-Series---Wifi-Socket-S120-%28EU-model%29-chipset-TYWE2S/#flashing","text":"As chipset is a TYWE2S , you'll have to connect GPIO0 (marked IO0) manually to the ground. There's better images than mines here and here on the wiki.","title":"Flashing"},{"location":"devices/S1-Series---Wifi-Socket-S120-%28EU-model%29-chipset-TYWE2S/#configuration","text":"GPIO5: Relay1 (21) GPIO12: Led1 (52) GPIO14: Button1 (17)","title":"Configuration"},{"location":"devices/SK03-Outdoor-Smart-Plug/","text":"SK03 Outdoor Smart Plug which can be found as different brand names on Amazon. The ESP8266 module inside is a TYWE3S by Tuya. The power monitoring is a HLW8012 much like the original Sonoff POW and other power monitoring modules. Pull the four rubber pads off the bottom to expose the screws and the unit opens up. Unscrew the small screws from the board and it comes out of the case. The relay is close to the soldering points on the Tuya module but it can be done if you are careful. GPIO0 is the button on the underside so you do not need to solder to that point, just hold the button during boot for your flashing process like you would with a Sonoff Basic. digiblurDIY did a livestream showing this device, soldering and flashing process (split in two videos): https://www.youtube.com/watch?v=C5_BqptJA_w and https://www.youtube.com/watch?v=ca7P9TR9r68 As of firmware 6.3.0.11, the SK03 is available for use in the module configuration. Information regarding the standard soldering and pinouts for the TYWE3S module: { \"SK03 Outdoor\", // Outdoor smart plug with power monitoring HLW8012 chip - https://www.amazon.com/gp/product/B07CG7MBPV GPIO_KEY1, // GPIO00 Button 0, 0, 0, GPIO_HLW_CF, // GPIO04 HLW8012 CF power GPIO_NRG_CF1, // GPIO05 HLW8012 CF1 current / voltage 0, 0, 0, 0, 0, 0, // Flash connection GPIO_NRG_SEL_INV, // GPIO12 HLW8012 CF Sel output (0 = Voltage) GPIO_LED2_INV, // GPIO13 Red Led (0 = On, 1 = Off) GPIO_LED1_INV, // GPIO14 Blue Led (0 = On, 1 = Off) GPIO_REL1, // GPIO15 Relay (0 = Off, 1 = On) 0, 0 }","title":"SK03 Outdoor Smart Plug"},{"location":"devices/SM-SO301/","text":"SM-SO301 with an FCC ID of 2AJ5F-SM-SO3015 has 4 mains power and 4 USB ports. Each mains power is independently controlled and the USB group is controllable via a solid state relay. The ESP8266 module inside is a TYWE3S by Tuya. Model purchased SM-SO301 (it seems to change on Amazon and other places, search for the model#). Other resellers may sell the same unit with various mains voltages/plug types. Also sold under the Vivitar name model HA-1007-ACD (US version). There is also an HA-1007-AU (AUS version). Product ~ Flashing and Configuration Pictures ~ Hold/Attach the GPIO0 wire/pin to ground during initial boot to flash. (TX pin to RX pin and RX pin to TX pin on USB flash adapter)","title":"SM SO301"},{"location":"devices/SM-SO301/#product","text":"","title":"Product"},{"location":"devices/SM-SO301/#flashing-and-configuration-pictures","text":"Hold/Attach the GPIO0 wire/pin to ground during initial boot to flash. (TX pin to RX pin and RX pin to TX pin on USB flash adapter)","title":"Flashing and Configuration Pictures"},{"location":"devices/SP108E-HardwareAnalysis/","text":"So far I analyzed it is equipped with these chips: ESP-12F STM32F-030C8T (Cortex M0) Winbond 25Q32 (EEPROM) 74HC245 XL1509 3.3E1 (Step down regulator) RX/TX of STM is connected to ESP. 74HC245 buffers the outputs ESP is connected to the STM RX/TX pins. No other connections seen. We can assume there is some firmware in the STM that does the low level connection to the LEDs. Question is how does the ESP communicate with the STM and what exactly does the STM at all. But we can mod the hardware so the ESP can talk to the LEDs. I made some pictures with phone and microscope. PCB Open the housing, see the red marks for the holders) RX/TX connection ESP to STM STM32F0 EEPROM Pins lead to the STM32F0 (Firmware flash? Debug?) ESP-12 and its pins Buffer chip 74HC245 Traces on bottom side from STM to HC245 (actually R3 and R4) For the hardware mod to make it working without the STM32F0, there are several ways: 1. Cut traces and add wires ~ We need to break one of the traces on the bottom of the PCB. Then connect GPIO4 of ESP-12 with R4. Also RX/TX connection between STM32F0 and ESP-12 need to be broken up. 2. Hold STM32F0 in reset ~ This is the simpler method, no cuts on the PCB required, just two additional wires. - NRST of STM32F0 to GND - IO4 of ESP-12 to R4 See here for details. Flashing prohibited ~ Major problem right now is that IO0 is directly connected to VCC, so we cannot bring ESP-12 into flash mode. Working on a solution.","title":"SP108E HardwareAnalysis"},{"location":"devices/SP108E-HardwareAnalysis/#1-cut-traces-and-add-wires","text":"We need to break one of the traces on the bottom of the PCB. Then connect GPIO4 of ESP-12 with R4. Also RX/TX connection between STM32F0 and ESP-12 need to be broken up.","title":"1. Cut traces and add wires"},{"location":"devices/SP108E-HardwareAnalysis/#2-hold-stm32f0-in-reset","text":"This is the simpler method, no cuts on the PCB required, just two additional wires. - NRST of STM32F0 to GND - IO4 of ESP-12 to R4 See here for details.","title":"2. Hold STM32F0 in reset"},{"location":"devices/SP108E-HardwareAnalysis/#flashing-prohibited","text":"Major problem right now is that IO0 is directly connected to VCC, so we cannot bring ESP-12 into flash mode. Working on a solution.","title":"Flashing prohibited"},{"location":"devices/SP108E-HardwareMod/","text":"Below is correct, but IO0 is directly connected to VCC, so we cannot bring ESP-12 into flash mode. Will check for some OTA mode that can be used. With just two additional wires we can use Tasmota with the SP108E. Analysis of the hardware The trick is to hold the STM32F0 controller in reset. Then we do not need to cut any traces on the PCB because all pins of the STM32F0 are inputs. Another warning: I did not yet proof it actually works, this is work in progress. Wire 1 - NRST (pin 7) of STM32F0 to GND Wire 2 - IO4 of ESP-12 to R4","title":"SP108E HardwareMod"},{"location":"devices/SP108E-LED-strip-controller/","text":"This is a controller for the WS2812 and similar LED chips (stripes). Prize is 13..15\u20ac at ebay. It uses another controller (STM32F0) to control CLK and Data lines to the LEDs tripes. Warning: Construction zone. To run Tasmota on it, we need to modify the hardware. See here for details. Currently not working, see HardwareMod for details: \"Other than that, the normal flash instruction for Tasmota do apply.\" SP108E","title":"SP108E LED strip controller"},{"location":"devices/SWB1-Smart-Power-Strip/","text":"Product ~ SWB1 Wi-Fi smart power strip with 4 main ports. Each port can be controlled manually FCCID: 2AJK8-SWB1 This is a new device not using the Tuya PCB but is a esp8266ex based and works great with Tasmota The product can be purchased on amazon.ca (could be found on other amazon sites) Inside ~ Inside PCB The chip used WT8266-S1. The specs can be found on wireless-tags.com JTAG ~ Pins used. You can choose one of 3 GND to your liking. the RESET(RST) pin is also marked for those that use that pin to reset the chip while flashing TASMOTA CONFIGURATION ~","title":"SWB1 Smart Power Strip"},{"location":"devices/SWB1-Smart-Power-Strip/#product","text":"SWB1 Wi-Fi smart power strip with 4 main ports. Each port can be controlled manually FCCID: 2AJK8-SWB1 This is a new device not using the Tuya PCB but is a esp8266ex based and works great with Tasmota The product can be purchased on amazon.ca (could be found on other amazon sites)","title":"Product"},{"location":"devices/SWB1-Smart-Power-Strip/#inside","text":"Inside PCB The chip used WT8266-S1. The specs can be found on wireless-tags.com","title":"Inside"},{"location":"devices/SWB1-Smart-Power-Strip/#jtag","text":"Pins used. You can choose one of 3 GND to your liking. the RESET(RST) pin is also marked for those that use that pin to reset the chip while flashing","title":"JTAG"},{"location":"devices/SWB1-Smart-Power-Strip/#tasmota-configuration","text":"","title":"TASMOTA CONFIGURATION"},{"location":"devices/Shelly-1/","text":"The Shelly 1 is supported in Tasmota from version 6.2.1.7 Allterco Shelly 1 Product Page Allterco Shelly 1 Shop \u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f ~ DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Shelly are connected to AC power! Only use a Shelly as designed. There is possibility to attach DS18B20 or other sensors BUT only using Digital Voltage Isolator For example the company sells Temperature Sensor AddOn for Shelly 1/1PM with DS18B20. This should not fool you, never ever attach any sensor directly to the GPIOs - this expansion board uses TexasInstruments ISO7221 for voltage isolation. More information and Tasmota support for the extension board at https://github.com/arendst/Tasmota/issues/7469. Do not connect AC power and the serial connection at the same time The GND connection of the Shelly is connected to the live AC wire. Connecting serial with your PC will fry your PC. Check the correct jumper position before connecting AC power to Shelly 1. If the jumper is set to 12V you will destroy your Shelly! An ESP8266 with 2MB flash single relay device 42mm \"round\" in size. Serial Connection ~ Shelly1 comes with a partially exposed programming/debug header which can be used to flash Tasmota on the device. A serial-to-USB adapter is needed as well as a reliable 3.3V source with at least 350 mA drive capability. The following diagram shows the device pinout and power source voltage selection jumper. Flash mode ~ To be able to flash the Tasmota firmware you need to get into flash mode. Therefore connect a wire from GPIO0 to ground. For further information have a look at Hardware Preparation . \u26a0\ufe0f\ufe0fWARNING\u26a0\ufe0f\ufe0f ~ Please note what version of the Shelly 1 you have (V1, V2 or V3). The V2 user guide is incorrect . The mains connections are as shown in the image above for all versions of the switch. The labels on the V2 switches are WRONG! Video tutorial by digiblurDIY ~ Video tutorial by BurnsHA ~","title":"Shelly 1"},{"location":"devices/Shelly-1/#special-shelly-attention","text":"DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Shelly are connected to AC power! Only use a Shelly as designed. There is possibility to attach DS18B20 or other sensors BUT only using Digital Voltage Isolator For example the company sells Temperature Sensor AddOn for Shelly 1/1PM with DS18B20. This should not fool you, never ever attach any sensor directly to the GPIOs - this expansion board uses TexasInstruments ISO7221 for voltage isolation. More information and Tasmota support for the extension board at https://github.com/arendst/Tasmota/issues/7469. Do not connect AC power and the serial connection at the same time The GND connection of the Shelly is connected to the live AC wire. Connecting serial with your PC will fry your PC. Check the correct jumper position before connecting AC power to Shelly 1. If the jumper is set to 12V you will destroy your Shelly! An ESP8266 with 2MB flash single relay device 42mm \"round\" in size.","title":"\u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f"},{"location":"devices/Shelly-1/#serial-connection","text":"Shelly1 comes with a partially exposed programming/debug header which can be used to flash Tasmota on the device. A serial-to-USB adapter is needed as well as a reliable 3.3V source with at least 350 mA drive capability. The following diagram shows the device pinout and power source voltage selection jumper.","title":"Serial Connection"},{"location":"devices/Shelly-1/#flash-mode","text":"To be able to flash the Tasmota firmware you need to get into flash mode. Therefore connect a wire from GPIO0 to ground. For further information have a look at Hardware Preparation .","title":"Flash mode"},{"location":"devices/Shelly-1/#warning","text":"Please note what version of the Shelly 1 you have (V1, V2 or V3). The V2 user guide is incorrect . The mains connections are as shown in the image above for all versions of the switch. The labels on the V2 switches are WRONG!","title":"\u26a0\ufe0f\ufe0fWARNING\u26a0\ufe0f\ufe0f"},{"location":"devices/Shelly-1/#video-tutorial-by-digiblurdiy","text":"","title":"Video tutorial by digiblurDIY"},{"location":"devices/Shelly-1/#video-tutorial-by-burnsha","text":"","title":"Video tutorial by BurnsHA"},{"location":"devices/Shelly-1PM/","text":"The Shelly 1PM is supported from Tasmota 6.5.0.10 using a template. Allterco Shelly 1PM Product Page Allterco Shelly 1PM Shop \u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f ~ DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Shelly are connected to AC power! Only use a Shelly as designed. Do not connect AC power and the serial connection at the same time The GND connection of the Shelly is connected to the live AC wire. Connecting serial with your PC will fry your PC. An ESP8266 with 2MB flash single relay device 42mm \"round\" in size. Serial Flashing ~ Shelly 1PM comes with a partially exposed programming/debug header which can be used to flash Tasmota on the device. A USB-to-UART adapter is needed as well as a reliable 3.3V with at least 350 mA drive capability. The following diagram shows the device pinout. Template ~ {\"NAME\":\"Shelly 1PM\",\"GPIO\":[56,0,0,0,82,134,0,0,0,0,0,21,0],\"FLAG\":2,\"BASE\":18} Calibration ~ Tasmota will disable serial logging after a restart as the communication between Tasmota and the Energy Monitoring chip is using the same serial interface. Make sure not to enable SerialLog as it will interfere with the Energy Monitoring functionality. To calibrate the Energy monitoring feature connect a known load and execute the commands shown below. Assumed an AC voltage of 240V, a resistive load of 60W and a line frequency of 50Hz. With a load of 60W the current should be 60W / 240V = 0.25A. FrequencySet 50.000 PowerSet 60.00 VoltageSet 240.0 CurrentSet 250.0 Pause a few seconds between executing the commands as the communication between Tasmota and the Energy Monitoring chip is a serial interface which can take over a second to complete.","title":"Shelly 1PM"},{"location":"devices/Shelly-1PM/#special-shelly-attention","text":"DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Shelly are connected to AC power! Only use a Shelly as designed. Do not connect AC power and the serial connection at the same time The GND connection of the Shelly is connected to the live AC wire. Connecting serial with your PC will fry your PC. An ESP8266 with 2MB flash single relay device 42mm \"round\" in size.","title":"\u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f"},{"location":"devices/Shelly-1PM/#serial-flashing","text":"Shelly 1PM comes with a partially exposed programming/debug header which can be used to flash Tasmota on the device. A USB-to-UART adapter is needed as well as a reliable 3.3V with at least 350 mA drive capability. The following diagram shows the device pinout.","title":"Serial Flashing"},{"location":"devices/Shelly-1PM/#template","text":"{\"NAME\":\"Shelly 1PM\",\"GPIO\":[56,0,0,0,82,134,0,0,0,0,0,21,0],\"FLAG\":2,\"BASE\":18}","title":"Template"},{"location":"devices/Shelly-1PM/#calibration","text":"Tasmota will disable serial logging after a restart as the communication between Tasmota and the Energy Monitoring chip is using the same serial interface. Make sure not to enable SerialLog as it will interfere with the Energy Monitoring functionality. To calibrate the Energy monitoring feature connect a known load and execute the commands shown below. Assumed an AC voltage of 240V, a resistive load of 60W and a line frequency of 50Hz. With a load of 60W the current should be 60W / 240V = 0.25A. FrequencySet 50.000 PowerSet 60.00 VoltageSet 240.0 CurrentSet 250.0 Pause a few seconds between executing the commands as the communication between Tasmota and the Energy Monitoring chip is a serial interface which can take over a second to complete.","title":"Calibration"},{"location":"devices/Shelly-2.5/","text":"The Shelly 2.5 is supported from Tasmota 6.5.0.8 using a template. Allterco Shelly 2.5 Product Page Allterco Shelly 2.5 Shop Shelly 2.5 Initial issue \u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f ~ DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Shelly are connected to AC power! Only use a Shelly as designed. Do not connect AC power and the serial connection at the same time The GND connection of the Shelly is connected to the live AC wire. Connecting serial with your PC will fry your PC. Shelly 2.5 ~ [!WARNING] Warning (April 10, 2019): This appears to affect a percentage of their entire first run production. Check your device before powering it on. An ESP8266 with 2MB flash dual relay device with Energy Monitoring. Slightly smaller than the original Shelly 2. Serial Connection ~ The Shelly 2.5 model comes with a partially exposed programming/debug header which can be used to flash Tasmota on the device. A USB-to-UART adapter is needed as well as a reliable 3.3V with at least 350 mA drive capability. The following diagram shows the device pinout and power source voltage selection jumper. The onboard connector is 1.27mm raster with 1mm diameter holes. Normal Dupont cables won't fit. To avoid damaging the pcb, use either a stripped 24 AWG Ethernet cable and breadboard as an adapter, or female header socket legs (see image below). The legs of a female header socket fit nicely. Solder them to custom-crimped Dupont wires for use with your USB-to-UART adapter. These often come with Wemos D1 Mini boards in multiple lengths. Otherwise you could simply buy an adapter that converts Dupont to 1.27mm raster at * tindie or * amazon Template ~ Tasmota 6.5.0.8 and higher supports Shelly 2.5 GPIO Component 0 LED1i 2 Button1 4 Relay1 5 Switch2n 12 I2C SDA 13 Switch1n 14 I2C SCL 15 Relay2 16 ADE7953 IRQ A0 Internal Temperature {\"NAME\":\"Shelly 2.5\",\"GPIO\":[56,0,17,0,21,83,0,0,6,82,5,22,156],\"FLAG\":2,\"BASE\":18} Energy metering is done by a ADE7953 chip connected via I2C and IRQ on GPIO16. If you connect momentary switches, use the following template: {\"NAME\":\"Shelly 2.5 (buttons)\",\"GPIO\":[56,0,19,0,21,127,0,0,6,126,5,22,156],\"FLAG\":2,\"BASE\":18} Button1 and Button2 are assigned to the SW1 and SW2 external inputs. Button3 is the button on the back of the device next to the pin header and you can optionally assign the behaviour you want using rules. If you want the buttons to respond instantly, go to the console and type SetOption13 1 . But, if you want press/double press/hold functionality, run instead Backlog SetOption1 1; SetOption11 1; SetOption32 20 to enable all three states and set hold time of 2 seconds. Use SetOption32 to set another hold time. If you want to see Voltage and Frequency also when the relays are off, use SetOption21 1 Flash mode ~ To be able to flash the Tasmota firmware you need to get into flash mode. Therefore connect a wire from GPIO0 to ground. For further information have a look at programming mode . Calibration ~ Tasmota will disable serial logging after a restart as the communication between Tasmota and the Energy Monitoring chip is using the same serial interface. Make sure not to enable SerialLog as it will interfere with the Energy Monitoring functionality. To calibrate the Energy monitoring feature connect a known load and execute the commands shown below. Assumed an AC voltage of 240V, a resistive load of 60W and a line frequency of 50Hz. With a load of 60W the current should be 60W / 240V = 0.25A. FrequencySet 50.000 PowerSet 60.00 VoltageSet 240.0 CurrentSet 250.0 Pause a few seconds between executing the commands as the communication between Tasmota and the energy monitoring chip is a serial interface which can take over a second to complete. Use rules to control shutter endpoints ~ As the Shelly 2.5 contains energy monitoring you can use rules to power off the shutter when too much current is drawn at the end point. This rule will power off both directions when the current becomes greater than 600mA. Before you activate the rule, let your shutter move and pay attention to the current value in the WebGUI. Note your value and add 0.050 to your value. After that, you change the value for the rule. Eg.: Your Value = 0.520 + 0.050 = 0.570 energy#current[X]>0.570 rule1 on energy#current[2]>0.600 do backlog power1 0;power2 0; endon on energy#current[1]>0.600 do backlog power1 0;power2 0 endon rule1 1 rule1 5 Use Shelly 2.5 device for Blinds and Shutters ~ Further Information: Blinds and Shutters Ghost switching ~ The Shelly 2.5 inputs appear to be notoriously susceptible to interference. Therefore ghost switching can happen if the wires are long (>1m / 3ft). If you experience this issue, you might want to experiment with the switch debounce delay. It is set to 50 milliseconds by default. Use command SwitchDebounce 100 to change it to a less sensitive value, which might work better. The value can be set up to 1000 milliseconds. Some issues were reported for this topic - search query Overheating ~ Due to the built-in temperature sensor, it is possible to switch off the relays when a certain temperature is exceeded. The limit for the original Shelly firmware seems to be around 95 \u00b0 C. Source The ambient temperature according to the manufacturer is between - 40 \u00b0 C up to 40 \u00b0 C Note It is set to 90 \u00b0 C This can be changed via SetOption42 . [!WARNING]It is absolutely not recommended to increase the limit.","title":"Shelly 2.5"},{"location":"devices/Shelly-2.5/#special-shelly-attention","text":"DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Shelly are connected to AC power! Only use a Shelly as designed. Do not connect AC power and the serial connection at the same time The GND connection of the Shelly is connected to the live AC wire. Connecting serial with your PC will fry your PC.","title":"\u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f"},{"location":"devices/Shelly-2.5/#shelly-25","text":"[!WARNING] Warning (April 10, 2019): This appears to affect a percentage of their entire first run production. Check your device before powering it on. An ESP8266 with 2MB flash dual relay device with Energy Monitoring. Slightly smaller than the original Shelly 2.","title":"Shelly 2.5"},{"location":"devices/Shelly-2.5/#serial-connection","text":"The Shelly 2.5 model comes with a partially exposed programming/debug header which can be used to flash Tasmota on the device. A USB-to-UART adapter is needed as well as a reliable 3.3V with at least 350 mA drive capability. The following diagram shows the device pinout and power source voltage selection jumper. The onboard connector is 1.27mm raster with 1mm diameter holes. Normal Dupont cables won't fit. To avoid damaging the pcb, use either a stripped 24 AWG Ethernet cable and breadboard as an adapter, or female header socket legs (see image below). The legs of a female header socket fit nicely. Solder them to custom-crimped Dupont wires for use with your USB-to-UART adapter. These often come with Wemos D1 Mini boards in multiple lengths. Otherwise you could simply buy an adapter that converts Dupont to 1.27mm raster at * tindie or * amazon","title":"Serial Connection"},{"location":"devices/Shelly-2.5/#template","text":"Tasmota 6.5.0.8 and higher supports Shelly 2.5 GPIO Component 0 LED1i 2 Button1 4 Relay1 5 Switch2n 12 I2C SDA 13 Switch1n 14 I2C SCL 15 Relay2 16 ADE7953 IRQ A0 Internal Temperature {\"NAME\":\"Shelly 2.5\",\"GPIO\":[56,0,17,0,21,83,0,0,6,82,5,22,156],\"FLAG\":2,\"BASE\":18} Energy metering is done by a ADE7953 chip connected via I2C and IRQ on GPIO16. If you connect momentary switches, use the following template: {\"NAME\":\"Shelly 2.5 (buttons)\",\"GPIO\":[56,0,19,0,21,127,0,0,6,126,5,22,156],\"FLAG\":2,\"BASE\":18} Button1 and Button2 are assigned to the SW1 and SW2 external inputs. Button3 is the button on the back of the device next to the pin header and you can optionally assign the behaviour you want using rules. If you want the buttons to respond instantly, go to the console and type SetOption13 1 . But, if you want press/double press/hold functionality, run instead Backlog SetOption1 1; SetOption11 1; SetOption32 20 to enable all three states and set hold time of 2 seconds. Use SetOption32 to set another hold time. If you want to see Voltage and Frequency also when the relays are off, use SetOption21 1","title":"Template"},{"location":"devices/Shelly-2.5/#flash-mode","text":"To be able to flash the Tasmota firmware you need to get into flash mode. Therefore connect a wire from GPIO0 to ground. For further information have a look at programming mode .","title":"Flash mode"},{"location":"devices/Shelly-2.5/#calibration","text":"Tasmota will disable serial logging after a restart as the communication between Tasmota and the Energy Monitoring chip is using the same serial interface. Make sure not to enable SerialLog as it will interfere with the Energy Monitoring functionality. To calibrate the Energy monitoring feature connect a known load and execute the commands shown below. Assumed an AC voltage of 240V, a resistive load of 60W and a line frequency of 50Hz. With a load of 60W the current should be 60W / 240V = 0.25A. FrequencySet 50.000 PowerSet 60.00 VoltageSet 240.0 CurrentSet 250.0 Pause a few seconds between executing the commands as the communication between Tasmota and the energy monitoring chip is a serial interface which can take over a second to complete.","title":"Calibration"},{"location":"devices/Shelly-2.5/#use-rules-to-control-shutter-endpoints","text":"As the Shelly 2.5 contains energy monitoring you can use rules to power off the shutter when too much current is drawn at the end point. This rule will power off both directions when the current becomes greater than 600mA. Before you activate the rule, let your shutter move and pay attention to the current value in the WebGUI. Note your value and add 0.050 to your value. After that, you change the value for the rule. Eg.: Your Value = 0.520 + 0.050 = 0.570 energy#current[X]>0.570 rule1 on energy#current[2]>0.600 do backlog power1 0;power2 0; endon on energy#current[1]>0.600 do backlog power1 0;power2 0 endon rule1 1 rule1 5","title":"Use rules to control shutter endpoints"},{"location":"devices/Shelly-2.5/#use-shelly-25-device-for-blinds-and-shutters","text":"Further Information: Blinds and Shutters","title":"Use Shelly 2.5 device for Blinds and Shutters"},{"location":"devices/Shelly-2.5/#ghost-switching","text":"The Shelly 2.5 inputs appear to be notoriously susceptible to interference. Therefore ghost switching can happen if the wires are long (>1m / 3ft). If you experience this issue, you might want to experiment with the switch debounce delay. It is set to 50 milliseconds by default. Use command SwitchDebounce 100 to change it to a less sensitive value, which might work better. The value can be set up to 1000 milliseconds. Some issues were reported for this topic - search query","title":"Ghost switching"},{"location":"devices/Shelly-2.5/#overheating","text":"Due to the built-in temperature sensor, it is possible to switch off the relays when a certain temperature is exceeded. The limit for the original Shelly firmware seems to be around 95 \u00b0 C. Source The ambient temperature according to the manufacturer is between - 40 \u00b0 C up to 40 \u00b0 C Note It is set to 90 \u00b0 C This can be changed via SetOption42 . [!WARNING]It is absolutely not recommended to increase the limit.","title":"Overheating"},{"location":"devices/Shelly-2/","text":"Shelly 2 is discontinued and replaced by Shelly 2.5 The Shelly 2 is fully supported in Tasmota from version 6.2.1.7 \u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f ~ DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Shelly are connected to AC power! Only use a Shelly as designed. Do not connect AC power and the serial connection at the same time The GND connection of the Shelly is connected to the live AC wire. Connecting serial with your PC will fry your PC. Check the correct jumper position before connecting AC power to Shelly 1. If the jumper is set to 12V you will destroy your Shelly! Shelly 2 ~ An ESP8266 with 2MB flash dual relay device with Energy Monitoring the size of round 45mm. Templates as of v6.4.1.17 ~ The inbuilt template equals the following: {\"NAME\":\"Shelly 2\",\"GPIO\":[0,135,0,136,21,22,0,0,9,0,10,137,0],\"FLAG\":0,\"BASE\":47} An alternative template without switch pull-up is: {\"NAME\":\"Shelly 2n\",\"GPIO\":[0,135,0,136,21,22,0,0,82,0,83,137,0],\"FLAG\":0,\"BASE\":47} Pullup or no pullup ~ The shelly 2 inputs may or may not need pullups for SW1 and SW2 to work correctly. Default state is pullups enabled. To disable pullups either use command SetOption62 1 or select the option from the GUI. Refer to the following issue: https://github.com/arendst/Tasmota/issues/4841","title":"Shelly 2"},{"location":"devices/Shelly-2/#special-shelly-attention","text":"DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Shelly are connected to AC power! Only use a Shelly as designed. Do not connect AC power and the serial connection at the same time The GND connection of the Shelly is connected to the live AC wire. Connecting serial with your PC will fry your PC. Check the correct jumper position before connecting AC power to Shelly 1. If the jumper is set to 12V you will destroy your Shelly!","title":"\u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f"},{"location":"devices/Shelly-2/#shelly-2","text":"An ESP8266 with 2MB flash dual relay device with Energy Monitoring the size of round 45mm.","title":"Shelly 2"},{"location":"devices/Shelly-2/#templates-as-of-v64117","text":"The inbuilt template equals the following: {\"NAME\":\"Shelly 2\",\"GPIO\":[0,135,0,136,21,22,0,0,9,0,10,137,0],\"FLAG\":0,\"BASE\":47} An alternative template without switch pull-up is: {\"NAME\":\"Shelly 2n\",\"GPIO\":[0,135,0,136,21,22,0,0,82,0,83,137,0],\"FLAG\":0,\"BASE\":47}","title":"Templates as of v6.4.1.17"},{"location":"devices/Shelly-2/#pullup-or-no-pullup","text":"The shelly 2 inputs may or may not need pullups for SW1 and SW2 to work correctly. Default state is pullups enabled. To disable pullups either use command SetOption62 1 or select the option from the GUI. Refer to the following issue: https://github.com/arendst/Tasmota/issues/4841","title":"Pullup or no pullup"},{"location":"devices/Shelly-RGBW2/","text":"The Shelly RGBW2 is supported by using a template. Allterco Shelly RGBW2 Product Page Allterco Shelly RGBW2 Shop \u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f ~ DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) There is no galvanic isolation between the DC Inputs and the GPIOs. Do not connect AC/DC power and the serial connection at the same time! Only use a Shelly as designed. Shelly RGBW2 ~ An ESP8266 with 2MB flash LED Controller. - Support any 12v or 24v White, RGB, RGBW led strips and 12/24v led bulbs, with up to 288W combined power - Support 4 ways PWM, applied to control 4 colors LED(R/G/B/W), meet a requirement for colored lights, color temperature lights, and general lights - A separate 12V/24V power supply unit is required. - 12V => 144W combined / 45W p. Channel - 24V => 288W combined / 90W p. Channel Serial Connection ~ The Shelly RGBW2 model comes with a partially exposed programming/debug header which can be used to flash Tasmota on the device. A USB-to-UART adapter is needed as well as a reliable 3.3V with at least 350 mA drive capability. The following diagram shows the device pinout. The onboard connector is 1.27mm raster with 1mm diameter holes. Normal Dupont cables won't fit. To avoid damaging the pcb, use either a stripped Ethernet cable and breadboard as an adapter, or female header socket legs (see image below). The legs of a female header socket fit nicely. Solder them to custom-crimped Dupont wires for use with your USB-to-UART adapter. These often come with Wemos D1 Mini boards in multiple lengths. Template ~ GPIO Component 0 None 1 None 2 LEDLink 3 None 4 PWM4 5 USER 9 None 10 None 12 PWM1 13 Button1 14 PWM3 15 PWM2 16 None A0 OpAmp Current Monitor Template: {\"NAME\":\"ShellyRGBW2\",\"GPIO\":[0,0,157,0,40,89,0,0,37,17,39,38,0],\"FLAG\":7,\"BASE\":18} Energy metering is done by a LM321 OpAmp (1mOhm Shunt lowside) via ADC0 . If you want to use a push button, you should take a look at the Button & Switches. If you want the buttons to respond instantly, go to the console and type SetOption13 1 . But, if you want press/double press/hold functionality, run instead Backlog SetOption1 1; SetOption11 1; SetOption32 20 to enable all three states and set hold time of 2 seconds. Use SetOption32 to set another hold time. Flash mode ~ To be able to flash the Tasmota firmware you need to get into flash mode. Therefore connect a wire from GPIO0 to ground. For further information have a look at programming mode . Calibration ~ After successfully flashing Tasmota and selecting the template for the Shelly RGBW2, you can start configuring the power consumption. Disconnect the GPIOs and connect the Shelly RGBW to its future power supply. Set ADC0 to Analog in the template settings . Save this setting. After restarting, you will find the acutal ADC Value of the analog input in the main menu. There should be no light on at this time. Make a note of this value. Its the baseValue. In the template settings, set ADC0 to CT-POWER and save the settings. Use the AdcParam command: AdcParam 7, baseValue, Multiplcator, Voltage in the webconsole. For a 12VDC PowerSupply and a baseValue of 407 this lines looks like this: AdcParam 7, 407, 3282, 0.012 If there are no lights on, the Main Menu should show only the Voltage but no consumption. Connect a light source with a current consumption known to you. Or measure the current with a multimeter. Compare the displayed values in the menu and those of your meter. Please note that the measurement of the Shelly RGBW2 is very inaccurate due to its electrical construction. Tip In case the values do not fit at all, you have to perform a recalibration. Set the ADC0 input back to analog. Note the base value when the light is switched off. Switch on the light and note the displayed analog value (comparison value) and the current value displayed by your meter (real value). Calculate: (ComparisonValue-baseValue)*100/realValue = Multiplicator Example BaseValue 407, ComparisonValue 455, realValue=1.5A (455-407)*100/1,5 = 3200 Set the ADC0 input back to CT-Power and start at 4. of the previous list. Use rules to control both switches ~ If SetOption37 is set to 128 the RGB and White is splited. To switch both RGB and W on/off with the connected hardware switch, you can use this Rule: rule1 on power1#state do power2 %value% endon rule1 1 Ghost switching ~ The Shelly 2.5 inputs appear to be notoriously susceptible to interference. Therefore ghost switching can happen if the wires are long (>1m / 3ft). If you experience this issue, you might want to experiment with the switch debounce delay. It is set to 50 milliseconds by default. Use command SwitchDebounce 100 to change it to a less sensitive value, which might work better. The value be set up to 1000 milliseconds. Some issues were reported for this topic - search query Light setup ~ Please read: Lights .","title":"Shelly RGBW2"},{"location":"devices/Shelly-RGBW2/#special-shelly-attention","text":"DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) There is no galvanic isolation between the DC Inputs and the GPIOs. Do not connect AC/DC power and the serial connection at the same time! Only use a Shelly as designed.","title":"\u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f"},{"location":"devices/Shelly-RGBW2/#shelly-rgbw2","text":"An ESP8266 with 2MB flash LED Controller. - Support any 12v or 24v White, RGB, RGBW led strips and 12/24v led bulbs, with up to 288W combined power - Support 4 ways PWM, applied to control 4 colors LED(R/G/B/W), meet a requirement for colored lights, color temperature lights, and general lights - A separate 12V/24V power supply unit is required. - 12V => 144W combined / 45W p. Channel - 24V => 288W combined / 90W p. Channel","title":"Shelly RGBW2"},{"location":"devices/Shelly-RGBW2/#serial-connection","text":"The Shelly RGBW2 model comes with a partially exposed programming/debug header which can be used to flash Tasmota on the device. A USB-to-UART adapter is needed as well as a reliable 3.3V with at least 350 mA drive capability. The following diagram shows the device pinout. The onboard connector is 1.27mm raster with 1mm diameter holes. Normal Dupont cables won't fit. To avoid damaging the pcb, use either a stripped Ethernet cable and breadboard as an adapter, or female header socket legs (see image below). The legs of a female header socket fit nicely. Solder them to custom-crimped Dupont wires for use with your USB-to-UART adapter. These often come with Wemos D1 Mini boards in multiple lengths.","title":"Serial Connection"},{"location":"devices/Shelly-RGBW2/#template","text":"GPIO Component 0 None 1 None 2 LEDLink 3 None 4 PWM4 5 USER 9 None 10 None 12 PWM1 13 Button1 14 PWM3 15 PWM2 16 None A0 OpAmp Current Monitor Template: {\"NAME\":\"ShellyRGBW2\",\"GPIO\":[0,0,157,0,40,89,0,0,37,17,39,38,0],\"FLAG\":7,\"BASE\":18} Energy metering is done by a LM321 OpAmp (1mOhm Shunt lowside) via ADC0 . If you want to use a push button, you should take a look at the Button & Switches. If you want the buttons to respond instantly, go to the console and type SetOption13 1 . But, if you want press/double press/hold functionality, run instead Backlog SetOption1 1; SetOption11 1; SetOption32 20 to enable all three states and set hold time of 2 seconds. Use SetOption32 to set another hold time.","title":"Template"},{"location":"devices/Shelly-RGBW2/#flash-mode","text":"To be able to flash the Tasmota firmware you need to get into flash mode. Therefore connect a wire from GPIO0 to ground. For further information have a look at programming mode .","title":"Flash mode"},{"location":"devices/Shelly-RGBW2/#calibration","text":"After successfully flashing Tasmota and selecting the template for the Shelly RGBW2, you can start configuring the power consumption. Disconnect the GPIOs and connect the Shelly RGBW to its future power supply. Set ADC0 to Analog in the template settings . Save this setting. After restarting, you will find the acutal ADC Value of the analog input in the main menu. There should be no light on at this time. Make a note of this value. Its the baseValue. In the template settings, set ADC0 to CT-POWER and save the settings. Use the AdcParam command: AdcParam 7, baseValue, Multiplcator, Voltage in the webconsole. For a 12VDC PowerSupply and a baseValue of 407 this lines looks like this: AdcParam 7, 407, 3282, 0.012 If there are no lights on, the Main Menu should show only the Voltage but no consumption. Connect a light source with a current consumption known to you. Or measure the current with a multimeter. Compare the displayed values in the menu and those of your meter. Please note that the measurement of the Shelly RGBW2 is very inaccurate due to its electrical construction. Tip In case the values do not fit at all, you have to perform a recalibration. Set the ADC0 input back to analog. Note the base value when the light is switched off. Switch on the light and note the displayed analog value (comparison value) and the current value displayed by your meter (real value). Calculate: (ComparisonValue-baseValue)*100/realValue = Multiplicator Example BaseValue 407, ComparisonValue 455, realValue=1.5A (455-407)*100/1,5 = 3200 Set the ADC0 input back to CT-Power and start at 4. of the previous list.","title":"Calibration"},{"location":"devices/Shelly-RGBW2/#use-rules-to-control-both-switches","text":"If SetOption37 is set to 128 the RGB and White is splited. To switch both RGB and W on/off with the connected hardware switch, you can use this Rule: rule1 on power1#state do power2 %value% endon rule1 1","title":"Use rules to control both switches"},{"location":"devices/Shelly-RGBW2/#ghost-switching","text":"The Shelly 2.5 inputs appear to be notoriously susceptible to interference. Therefore ghost switching can happen if the wires are long (>1m / 3ft). If you experience this issue, you might want to experiment with the switch debounce delay. It is set to 50 milliseconds by default. Use command SwitchDebounce 100 to change it to a less sensitive value, which might work better. The value be set up to 1000 milliseconds. Some issues were reported for this topic - search query","title":"Ghost switching"},{"location":"devices/Shelly-RGBW2/#light-setup","text":"Please read: Lights .","title":"Light setup"},{"location":"devices/Slitinto-NX-SP202/","text":"indirectly supported as configuration of Digoo NX-SP202 seems to work fine Device can switch 2 individual plugs. It has a builtin metering sensor which measures power consumption of the sum of both. My 2 devices I bought at Amazon have ROHS and CE signs and are officially valid for a maximum of 16A. You can buy it at Amazon According to the template configuration the device seems to be compatible with Digoo NX-SP202 Configuration ~ Currently Slitinto is not present as separate module but DIGOO NX-SP202 seems to work. I had to adjust voltage and current with the following commands in the console * command VoltageSet 233 // measured with a multimeter * command CurrentSet 171 // known milliampere of my reference (here lightbulb of 40watts) This calibration is potentially individual for every device so I would suggest to calibrate it with a known power consuming device like a good old light bulb where the wattage is well known. Flashing ~ Disassembly ~ The device has no screws but disassembling as not needed as you can flash it OTA using tuya-convert. Nevertheless one user described a method to \"crack\" it using a rubber hammer and then glue it together again with no visible defects. Pinout ~ Not known. Procedure ~ Here is described how to crack the device but also how to flash it OTA. Miscellaneous ~ I use metering capable devices to observe the power consumption and execute rule based behaviour on base of the consumption values. i.e.: if the power consumption is lower than 10W for 30min (checked every 60 seconds) then switch off. My script for this looks like this: * rule1 on Energy#Power>10 do backlog ruletimer1 1800; ruletimer2 60; rule1 off; endon * rule2 on rules#timer=1 do power2 off endon * rule3 on rules#timer=2 do rule1 on endon * rule1 on * rule2 on * rule3 on","title":"Slitinto NX SP202"},{"location":"devices/Slitinto-NX-SP202/#configuration","text":"Currently Slitinto is not present as separate module but DIGOO NX-SP202 seems to work. I had to adjust voltage and current with the following commands in the console * command VoltageSet 233 // measured with a multimeter * command CurrentSet 171 // known milliampere of my reference (here lightbulb of 40watts) This calibration is potentially individual for every device so I would suggest to calibrate it with a known power consuming device like a good old light bulb where the wattage is well known.","title":"Configuration"},{"location":"devices/Slitinto-NX-SP202/#flashing","text":"","title":"Flashing"},{"location":"devices/Slitinto-NX-SP202/#disassembly","text":"The device has no screws but disassembling as not needed as you can flash it OTA using tuya-convert. Nevertheless one user described a method to \"crack\" it using a rubber hammer and then glue it together again with no visible defects.","title":"Disassembly"},{"location":"devices/Slitinto-NX-SP202/#pinout","text":"Not known.","title":"Pinout"},{"location":"devices/Slitinto-NX-SP202/#procedure","text":"Here is described how to crack the device but also how to flash it OTA.","title":"Procedure"},{"location":"devices/Slitinto-NX-SP202/#miscellaneous","text":"I use metering capable devices to observe the power consumption and execute rule based behaviour on base of the consumption values. i.e.: if the power consumption is lower than 10W for 30min (checked every 60 seconds) then switch off. My script for this looks like this: * rule1 on Energy#Power>10 do backlog ruletimer1 1800; ruletimer2 60; rule1 off; endon * rule2 on rules#timer=1 do power2 off endon * rule3 on rules#timer=2 do rule1 on endon * rule1 on * rule2 on * rule3 on","title":"Miscellaneous"},{"location":"devices/Smart-Light-Switch--SS118-01K1/","text":"Generic Smart Light Switch from Amazon TYWE3S Model - In Canada ESP8266-S1 Model - August 2019 Product ~ Pins ~ Module Configuration ~ New Version - August 2019 Product ~ Pins ~ Module Configuration ~ GPIO Tasmota Component Device Function 0 LedLink (157) Red LED 2 Button1 (17) Button 12 LED1i (56) Green LED 15 Relay1 (21) Relay","title":"Smart Light Switch  SS118 01K1"},{"location":"devices/Smart-Light-Switch--SS118-01K1/#product","text":"","title":"Product"},{"location":"devices/Smart-Light-Switch--SS118-01K1/#pins","text":"","title":"Pins"},{"location":"devices/Smart-Light-Switch--SS118-01K1/#module-configuration","text":"New Version - August 2019","title":"Module Configuration"},{"location":"devices/Smart-Light-Switch--SS118-01K1/#product_1","text":"","title":"Product"},{"location":"devices/Smart-Light-Switch--SS118-01K1/#pins_1","text":"","title":"Pins"},{"location":"devices/Smart-Light-Switch--SS118-01K1/#module-configuration_1","text":"GPIO Tasmota Component Device Function 0 LedLink (157) Red LED 2 Button1 (17) Button 12 LED1i (56) Green LED 15 Relay1 (21) Relay","title":"Module Configuration"},{"location":"devices/SmartHome/","text":"Connection ~ Vcc - 3,3V TX - RX RX - TX GND - GND Additional Information ~ SmartHome is a cheap Sonoff Basic clone, but they still work with Tasmota. More Infos can be found here: #1474 . Device Images ~ Generic Module Config ~ ESP Module ~ The module being used in this device is the esp8266-s3","title":"SmartHome"},{"location":"devices/SmartHome/#connection","text":"Vcc - 3,3V TX - RX RX - TX GND - GND","title":"Connection"},{"location":"devices/SmartHome/#additional-information","text":"SmartHome is a cheap Sonoff Basic clone, but they still work with Tasmota. More Infos can be found here: #1474 .","title":"Additional Information"},{"location":"devices/SmartHome/#device-images","text":"","title":"Device Images"},{"location":"devices/SmartHome/#generic-module-config","text":"","title":"Generic Module Config"},{"location":"devices/SmartHome/#esp-module","text":"The module being used in this device is the esp8266-s3","title":"ESP Module"},{"location":"devices/SmartPlug-with-POW/","text":"Smart Plugs from Amazon with same internal parts: - AISIRER - AVATAR Device: ~ solid design with 16A Relays 8 MB memory chip 2 LEDs POW function (unfortunately did not test yet, need help) very small size, easy to disassemble no need to disassemble PCBs test mode works with 5 or 3.3 V (relays also works) Disassemble * take off the lead with 2 screws * put small cross screwdriver inside 220V plug connector, there are 2 screws * free the antenna from plastic (no need to disconnect) * pull of PCB from the case Important build flags. * in Platformio for Tasmota flag change from 1MB to 8MB is needed, otherwise flash fails. build_flags = ${esp82xx_defaults.build_flags} -Wl,-Teagle.flash.8m.ld * in Arduino IDE: board selected - \"Node MCU 1.0\", standard Found how some of PINS are linked to main PCB and are easy to connect for flashing PCB Flashing: ~ I've decided to use 5V - there is a painted pad on the PCB, clean it and attach 5V (see image) * Connect GPIO0 to GND * Connect RX, TX * Connect 5V and GND * Connect USB to PC, start flashing Tasmota WEB config (Generic) * GPIO0 - Led1i * GPIO2 - Led2i * GPIO5 - HLW8012 CF * GPIO12 - HLWBLSELi * GPIO13 - Button1 * GPIO14 - HLWBL CF1 * GPIO15- Relais1 webconfig IMPORTANT: in order to have an accurate measurement of Voltage/Current/Power, you have to calibrate the internal meter with a well know load (like lamp or hair dryer) using this detailed procedure . Update from my side ~ I managed to flash two Aisirer plugs using pre-compiled tasmota.binaries, since my plugs had only 1M flash. I used 3.3V connected directly to the ESP board. I had some trouble with WLAN connectivity which caused the relays to pulse, so I switched to 2.3.0 core, which seems default again since a few releases. This runs quite well. Configure as BlitzWolf SHP(45) Module and also the power measurement is working. Update from nos86 ~ I have updated the guide in order to interface Tasmota with the power meter inside smart plug (tested only on AISIRER) and added the link for the power monitoring calibration","title":"SmartPlug with POW"},{"location":"devices/SmartPlug-with-POW/#device","text":"solid design with 16A Relays 8 MB memory chip 2 LEDs POW function (unfortunately did not test yet, need help) very small size, easy to disassemble no need to disassemble PCBs test mode works with 5 or 3.3 V (relays also works) Disassemble * take off the lead with 2 screws * put small cross screwdriver inside 220V plug connector, there are 2 screws * free the antenna from plastic (no need to disconnect) * pull of PCB from the case Important build flags. * in Platformio for Tasmota flag change from 1MB to 8MB is needed, otherwise flash fails. build_flags = ${esp82xx_defaults.build_flags} -Wl,-Teagle.flash.8m.ld * in Arduino IDE: board selected - \"Node MCU 1.0\", standard Found how some of PINS are linked to main PCB and are easy to connect for flashing PCB","title":"Device:"},{"location":"devices/SmartPlug-with-POW/#flashing","text":"I've decided to use 5V - there is a painted pad on the PCB, clean it and attach 5V (see image) * Connect GPIO0 to GND * Connect RX, TX * Connect 5V and GND * Connect USB to PC, start flashing Tasmota WEB config (Generic) * GPIO0 - Led1i * GPIO2 - Led2i * GPIO5 - HLW8012 CF * GPIO12 - HLWBLSELi * GPIO13 - Button1 * GPIO14 - HLWBL CF1 * GPIO15- Relais1 webconfig IMPORTANT: in order to have an accurate measurement of Voltage/Current/Power, you have to calibrate the internal meter with a well know load (like lamp or hair dryer) using this detailed procedure .","title":"Flashing:"},{"location":"devices/SmartPlug-with-POW/#update-from-my-side","text":"I managed to flash two Aisirer plugs using pre-compiled tasmota.binaries, since my plugs had only 1M flash. I used 3.3V connected directly to the ESP board. I had some trouble with WLAN connectivity which caused the relays to pulse, so I switched to 2.3.0 core, which seems default again since a few releases. This runs quite well. Configure as BlitzWolf SHP(45) Module and also the power measurement is working.","title":"Update from my side"},{"location":"devices/SmartPlug-with-POW/#update-from-nos86","text":"I have updated the guide in order to interface Tasmota with the power meter inside smart plug (tested only on AISIRER) and added the link for the power monitoring calibration","title":"Update from nos86"},{"location":"devices/Sonoff-4CH-DIY/","text":"Sonoff 4CH DIY Itead Shop: https://www.itead.cc/psf-b85.html Itead Wiki: https://www.itead.cc/wiki/PSF-B85 The Sonoff 4CH DIY is based on the ESP8285. Serial Connection ~ Sonoff 4CH DIY ~ Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) can be seen in the picture. Programming the Sonoff 4CH DIY is a breeze although the on-board-button is not connected to GPIO0. As with all ESP8266/ESP8285 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. Luckily both GND and GPIO0 (as KEY 1) are available on the header. A simple jumper between GND and KEY 1 while programming will do. Module parameters ~ Type ~ Module Type => Generic (18) Restart the module. GPIO9 & GPIO10 ~ To use GPIO9 and GPIO10 of the ESP8285, open the consol and enter => \"SetOption51 on\". Restart the module. Assign inputs and outputs ~ GPIO 1 => Button 1 (17) GPIO 9 => Button 2 (18) GPIO 10 => Button 3 (19) GPIO 14 => Button 4 (20) GPIO 12 => relay 1 (21) GPIO 5 => relay 2 (22) GPIO 4 => relay 3 (23) GPIO 15 => relay 4 (24) GPIO 13 => LED 1 (52)","title":"Sonoff 4CH DIY"},{"location":"devices/Sonoff-4CH-DIY/#serial-connection","text":"","title":"Serial Connection"},{"location":"devices/Sonoff-4CH-DIY/#sonoff-4ch-diy","text":"Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) can be seen in the picture. Programming the Sonoff 4CH DIY is a breeze although the on-board-button is not connected to GPIO0. As with all ESP8266/ESP8285 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. Luckily both GND and GPIO0 (as KEY 1) are available on the header. A simple jumper between GND and KEY 1 while programming will do.","title":"Sonoff 4CH DIY"},{"location":"devices/Sonoff-4CH-DIY/#module-parameters","text":"","title":"Module parameters"},{"location":"devices/Sonoff-4CH-DIY/#type","text":"Module Type => Generic (18) Restart the module.","title":"Type"},{"location":"devices/Sonoff-4CH-DIY/#gpio9-gpio10","text":"To use GPIO9 and GPIO10 of the ESP8285, open the consol and enter => \"SetOption51 on\". Restart the module.","title":"GPIO9 &amp; GPIO10"},{"location":"devices/Sonoff-4CH-DIY/#assign-inputs-and-outputs","text":"GPIO 1 => Button 1 (17) GPIO 9 => Button 2 (18) GPIO 10 => Button 3 (19) GPIO 14 => Button 4 (20) GPIO 12 => relay 1 (21) GPIO 5 => relay 2 (22) GPIO 4 => relay 3 (23) GPIO 15 => relay 4 (24) GPIO 13 => LED 1 (52)","title":"Assign inputs and outputs"},{"location":"devices/Sonoff-4CH-Pro/","text":"Compared to the 4CH the main differences/improvements of the 4CH Pro are: Relays are isolated from mains and can each switch their own circuit (mains or low voltage). With stock firmware special modes are supported (stand-alone schedules, inching, interlocking). RF receiver (optional key fob or Sonoff RF Bridge 433 required). Dual microcontroller, both a ESP8285 and a STM32. Serial Flashing ~ Sonoff 4CH Pro ~ The \"FW/IO0\" button (Switch 1) is not directly connected to GPIO0 of the ESP module. A different method has to be used to program this board. To program the ESP chip disconnect power from the board, connect a cable from any Ground (GND) pin to the GPIO0 pin on the ESP (be careful not to touch any of the other pins). This is the second pin to the right on the top row of pins (see picture). While holding the pin connected power on the board. The board does not respond to any button pressed when in programming mode and LED 1, 2 and 3 are on (might differ per board). Use the ESP programming header as described in the picture to upload the firmware and follow regular programming procedure. Sonoff 4CH Pro R2 ~ On the R2 module the GPIO0 pin is broken out to a small pad to the right of the ESP package : If you have 4CH R2 v1.0 hardware, the GPIO0 is available as L1 switch - you don't need to solder additional cable to the PCB. Just push it during powering on for 3 seconds and release. Solving Sonoff 4CH Pro programing issues ~ If you have problems to program the 4CH Pro, you might find below tips useful: * Use the ESP program header and ensure that the right port is set in the Arduino IDE. * TX/RX are printed correctly on the pro version => TX goes to RX PIN and RX to TX. * GPIO0 needs to be connected to ground the first 3 seconds during reboot (or longer)! If not you can not program it. * On 4CH Pro R2 try switch S6 to 0 before connecting power to enter flash mode. Reset to 1 (default) after finished flashing. If you use Windows7+, check in the device manager if the port is not added/removed all 2 seconds. If yes then your USB port does not deliver enough ampere. And/Or reduce upload speed to 57600 in Arduino IDE. Use an active USB HUB if your computer delivers not enough ampere External power source will stabilize the 4CH-pro and you can increase upload speed back to 115200. Using a Laptop instead of a Desktop Tower might also do the trick as Laptops have a battery to deliver more ampere. you can not flash it with tasmota-minimal.bin, you need to flash it with tasmota.bin ! Using esptool following commands might be usefull (you need to change com port) to clear: esptool.exe -cp COM6 -cb 115200 -ce -v to program: esptool.exe -cp COM6 -bm dout -cf tasmota.bin -v 4CH Pro DIPSwitch Configuration ~ Most special modes of the 4CH Pro are controlled by DIP switch panels on the board. Please refer to the back of the board or the Sonoff documentation for more details. For normal operation with Tasmota the following settings are recommended: S6: 1 K5: all 1 K6: all 0 (0 and 1 are printed onto the board next to the switch names) Changing these switches for operations like inching and interlocking are also supported with Tasmota. Official Sources ~ Itead Product Page Itead Shop Itead Wiki WARNING The Sonoff CH4 PRO is subject to radio frequency disturbances with random activation of the buttons. To eliminate interference due to the U7 (SYN470RU7 RF-433 module) you can cut the wire between U7 and U8 (MCU STM32f030c6). This line starts from pin 10 of U7, the part towards MCU can be soldered to ground (surrounding area). It is also possible to set the RF module (U7) in shutdown-mode by unsoldering or cutting pin 11.","title":"Sonoff 4CH Pro"},{"location":"devices/Sonoff-4CH-Pro/#serial-flashing","text":"","title":"Serial Flashing"},{"location":"devices/Sonoff-4CH-Pro/#sonoff-4ch-pro","text":"The \"FW/IO0\" button (Switch 1) is not directly connected to GPIO0 of the ESP module. A different method has to be used to program this board. To program the ESP chip disconnect power from the board, connect a cable from any Ground (GND) pin to the GPIO0 pin on the ESP (be careful not to touch any of the other pins). This is the second pin to the right on the top row of pins (see picture). While holding the pin connected power on the board. The board does not respond to any button pressed when in programming mode and LED 1, 2 and 3 are on (might differ per board). Use the ESP programming header as described in the picture to upload the firmware and follow regular programming procedure.","title":"Sonoff 4CH Pro"},{"location":"devices/Sonoff-4CH-Pro/#sonoff-4ch-pro-r2","text":"On the R2 module the GPIO0 pin is broken out to a small pad to the right of the ESP package : If you have 4CH R2 v1.0 hardware, the GPIO0 is available as L1 switch - you don't need to solder additional cable to the PCB. Just push it during powering on for 3 seconds and release.","title":"Sonoff 4CH Pro R2"},{"location":"devices/Sonoff-4CH-Pro/#solving-sonoff-4ch-pro-programing-issues","text":"If you have problems to program the 4CH Pro, you might find below tips useful: * Use the ESP program header and ensure that the right port is set in the Arduino IDE. * TX/RX are printed correctly on the pro version => TX goes to RX PIN and RX to TX. * GPIO0 needs to be connected to ground the first 3 seconds during reboot (or longer)! If not you can not program it. * On 4CH Pro R2 try switch S6 to 0 before connecting power to enter flash mode. Reset to 1 (default) after finished flashing. If you use Windows7+, check in the device manager if the port is not added/removed all 2 seconds. If yes then your USB port does not deliver enough ampere. And/Or reduce upload speed to 57600 in Arduino IDE. Use an active USB HUB if your computer delivers not enough ampere External power source will stabilize the 4CH-pro and you can increase upload speed back to 115200. Using a Laptop instead of a Desktop Tower might also do the trick as Laptops have a battery to deliver more ampere. you can not flash it with tasmota-minimal.bin, you need to flash it with tasmota.bin ! Using esptool following commands might be usefull (you need to change com port) to clear: esptool.exe -cp COM6 -cb 115200 -ce -v to program: esptool.exe -cp COM6 -bm dout -cf tasmota.bin -v","title":"Solving Sonoff 4CH Pro programing issues"},{"location":"devices/Sonoff-4CH-Pro/#4ch-pro-dipswitch-configuration","text":"Most special modes of the 4CH Pro are controlled by DIP switch panels on the board. Please refer to the back of the board or the Sonoff documentation for more details. For normal operation with Tasmota the following settings are recommended: S6: 1 K5: all 1 K6: all 0 (0 and 1 are printed onto the board next to the switch names) Changing these switches for operations like inching and interlocking are also supported with Tasmota.","title":"4CH Pro DIPSwitch Configuration"},{"location":"devices/Sonoff-4CH-Pro/#official-sources","text":"Itead Product Page Itead Shop Itead Wiki WARNING The Sonoff CH4 PRO is subject to radio frequency disturbances with random activation of the buttons. To eliminate interference due to the U7 (SYN470RU7 RF-433 module) you can cut the wire between U7 and U8 (MCU STM32f030c6). This line starts from pin 10 of U7, the part towards MCU can be soldered to ground (surrounding area). It is also possible to set the RF module (U7) in shutdown-mode by unsoldering or cutting pin 11.","title":"Official Sources"},{"location":"devices/Sonoff-4CH/","text":"Serial Flashing ~ Please see the Hardware Preparation page for general instructions. Sonoff 4CH and Sonoff 4CH R2 use the same configuration but have slightly different boards. Check which version you own before proceeding. Sonoff 4CH ~ Attention: The printed labels on the PCB for RX and TX may be incorrectly swapped as can be seen on the image. Regardless of the labels, the pin next to VCC33 is RX. The Sonoff 4CH features four hardware buttons. Button marked FW/IO0 is connected to GPIO0 and can be used to bring the module into flash mode. Sonoff 4CH R2 ~ Board is labelled Sonoff 4CH R2 V1.0. The RX and TX pins are correctly labelled on this PCB revision. The button labelled IO0 is connected to GPIO0 and can be used to bring the module into flash mode. Official Sources ~ Itead Product Page Itead Shop Itead Wiki","title":"Sonoff 4CH"},{"location":"devices/Sonoff-4CH/#serial-flashing","text":"Please see the Hardware Preparation page for general instructions. Sonoff 4CH and Sonoff 4CH R2 use the same configuration but have slightly different boards. Check which version you own before proceeding.","title":"Serial Flashing"},{"location":"devices/Sonoff-4CH/#sonoff-4ch","text":"Attention: The printed labels on the PCB for RX and TX may be incorrectly swapped as can be seen on the image. Regardless of the labels, the pin next to VCC33 is RX. The Sonoff 4CH features four hardware buttons. Button marked FW/IO0 is connected to GPIO0 and can be used to bring the module into flash mode.","title":"Sonoff 4CH"},{"location":"devices/Sonoff-4CH/#sonoff-4ch-r2","text":"Board is labelled Sonoff 4CH R2 V1.0. The RX and TX pins are correctly labelled on this PCB revision. The button labelled IO0 is connected to GPIO0 and can be used to bring the module into flash mode.","title":"Sonoff 4CH R2"},{"location":"devices/Sonoff-4CH/#official-sources","text":"Itead Product Page Itead Shop Itead Wiki","title":"Official Sources"},{"location":"devices/Sonoff-B1-and-B1-R2/","text":"PAGE MOVED!","title":"Sonoff B1 and B1 R2"},{"location":"devices/Sonoff-B1/","text":"Sonoff B1 R2 is the replacement for Sonoff B1 and can be programmed the same way as the B1. See here for more background information. Serial Flashing ~ Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. First pop up the top part of the bulb with controlled force. The PCB as shown in the image will become visible. The four serial pins (3V3, RX, TX, GND) as well as the GPIO0 signal line are available as test points and clearly marked. Solder wires to those or use pogo pins as you prefer. As with all modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. An additional GND pad is available in the middle of the PCB. NOTE: If experiencing trouble getting the B1 R2 into flash mode, try pulling GPIO to GND during power up and holding it for 20 to 25 seconds before release. LED HEX10 Color Codes ~ The Sonoff B1 uses a TEN charter HEX code for all colors. Colors tested with firmware 5.9.1 20171107: * 00000000A0 = WARM * 000000A000 = COOL * 0000A00000 = BLUE * FF14500000 = PURPLE * 551A8B0000 = DARK PURPLE * A300000000 = RED * 00ff000000 = GREEN Official Sources ~ Itead Product Page: http://sonoff.itead.cc/en/products/residential/sonoff-b1 Itead Shop: https://www.itead.cc/sonoff-b1.html Itead Wiki: (not available)","title":"Sonoff B1"},{"location":"devices/Sonoff-B1/#serial-flashing","text":"Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. First pop up the top part of the bulb with controlled force. The PCB as shown in the image will become visible. The four serial pins (3V3, RX, TX, GND) as well as the GPIO0 signal line are available as test points and clearly marked. Solder wires to those or use pogo pins as you prefer. As with all modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. An additional GND pad is available in the middle of the PCB. NOTE: If experiencing trouble getting the B1 R2 into flash mode, try pulling GPIO to GND during power up and holding it for 20 to 25 seconds before release.","title":"Serial Flashing"},{"location":"devices/Sonoff-B1/#led-hex10-color-codes","text":"The Sonoff B1 uses a TEN charter HEX code for all colors. Colors tested with firmware 5.9.1 20171107: * 00000000A0 = WARM * 000000A000 = COOL * 0000A00000 = BLUE * FF14500000 = PURPLE * 551A8B0000 = DARK PURPLE * A300000000 = RED * 00ff000000 = GREEN","title":"LED HEX10 Color Codes"},{"location":"devices/Sonoff-B1/#official-sources","text":"Itead Product Page: http://sonoff.itead.cc/en/products/residential/sonoff-b1 Itead Shop: https://www.itead.cc/sonoff-b1.html Itead Wiki: (not available)","title":"Official Sources"},{"location":"devices/Sonoff-Basic-and-BME280/","text":"This feature is included only in tasmota-sensors.bin \"BME280 sensor, an environmental sensor with temperature, barometric pressure and humidity\", see Datasheet. \"tasmota-sensors.bin is needed for this to work. tasmota.bin an tasmota-lite.bin do not include the necessary driver.\" Connect BME280 to Sonoff-Basic based on the GPIO locations ~ BME280-3.3V -> Sonoff-3.3V BME280-GND -> Sonoff-GND BME280-SCL -> Sonoff-TX BME280-SDA -> Sonoff-RX NOTE: YOU NEED TO DISABLE SERIAL LOG COMPLETELY TO ALLOW SENSORS ON TX/RX PINS On the Tasmota web interface go to Configuration->Configure Module and set","title":"Sonoff Basic and BME280"},{"location":"devices/Sonoff-Basic-and-BME280/#connect-bme280-to-sonoff-basic-based-on-the-gpio-locations","text":"BME280-3.3V -> Sonoff-3.3V BME280-GND -> Sonoff-GND BME280-SCL -> Sonoff-TX BME280-SDA -> Sonoff-RX NOTE: YOU NEED TO DISABLE SERIAL LOG COMPLETELY TO ALLOW SENSORS ON TX/RX PINS On the Tasmota web interface go to Configuration->Configure Module and set","title":"Connect BME280 to Sonoff-Basic based on the GPIO locations"},{"location":"devices/Sonoff-Basic/","text":"Sonoff Basic - the one that started it all! Serial Flashing ~ Please see the Hardware Preparation page for general instructions. You need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) are available in the middle of the PCB, right next to the on-board button. Newer versions of the Sonoff Basic device provide five pins below the button, ignore the pin furthest away from the Button (GPIO14 or I02) if available. The square pin right next to the button is the 3.3V line. For flashing the Sonoff Basic, hold the button while connecting the 3.3V power. The LED remains off until the flashing process is done and the board is rebooted. If your switch is powering up but is showing a solid-blink-reset pattern see this FAQ entry for advice . GPIO00 - BUTTON GPIO12 - RELAY GPIO13 - LED1 GPIO03 - RX PIN GPIO01 - TX PIN Sonoff Basic R3 ~ This is the board layout for the third design iteration of the Sonoff Basic. The Sonoff Basic R3 uses the ESP8255 chip. With this version, the mains power reverts to solder rails directly on the PCB. It also moves the Wi-Fi module to a separate PCB mounted on the main PCB. It makes access to the underside of the serial interface contacts quite difficult. This version of the device supports the new Itead DIY architecture which allows OTA firmware upload . The device was reviewed by DigiblurDIY in this video . The serial interface pins are broken out on the PCB making flashing using a serial adapter as well. Since the underside of the contacts is not easily reachable, use a solderless solution (i.e., friction) to maintain contact with the pins to flash the device. Sonoff Basic R2 ~ Around November 2018, Itead changed the layout of the Sonoff Basic ( issue #4515 ). The new board is labeled as Sonoff RF R2 POWER V1.0 . It is easily discerned from previous revisions since it uses wires instead of thick solder traces for mains power. The new version of the Sonoff Basic smart switch uses an ESP8285 SoC with the 1MB flash integrated into the same SoC chip. GPIO14 is no longer broken out to a contact on the PCB. Instead, GPIO02 (no pullup) is broken out. It is labeled as IO2 on the board. To use GPIO02, take care that it is not being pulled low when the device is booting . Otherwise, the device will not boot into its regular operational mode. Alternatively, you can use use GPIO03 (Rx) which does not have any boot function restrictions. However, both of these GPIO are pulled high momentarily after boot. This means that any connected device may \"blink\" when the Sonoff is powering up. Unlike GPIO03, the GPIO02 PCB contact is not prepared for a pin. You will need to solder your cable directly on the board. Be careful. Too high a temperature or long heating can damage the contact and its connectivity. You should also make sure that there is no tension on the cable. Affix the cable with a cable tie and perhaps some hot glue. GPIO02 as a user configurable input is implemented in the Sonoff Basic module (introduced in 6.3.0.15). If you use GPIO03, you must use a device template (rather than selecting the Sonoff Basic module), and also disable serial logging ( SerialLog 0 ). You can remove the thick wires from the PCB to use the screw connection on the output side for low voltage. Then add a screw terminal next to the relay for the LINE OUT. This keeps all high voltage on one side of the board Sonoff Basic R1 ~ This is the board layout for the first board version of the Sonoff Basic. (Image re-used from https://www.instructables.com/id/Use-Homie-Firmware-to-Drive-Sonoff-Switch-Module-E/ Thanks @amayii0) Usable GPIO: - GPIO14 is broken out on the PCB adjacent to the GND pin. - GPIO13 - You must remove the bi-colour LED - GPIO04 - You must solder wire to pin on ESP chip Official Sources ~ Itead Product Page Itead Shop Itead Wiki","title":"Sonoff Basic"},{"location":"devices/Sonoff-Basic/#serial-flashing","text":"Please see the Hardware Preparation page for general instructions. You need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) are available in the middle of the PCB, right next to the on-board button. Newer versions of the Sonoff Basic device provide five pins below the button, ignore the pin furthest away from the Button (GPIO14 or I02) if available. The square pin right next to the button is the 3.3V line. For flashing the Sonoff Basic, hold the button while connecting the 3.3V power. The LED remains off until the flashing process is done and the board is rebooted. If your switch is powering up but is showing a solid-blink-reset pattern see this FAQ entry for advice . GPIO00 - BUTTON GPIO12 - RELAY GPIO13 - LED1 GPIO03 - RX PIN GPIO01 - TX PIN","title":"Serial Flashing"},{"location":"devices/Sonoff-Basic/#sonoff-basic-r3","text":"This is the board layout for the third design iteration of the Sonoff Basic. The Sonoff Basic R3 uses the ESP8255 chip. With this version, the mains power reverts to solder rails directly on the PCB. It also moves the Wi-Fi module to a separate PCB mounted on the main PCB. It makes access to the underside of the serial interface contacts quite difficult. This version of the device supports the new Itead DIY architecture which allows OTA firmware upload . The device was reviewed by DigiblurDIY in this video . The serial interface pins are broken out on the PCB making flashing using a serial adapter as well. Since the underside of the contacts is not easily reachable, use a solderless solution (i.e., friction) to maintain contact with the pins to flash the device.","title":"Sonoff Basic R3"},{"location":"devices/Sonoff-Basic/#sonoff-basic-r2","text":"Around November 2018, Itead changed the layout of the Sonoff Basic ( issue #4515 ). The new board is labeled as Sonoff RF R2 POWER V1.0 . It is easily discerned from previous revisions since it uses wires instead of thick solder traces for mains power. The new version of the Sonoff Basic smart switch uses an ESP8285 SoC with the 1MB flash integrated into the same SoC chip. GPIO14 is no longer broken out to a contact on the PCB. Instead, GPIO02 (no pullup) is broken out. It is labeled as IO2 on the board. To use GPIO02, take care that it is not being pulled low when the device is booting . Otherwise, the device will not boot into its regular operational mode. Alternatively, you can use use GPIO03 (Rx) which does not have any boot function restrictions. However, both of these GPIO are pulled high momentarily after boot. This means that any connected device may \"blink\" when the Sonoff is powering up. Unlike GPIO03, the GPIO02 PCB contact is not prepared for a pin. You will need to solder your cable directly on the board. Be careful. Too high a temperature or long heating can damage the contact and its connectivity. You should also make sure that there is no tension on the cable. Affix the cable with a cable tie and perhaps some hot glue. GPIO02 as a user configurable input is implemented in the Sonoff Basic module (introduced in 6.3.0.15). If you use GPIO03, you must use a device template (rather than selecting the Sonoff Basic module), and also disable serial logging ( SerialLog 0 ). You can remove the thick wires from the PCB to use the screw connection on the output side for low voltage. Then add a screw terminal next to the relay for the LINE OUT. This keeps all high voltage on one side of the board","title":"Sonoff Basic R2"},{"location":"devices/Sonoff-Basic/#sonoff-basic-r1","text":"This is the board layout for the first board version of the Sonoff Basic. (Image re-used from https://www.instructables.com/id/Use-Homie-Firmware-to-Drive-Sonoff-Switch-Module-E/ Thanks @amayii0) Usable GPIO: - GPIO14 is broken out on the PCB adjacent to the GND pin. - GPIO13 - You must remove the bi-colour LED - GPIO04 - You must solder wire to pin on ESP chip","title":"Sonoff Basic R1"},{"location":"devices/Sonoff-Basic/#official-sources","text":"Itead Product Page Itead Shop Itead Wiki","title":"Official Sources"},{"location":"devices/Sonoff-Dual-R2/","text":"Sonoff Dual R2 is the replacement for Sonoff Dual. Compared to the Dual the main differences/improvements for R2 are: * As the second microcontroller has been removed both relays are now controlled directly by an ESP8285 * The button is now directly connected to the ESP8285 * The header connector is now supported in Tasmota Serial Flashing (Sonoff Dual R2) ~ Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. VCC, RX, TX and GND are available at the bottom left end of the PCB in the image below. Programming the Sonoff Dual R2 is a breeze although the on-board-button is not connected to GPIO0. As with all ESP8266/ESP8285 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. Luckily both GND and GPIO0 (as BUTTON 0) are available on the second header. A simple jumper between GND and BUTTON 0 while powering on will do. For a video on how to flash the Sonoff Dual R2 with Tasmota, take a look here . Use external switches ~ The relays can be controlled by external push buttons or switches connected to the header at the designated positions. BUTTON 0 (on GPIO0) connected to GND controls Relay1 and BUTTON 1 (on GPIO9) connected to GND controls Relay2. See the image on the right how to configure this functionality in Tasmota as Switch1 and Switch2. NOTE Make sure not to use a switch that keeps the connection between GND and BUTTON 0 active while power is re-applied as the device will start in programming mode. Note 2: GPIO9 and 10 can be safely used with an external switch (even rebooting with the contacts closed), and configured as such using a template. GPIO9 is available in the header, and GPIO10 is the board's button (you only need to solder a wire to the GPIO10 side of the button, no need to remove it). Sonoff Dual ( not R2) ~ Serial Connection ~ Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) are available at the short end of the PCB and can be seen on the left side of the first image and are labeled in red on the second image. For the v2.0 version of the board you need to cross-over the serial interface, see troubleshooting . Programming the Sonoff Dual is more difficult because the on-board-button is not connected to GPIO0. As with all ESP8266 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. GND can be found on all three headers. GPIO0 can be accessed two ways: 1. Unscrew the Sonoff Dual from the housing and access the underside of the PCB You can find GPIO0 on one side of a resistor as shown in the second image. 2. GPIO0 can be found on the small inter layer via pointed at in the first image. Attention: If the via is covered by silk screen (green) you need to expose the underlying conductive (copper) by careful scratching it off. Restricted Button Functionality ~ Please be aware, that the button on the Sonoff Dual will initially not have any functionality! Other than on most Sonoff module the button is not connected to the normal button pin (GPIO0). After freshly flashing Tasmota (with the default module setting \"Sonoff Basic\"), the button will not act as described in the Buttons and Switches article. You will not be able to switch power or activate the special WiFi modes. You will need to configure wifi credentials connecting directly to the wifi AP your Dual will broadcast or configure the module firmware config beforehand via user_config_override.h . After configuring the device as a \"Sonoff Dual\", the button will regain normal functionality. GPIO Locations ~ GPIO4 => red, GPIO14 => orange Solving intermittent relay switch errors ~ Where most Sonoff's use GPIO to control one or more relays the Sonoff Dual and 4 Channel Inching Relay Assy do use the standard SERIAL interface to control the relays. Commands are send from the ESP8266 via a 19200 baud serial connection to a dedicated chip that controls the relays. It is therefore important to disable any serial communication to and from the device once you have debugged any anomalies. To assist easy installation serial logging is enabled by default in user_config_override.h for all Sonoffs. Once in production it's wise to turn it off for all Sonoffs. For the Dual it is almost mandatory to turn it off. Execute command seriallog 0 once to turn all communication on the serial port off. If within 10 minutes no input is received serial communication is turned off too. Another reason for intermittent switching errors can be Power Saving. Make sure it is disabled by executing the command sleep 0 . Official Sources ~ Itead Product Page: http://sonoff.itead.cc/en/products/sonoff/sonoff-dual Itead Shop: https://www.itead.cc/sonoff-dual.html Itead Wiki: https://www.itead.cc/wiki/Sonoff_Dual","title":"Sonoff Dual R2"},{"location":"devices/Sonoff-Dual-R2/#serial-flashing-sonoff-dual-r2","text":"Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. VCC, RX, TX and GND are available at the bottom left end of the PCB in the image below. Programming the Sonoff Dual R2 is a breeze although the on-board-button is not connected to GPIO0. As with all ESP8266/ESP8285 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. Luckily both GND and GPIO0 (as BUTTON 0) are available on the second header. A simple jumper between GND and BUTTON 0 while powering on will do. For a video on how to flash the Sonoff Dual R2 with Tasmota, take a look here .","title":"Serial Flashing (Sonoff Dual R2)"},{"location":"devices/Sonoff-Dual-R2/#use-external-switches","text":"The relays can be controlled by external push buttons or switches connected to the header at the designated positions. BUTTON 0 (on GPIO0) connected to GND controls Relay1 and BUTTON 1 (on GPIO9) connected to GND controls Relay2. See the image on the right how to configure this functionality in Tasmota as Switch1 and Switch2. NOTE Make sure not to use a switch that keeps the connection between GND and BUTTON 0 active while power is re-applied as the device will start in programming mode. Note 2: GPIO9 and 10 can be safely used with an external switch (even rebooting with the contacts closed), and configured as such using a template. GPIO9 is available in the header, and GPIO10 is the board's button (you only need to solder a wire to the GPIO10 side of the button, no need to remove it).","title":"Use external switches"},{"location":"devices/Sonoff-Dual-R2/#sonoff-dual-not-r2","text":"","title":"Sonoff Dual (not R2)"},{"location":"devices/Sonoff-Dual-R2/#serial-connection","text":"Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) are available at the short end of the PCB and can be seen on the left side of the first image and are labeled in red on the second image. For the v2.0 version of the board you need to cross-over the serial interface, see troubleshooting . Programming the Sonoff Dual is more difficult because the on-board-button is not connected to GPIO0. As with all ESP8266 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. GND can be found on all three headers. GPIO0 can be accessed two ways: 1. Unscrew the Sonoff Dual from the housing and access the underside of the PCB You can find GPIO0 on one side of a resistor as shown in the second image. 2. GPIO0 can be found on the small inter layer via pointed at in the first image. Attention: If the via is covered by silk screen (green) you need to expose the underlying conductive (copper) by careful scratching it off.","title":"Serial Connection"},{"location":"devices/Sonoff-Dual-R2/#restricted-button-functionality","text":"Please be aware, that the button on the Sonoff Dual will initially not have any functionality! Other than on most Sonoff module the button is not connected to the normal button pin (GPIO0). After freshly flashing Tasmota (with the default module setting \"Sonoff Basic\"), the button will not act as described in the Buttons and Switches article. You will not be able to switch power or activate the special WiFi modes. You will need to configure wifi credentials connecting directly to the wifi AP your Dual will broadcast or configure the module firmware config beforehand via user_config_override.h . After configuring the device as a \"Sonoff Dual\", the button will regain normal functionality.","title":"Restricted Button Functionality"},{"location":"devices/Sonoff-Dual-R2/#gpio-locations","text":"GPIO4 => red, GPIO14 => orange","title":"GPIO Locations"},{"location":"devices/Sonoff-Dual-R2/#solving-intermittent-relay-switch-errors","text":"Where most Sonoff's use GPIO to control one or more relays the Sonoff Dual and 4 Channel Inching Relay Assy do use the standard SERIAL interface to control the relays. Commands are send from the ESP8266 via a 19200 baud serial connection to a dedicated chip that controls the relays. It is therefore important to disable any serial communication to and from the device once you have debugged any anomalies. To assist easy installation serial logging is enabled by default in user_config_override.h for all Sonoffs. Once in production it's wise to turn it off for all Sonoffs. For the Dual it is almost mandatory to turn it off. Execute command seriallog 0 once to turn all communication on the serial port off. If within 10 minutes no input is received serial communication is turned off too. Another reason for intermittent switching errors can be Power Saving. Make sure it is disabled by executing the command sleep 0 .","title":"Solving intermittent relay switch errors"},{"location":"devices/Sonoff-Dual-R2/#official-sources","text":"Itead Product Page: http://sonoff.itead.cc/en/products/sonoff/sonoff-dual Itead Shop: https://www.itead.cc/sonoff-dual.html Itead Wiki: https://www.itead.cc/wiki/Sonoff_Dual","title":"Official Sources"},{"location":"devices/Sonoff-Dual/","text":"Sonoff Dual has been obsoleted by Sonoff Dual R2 . Before configuring your device check which revision you have since there are significant differences in how they operate. Serial Flashing ~ Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) are available at the short end of the PCB and can be seen on the left side of the first image and are labeled in red on the second image. Alternative GPIO locations Programming the Sonoff Dual is more difficult because the on-board-button is not connected to GPIO0. As with all ESP8266 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. GND can be found on all three headers. GPIO0 can be accessed in two ways: 1. Unscrew the Sonoff Dual from the housing and access the underside of the PCB. You can find GPIO0 on one side of a resistor as shown in the second image. 2. GPIO0 can be found on the small inter layer via pointed at in the first image. Attention: If the via is covered by silk screen (green) you need to expose the underlying conductive (copper) by carefully scratching it off. Restricted Button Functionality ~ Please be aware, that the button on the Sonoff Dual will initially not have any functionality! The button is not connected to the normal button pin (GPIO0). After freshly flashing Tasmota (with the default module setting \"Sonoff Basic\"), the button will not act as described in the Buttons and Switches article. You will not be able to switch power or activate the special WiFi modes. After configuring the device as \"Sonoff Dual (5)\", the button will regain normal functionality. GPIO Locations ~ GPIO4 = red, GPIO14 = orange Solving intermittent relay switch errors ~ Where most Sonoff's use GPIO to control one or more relays the Sonoff Dual uses the serial interface to control the relays. Commands are send from the ESP8266 via a 19200 baud serial connection to a dedicated chip that controls the relays. It is therefore important to disable any serial communication to and from the device once you have debugged any anomalies. To assist easy installation serial logging is enabled by default in Tasmota. For the Dual it is mandatory to turn it off withe SerialLog 0 comand. Another reason for intermittent switching errors can be Power Saving. Make sure it is disabled by executing the command sleep 0 . Official Sources ~ Itead Product Page: http://sonoff.itead.cc/en/products/sonoff/sonoff-dual Itead Shop: https://www.itead.cc/sonoff-dual.html Itead Wiki: https://www.itead.cc/wiki/Sonoff_Dual","title":"Sonoff Dual"},{"location":"devices/Sonoff-Dual/#serial-flashing","text":"Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) are available at the short end of the PCB and can be seen on the left side of the first image and are labeled in red on the second image. Alternative GPIO locations Programming the Sonoff Dual is more difficult because the on-board-button is not connected to GPIO0. As with all ESP8266 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. GND can be found on all three headers. GPIO0 can be accessed in two ways: 1. Unscrew the Sonoff Dual from the housing and access the underside of the PCB. You can find GPIO0 on one side of a resistor as shown in the second image. 2. GPIO0 can be found on the small inter layer via pointed at in the first image. Attention: If the via is covered by silk screen (green) you need to expose the underlying conductive (copper) by carefully scratching it off.","title":"Serial Flashing"},{"location":"devices/Sonoff-Dual/#restricted-button-functionality","text":"Please be aware, that the button on the Sonoff Dual will initially not have any functionality! The button is not connected to the normal button pin (GPIO0). After freshly flashing Tasmota (with the default module setting \"Sonoff Basic\"), the button will not act as described in the Buttons and Switches article. You will not be able to switch power or activate the special WiFi modes. After configuring the device as \"Sonoff Dual (5)\", the button will regain normal functionality.","title":"Restricted Button Functionality"},{"location":"devices/Sonoff-Dual/#gpio-locations","text":"GPIO4 = red, GPIO14 = orange","title":"GPIO Locations"},{"location":"devices/Sonoff-Dual/#solving-intermittent-relay-switch-errors","text":"Where most Sonoff's use GPIO to control one or more relays the Sonoff Dual uses the serial interface to control the relays. Commands are send from the ESP8266 via a 19200 baud serial connection to a dedicated chip that controls the relays. It is therefore important to disable any serial communication to and from the device once you have debugged any anomalies. To assist easy installation serial logging is enabled by default in Tasmota. For the Dual it is mandatory to turn it off withe SerialLog 0 comand. Another reason for intermittent switching errors can be Power Saving. Make sure it is disabled by executing the command sleep 0 .","title":"Solving intermittent relay switch errors"},{"location":"devices/Sonoff-Dual/#official-sources","text":"Itead Product Page: http://sonoff.itead.cc/en/products/sonoff/sonoff-dual Itead Shop: https://www.itead.cc/sonoff-dual.html Itead Wiki: https://www.itead.cc/wiki/Sonoff_Dual","title":"Official Sources"},{"location":"devices/Sonoff-Mini/","text":"The Sonoff Mini is, as the name implies, a very small device, designed to be hidden where there's only supposed to be cables. Since it's not supposed to be visible, it's also designed to easily attach an external button. Tasmota can be flashed on this device via OTA using the Sonoff DIY feature. Several free GPIO are available. The OTA jumper pin is the most accessible and very easy to use on a pin header. GPIO Description 0 Button 1 TX 2 Available 3 RX 4 S2 (external switch input) 12 Relay and red LED 13 Blue LED 16 OTA jumper pin GND S1 (external switch input)","title":"Sonoff Mini"},{"location":"devices/Sonoff-PSA/","text":"itead page","title":"Sonoff PSA"},{"location":"devices/Sonoff-Pow-R2/","text":"\u26a0\ufe0f\ufe0fSpecial Attention \u26a0\ufe0f\ufe0f ~ Do not connect AC power and the serial connection at the same time The GND connection of the Pow is connected to the live AC wire. Connecting serial with your PC will fry your PC and will electrocute you. DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Pow are connected to AC power! Only use a POW R2 as designed. The AC connection between Pow and Pow R2 is different , please check exactly which version you have. - Pow R2 : Lo-E-E-Li-N-N = LineOut-EarthOut-EarthIn-LineIn-NeutralOut-NeutralIn - Pow : Lo-E-E-N-N-Li = LineOut-EarthOut-EarthIn-NeutralOut-NeutralIn-LineIn Serial Flashing ~ Please see the Hardware Preparation page for general instructions. 3V3, RX, TX and GND pins are available at the rear/short end of the PCB. To enter flash mode , press down on the button while powering the device. Note - After the module type is changed to \"Sonoff Pow R2\", the serial port is no longer available for entering configuration commands because the serial port is used to communicate to the power measurement chip. Make sure you have set up your network connection before doing this. Serial logging ~ Serial logging is disabled by the Tasmota code for this module. Serial communication is used by the device to transfer the data from the energy monitoring chip to the ESP chip. Do not enable serial logging ( SerialLog 0 ) on this device. It can cause the device software to crash. Be sure to leave it disabled. Video tutorial by alsolh ~ Power Monitoring Calibration ~ Sonoff Pow R2 might need calibration as correct measurements are influenced by hardware and timing differences. See Power Monitoring Calibration Telemetry ~ The Sonoff Pow R2 can provide Energy, Power, Voltage and Current information in different ways. The preffered way is using the periodic telemetry data. Default setting TelePeriod 300 will send telemetry data every 5 minutes. If the setting PowerDelta (new since version 5.12.0e) is not 0 (default 80%), telemetry will be sent on power change too. tele/pow1/SENSOR = {\"Time\":\"2018-02-15T17:37:10\",\"ENERGY\":{\"TotalStartTime\":\"2018-11-14T18:39:40\",\"Total\":6.294,\"Yesterday\":5.340,\"Today\":0.954,\"Period\":217,\"Power\":2635,\"ApparentPower\":2650,\"ReactivePower\":282,\"Factor\":0.99,\"Voltage\":227,\"Current\":11.661}} To request information you can use command Status 8 . stat/pow1/STATUS8 = {\"StatusSNS\":{\"Time\":\"2018-11-15T08:54:18\",\"ENERGY\":{\"TotalStartTime\":\"2018-11-14T18:39:40\",\"Total\":6.404,\"Yesterday\":5.340,\"Today\":1.064,\"Power\":2629,\"ApparentPower\":2645,\"ReactivePower\":288,\"Factor\":0.99,\"Voltage\":226,\"Current\":11.677}}} The presented information has the following meaning: Message | Unit | Description ---------------|------|----------------------------------------------------- TotalStartTime | Date | DateTime of calculation for Total Total | kWh | Total Energy usage including Today Yesterday | kWh | Total Energy usage between 00 : 00 and 24 : 00 yesterday Today | kWh | Total Energy usage today from 00 : 00 until now Period | Wh | Energy usage between previous message and now Power | W | Current effective power load ApparentPower | W | Power load on the cable = sqrt ( Power ^ 2 + | | ReactivePower ^ 2 ) ReactivePower | W | Reactive load Factor | | The ratio of the real power flowing to the load to | | the apparent power in the circuit Voltage | V | Current line voltage Current | A | Current line current Official Sources ~ Itead Product Page Itead Shop (R2) Itead Wiki","title":"Sonoff Pow R2"},{"location":"devices/Sonoff-Pow-R2/#special-attention","text":"Do not connect AC power and the serial connection at the same time The GND connection of the Pow is connected to the live AC wire. Connecting serial with your PC will fry your PC and will electrocute you. DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Pow are connected to AC power! Only use a POW R2 as designed. The AC connection between Pow and Pow R2 is different , please check exactly which version you have. - Pow R2 : Lo-E-E-Li-N-N = LineOut-EarthOut-EarthIn-LineIn-NeutralOut-NeutralIn - Pow : Lo-E-E-N-N-Li = LineOut-EarthOut-EarthIn-NeutralOut-NeutralIn-LineIn","title":"\u26a0\ufe0f\ufe0fSpecial Attention   \u26a0\ufe0f\ufe0f"},{"location":"devices/Sonoff-Pow-R2/#serial-flashing","text":"Please see the Hardware Preparation page for general instructions. 3V3, RX, TX and GND pins are available at the rear/short end of the PCB. To enter flash mode , press down on the button while powering the device. Note - After the module type is changed to \"Sonoff Pow R2\", the serial port is no longer available for entering configuration commands because the serial port is used to communicate to the power measurement chip. Make sure you have set up your network connection before doing this.","title":"Serial Flashing"},{"location":"devices/Sonoff-Pow-R2/#serial-logging","text":"Serial logging is disabled by the Tasmota code for this module. Serial communication is used by the device to transfer the data from the energy monitoring chip to the ESP chip. Do not enable serial logging ( SerialLog 0 ) on this device. It can cause the device software to crash. Be sure to leave it disabled.","title":"Serial logging"},{"location":"devices/Sonoff-Pow-R2/#video-tutorial-by-alsolh","text":"","title":"Video tutorial by alsolh"},{"location":"devices/Sonoff-Pow-R2/#power-monitoring-calibration","text":"Sonoff Pow R2 might need calibration as correct measurements are influenced by hardware and timing differences. See Power Monitoring Calibration","title":"Power Monitoring Calibration"},{"location":"devices/Sonoff-Pow-R2/#telemetry","text":"The Sonoff Pow R2 can provide Energy, Power, Voltage and Current information in different ways. The preffered way is using the periodic telemetry data. Default setting TelePeriod 300 will send telemetry data every 5 minutes. If the setting PowerDelta (new since version 5.12.0e) is not 0 (default 80%), telemetry will be sent on power change too. tele/pow1/SENSOR = {\"Time\":\"2018-02-15T17:37:10\",\"ENERGY\":{\"TotalStartTime\":\"2018-11-14T18:39:40\",\"Total\":6.294,\"Yesterday\":5.340,\"Today\":0.954,\"Period\":217,\"Power\":2635,\"ApparentPower\":2650,\"ReactivePower\":282,\"Factor\":0.99,\"Voltage\":227,\"Current\":11.661}} To request information you can use command Status 8 . stat/pow1/STATUS8 = {\"StatusSNS\":{\"Time\":\"2018-11-15T08:54:18\",\"ENERGY\":{\"TotalStartTime\":\"2018-11-14T18:39:40\",\"Total\":6.404,\"Yesterday\":5.340,\"Today\":1.064,\"Power\":2629,\"ApparentPower\":2645,\"ReactivePower\":288,\"Factor\":0.99,\"Voltage\":226,\"Current\":11.677}}} The presented information has the following meaning: Message | Unit | Description ---------------|------|----------------------------------------------------- TotalStartTime | Date | DateTime of calculation for Total Total | kWh | Total Energy usage including Today Yesterday | kWh | Total Energy usage between 00 : 00 and 24 : 00 yesterday Today | kWh | Total Energy usage today from 00 : 00 until now Period | Wh | Energy usage between previous message and now Power | W | Current effective power load ApparentPower | W | Power load on the cable = sqrt ( Power ^ 2 + | | ReactivePower ^ 2 ) ReactivePower | W | Reactive load Factor | | The ratio of the real power flowing to the load to | | the apparent power in the circuit Voltage | V | Current line voltage Current | A | Current line current","title":"Telemetry"},{"location":"devices/Sonoff-Pow-R2/#official-sources","text":"Itead Product Page Itead Shop (R2) Itead Wiki","title":"Official Sources"},{"location":"devices/Sonoff-Pow/","text":"Sonoff Pow has been obsoleted with Sonoff Pow R2 . Before configuring your device check which revision you have. \u26a0\ufe0f\ufe0fSpecial Attention \u26a0\ufe0f\ufe0f ~ Do not connect AC power and the serial connection at the same time The GND connection of the Pow is connected to the live AC wire. Connecting serial with your PC will fry your PC and will electrocute you. DO NOT CONNECT ANYTHING TO THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Pow are connected to AC power! Only use a POW as designed. The AC connection between Pow and Pow R2 is different , please check exactly which version you have. - Pow R2 : Lo-E-E-Li-N-N = LineOut-EarthOut-EarthIn-LineIn-NeutralOut-NeutralIn - Pow : Lo-E-E-N-N-Li = LineOut-EarthOut-EarthIn-NeutralOut-NeutralIn-LineIn Serial Connection ~ Please see the Hardware Preparation page for general instructions. 3V3, RX, TX and GND pins are available at the rear end of the PCB. To enter flash mode , press down on the button while powering the device. Power Monitoring Calibration ~ Sonoff Pow might need calibration as correct measurements are influenced by hardware and timing differences. See Power Monitoring Calibration Telemetry ~ The Sonoff Pow can provide Energy, Power, Voltage and Current information in different ways. The preferred way is using the periodic telemetry data. Default setting TelePeriod 300 will send telemetry data every 5 minutes. If the setting PowerDelta (new since version 5.12.0e) is not 0 (default 80%), telemetry will be sent on power change too. tele/pow1/SENSOR = {\"Time\":\"2018-02-15T17:37:10\",\"ENERGY\":{\"TotalStartTime\":\"2018-11-14T18:39:40\",\"Total\":6.294,\"Yesterday\":5.340,\"Today\":0.954,\"Period\":217,\"Power\":2635,\"ApparentPower\":2650,\"ReactivePower\":282,\"Factor\":0.99,\"Voltage\":227,\"Current\":11.661}} To request information you can use command Status 8 . stat/pow1/STATUS8 = {\"StatusSNS\":{\"Time\":\"2018-11-15T08:54:18\",\"ENERGY\":{\"TotalStartTime\":\"2018-11-14T18:39:40\",\"Total\":6.404,\"Yesterday\":5.340,\"Today\":1.064,\"Power\":2629,\"ApparentPower\":2645,\"ReactivePower\":288,\"Factor\":0.99,\"Voltage\":226,\"Current\":11.677}}} The presented information has the following meaning: Message | Unit | Description ---------------|------|----------------------------------------------------- TotalStartTime | Date | DateTime of calculation for Total Total | kWh | Total Energy usage including Today Yesterday | kWh | Total Energy usage between 00 : 00 and 24 : 00 yesterday Today | kWh | Total Energy usage today from 00 : 00 until now Period | Wh | Energy usage between previous message and now Power | W | Current effective power load ApparentPower | W | Power load on the cable = sqrt ( Power ^ 2 + | | ReactivePower ^ 2 ) ReactivePower | W | Reactive load Factor | | The ratio of the real power flowing to the load to | | the apparent power in the circuit Voltage | V | Current line voltage Current | A | Current line current Self Protection for Sonoff Pow ~ ITEAD published a recall notice for the Sonoff Pow on March 1st 2017. Some units produced in december 2016 and january 2017 are not well suited for 16A. If you have one of these units you can decide to use them anyway by limiting the maximum current in software. It is, in fact, possible to set a Maximum Power Threshold for the Sonoff Pow. If the power measured by the device exceeds the threshold set by the command MaxPower for a number of seconds set by the command MaxPowerHold the device will remain switched off for MaxPowerWindow seconds (to let it cool down, for example). For all details see issue #218 Official Sources ~ Itead Product Page Itead Shop Itead Wiki","title":"Sonoff Pow"},{"location":"devices/Sonoff-Pow/#special-attention","text":"Do not connect AC power and the serial connection at the same time The GND connection of the Pow is connected to the live AC wire. Connecting serial with your PC will fry your PC and will electrocute you. DO NOT CONNECT ANYTHING TO THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Pow are connected to AC power! Only use a POW as designed. The AC connection between Pow and Pow R2 is different , please check exactly which version you have. - Pow R2 : Lo-E-E-Li-N-N = LineOut-EarthOut-EarthIn-LineIn-NeutralOut-NeutralIn - Pow : Lo-E-E-N-N-Li = LineOut-EarthOut-EarthIn-NeutralOut-NeutralIn-LineIn","title":"\u26a0\ufe0f\ufe0fSpecial Attention   \u26a0\ufe0f\ufe0f"},{"location":"devices/Sonoff-Pow/#serial-connection","text":"Please see the Hardware Preparation page for general instructions. 3V3, RX, TX and GND pins are available at the rear end of the PCB. To enter flash mode , press down on the button while powering the device.","title":"Serial Connection"},{"location":"devices/Sonoff-Pow/#power-monitoring-calibration","text":"Sonoff Pow might need calibration as correct measurements are influenced by hardware and timing differences. See Power Monitoring Calibration","title":"Power Monitoring Calibration"},{"location":"devices/Sonoff-Pow/#telemetry","text":"The Sonoff Pow can provide Energy, Power, Voltage and Current information in different ways. The preferred way is using the periodic telemetry data. Default setting TelePeriod 300 will send telemetry data every 5 minutes. If the setting PowerDelta (new since version 5.12.0e) is not 0 (default 80%), telemetry will be sent on power change too. tele/pow1/SENSOR = {\"Time\":\"2018-02-15T17:37:10\",\"ENERGY\":{\"TotalStartTime\":\"2018-11-14T18:39:40\",\"Total\":6.294,\"Yesterday\":5.340,\"Today\":0.954,\"Period\":217,\"Power\":2635,\"ApparentPower\":2650,\"ReactivePower\":282,\"Factor\":0.99,\"Voltage\":227,\"Current\":11.661}} To request information you can use command Status 8 . stat/pow1/STATUS8 = {\"StatusSNS\":{\"Time\":\"2018-11-15T08:54:18\",\"ENERGY\":{\"TotalStartTime\":\"2018-11-14T18:39:40\",\"Total\":6.404,\"Yesterday\":5.340,\"Today\":1.064,\"Power\":2629,\"ApparentPower\":2645,\"ReactivePower\":288,\"Factor\":0.99,\"Voltage\":226,\"Current\":11.677}}} The presented information has the following meaning: Message | Unit | Description ---------------|------|----------------------------------------------------- TotalStartTime | Date | DateTime of calculation for Total Total | kWh | Total Energy usage including Today Yesterday | kWh | Total Energy usage between 00 : 00 and 24 : 00 yesterday Today | kWh | Total Energy usage today from 00 : 00 until now Period | Wh | Energy usage between previous message and now Power | W | Current effective power load ApparentPower | W | Power load on the cable = sqrt ( Power ^ 2 + | | ReactivePower ^ 2 ) ReactivePower | W | Reactive load Factor | | The ratio of the real power flowing to the load to | | the apparent power in the circuit Voltage | V | Current line voltage Current | A | Current line current","title":"Telemetry"},{"location":"devices/Sonoff-Pow/#self-protection-for-sonoff-pow","text":"ITEAD published a recall notice for the Sonoff Pow on March 1st 2017. Some units produced in december 2016 and january 2017 are not well suited for 16A. If you have one of these units you can decide to use them anyway by limiting the maximum current in software. It is, in fact, possible to set a Maximum Power Threshold for the Sonoff Pow. If the power measured by the device exceeds the threshold set by the command MaxPower for a number of seconds set by the command MaxPowerHold the device will remain switched off for MaxPowerWindow seconds (to let it cool down, for example). For all details see issue #218","title":"Self Protection for Sonoff Pow"},{"location":"devices/Sonoff-Pow/#official-sources","text":"Itead Product Page Itead Shop Itead Wiki","title":"Official Sources"},{"location":"devices/Sonoff-RF-Bridge-433/","text":"The Sonoff RF Bridge has two separate chips to handle the Wi-Fi (ESP8285) and RF (EFM8BB1) communications respectively. It is used to send and receive codes with 433.9MHz frequency RF devices. Codes received from RF devices such as remote controls is passed to the onboard ESP8285 via the serial interface. The code data is relayed via MQTT. Similarly, the Bridge receives commands over Wi-Fi and sends the encoded data to the RF chip to control an RF device. Thus, the Sonoff RF Bridge \"bridges\" communications between RF and Wi-Fi. Flash Tasmota ~ Please Hardware Preparation article for general flashing instructions. Access the serial interface available on the 5-pin header next to the switch as can be seen in the image. To flash the ESP8285, first move the switch position towards the 5-pin header. Connect the serial-to-USB adapter and press the button on the edge while powering the device in order to put the ESP8285 into programming mode in order to upload the Tasmota firmware. After flashing the ESP8285, be sure to move the switch position away from the 5-pin header to restore the connection to the RF microcontroller. Configure the device as usual and select module Sonoff Bridge (25) . During normal operation the serial interface is used at 19200 baud to communicate with the RF microcontroller. Therefore serial logging ( SerialLog 0 ) must be disabled. IMPORTANT: In the Module configuration GPIO4 and GPIO5 must be left as 00 None On R2 versions of the Sonoff RF Bridge, a hardware modification is required in order to use these GPIOs. Video tutorial by alsolh ~ RF Firmware ~ The RF chip has its own firmware. The device is shipped with Itead firmware which supports a limited set of RF devices limited to mostly just Sonoff devices (a single 24-bit RF protocol). Some later versions of the factory firmware will only relay received RF data once the transmitting device stops. This is fine for remote controls or devices such as door sensors. But for devices such as smoke detectors, this behavior is not acceptable. Custom firmware is available for the RF chip which is commonly referred to as 'Portisch'. By updating the firmware on the RF chip, new types of devices and new features become usable. It also relays the RF data when the data is received rather than waiting until the transmitter stops. Tasmota supports the original Sonoff RF firmware and the Portisch firmware . RF Firmware Upgrade ~ The RF upgrade requires wiring the bridge and then flashing the firmware via the Tasmota web UI. **Attention \u26a0\ufe0f\ufe0f\u26a0\ufe0f\ufe0f\u26a0\ufe0f\ufe0f There are 2 versions of the Sonoff RF Bridge 433 : the R1 and the R2 V1.0 . R1 R2 V1.0 RF firmware flashing: Hardware Preparation This section applies only to the R2 revision of the Sonoff RF Bridge Apply this modification only if you intend to use USB for powering the device during flash process or if you want to use GPIO4 or GPIO5 for other purposes with the RF Bridge. The R2 revision boards connect the GPIO4 and GPIO5 pins to the USB data lines of the power connector. Compliant USB chargers/power supplies are expected to short the two pins together, which is a problem. These lines are not used by the original firmware, nor by Tasmota. The traces toward the USB power connector need to be cut to avoid interference by the USB wiring. Removing these connections does not interfere with the normal Bridge functionality. Flashing RF Firmware Make sure you have previously flashed a Tasmota binary built with RF_FLASH . Refer to the builds table for pre-compiled binaries which include this feature. Otherwise the \"Magic byte is not 0xE9\" error will occur. Set the module type to Sonoff Bridge (25) Connect two wires (this will be different depending on the Sonoff RF Bridge 433 hardware version): For R1 : Connect GPIO4 to C2Ck and GPIO5 to C2D . For R2 : Connect GPIO4 to C2D and GPIO5 to C2Ck . ( The text on the R2 PCB silkscreen is switched. Therefore this is the same wiring as on the R1) Switch the ON/OFF switch on the board to 'OFF'. Power up the bridge via the 3.3V & GND pins. (See below if you need to power the device through the USB power port) Obtain the Portisch firmware file: (Clicking on the file link on the GitHub web site does not work since this will download the GitHub preview/content of the file rather than the raw file contents) Download the entire contents of the Tasmota GitHub project project via the green Clone or Download button to ensure that the firmware hex files are downloaded properly. The firmware files are located in the ./tools/fw_SonoffRfBridge_efm8bb1/ folder. Select the newest available hex file. Otherwise you may get error \"Magic byte is not 0xE9\" . As an alternative use wget/curl to download the raw file (https://github.com/arendst/Tasmota/tree/master/tools/fw_SonoffRfBridge_efm8bb1) directly. Select the newest available hex file. Otherwise you may get error \"Magic byte is not 0xE9\" . PowerShell example: wget https://github.com/arendst/Tasmota/raw/master/tools/fw_SonoffRfBridge_efm8bb1/RF-Bridge-EFM8BB1-XXXXXXXX.hex -OutFile .\\RF-Bridge-EFM8BB1-XXXXXXXX.hex Go to the Web UI Firmware Upgrade > Upgrade by File Upload (introduced in v6.0.0a) In the file selection dialog, navigate to the folder on your computer where you saved the hex file from step 6. Click Start Upgrade . The flashing should complete within 60 seconds. Device will restart after upgrade completes. Disconnect wiring and put the ON/OFF switch on the board back to 'ON' to enable the RF again. Operation ~ The Sonoff RF Bridge is able to learn up to 16 different fixed code remote control commands as provided by PT2260, PT2262, PT2264 and EV1527 transmitters. It was not able to recognize the latest Klik Aan Klik Uit (KaKu) remote control signals but some people managed to use the fixed code KaKu devices like PAR-1000 receiver and PAT-103 transmitter. Tasmota provides default remote control commands to all 16 keys so you can start using the bridge with a Sonoff 4Ch Pro or Sonoff RF device without having the bridge have to learn remote control commands. See RF Bridge commands. Portisch Firmware Specific Usage ~ These sections only apply to the custom Portisch firmware. Learning Commands with Portisch Firmware ~ In order to learn Buttons from your remote, go to the Console of your RF Bridge. There, enter rfraw 177 and push the buttons on your remote. Repeat each button 2-3 times, as the signal may be different for each try. This will give you a so called B1 code of your button, which needs to be converted to a B0 code (see below). Sending Commands with Portisch Firmware ~ The commands learned with Portisch Firmware cannot be stored in device memory. Instead, they must be sent as a command. Example using MQTT: cmnd/sonoffRFBridge/Backlog RfRaw AAB0210314016703F924180101011001100110010101100110011001010110010101100255; RfRaw 0 Refer to issue #3973 for further information. B1 to B0 Conversion Tools ~ After learning how bitbucket works from the Portisch wiki , use one of these tools to help convert received B1 sniffing messages to the right 'B0' format to send in the 'RfRaw' command. Online Process: Enter rfraw 177 in the Sonoff Bridge web UI Console Press a function (each Button 2-3 times) on your remote control Copy the JSON payload output from the Console and paste it in the online converter and click Convert e.g., {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37DC 010101010101101001010101101010100102 55\"}} The utility will return the resulting B0 string to use in setting up commands in the RF Bridge e.g., AA B0 1A 03 08 07F9 0124 37DC 010101010101101001010101101010100102 55 CLI (rename file from BitBucketConverter.txt to BitBucketConverter.py ) In the command line give the B1 message string and the retries value (in decimal): e.g., BitBucketConverter.py \"AA B1 04 07EB 0157 00FD 3EBC 010101010101101001010101101010100103 55\" 20 Command Line : \"AA B1 04 07EB 0157 00FD 3EBC 010101010101101001010101101010100103 55\" 20 Result: RfRaw AAB01C041407EB015700FD3EBC01010101010110100101010110101010010355 Batch Process: Enter rfraw 177 in the Sonoff Bridge web UI Console Press each function (each Button 2-3 times) on your remote control Save everything from the console that happened after rfraw 177 to a text file Run bitbuckedconverter.py -f console.txt Each line of console.txt will be converted into a B0 string and displayed Run bitbuckedconverter.py -f console.txt -e Each line of console.txt will be converted into a B0 string and sent to the Bridge Then: * If the device reacted as expected, you can enter a name of the button (e.g., \"light\") * Else enter nothing to try the next * Repeat this until all lines have been tried * The tool will create a list of buttons and their B0 codes that have worked (i.e. for which you have specified a name) * In the end you can test all of these codes \"Raw sniffing\" As suggested by the Portisch firmware, perform the following: In the web UI Console, send RfRaw AAB155 This will result in two consecutive messages: 1. The first one tells you that you are using one of the new firmware commands 22:58:44 MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":\"ON\"} The second one tells that the EFM8BB1 RF chip new firmware accepts the command and enters raw sniffing mode ('A0' means 'ACK') 22:58:44 MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AAA055\"}} After that keep pushing one of the buttons on the remote. MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AAA055\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 04 07F0 0128 00F2 3822 010101010101101001010101101010100103 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37DC 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37DC 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0126 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F5 0127 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F7 0125 37DC 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0125 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0123 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07FC 011E 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F8 0125 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F8 0124 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0125 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F8 0122 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F1 012D 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0123 37C8 010101010101101001010101101010100102 55\"}}` MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F8 0128 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0124 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0123 37D2 010101010101101001010101101010100102 55\"}} Notice that this sequence of messages all start with 'AA' then 'B1' and the last byte '55' The reason for pushing the remote button for several seconds is to get enough 'AA B1 ...... 55' sequences to select the best one to be transmitted back. Then discard the sequences with 'data values' not equal. In the example 'data values' are the 010101010101101001010101101010100102 string. Notice that before that 'data values' string there are several 2 byte values (they are called 'buckets'); they are time values in microseconds. The number of 'buckets' is indicated in a previous byte (in the example a 3 or a 4). In the example, discard the first message (it contains 4 buckets, whereas the rest have only 3 buckets). Examine the values on the buckets in order to choose the message where more buckets are 'similar'. For example messages with ' 37D2 ' in the third bucket are good candidates. Messages with ' 0124 ' in the second bucket are also good candidates. First bucket values are very similar; ' 07F8 ' can be a good one. External Sources ~ Itead Product Page Itead Shop Itead Wiki RF Bridge 433 R2 Information","title":"Sonoff RF Bridge 433"},{"location":"devices/Sonoff-RF-Bridge-433/#flash-tasmota","text":"Please Hardware Preparation article for general flashing instructions. Access the serial interface available on the 5-pin header next to the switch as can be seen in the image. To flash the ESP8285, first move the switch position towards the 5-pin header. Connect the serial-to-USB adapter and press the button on the edge while powering the device in order to put the ESP8285 into programming mode in order to upload the Tasmota firmware. After flashing the ESP8285, be sure to move the switch position away from the 5-pin header to restore the connection to the RF microcontroller. Configure the device as usual and select module Sonoff Bridge (25) . During normal operation the serial interface is used at 19200 baud to communicate with the RF microcontroller. Therefore serial logging ( SerialLog 0 ) must be disabled. IMPORTANT: In the Module configuration GPIO4 and GPIO5 must be left as 00 None On R2 versions of the Sonoff RF Bridge, a hardware modification is required in order to use these GPIOs.","title":"Flash Tasmota"},{"location":"devices/Sonoff-RF-Bridge-433/#video-tutorial-by-alsolh","text":"","title":"Video tutorial by alsolh"},{"location":"devices/Sonoff-RF-Bridge-433/#rf-firmware","text":"The RF chip has its own firmware. The device is shipped with Itead firmware which supports a limited set of RF devices limited to mostly just Sonoff devices (a single 24-bit RF protocol). Some later versions of the factory firmware will only relay received RF data once the transmitting device stops. This is fine for remote controls or devices such as door sensors. But for devices such as smoke detectors, this behavior is not acceptable. Custom firmware is available for the RF chip which is commonly referred to as 'Portisch'. By updating the firmware on the RF chip, new types of devices and new features become usable. It also relays the RF data when the data is received rather than waiting until the transmitter stops. Tasmota supports the original Sonoff RF firmware and the Portisch firmware .","title":"RF Firmware"},{"location":"devices/Sonoff-RF-Bridge-433/#rf-firmware-upgrade","text":"The RF upgrade requires wiring the bridge and then flashing the firmware via the Tasmota web UI. **Attention \u26a0\ufe0f\ufe0f\u26a0\ufe0f\ufe0f\u26a0\ufe0f\ufe0f There are 2 versions of the Sonoff RF Bridge 433 : the R1 and the R2 V1.0 . R1 R2 V1.0 RF firmware flashing:","title":"RF Firmware Upgrade"},{"location":"devices/Sonoff-RF-Bridge-433/#operation","text":"The Sonoff RF Bridge is able to learn up to 16 different fixed code remote control commands as provided by PT2260, PT2262, PT2264 and EV1527 transmitters. It was not able to recognize the latest Klik Aan Klik Uit (KaKu) remote control signals but some people managed to use the fixed code KaKu devices like PAR-1000 receiver and PAT-103 transmitter. Tasmota provides default remote control commands to all 16 keys so you can start using the bridge with a Sonoff 4Ch Pro or Sonoff RF device without having the bridge have to learn remote control commands. See RF Bridge commands.","title":"Operation"},{"location":"devices/Sonoff-RF-Bridge-433/#portisch-firmware-specific-usage","text":"These sections only apply to the custom Portisch firmware.","title":"Portisch Firmware Specific Usage"},{"location":"devices/Sonoff-RF-Bridge-433/#learning-commands-with-portisch-firmware","text":"In order to learn Buttons from your remote, go to the Console of your RF Bridge. There, enter rfraw 177 and push the buttons on your remote. Repeat each button 2-3 times, as the signal may be different for each try. This will give you a so called B1 code of your button, which needs to be converted to a B0 code (see below).","title":"Learning Commands with Portisch Firmware"},{"location":"devices/Sonoff-RF-Bridge-433/#sending-commands-with-portisch-firmware","text":"The commands learned with Portisch Firmware cannot be stored in device memory. Instead, they must be sent as a command. Example using MQTT: cmnd/sonoffRFBridge/Backlog RfRaw AAB0210314016703F924180101011001100110010101100110011001010110010101100255; RfRaw 0 Refer to issue #3973 for further information.","title":"Sending Commands with Portisch Firmware"},{"location":"devices/Sonoff-RF-Bridge-433/#b1-to-b0-conversion-tools","text":"After learning how bitbucket works from the Portisch wiki , use one of these tools to help convert received B1 sniffing messages to the right 'B0' format to send in the 'RfRaw' command. Online Process: Enter rfraw 177 in the Sonoff Bridge web UI Console Press a function (each Button 2-3 times) on your remote control Copy the JSON payload output from the Console and paste it in the online converter and click Convert e.g., {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37DC 010101010101101001010101101010100102 55\"}} The utility will return the resulting B0 string to use in setting up commands in the RF Bridge e.g., AA B0 1A 03 08 07F9 0124 37DC 010101010101101001010101101010100102 55 CLI (rename file from BitBucketConverter.txt to BitBucketConverter.py ) In the command line give the B1 message string and the retries value (in decimal): e.g., BitBucketConverter.py \"AA B1 04 07EB 0157 00FD 3EBC 010101010101101001010101101010100103 55\" 20 Command Line : \"AA B1 04 07EB 0157 00FD 3EBC 010101010101101001010101101010100103 55\" 20 Result: RfRaw AAB01C041407EB015700FD3EBC01010101010110100101010110101010010355 Batch Process: Enter rfraw 177 in the Sonoff Bridge web UI Console Press each function (each Button 2-3 times) on your remote control Save everything from the console that happened after rfraw 177 to a text file Run bitbuckedconverter.py -f console.txt Each line of console.txt will be converted into a B0 string and displayed Run bitbuckedconverter.py -f console.txt -e Each line of console.txt will be converted into a B0 string and sent to the Bridge Then: * If the device reacted as expected, you can enter a name of the button (e.g., \"light\") * Else enter nothing to try the next * Repeat this until all lines have been tried * The tool will create a list of buttons and their B0 codes that have worked (i.e. for which you have specified a name) * In the end you can test all of these codes \"Raw sniffing\" As suggested by the Portisch firmware, perform the following: In the web UI Console, send RfRaw AAB155 This will result in two consecutive messages: 1. The first one tells you that you are using one of the new firmware commands 22:58:44 MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":\"ON\"} The second one tells that the EFM8BB1 RF chip new firmware accepts the command and enters raw sniffing mode ('A0' means 'ACK') 22:58:44 MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AAA055\"}} After that keep pushing one of the buttons on the remote. MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AAA055\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 04 07F0 0128 00F2 3822 010101010101101001010101101010100103 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37DC 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37DC 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0126 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F5 0127 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F7 0125 37DC 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0125 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0123 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07FC 011E 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F8 0125 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F8 0124 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0125 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F8 0122 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F1 012D 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0123 37C8 010101010101101001010101101010100102 55\"}}` MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F8 0128 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0124 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0123 37D2 010101010101101001010101101010100102 55\"}} Notice that this sequence of messages all start with 'AA' then 'B1' and the last byte '55' The reason for pushing the remote button for several seconds is to get enough 'AA B1 ...... 55' sequences to select the best one to be transmitted back. Then discard the sequences with 'data values' not equal. In the example 'data values' are the 010101010101101001010101101010100102 string. Notice that before that 'data values' string there are several 2 byte values (they are called 'buckets'); they are time values in microseconds. The number of 'buckets' is indicated in a previous byte (in the example a 3 or a 4). In the example, discard the first message (it contains 4 buckets, whereas the rest have only 3 buckets). Examine the values on the buckets in order to choose the message where more buckets are 'similar'. For example messages with ' 37D2 ' in the third bucket are good candidates. Messages with ' 0124 ' in the second bucket are also good candidates. First bucket values are very similar; ' 07F8 ' can be a good one.","title":"B1 to B0 Conversion Tools"},{"location":"devices/Sonoff-RF-Bridge-433/#external-sources","text":"Itead Product Page Itead Shop Itead Wiki RF Bridge 433 R2 Information","title":"External Sources"},{"location":"devices/Sonoff-RF-R3/","text":"See Sonoff DIY for flashing instructions Convert RF R3 into an RF Bridge ~ Instructions","title":"Sonoff RF R3"},{"location":"devices/Sonoff-RF-R3/#convert-rf-r3-into-an-rf-bridge","text":"Instructions","title":"Convert RF R3 into an RF Bridge"},{"location":"devices/Sonoff-RF/","text":"Serial Flashing ~ The Sonoff RF needs some tweaking as the connection needed during programming between the button and GPIO0 might not be present. This connection must be removed after the conversion to Tasmota or a button press will send the device in an ON/OFF loop. This can be achieved by shorting both solder pads of R21 with a small screwdriver while holding down the button during programming. This can be a bit fiddly, and ideally you should check the bootloader output over serial to see whether you managed to get it into programming mode. Alternatively, Phalox installed a jumper wire (explained in the picture below). Remember to remove it after programming. The R2 V1.0 version of the Sonoff RF uses an ESP8285 which is covered by a horizontally orientated RF expansion board. Entering flash ready mode can be achieved by grounding K_P (which is connected to GPIO0) to the neighbouring GND pin on the RF board during power on. Pairing the iTead RF remote controller is the same as with the original iTead software: - two short button presses will blink a red led shortly and start RF signal recognition. Three longer blinks signal RF reception. - three short button presses will keep the red led on for some seconds and erase the known RF code. I was unable to pair the Sonoff RF 434MHz receiver with my KaKu switches but the iTead provided remote control works just fine. Pairing a RF remote control ~ During programming a connection for R21 is needed in order to use a button press to ground GPIO0. To pair a RF remote control with the Sonoff RF it is important that there is NO connection made for R21. User gadjet installed a jumper in place of R21 allowing easy programming (jumper in), pairing (jumper out) and normal use (jumper out). The Slampher RF Revision 2.0 can have the same modification applied, but it requires its jumper across R3. Pairing Instructions ~ Pairing the iTead RF remote controller is the same as with the original iTead software: - two short button presses will blink a red led shortly and start RF signal recognition. Three longer blinks signal RF reception. - three short button presses will keep the red led on for some seconds and erase the known RF code. I was unable to pair the Sonoff RF 434MHz receiver with my KaKu switches but the iTead provided remote control works just fine. Version 2 Pairing Instructions ~ RF units produced after 6/2018 use a different procedure for pairing. Press and hold the button for 3-seconds until the red light flashes once, then press then button on your remote to program. Press and hold for button for 5-seconds until the red light flashes twice to clear remote programming.","title":"Sonoff RF"},{"location":"devices/Sonoff-RF/#serial-flashing","text":"The Sonoff RF needs some tweaking as the connection needed during programming between the button and GPIO0 might not be present. This connection must be removed after the conversion to Tasmota or a button press will send the device in an ON/OFF loop. This can be achieved by shorting both solder pads of R21 with a small screwdriver while holding down the button during programming. This can be a bit fiddly, and ideally you should check the bootloader output over serial to see whether you managed to get it into programming mode. Alternatively, Phalox installed a jumper wire (explained in the picture below). Remember to remove it after programming. The R2 V1.0 version of the Sonoff RF uses an ESP8285 which is covered by a horizontally orientated RF expansion board. Entering flash ready mode can be achieved by grounding K_P (which is connected to GPIO0) to the neighbouring GND pin on the RF board during power on. Pairing the iTead RF remote controller is the same as with the original iTead software: - two short button presses will blink a red led shortly and start RF signal recognition. Three longer blinks signal RF reception. - three short button presses will keep the red led on for some seconds and erase the known RF code. I was unable to pair the Sonoff RF 434MHz receiver with my KaKu switches but the iTead provided remote control works just fine.","title":"Serial Flashing"},{"location":"devices/Sonoff-RF/#pairing-a-rf-remote-control","text":"During programming a connection for R21 is needed in order to use a button press to ground GPIO0. To pair a RF remote control with the Sonoff RF it is important that there is NO connection made for R21. User gadjet installed a jumper in place of R21 allowing easy programming (jumper in), pairing (jumper out) and normal use (jumper out). The Slampher RF Revision 2.0 can have the same modification applied, but it requires its jumper across R3.","title":"Pairing a RF remote control"},{"location":"devices/Sonoff-RF/#pairing-instructions","text":"Pairing the iTead RF remote controller is the same as with the original iTead software: - two short button presses will blink a red led shortly and start RF signal recognition. Three longer blinks signal RF reception. - three short button presses will keep the red led on for some seconds and erase the known RF code. I was unable to pair the Sonoff RF 434MHz receiver with my KaKu switches but the iTead provided remote control works just fine.","title":"Pairing Instructions"},{"location":"devices/Sonoff-RF/#version-2-pairing-instructions","text":"RF units produced after 6/2018 use a different procedure for pairing. Press and hold the button for 3-seconds until the red light flashes once, then press then button on your remote to program. Press and hold for button for 5-seconds until the red light flashes twice to clear remote programming.","title":"Version 2 Pairing Instructions"},{"location":"devices/Sonoff-S20/","text":"Sonoff S20 comes in 4 different plug type variations. Flashing process will be the same for each type. Serial Connection ~ Please see the Hardware Preparation page for general instructions. The picture shows how to program the S20 Smart Socket powered by the serial-to-USB converter. With newer US sockets, either use a right-angle header, or remove the header after flashing. Otherwise,the pushbutton may rub against a pin and get stuck. Be sure it is NOT plugged in mains! Remove the \"hidden\" screw. (optional) Remove the board from the plastic shell to have better access to serial pins. There are 2 screws at the red and blue wire. Be careful not to damage the soldered connection! Connect the jumper wires. From top to bottom (see image below): - Vcc (3,3V) - RXD - TXD - GND Connected? Hold the little button pressed while connecting the serial-to-USB adapter to your computer. After about 2 seconds let go of the button. It is now in flashing mode and ready to be flashed with Tasmota. Video tutorial by Don't It Yourself ~ Official Sources ~ Itead Product Page: http://sonoff.itead.cc/en/products/residential/s20-socket Itead Wiki: https://www.itead.cc/wiki/S20_Smart_Socket OpenHab Configuration ~ sonoff.items: Switch S20_1 \"Coffee S20-1 Powerplug\" (LR,gLight) { mqtt=\">[broker:cmnd/sonoff-S20-1/POWER:command:*:default], <[broker:stat/sonoff-S20-1/POWER:state:default], <[broker:stat/sonoff-S20-1/RESULT:state:JSONPATH($.POWER)], <[broker:tele/sonoff-S20-1/STATE:state:JSONPATH($.POWER)] \"} Switch S20_1_Reachable \"S20-1 reachable\" <contact> (gReachable) { mqtt=\"<[broker:tele/sonoff-S20-1/LWT:state:MAP(reachable.map)], <[broker:stat/sonoff-S20-1/RESULT:state:ON], <[broker:stat/sonoff-S20-1/POWER:state:ON], <[broker:tele/sonoff-S20-1/STATE:state:ON] \" } default.sitemap: Switch item=S20_1 labelcolor=[S20_1_Reachable == \"ON\" = \"green\",S20_1_Reachable == \"OFF\" = \"red\"] Configuration ~ Once set up and connected, you can set the module type to Sonoff S2X (8) in Configure module .","title":"Sonoff S20"},{"location":"devices/Sonoff-S20/#serial-connection","text":"Please see the Hardware Preparation page for general instructions. The picture shows how to program the S20 Smart Socket powered by the serial-to-USB converter. With newer US sockets, either use a right-angle header, or remove the header after flashing. Otherwise,the pushbutton may rub against a pin and get stuck. Be sure it is NOT plugged in mains! Remove the \"hidden\" screw. (optional) Remove the board from the plastic shell to have better access to serial pins. There are 2 screws at the red and blue wire. Be careful not to damage the soldered connection! Connect the jumper wires. From top to bottom (see image below): - Vcc (3,3V) - RXD - TXD - GND Connected? Hold the little button pressed while connecting the serial-to-USB adapter to your computer. After about 2 seconds let go of the button. It is now in flashing mode and ready to be flashed with Tasmota.","title":"Serial Connection"},{"location":"devices/Sonoff-S20/#video-tutorial-by-dont-it-yourself","text":"","title":"Video tutorial by Don't It Yourself"},{"location":"devices/Sonoff-S20/#official-sources","text":"Itead Product Page: http://sonoff.itead.cc/en/products/residential/s20-socket Itead Wiki: https://www.itead.cc/wiki/S20_Smart_Socket","title":"Official Sources"},{"location":"devices/Sonoff-S20/#openhab-configuration","text":"sonoff.items: Switch S20_1 \"Coffee S20-1 Powerplug\" (LR,gLight) { mqtt=\">[broker:cmnd/sonoff-S20-1/POWER:command:*:default], <[broker:stat/sonoff-S20-1/POWER:state:default], <[broker:stat/sonoff-S20-1/RESULT:state:JSONPATH($.POWER)], <[broker:tele/sonoff-S20-1/STATE:state:JSONPATH($.POWER)] \"} Switch S20_1_Reachable \"S20-1 reachable\" <contact> (gReachable) { mqtt=\"<[broker:tele/sonoff-S20-1/LWT:state:MAP(reachable.map)], <[broker:stat/sonoff-S20-1/RESULT:state:ON], <[broker:stat/sonoff-S20-1/POWER:state:ON], <[broker:tele/sonoff-S20-1/STATE:state:ON] \" } default.sitemap: Switch item=S20_1 labelcolor=[S20_1_Reachable == \"ON\" = \"green\",S20_1_Reachable == \"OFF\" = \"red\"]","title":"OpenHab Configuration"},{"location":"devices/Sonoff-S20/#configuration","text":"Once set up and connected, you can set the module type to Sonoff S2X (8) in Configure module .","title":"Configuration"},{"location":"devices/Sonoff-S26-Smart-Socket/","text":"Itead Product Page: http://sonoff.itead.cc/en/products/residential/sonoff-s26-smart-plug Itead Shop: https://www.itead.cc/sonoff-s26-wifi-smart-plug.html Serial Connection ~ Please see the Hardware Preparation page for general instructions. LED State ~ The S26 has a red LED connected to GPIO12 along with the relay so it's not possible to disable the power button LED entirely. Setting LedState 0 disables the blue LED when the relay is turned on and reserves it for Wi-Fi/MQTT state only. Soldering guide ~ Apply rosin to shaved wires. Solder tin to the flats on the module.(First put solder tip to flat and apply tin). Gently solder the wires. Alternative solder points available for 3V3, GND and RX on the underside of the mainboard. Jumper Pin J1 3V3 J2 GND J3 GPIO-12 J4 GPIO-0 J5 GPIO-13 J10 RX No Solder Connection ~ With the help of some adhesive tape it is possible to acheive a flash without soldering. Hook your connecting wires / pins into the locations shown on the T1117A regulator - there is enough space under the SOT-223 package pins for a connection to be made. Use some adhesive tape to hold these pins in place; it only needs to remain there for a few minutes. (Vout = 3v3, Pin 1 = GND) Flip the board on its side to expose the TX and RX pins. Follow steps 1-4 below, ignoring the TX/RX connection. Once in flash mode, hold the TX/RX pin connection in place with one hand and start the flash with the other! It looks messy with the tape in the below photo but means no soldering required. Bringing the Module into Flash Mode ~ Disconnect serial programmer and power Press and hold the on-board button - Note: The Button on the main board is not very sensitive and must be pressed firmly. Connect the serial programmer (VCC, RX, TX, GND) Release the on-board button The blue LED should NOT be blinking when in Flash mode. Storage/Memory ~ Running Tasmota 6.1.1 the unit reports: Flash Size 1024kB Program Flash Size 1024kB Program Size 536kB Free Program Space 464kB Free Memory 16kB More information ~ See issue #2808 for user information","title":"Sonoff S26 Smart Socket"},{"location":"devices/Sonoff-S26-Smart-Socket/#serial-connection","text":"Please see the Hardware Preparation page for general instructions.","title":"Serial Connection"},{"location":"devices/Sonoff-S26-Smart-Socket/#led-state","text":"The S26 has a red LED connected to GPIO12 along with the relay so it's not possible to disable the power button LED entirely. Setting LedState 0 disables the blue LED when the relay is turned on and reserves it for Wi-Fi/MQTT state only.","title":"LED State"},{"location":"devices/Sonoff-S26-Smart-Socket/#soldering-guide","text":"Apply rosin to shaved wires. Solder tin to the flats on the module.(First put solder tip to flat and apply tin). Gently solder the wires. Alternative solder points available for 3V3, GND and RX on the underside of the mainboard. Jumper Pin J1 3V3 J2 GND J3 GPIO-12 J4 GPIO-0 J5 GPIO-13 J10 RX","title":"Soldering guide"},{"location":"devices/Sonoff-S26-Smart-Socket/#no-solder-connection","text":"With the help of some adhesive tape it is possible to acheive a flash without soldering. Hook your connecting wires / pins into the locations shown on the T1117A regulator - there is enough space under the SOT-223 package pins for a connection to be made. Use some adhesive tape to hold these pins in place; it only needs to remain there for a few minutes. (Vout = 3v3, Pin 1 = GND) Flip the board on its side to expose the TX and RX pins. Follow steps 1-4 below, ignoring the TX/RX connection. Once in flash mode, hold the TX/RX pin connection in place with one hand and start the flash with the other! It looks messy with the tape in the below photo but means no soldering required.","title":"No Solder Connection"},{"location":"devices/Sonoff-S26-Smart-Socket/#bringing-the-module-into-flash-mode","text":"Disconnect serial programmer and power Press and hold the on-board button - Note: The Button on the main board is not very sensitive and must be pressed firmly. Connect the serial programmer (VCC, RX, TX, GND) Release the on-board button The blue LED should NOT be blinking when in Flash mode.","title":"Bringing the Module into Flash Mode"},{"location":"devices/Sonoff-S26-Smart-Socket/#storagememory","text":"Running Tasmota 6.1.1 the unit reports: Flash Size 1024kB Program Flash Size 1024kB Program Size 536kB Free Program Space 464kB Free Memory 16kB","title":"Storage/Memory"},{"location":"devices/Sonoff-S26-Smart-Socket/#more-information","text":"See issue #2808 for user information","title":"More information"},{"location":"devices/Sonoff-S31/","text":"\u26a0\ufe0f\ufe0f\ufe0f Do not connect AC power and the serial connection at the same time \ufe0f\ufe0f\ufe0f\u26a0\ufe0f\ufe0f\ufe0f The GND connection of the S31 is connected to the live AC wire. Connecting serial with your PC will fry your PC and will electrocute you. DO NOT CONNECT ANY SENSOR TO THESE DEVICES. Only use them as designed. The GPIOs on this device are connected to AC power , therefore it is not possible to safely add sensors or displays to it. Serial Flashing ~ The S31 is pretty easy to take apart. 1. Pry off the gray cover on the end. 1. Slide off the two rounded corner pieces to reveal the 3 screws. 1. Unscrew the 3 screws. 1. Lift off the cover. 1. There are no through holes. You can solder a piece of header or you can fabricate something using pogo pins and just hold it for the duration of the flashing process. But, be aware that can get tiring if you need to do it multiple times. 1. The pads are labeled, you need VCC, RX, TX, GND. There are two others that also have RX and TX on them. The ones next to the GND pin are not used for flashing. 1. Connect to your serial converter and 3V3. 1. You need to press the switch (GPIO0) before applying power to put into bootloader mode. For exact energy monitoring you might need to calibrate the device . Tinkerman's review of Sonoff S31 Video tutorial by BK Hobby ~","title":"Sonoff S31"},{"location":"devices/Sonoff-S31/#serial-flashing","text":"The S31 is pretty easy to take apart. 1. Pry off the gray cover on the end. 1. Slide off the two rounded corner pieces to reveal the 3 screws. 1. Unscrew the 3 screws. 1. Lift off the cover. 1. There are no through holes. You can solder a piece of header or you can fabricate something using pogo pins and just hold it for the duration of the flashing process. But, be aware that can get tiring if you need to do it multiple times. 1. The pads are labeled, you need VCC, RX, TX, GND. There are two others that also have RX and TX on them. The ones next to the GND pin are not used for flashing. 1. Connect to your serial converter and 3V3. 1. You need to press the switch (GPIO0) before applying power to put into bootloader mode. For exact energy monitoring you might need to calibrate the device . Tinkerman's review of Sonoff S31","title":"Serial Flashing"},{"location":"devices/Sonoff-S31/#video-tutorial-by-bk-hobby","text":"","title":"Video tutorial by BK Hobby"},{"location":"devices/Sonoff-SC/","text":"Serial Connection / Flashing ~ Please see the Hardware Preparation page for general instructions. Flashing the ESP8266 Remove the 4 screws on the bottom. The button is connected to GPIO0. You will have to remove the TX jumper in the board to avoid the ATMega328P to interfere in the upload process. Press and hold the button while powering the board to set the ESP8266 into flashing mode. Note! After flashing you need to set the baudrate to 19200. Don't forget to reconnect the TX jumper after flashing ;)","title":"Sonoff SC"},{"location":"devices/Sonoff-SC/#serial-connection-flashing","text":"Please see the Hardware Preparation page for general instructions. Flashing the ESP8266 Remove the 4 screws on the bottom. The button is connected to GPIO0. You will have to remove the TX jumper in the board to avoid the ATMega328P to interfere in the upload process. Press and hold the button while powering the board to set the ESP8266 into flashing mode. Note! After flashing you need to set the baudrate to 19200. Don't forget to reconnect the TX jumper after flashing ;)","title":"Serial Connection / Flashing"},{"location":"devices/Sonoff-SV/","text":"Sonoff Safe Voltage is almost the same as Sonoff Basic R1. These are the differences between the two: * It can be powered by DC voltage * It has more usable GPIO pins - GPIO4 - GPIO5 - GPIO14 * It has two LED status lights (RED and GREEN) * The traces on the bottom aren't soldered * The GND, TX, RX and 3v3 pins are labeled \u26a0\ufe0f What can the unit handle \u26a0\ufe0f ~ The trace is 2 mm wide. By assuming the PCB trace thickness is 1 oz/ft^2 you can calculate the current: 2A If you are using more than 2A be sure to put more solder on the solder traces. Using Sonoff SV ~ You can use the Sonoff SV in three different ways: 1. Variable DC voltage between 5-24 V By not having the jumper connected in the far left. the voltage regulator is used for the relay. 2. Solid DC voltage 5 V By bridging the two pins you are connecting the 5 V input directly to the relay so you are bypassing the regulator so the relay still gets 5 V 3. \u26a0\ufe0f With AC voltage \u26a0\ufe0f \u26a0\ufe0f \u26a1\ufe0f WARNING ONLY DO THIS WHEN YOU KNOW WHAT YOU ARE DOING. \u26a1\ufe0f \u26a0\ufe0f By removing the two 0 ohm SMD resistors next to the jumper you are disconnecting the voltage input from the logic. By doing this you can switch AC again like the Sonoff Basic. Than You can use the jumpers labeled 5~12 V as your DC voltage for the ESP and relay. Official Sources ~ Itead Product Page: Itead Shop: https://www.itead.cc/sonoff-sv.html Itead Wiki: https://www.itead.cc/wiki/Sonoff_SV","title":"Sonoff SV"},{"location":"devices/Sonoff-SV/#what-can-the-unit-handle","text":"The trace is 2 mm wide. By assuming the PCB trace thickness is 1 oz/ft^2 you can calculate the current: 2A If you are using more than 2A be sure to put more solder on the solder traces.","title":"\u26a0\ufe0f What can the unit handle \u26a0\ufe0f"},{"location":"devices/Sonoff-SV/#using-sonoff-sv","text":"You can use the Sonoff SV in three different ways:","title":"Using Sonoff SV"},{"location":"devices/Sonoff-SV/#official-sources","text":"Itead Product Page: Itead Shop: https://www.itead.cc/sonoff-sv.html Itead Wiki: https://www.itead.cc/wiki/Sonoff_SV","title":"Official Sources"},{"location":"devices/Sonoff-Slampher/","text":"See this article: Tasmota: Sonoff Slampher WiFi Bulb Holder Local Control (external link) I purchased a Sonoff Slampher V2 in July, 2020. The circuit board didn't match either/any of the tutorial for getting the original or V2 devices into programming mode. Though it's labeled \"V2\", the cluster of resistors/capacitors around the CPU is different; in particular the resistor at the position indicated by many of the tutorials as labelled r9 , is instead labelled r18 . There does seem to be a trace attached to the GPIO0 pin on the CPU but it leads to a dead end (perhaps a via to the other side of the board). After much screwing around, I discovered that simply holding the button while I connected to the four header pins and powered it on put it into programming mode. I flashed it from a mac terminal window like so: esptool . py -- port / dev / tty . usbserial - A60226NF write_flash - fs 1 MB - fm dout 0x0 ~/ Downloads / tasmota . bin The barcode on the box for the device that I received is 6920075757361, it's also labeled with MPN:IM190528001. I purchased the device from Amazon, it was titled SONOFF Slampher R2 433MHz RF&WiFi Smart Lamp Bulb Holder for Smart Home, Compatible with Alexa and Google Assistant and was at this URL: https://www.amazon.com/gp/product/B07TRSYJGB","title":"Sonoff Slampher"},{"location":"devices/Sonoff-T1/","text":"Sonoff-T1 seems to be an evolution of Sonoff Touch and exists in one, two or three button variations and contains a 433MHz receiver. Based on the ESP8285, but using a Silabs EFM8BB1 microcontroller to extend the number of IOs needed to control 3 buttons, with separate relays and LEDs together with the radio. SYN470R is used as 433Mhz Radio. The chip for touch is unlabeled. EFM8BB1 Data Sheet ESP8285 Data Sheet SYN470R Data Sheet Read before flashing ~ Tasmota has functionality to perform special actions on multiple button presses and long press for 40 seconds resets firmware to default. This will cause the T1 board to reset if relay board is not connected, because long press on Button1 will be detected. To avoid this, use command SetOption13 1 immediately after flashing Tasmota. When powered solely with 3.3v from the serial-to-USB adapter long press will be detected by Tasmota on Button1. When powered solely with 3.3v from the serial-to-USB adapter RF functions do not work. If you can't flash succesfully lower the baud rate, most likely to 74880 . Serial Flashing ~ Sonoff T1 UK ~ The front circuit board should be disconnected from the rear relay board to prevent power draw upsetting the flashing process. The unit must be powered up before attempting to enter programming mode. If touch Button1 is held while power is connected, the device will not go enter flash mode. The touch IC does not have time to recognise the key-press before the device boots. Touch Board VER:1 ~ The following board layouts are from the 3 variants of the Sonoff T1 UK variant and are marked Sonoff T1 R2 UK Touch Board, Ver 1.0. Entering Flashing mode varies between the 1, 2 and 3 channel versions. See the above picture for button nomenclature used. (The variations between the 3 versions appear to be managed by the touch IC rather than in the ESP). To enter flashing mode the unit should be powered and connected to the programmer of choice. Touch Button 1 should then be held while the reset button (4) is pressed. When the device reboots, Button 1 can be released. OR Double-press the reset-button Try option 1 OR option 2. This will cause the unit to reboot into flash mode. This is confirmed on a serial console (74880 baud) by the boot mode displaying (1,x) indicating that we are booted to the bootloader and not the flash. You can also confirm booted to flash without a serial console, the main led should be off and the backlight LEDs lit dimly. There is no longer a need to solder anything to GPIO0 or to ground it while powering up for Ver1.0; this step is replaced by the above button sequence. However, GPIO0 to GND is the only way for Ver1.1 boards. Touch Board Ver:1.1 ~ Notes: 1. There is not enough room with this version to solder header pins to the programming port and still close the case. One possibility is to slightly bend the pins of a 4-way header and push it into the holes, removing it after programming. 2. GPIO0 is connected to the helper chip on this version, so the only way to get Ver1.1 of the board into flash mode is to solder a lead onto the resistor R19 from pin 15 on the ESP chip (GPIO0) and connect this lead to GND on power up; the device will set all the touch pads to dim and the WiFi LED D3 will NOT be on at all. 3. The connection marked 'LOG' on the J3 header is GPIO2. WARNING!! Do not attempt to power the device from your serial-to-USB adapter when connected to the relay board. This draws too much power and will cause the ESP to reboot frequently and reset all the configured settings. Sonoff T1 EU ~ For most devices, the UK version flashing guide may work. Sonoff T1 EU 1CH (2018-06-04) ~ All the flashing pins are in the front top right corner (sorry about covering them with the wires). From top to bottom: - LOG (GPIO2 not used) - GND - TXD - RXD - VCC To flash simply connect GND, TXD, RXD, and VCC as any regular ESP. Hold the touch button, press reset at once, then it boots into flash mode (no blinking WiFi LED, dimmed touch button). If this does not work, try shorting R19 to GND as shown in \"Touch Board VER:1.1\" * Stock baud rate: 74880 * Relay pin: 0 Sonoff T1 EU 2CH (v1.0) ~ For 2 Channel board version 1.0 , you need to solder (or otherwise permanently connect) GPIO0 (R19) to GND before powering the board and only disconnect them once the flashing is complete. After having connected GPIO0 and GND, power the board - it will boot directly to flashing mode. Flash your firmware and disconnect the board. Sonoff T1 EU 3CH (2018-10-03) ~ There are two pin headers (J1 and J3) and no reset button. J3 is used for flashing. GPIO0 is exposed on the back as test point (TP2/GPIO0). Connecting it to any ground such as the ground from J1 when powering up puts the ESP8255 into flash mode. Baud rate for flashing is 74880. Sonoff T1 US ~ It appears that SonOTA may work again with Sonoff firmware v2.0.1 or greater . This needs to be verified for this specific device. To get it working you can simply plug it to mains, once it's powered up, press and hold the button that's closer to the Wi-Fi logo (you'll hear a beep sound). Keep holding it until you hear that beep for the second time. Now let go. The Wi-Fi light should blink in pairs of 3. Now repeat the procedure (Press and hold until you hear the beep 2 times). Now you should be seeing the Wi-Fi logo flashing rapidly. You can proceed to try and flash with SonOTA now. US Model of 3-button T1, received direct from Sonoff China 2018-05-12 ~ Front photo (Google photos) Rear photo (Google photos) (Sorry about the tape smudges). The header labels on J3 are accurate (apparently some boards have TX and RX reversed; this doesn't seem to suffer that). Flashed with SonOTA . Above method of getting into flash mode doesn't seem to work. UPDATE: I did flash it with the FTDI method. To put then in flash mode press 2 times quickly the internal switch S1. UPDATE 2: Confirmed by another user that flashed with SonOTA works as described on \"Preparing\" Sonoff T1 US 3 Gang ~ The jump-wire method to enter the flash mode: * Jump the wire as attached picture * While keeping the wire connected then plug the serial-to-USB adapter to the computer * Wait for 1 to 2 seconds then release the jump-wire * You can start flashing the Sonoff T1 US 3C. Sonoff TX US 2/3 Gang ~ The PCB layout for the TX/T0 model (vertical, black or white face-plate with squared-off, LED-lit buttons) is different again from the original T1. There is no TP2/GPIO0 test point on the back of the PCB and R19 has moved. The basic instructions for flashing the T1 (with a USB adapter) still work. ~ It seems that Sonoff is trying to seal off the ESP using some glue see image: 433MHz remote ~ The Tasmota firmware is compatible with the RF remote feature built in to the T1 modules. Pairing a new remote is the same procedure as a stock Sonoff, i.e., hold the desired button on your sonoff until you are given 1 beep (approx 7 seconds), press the button on your RF remote. The Sonoff will beep to confirm the pairing. To unpair a remote, press until you are given 2 beeps, press the button on your RF remote. The Sonoff will beep to confirm the unpairing. Circuit ~ ESP8285 GPIO0 EFM8BB1 P1,3 Switch 1 input (Goes low when first touch button is pressed) GPIO04 is connected to the small (soft) reset button on the front. GPIO09 EFM8BB1 P1,4 - Switch 3 input (Goes low when third touch button is pressed) GPIO10 EFM8BB1 P1,5 - Switch 2 input GPIO13 is connected to status LED D3. GPIO12 Relay 1 GPIO5 Relay 2 GPIO4 Relay 3 GPIO2 is connected on J3 pin 5 (LOG) On the EFM8BB1 (QFN20 package) P0,0 Relay 1 P0,1 Relay 2 P0,2 Relay 3 P0,3 Button 1 P0,4 Button 2 P0,5 Button 3 P0,6 SYN470R Data Out P0,7 Buzzer P1,0 Led button 1 P1,1 Led button 2 P1,2 Led button 3 P1,3 ESP8285 GPIO0 P1,4 ESP8285 GPIO09 P1,5 ESP8285 GPIO10 P1,6 ESP8285 EXT_RSTB (RESET) Ghost Switching ~ Some of these devices are prone to hardware ghost switching. You may need to experiment with ButtonDebounce and SetOption40 to reduce or eliminate these issues. Also, during the flashing process, you may have soldered a lead to GPIO0 in order to connect it to GND for putting the ESP into programming mode. If there are any random oscillations on GPIO0, this can trigger the relay. The contacts on the PCB are very close together. Check that you don't have any stray solder to another contact. Even if there isn't contact, over time heat and humidity can cause any residual flux to become resistive and allow conductivity. Be sure to clean everything after removing any leads. Known so far ~ When pushing a button, the touch chip lift the power high to the EFM8BB1, and the EFM8BB1 chip ties the signal line for each button low, for the full duration of the keypress. Debouncing is not needed. 433MHz remotes are compatible with the Tasmota firmware DO NOT attempt to power the device from your programmer when connected to the relay board. This draws too much power and will cause the ESP to reboot frequently and will reset all the configured settings. The relays state can be set on the GPIO's 12, 5 and 4. The switch status can be read on GPIO's 0, 10 and 9. Push button active low. Unknown so far ~ Where GPIO15 is connected? Over R18 10kOhm pull-down only? Official Sources ~ Sonoff T1 UK ~ Itead Product Page Itead Shop The Sonoff T1 UK with 1 to 3 gang is fully supported by Tasmota starting with version 5.6.1. Sonoff T1 EU ~ Itead Product Page Itead Shop The Sonoff T1 EU with 1 to 3 gang is fully supported by Tasmota starting with version 5.6.1. Sonoff T1 US ~ Itead Product Page Itead Shop The Sonoff T1 US with 1 to 3 gang was launched March 2018. Sonoff TX US ~ Itead Product Page Itead Shop","title":"Sonoff T1"},{"location":"devices/Sonoff-T1/#read-before-flashing","text":"Tasmota has functionality to perform special actions on multiple button presses and long press for 40 seconds resets firmware to default. This will cause the T1 board to reset if relay board is not connected, because long press on Button1 will be detected. To avoid this, use command SetOption13 1 immediately after flashing Tasmota. When powered solely with 3.3v from the serial-to-USB adapter long press will be detected by Tasmota on Button1. When powered solely with 3.3v from the serial-to-USB adapter RF functions do not work. If you can't flash succesfully lower the baud rate, most likely to 74880 .","title":"Read before flashing"},{"location":"devices/Sonoff-T1/#serial-flashing","text":"","title":"Serial Flashing"},{"location":"devices/Sonoff-T1/#sonoff-t1-uk","text":"The front circuit board should be disconnected from the rear relay board to prevent power draw upsetting the flashing process. The unit must be powered up before attempting to enter programming mode. If touch Button1 is held while power is connected, the device will not go enter flash mode. The touch IC does not have time to recognise the key-press before the device boots.","title":"Sonoff T1 UK"},{"location":"devices/Sonoff-T1/#touch-board-ver1","text":"The following board layouts are from the 3 variants of the Sonoff T1 UK variant and are marked Sonoff T1 R2 UK Touch Board, Ver 1.0. Entering Flashing mode varies between the 1, 2 and 3 channel versions. See the above picture for button nomenclature used. (The variations between the 3 versions appear to be managed by the touch IC rather than in the ESP). To enter flashing mode the unit should be powered and connected to the programmer of choice. Touch Button 1 should then be held while the reset button (4) is pressed. When the device reboots, Button 1 can be released. OR Double-press the reset-button Try option 1 OR option 2. This will cause the unit to reboot into flash mode. This is confirmed on a serial console (74880 baud) by the boot mode displaying (1,x) indicating that we are booted to the bootloader and not the flash. You can also confirm booted to flash without a serial console, the main led should be off and the backlight LEDs lit dimly. There is no longer a need to solder anything to GPIO0 or to ground it while powering up for Ver1.0; this step is replaced by the above button sequence. However, GPIO0 to GND is the only way for Ver1.1 boards.","title":"Touch Board VER:1"},{"location":"devices/Sonoff-T1/#touch-board-ver11","text":"Notes: 1. There is not enough room with this version to solder header pins to the programming port and still close the case. One possibility is to slightly bend the pins of a 4-way header and push it into the holes, removing it after programming. 2. GPIO0 is connected to the helper chip on this version, so the only way to get Ver1.1 of the board into flash mode is to solder a lead onto the resistor R19 from pin 15 on the ESP chip (GPIO0) and connect this lead to GND on power up; the device will set all the touch pads to dim and the WiFi LED D3 will NOT be on at all. 3. The connection marked 'LOG' on the J3 header is GPIO2. WARNING!! Do not attempt to power the device from your serial-to-USB adapter when connected to the relay board. This draws too much power and will cause the ESP to reboot frequently and reset all the configured settings.","title":"Touch Board Ver:1.1"},{"location":"devices/Sonoff-T1/#sonoff-t1-eu","text":"For most devices, the UK version flashing guide may work.","title":"Sonoff T1 EU"},{"location":"devices/Sonoff-T1/#sonoff-t1-eu-1ch-2018-06-04","text":"All the flashing pins are in the front top right corner (sorry about covering them with the wires). From top to bottom: - LOG (GPIO2 not used) - GND - TXD - RXD - VCC To flash simply connect GND, TXD, RXD, and VCC as any regular ESP. Hold the touch button, press reset at once, then it boots into flash mode (no blinking WiFi LED, dimmed touch button). If this does not work, try shorting R19 to GND as shown in \"Touch Board VER:1.1\" * Stock baud rate: 74880 * Relay pin: 0","title":"Sonoff T1 EU 1CH (2018-06-04)"},{"location":"devices/Sonoff-T1/#sonoff-t1-eu-2ch-v10","text":"For 2 Channel board version 1.0 , you need to solder (or otherwise permanently connect) GPIO0 (R19) to GND before powering the board and only disconnect them once the flashing is complete. After having connected GPIO0 and GND, power the board - it will boot directly to flashing mode. Flash your firmware and disconnect the board.","title":"Sonoff T1 EU 2CH (v1.0)"},{"location":"devices/Sonoff-T1/#sonoff-t1-eu-3ch-2018-10-03","text":"There are two pin headers (J1 and J3) and no reset button. J3 is used for flashing. GPIO0 is exposed on the back as test point (TP2/GPIO0). Connecting it to any ground such as the ground from J1 when powering up puts the ESP8255 into flash mode. Baud rate for flashing is 74880.","title":"Sonoff T1 EU 3CH (2018-10-03)"},{"location":"devices/Sonoff-T1/#sonoff-t1-us","text":"It appears that SonOTA may work again with Sonoff firmware v2.0.1 or greater . This needs to be verified for this specific device. To get it working you can simply plug it to mains, once it's powered up, press and hold the button that's closer to the Wi-Fi logo (you'll hear a beep sound). Keep holding it until you hear that beep for the second time. Now let go. The Wi-Fi light should blink in pairs of 3. Now repeat the procedure (Press and hold until you hear the beep 2 times). Now you should be seeing the Wi-Fi logo flashing rapidly. You can proceed to try and flash with SonOTA now.","title":"Sonoff T1 US"},{"location":"devices/Sonoff-T1/#us-model-of-3-button-t1-received-direct-from-sonoff-china-2018-05-12","text":"Front photo (Google photos) Rear photo (Google photos) (Sorry about the tape smudges). The header labels on J3 are accurate (apparently some boards have TX and RX reversed; this doesn't seem to suffer that). Flashed with SonOTA . Above method of getting into flash mode doesn't seem to work. UPDATE: I did flash it with the FTDI method. To put then in flash mode press 2 times quickly the internal switch S1. UPDATE 2: Confirmed by another user that flashed with SonOTA works as described on \"Preparing\"","title":"US Model of 3-button T1, received direct from Sonoff China 2018-05-12"},{"location":"devices/Sonoff-T1/#sonoff-t1-us-3-gang","text":"The jump-wire method to enter the flash mode: * Jump the wire as attached picture * While keeping the wire connected then plug the serial-to-USB adapter to the computer * Wait for 1 to 2 seconds then release the jump-wire * You can start flashing the Sonoff T1 US 3C.","title":"Sonoff T1 US 3 Gang"},{"location":"devices/Sonoff-T1/#sonoff-tx-us-23-gang","text":"The PCB layout for the TX/T0 model (vertical, black or white face-plate with squared-off, LED-lit buttons) is different again from the original T1. There is no TP2/GPIO0 test point on the back of the PCB and R19 has moved. The basic instructions for flashing the T1 (with a USB adapter) still work.","title":"Sonoff TX US 2/3 Gang"},{"location":"devices/Sonoff-T1/#_1","text":"It seems that Sonoff is trying to seal off the ESP using some glue see image:","title":""},{"location":"devices/Sonoff-T1/#433mhz-remote","text":"The Tasmota firmware is compatible with the RF remote feature built in to the T1 modules. Pairing a new remote is the same procedure as a stock Sonoff, i.e., hold the desired button on your sonoff until you are given 1 beep (approx 7 seconds), press the button on your RF remote. The Sonoff will beep to confirm the pairing. To unpair a remote, press until you are given 2 beeps, press the button on your RF remote. The Sonoff will beep to confirm the unpairing.","title":"433MHz remote"},{"location":"devices/Sonoff-T1/#circuit","text":"ESP8285 GPIO0 EFM8BB1 P1,3 Switch 1 input (Goes low when first touch button is pressed) GPIO04 is connected to the small (soft) reset button on the front. GPIO09 EFM8BB1 P1,4 - Switch 3 input (Goes low when third touch button is pressed) GPIO10 EFM8BB1 P1,5 - Switch 2 input GPIO13 is connected to status LED D3. GPIO12 Relay 1 GPIO5 Relay 2 GPIO4 Relay 3 GPIO2 is connected on J3 pin 5 (LOG) On the EFM8BB1 (QFN20 package) P0,0 Relay 1 P0,1 Relay 2 P0,2 Relay 3 P0,3 Button 1 P0,4 Button 2 P0,5 Button 3 P0,6 SYN470R Data Out P0,7 Buzzer P1,0 Led button 1 P1,1 Led button 2 P1,2 Led button 3 P1,3 ESP8285 GPIO0 P1,4 ESP8285 GPIO09 P1,5 ESP8285 GPIO10 P1,6 ESP8285 EXT_RSTB (RESET)","title":"Circuit"},{"location":"devices/Sonoff-T1/#ghost-switching","text":"Some of these devices are prone to hardware ghost switching. You may need to experiment with ButtonDebounce and SetOption40 to reduce or eliminate these issues. Also, during the flashing process, you may have soldered a lead to GPIO0 in order to connect it to GND for putting the ESP into programming mode. If there are any random oscillations on GPIO0, this can trigger the relay. The contacts on the PCB are very close together. Check that you don't have any stray solder to another contact. Even if there isn't contact, over time heat and humidity can cause any residual flux to become resistive and allow conductivity. Be sure to clean everything after removing any leads.","title":"Ghost Switching"},{"location":"devices/Sonoff-T1/#known-so-far","text":"When pushing a button, the touch chip lift the power high to the EFM8BB1, and the EFM8BB1 chip ties the signal line for each button low, for the full duration of the keypress. Debouncing is not needed. 433MHz remotes are compatible with the Tasmota firmware DO NOT attempt to power the device from your programmer when connected to the relay board. This draws too much power and will cause the ESP to reboot frequently and will reset all the configured settings. The relays state can be set on the GPIO's 12, 5 and 4. The switch status can be read on GPIO's 0, 10 and 9. Push button active low.","title":"Known so far"},{"location":"devices/Sonoff-T1/#unknown-so-far","text":"Where GPIO15 is connected? Over R18 10kOhm pull-down only?","title":"Unknown so far"},{"location":"devices/Sonoff-T1/#official-sources","text":"","title":"Official Sources"},{"location":"devices/Sonoff-T1/#sonoff-t1-uk_1","text":"Itead Product Page Itead Shop The Sonoff T1 UK with 1 to 3 gang is fully supported by Tasmota starting with version 5.6.1.","title":"Sonoff T1 UK"},{"location":"devices/Sonoff-T1/#sonoff-t1-eu_1","text":"Itead Product Page Itead Shop The Sonoff T1 EU with 1 to 3 gang is fully supported by Tasmota starting with version 5.6.1.","title":"Sonoff T1 EU"},{"location":"devices/Sonoff-T1/#sonoff-t1-us_1","text":"Itead Product Page Itead Shop The Sonoff T1 US with 1 to 3 gang was launched March 2018.","title":"Sonoff T1 US"},{"location":"devices/Sonoff-T1/#sonoff-tx-us","text":"Itead Product Page Itead Shop","title":"Sonoff TX US"},{"location":"devices/Sonoff-TH/","text":"Sonoff TH10 or TH16 / Ver 2.0 (year 2017/2018/2019) based on ESP8266. TH10 has a relay rated to 10 amps and TH16 to 16 amps (Input voltage: 90~ 250V AC). Serial Flashing ~ The 2.5mm jack socket connects to GPIO14. In PCB Ver 2.1 you can find a fifth pin next to the serial pins, labeled EXP-LOG . You can use this as GPIO2 to any generic purpose. Currently should make a custom template for it. Sonoff sensors with 2.5mm jack ~ Sonoff sells 3 sensors with 2.5mm jack to use with the Sonoff TH. 1. Sonoff TH Sensor Si7021 2. Sonoff TH Sensor AM2301 3. Sonoff Temp Sensor DS18B20 Length of the wire is approximately 47cm apart from DS18b20 sensor that comes with approximately 1m long wire. Can be extended with a Sonoff 5m sensor extension cable. NOTE!!! Normally a Si7021 sensor is an I 2 C device. The Sonoff labelled Si7021 sensor is BASED on an Si7021, but, to make this sensor plug'n'play on a Sonoff TH an 8-bit MCU is added on the board. This changes the I 2 C communication of an Si7021 sensor to one-wire communication! That is why a \"Sonoff SI7021 sensor\" doesn't work in combination with a I 2 C library. Tasmota supports Sonoff TH with all three Sonoff sensors. Just select module Sonoff TH (4) and under GPIO14 configure the sensor you have connected. NOT SUPPORTED ~ Si7021 sensor contains an integrated resistive heating element that may be used to drive off condensation. It's recommended enabling the heater when the humidity readings are above 80%. Humidity readings above 80% become very unreliable. If the \"Sonoff Si7021 sensor\" is used at the dew point and condensation occurs on the sensor, the on-chip heater could be activated to dry the sensor and restore operation once the sensor is above the dew point. Turning on the heater will also reduce the tendency of the humidity sensor to accumulate an offset due to \"memory\" of sustained high humidity conditions. Six different power levels are available. The maximum source current of a GPIO pin on an ESP8266 is about 12mA. So the first power level of 3.09mA and second power level of 9.18mA would be theoretically usable. Keep that in mind if you use this \"Sonoff Si7021 sensor\" outdoors! Si7021 Datasheet Official Sources ~ Itead Product Page Itead Shop Itead Wiki","title":"Sonoff TH"},{"location":"devices/Sonoff-TH/#serial-flashing","text":"The 2.5mm jack socket connects to GPIO14. In PCB Ver 2.1 you can find a fifth pin next to the serial pins, labeled EXP-LOG . You can use this as GPIO2 to any generic purpose. Currently should make a custom template for it.","title":"Serial Flashing"},{"location":"devices/Sonoff-TH/#sonoff-sensors-with-25mm-jack","text":"Sonoff sells 3 sensors with 2.5mm jack to use with the Sonoff TH. 1. Sonoff TH Sensor Si7021 2. Sonoff TH Sensor AM2301 3. Sonoff Temp Sensor DS18B20 Length of the wire is approximately 47cm apart from DS18b20 sensor that comes with approximately 1m long wire. Can be extended with a Sonoff 5m sensor extension cable. NOTE!!! Normally a Si7021 sensor is an I 2 C device. The Sonoff labelled Si7021 sensor is BASED on an Si7021, but, to make this sensor plug'n'play on a Sonoff TH an 8-bit MCU is added on the board. This changes the I 2 C communication of an Si7021 sensor to one-wire communication! That is why a \"Sonoff SI7021 sensor\" doesn't work in combination with a I 2 C library. Tasmota supports Sonoff TH with all three Sonoff sensors. Just select module Sonoff TH (4) and under GPIO14 configure the sensor you have connected.","title":"Sonoff sensors with 2.5mm jack"},{"location":"devices/Sonoff-TH/#not-supported","text":"Si7021 sensor contains an integrated resistive heating element that may be used to drive off condensation. It's recommended enabling the heater when the humidity readings are above 80%. Humidity readings above 80% become very unreliable. If the \"Sonoff Si7021 sensor\" is used at the dew point and condensation occurs on the sensor, the on-chip heater could be activated to dry the sensor and restore operation once the sensor is above the dew point. Turning on the heater will also reduce the tendency of the humidity sensor to accumulate an offset due to \"memory\" of sustained high humidity conditions. Six different power levels are available. The maximum source current of a GPIO pin on an ESP8266 is about 12mA. So the first power level of 3.09mA and second power level of 9.18mA would be theoretically usable. Keep that in mind if you use this \"Sonoff Si7021 sensor\" outdoors! Si7021 Datasheet","title":"NOT SUPPORTED"},{"location":"devices/Sonoff-TH/#official-sources","text":"Itead Product Page Itead Shop Itead Wiki","title":"Official Sources"},{"location":"devices/Sonoff-TX-Series/","text":"The sonoff TX Series comes with 4 versions T0, T1, T2, T3 The boards are the same for all the series with only a difference in the T0 which has no RF chip Flashing ~ The flashing steps are the same than for the older T1 switch but holding switch 1 does not put the board into flashing mode and there is no reset button on the board So to put a T1 Touch v1.0 board into flash mode you need to ground GPIO 0 which is exposed on the back of the board and plug the board to USB Here is an image of the wiring Legend: * Yellow => 3.3v * Purple => GND * Green => TX FTDI to RX sonoff * Blue => RX FTDI to TX sonoff If the manipulation is done correctly the Wifi led will not blink when the device is powered, this means you are in flash mode and you can follow the other guide","title":"Sonoff TX Series"},{"location":"devices/Sonoff-TX-Series/#flashing","text":"The flashing steps are the same than for the older T1 switch but holding switch 1 does not put the board into flashing mode and there is no reset button on the board So to put a T1 Touch v1.0 board into flash mode you need to ground GPIO 0 which is exposed on the back of the board and plug the board to USB Here is an image of the wiring Legend: * Yellow => 3.3v * Purple => GND * Green => TX FTDI to RX sonoff * Blue => RX FTDI to TX sonoff If the manipulation is done correctly the Wifi led will not blink when the device is powered, this means you are in flash mode and you can follow the other guide","title":"Flashing"},{"location":"devices/Sonoff-TX-T0-Touch-1CH-2CH-3CH----US/","text":"June 2019 - Devices delivered with Sonoff v3.3.0 stock firmware. Product page Banggood Serial flashing works for this device. You may wish to check whether the Sonoff DIY flashing method works if this device is upgraded to v3.3.1. Board label: T0US TOUCH v1.0 2008.11.15 TX T0 US, 1-3CH boards are physically the same. Only need the \"top board\" to flash (not the bottom relay part) -- don't power with mains (you can't if you only use top anyway) R19 is tied to GPIO 0 to enter flash mode, just like on T1 but in a different spot for t0 (or US?). Find the C2 (j1) pins and look directly up about half inch for r19 Ensure that you select 3.3v and not 5v! to flash the board. ESP8285 - 1M - DOUT - erase flash - 115200 baud Like the T1, this does not have enough room to solder a header on. Use a piece of thick cardboard to lay your top board on. Firmly press some jumpers through the serial holes into the cardboard. If you push these through at an angle will be good enough to make contact to connect to your serial adaptor, trial and error but is not hard. See photo below. Regular flashing steps apply: connect Ground, Vcc TX, RX to your serial adaptor. Pay attention to TX/RX! For flash mode, use another jumper through the ground hole on the C2 pins (left of the serial and label J1). Same as above, push the jumper through cardboard to secure it. While powered off hold the other end of jumper to R19 and then power up (plug in your USB serial adaptor). Hold it for 3-5 seconds after it powers up before removing it. You should not see the network status led flash anymore, then you know you're in flash mode. If its flashing power off and try again. Using the TX T1 1-3 device template will work. A new T0 template is forthcoming. Start-to-Finish Flashing Guide ~ Flashing ~ Connect the device's serial interface pins to the Serial-to-USB adapter . Be sure that your adapter is set to supply 3.3v . Place a jumper wire from GND to the side of R19 nearest the screw hole cutout - this is connected to GPIO0. Download tasmota.bin from http://ota.tasmota.com/tasmota Have Flashing tool running with the correct settings. Be sure to select DOUT and Erase flash - yes . Select the right COM port for your serial-to-USB adapter and select tasmota.bin from the folder where you downloaded the file. Plug the serial adapter into the USB port and click the Flash button on Tasmota PyFlasher . When you get the flash complete, remove the GND jumper wire from GPIO0. Cycle power on your device by disconnecting the serial adapter from the USB port for a couple of seconds and plugging it back in. IP Configuration ~ Using a mobile device, scan for Wi-Fi networks and connect to the sonoff-xxxx access point. When it connects to the network, you may get a warning that there is no Internet connection and be prompted to connect to a different network. Do not allow the mobile device to select a different network . Open the browser on your mobile device and navigate to http://192.168.4.1. In the Tasmota web UI, scan wifi networks and select the network for your home. Then enter the network's password ( click the checkbox to see the password you enter to ensure that it is correct and that your mobile device has not inadvertently capitalized the first letter if it is supposed to be lower case nor autocorrected what you entered ). When you save the settings, the device will restart and connect to your home network. The sonoff-xxxx network will not longer be present. Therefore your mobile device will automatically be disconnected and should connect back to its data network. Check in your router or use an IP scanner to ensure that the device is connected to your home network. Make not of the IP address assigned to your device. MQTT Configuration ~ Go to new IP address (http:// IP ) in a browser. Click Configuration->Configure MQTT-> MQTT Host: Enter the address (192.168.xx.yy or Hostname) of your MQTT broker. If you use the Home Assistant embedded broker, this will be your HA server. User: Enter the username for your MQTT broker Password: Enter the password for your MQTT broker Topic: Enter the unique MQTT topic for your device Save your settings. The device will restart Device Configuration ~ Click Configuration->Configure Module->Module Type->Sonoff T1 3CH (30) (the appropriate module for your device model) and save. The device will restart. Test the operation of the switches from the web UI. You should hear the relays click. Click Console If you use Home Assistant, enter SetOption19 1 to enable device auto-discovery. Check the log for any errors. Reassemble the switch and connect it to mains power. Check in your router or use an IP scanner to ensure that the device is connected to your home network. Also use the Tasmota web UI to ensure the switch is operating as expected. Home Assistant Configuration ~ Open TasmoAdmin via Hassio and Autoscan In Name1->Name3 enter switch position names again (note: understand orientation of switch) Go to \u2018Devices List\u2019 and check/test buttons click Click Cog configuration and enter names again and save Click Cog configuration, go to MQTT and change Group Topic to swtheatre and save Go to Devices List again and the circle arrows to restart the device Go to Integrations->MQTT and find the new switch and rename/locate items accordingly","title":"Sonoff TX T0 Touch 1CH 2CH 3CH    US"},{"location":"devices/Sonoff-TX-T0-Touch-1CH-2CH-3CH----US/#start-to-finish-flashing-guide","text":"","title":"Start-to-Finish Flashing Guide"},{"location":"devices/Sonoff-TX-T0-Touch-1CH-2CH-3CH----US/#flashing","text":"Connect the device's serial interface pins to the Serial-to-USB adapter . Be sure that your adapter is set to supply 3.3v . Place a jumper wire from GND to the side of R19 nearest the screw hole cutout - this is connected to GPIO0. Download tasmota.bin from http://ota.tasmota.com/tasmota Have Flashing tool running with the correct settings. Be sure to select DOUT and Erase flash - yes . Select the right COM port for your serial-to-USB adapter and select tasmota.bin from the folder where you downloaded the file. Plug the serial adapter into the USB port and click the Flash button on Tasmota PyFlasher . When you get the flash complete, remove the GND jumper wire from GPIO0. Cycle power on your device by disconnecting the serial adapter from the USB port for a couple of seconds and plugging it back in.","title":"Flashing"},{"location":"devices/Sonoff-TX-T0-Touch-1CH-2CH-3CH----US/#ip-configuration","text":"Using a mobile device, scan for Wi-Fi networks and connect to the sonoff-xxxx access point. When it connects to the network, you may get a warning that there is no Internet connection and be prompted to connect to a different network. Do not allow the mobile device to select a different network . Open the browser on your mobile device and navigate to http://192.168.4.1. In the Tasmota web UI, scan wifi networks and select the network for your home. Then enter the network's password ( click the checkbox to see the password you enter to ensure that it is correct and that your mobile device has not inadvertently capitalized the first letter if it is supposed to be lower case nor autocorrected what you entered ). When you save the settings, the device will restart and connect to your home network. The sonoff-xxxx network will not longer be present. Therefore your mobile device will automatically be disconnected and should connect back to its data network. Check in your router or use an IP scanner to ensure that the device is connected to your home network. Make not of the IP address assigned to your device.","title":"IP Configuration"},{"location":"devices/Sonoff-TX-T0-Touch-1CH-2CH-3CH----US/#mqtt-configuration","text":"Go to new IP address (http:// IP ) in a browser. Click Configuration->Configure MQTT-> MQTT Host: Enter the address (192.168.xx.yy or Hostname) of your MQTT broker. If you use the Home Assistant embedded broker, this will be your HA server. User: Enter the username for your MQTT broker Password: Enter the password for your MQTT broker Topic: Enter the unique MQTT topic for your device Save your settings. The device will restart","title":"MQTT Configuration"},{"location":"devices/Sonoff-TX-T0-Touch-1CH-2CH-3CH----US/#device-configuration","text":"Click Configuration->Configure Module->Module Type->Sonoff T1 3CH (30) (the appropriate module for your device model) and save. The device will restart. Test the operation of the switches from the web UI. You should hear the relays click. Click Console If you use Home Assistant, enter SetOption19 1 to enable device auto-discovery. Check the log for any errors. Reassemble the switch and connect it to mains power. Check in your router or use an IP scanner to ensure that the device is connected to your home network. Also use the Tasmota web UI to ensure the switch is operating as expected.","title":"Device Configuration"},{"location":"devices/Sonoff-TX-T0-Touch-1CH-2CH-3CH----US/#home-assistant-configuration","text":"Open TasmoAdmin via Hassio and Autoscan In Name1->Name3 enter switch position names again (note: understand orientation of switch) Go to \u2018Devices List\u2019 and check/test buttons click Click Cog configuration and enter names again and save Click Cog configuration, go to MQTT and change Group Topic to swtheatre and save Go to Devices List again and the circle arrows to restart the device Go to Integrations->MQTT and find the new switch and rename/locate items accordingly","title":"Home Assistant Configuration"},{"location":"devices/Sonoff-Touch/","text":"Itead Product Page Itead Shop Itead Wiki: (n/a) Unlike most Sonoff modules, the Sonoff Touch is based on the ESP8285 rather than the ESP8266. The actual chip inside may be a PSF-A85 . Serial Connection ~ Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. Carefully remove the top PCB from the assembly. The hidden underside of the PCB contains the ESP8285 as shown in the pictures. The four serial pins (3V3, Rx, Tx, GND) can be seen in the pictures for the US version (left) and the EU version (right) of the module PCB. Be careful while removing and reassembling the top PCB. The touch sensor should be back in its intended place. Be sure to not touch it directly during the modifications. The Sonoff Touch button is not connected to GPIO0 and hence cannot be used to bring the module into Programming Mode . A connection between GPIO0 and GND needs to be made manually. GPIO0 can be found on the right side of the ESP8285 and is the second pin from the bottom, as can be seen on the pictures. Note: Even if you have the PSF-A85 chip inside instead of a default ESP8285, the GPIO0 pin is in the same location. Pay attention to the corner of the chip with three unused solder contacts. That is where the external antenna connector is located in the images above. The PSF-A85 in the Sonoff Touch does not have the external antenna connector soldered on. Control ON/OFF Leds on Sonoff Touch solution ~ Solder the switch LED where the Wi-Fi LED is and then you can control the LED by using the command LedPower ON . The Switch LED is on all the time, even when the switch is off so you can easily find the switch in the dark. Alternatively, you can solder the switch LED on 3.3v and ground but then you can't control the LED, it is always on and very bright.","title":"Sonoff Touch"},{"location":"devices/Sonoff-Touch/#serial-connection","text":"Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. Carefully remove the top PCB from the assembly. The hidden underside of the PCB contains the ESP8285 as shown in the pictures. The four serial pins (3V3, Rx, Tx, GND) can be seen in the pictures for the US version (left) and the EU version (right) of the module PCB. Be careful while removing and reassembling the top PCB. The touch sensor should be back in its intended place. Be sure to not touch it directly during the modifications. The Sonoff Touch button is not connected to GPIO0 and hence cannot be used to bring the module into Programming Mode . A connection between GPIO0 and GND needs to be made manually. GPIO0 can be found on the right side of the ESP8285 and is the second pin from the bottom, as can be seen on the pictures. Note: Even if you have the PSF-A85 chip inside instead of a default ESP8285, the GPIO0 pin is in the same location. Pay attention to the corner of the chip with three unused solder contacts. That is where the external antenna connector is located in the images above. The PSF-A85 in the Sonoff Touch does not have the external antenna connector soldered on.","title":"Serial Connection"},{"location":"devices/Sonoff-Touch/#control-onoff-leds-on-sonoff-touch-solution","text":"Solder the switch LED where the Wi-Fi LED is and then you can control the LED by using the command LedPower ON . The Switch LED is on all the time, even when the switch is off so you can easily find the switch in the dark. Alternatively, you can solder the switch LED on 3.3v and ground but then you can't control the LED, it is always on and very bright.","title":"Control ON/OFF Leds on Sonoff Touch solution"},{"location":"devices/Sonoff-iFan02/","text":"The Sonoff iFan02 is supported in Tasmota from version 6.0.0b Itead Product Page Itead Shop Itead iFan02 Schematics Serial Flashing ~ Please see the Hardware Preparation page for general instructions. Flashing using only a USB to serial converter will not work as the unit draws too much current as can be observed by a flashing blue led on the PCA and a lot of serial gibberish. As AC is not connected to Gnd I used the available power supply of the unit and connecting the USB to serial converter to J3 pins Gnd, Tx and Rx. The button is not connected to GPIO0 so flashing the unit requires some extra work. I managed to flash the iFan02 by soldering a wire to TP16 (GPIO00) on the bottom of the PCA. Keep this wire connected to Gnd during the power-on or reset process (pressing the button) and the unit will be in firmware upgrade mode. If you've soldered the gpio0 connection don't forget to unsolder before booting normally. Connect RX -> TX | 3.3 -> 3.3 | TX -> RX | GND -> GND and connect TP16 to GND (as used in the TTL). Press and hold the button while connecting to power. If you have an Arduino you may be able to flash without providing an additional power source. I have successfully flashed using an Arduino Duemilanove with the atmel chip pulled out (basically using it for FTDI and 3.3v power regulation). Rx on Arduino goes to Rx on iFan02, Tx to Tx (no crossover like with FTDI). I did not have to press the button, only to ground TP16 while initiating the flash in Arduino IDE. The Arduino provides enough power to flash, however it will not boot into Tasmota unless you plug in to external power (it boot loops after flashing is complete). Additonal information ~ See issue #2839 for user information See issue #3412 light on after restore power Functioning iFan02 in Tasmota WebUI iFan02 PCA with TP16 Two users report the TP16 pad lifting after soldering a wire to ground as shown in picture. This renders it useless. It may be better to use a pogo pin contact, bare wire or solder and then epoxy/glue the wire in place, leaving it permanently. Board Top Showing ESP8285 ESP8285 Pinout Using hard wired push button switch attached to iFan02 GPIO to cycle speeds ~ If anyone wants to setup a single push button switch attached to the GPIO3 Serial + ground In that will cycle through the speeds and turn off - after setting it in the configuration (GPIO3 to 11 Switch3) the console code is: rule1 on switch3#state do FanSpeed + endon Alternate Power Supply Schematic ~","title":"Sonoff iFan02"},{"location":"devices/Sonoff-iFan02/#serial-flashing","text":"Please see the Hardware Preparation page for general instructions. Flashing using only a USB to serial converter will not work as the unit draws too much current as can be observed by a flashing blue led on the PCA and a lot of serial gibberish. As AC is not connected to Gnd I used the available power supply of the unit and connecting the USB to serial converter to J3 pins Gnd, Tx and Rx. The button is not connected to GPIO0 so flashing the unit requires some extra work. I managed to flash the iFan02 by soldering a wire to TP16 (GPIO00) on the bottom of the PCA. Keep this wire connected to Gnd during the power-on or reset process (pressing the button) and the unit will be in firmware upgrade mode. If you've soldered the gpio0 connection don't forget to unsolder before booting normally. Connect RX -> TX | 3.3 -> 3.3 | TX -> RX | GND -> GND and connect TP16 to GND (as used in the TTL). Press and hold the button while connecting to power. If you have an Arduino you may be able to flash without providing an additional power source. I have successfully flashed using an Arduino Duemilanove with the atmel chip pulled out (basically using it for FTDI and 3.3v power regulation). Rx on Arduino goes to Rx on iFan02, Tx to Tx (no crossover like with FTDI). I did not have to press the button, only to ground TP16 while initiating the flash in Arduino IDE. The Arduino provides enough power to flash, however it will not boot into Tasmota unless you plug in to external power (it boot loops after flashing is complete).","title":"Serial Flashing"},{"location":"devices/Sonoff-iFan02/#additonal-information","text":"See issue #2839 for user information See issue #3412 light on after restore power Functioning iFan02 in Tasmota WebUI iFan02 PCA with TP16 Two users report the TP16 pad lifting after soldering a wire to ground as shown in picture. This renders it useless. It may be better to use a pogo pin contact, bare wire or solder and then epoxy/glue the wire in place, leaving it permanently. Board Top Showing ESP8285 ESP8285 Pinout","title":"Additonal information"},{"location":"devices/Sonoff-iFan02/#using-hard-wired-push-button-switch-attached-to-ifan02-gpio-to-cycle-speeds","text":"If anyone wants to setup a single push button switch attached to the GPIO3 Serial + ground In that will cycle through the speeds and turn off - after setting it in the configuration (GPIO3 to 11 Switch3) the console code is: rule1 on switch3#state do FanSpeed + endon","title":"Using hard wired push button switch attached to iFan02 GPIO to cycle speeds"},{"location":"devices/Sonoff-iFan02/#alternate-power-supply-schematic","text":"","title":"Alternate Power Supply Schematic"},{"location":"devices/Sonoff-iFan03/","text":"(For information on the iFan02 please see here - iFan02 ) Serial Flashing ~ Please see the Hardware Preparation page for general instructions. Next, please see the Flashing page for general information on the flashing process. Flash the latest version of tasmota.bin : Connect your serial flashing device pins to the iFan03 (for connection locations see the pin out on the left hand side of the picture below). When you are ready to flash your device, hold down the large white tipped button on the iFan03 while connecting the serial adapter to your computer. This will power the serial adapter as well as the iFan03. Usually, you can release the button on the iFan03 once it has fully booted - after 3-5 seconds once the lights have flashed. If the device does not enter programming mode successfully, cycle power but this time continue to hold the button during the entire firmware upload process (i.e., step 4 below). Using Tasmota PyFlasher (recommended): Select the firmware file that you want to flash Set the COM port for your serial programming adapter Ensure that flash mode Dual Output (DOUT) , and baud rate of 115200 is selected If you are flashing Tasmota for the first time, also select yes, wipes all data . Click on the \"Flash NodeMCU\" button and wait until the flashing process is completed. Cycle power on the serial adapter by unplugging and plugging it back in from the USB port. Do not hold down the iFan03 button. Wait for the iFan03 to reboot. If this is the first time you have flashed Tasmota on the device, connect to the iFan03 sonoff-xxxx Wi-Fi access point and configure your Wi-Fi credentials by opening 192.168.4.1 in a browser. Wait for the iFan03 to reboot. Find the IP address of the iFan03 and navigate to that IP address in any browser. Select \"Configure Module\" from the \"Configuration\" menu and select Sonoff iFan03 (71) from the drop down list. Wait for the iFan03 to restart and then continue any other required or desired configuration. US Ceiling Fans ~ The capacitors in the iFan03 do not set the speed of US fans correctly. To correct the speeds for US ceiling fans, you need to remove the existing capacitors from the iFan03 and replace them with equivalently electrically rated 5uF (microfarad) capacitors. Do NOT do this if you are not comfortable using a soldering iron as improperly performing this action could increase the risk of bodily injury or property damage. RF Remote Control Pairing ~ To pair the remote control after the device has been flashed with the new firmware, the device needs to be powered from mains voltage (not from the USB serial flashing device). Be careful dealing with mains voltages. Ensure that all connections are correctly made and that the iFan03 covers are properly re-assembled. To pair the remote control, hold down any button on the remote control and apply power to the iFan03. Once the device boots up you should hear a series of clicks as the internal relays operate. Once completed you can test the remote and it should all be operational.","title":"Sonoff iFan03"},{"location":"devices/Sonoff-iFan03/#serial-flashing","text":"Please see the Hardware Preparation page for general instructions. Next, please see the Flashing page for general information on the flashing process. Flash the latest version of tasmota.bin : Connect your serial flashing device pins to the iFan03 (for connection locations see the pin out on the left hand side of the picture below). When you are ready to flash your device, hold down the large white tipped button on the iFan03 while connecting the serial adapter to your computer. This will power the serial adapter as well as the iFan03. Usually, you can release the button on the iFan03 once it has fully booted - after 3-5 seconds once the lights have flashed. If the device does not enter programming mode successfully, cycle power but this time continue to hold the button during the entire firmware upload process (i.e., step 4 below). Using Tasmota PyFlasher (recommended): Select the firmware file that you want to flash Set the COM port for your serial programming adapter Ensure that flash mode Dual Output (DOUT) , and baud rate of 115200 is selected If you are flashing Tasmota for the first time, also select yes, wipes all data . Click on the \"Flash NodeMCU\" button and wait until the flashing process is completed. Cycle power on the serial adapter by unplugging and plugging it back in from the USB port. Do not hold down the iFan03 button. Wait for the iFan03 to reboot. If this is the first time you have flashed Tasmota on the device, connect to the iFan03 sonoff-xxxx Wi-Fi access point and configure your Wi-Fi credentials by opening 192.168.4.1 in a browser. Wait for the iFan03 to reboot. Find the IP address of the iFan03 and navigate to that IP address in any browser. Select \"Configure Module\" from the \"Configuration\" menu and select Sonoff iFan03 (71) from the drop down list. Wait for the iFan03 to restart and then continue any other required or desired configuration.","title":"Serial Flashing"},{"location":"devices/Sonoff-iFan03/#us-ceiling-fans","text":"The capacitors in the iFan03 do not set the speed of US fans correctly. To correct the speeds for US ceiling fans, you need to remove the existing capacitors from the iFan03 and replace them with equivalently electrically rated 5uF (microfarad) capacitors. Do NOT do this if you are not comfortable using a soldering iron as improperly performing this action could increase the risk of bodily injury or property damage.","title":"US Ceiling Fans"},{"location":"devices/Sonoff-iFan03/#rf-remote-control-pairing","text":"To pair the remote control after the device has been flashed with the new firmware, the device needs to be powered from mains voltage (not from the USB serial flashing device). Be careful dealing with mains voltages. Ensure that all connections are correctly made and that the iFan03 covers are properly re-assembled. To pair the remote control, hold down any button on the remote control and apply power to the iFan03. Once the device boots up you should hear a series of clicks as the internal relays operate. Once completed you can test the remote and it should all be operational.","title":"RF Remote Control Pairing"},{"location":"devices/Supernight-dual-wifi-plug/","text":"Received these in a 2 pack. flashing with OTA was no issue. I quickly figured out most of the IO. GPIO1 = Left Socket Button GPIO3 = Left Socket Relay GPIO12 = Right Socket Relay GPIO14 = Red LED for both buttons The \"night light\" seems to be tied to the light sensor only and cannot be turned off. This makes the plug a no-go for me. Also, I could not figure out the right socket button. I ended up destroying one of the two plugs to see what was inside. There are 2 circuit boards. One with the Wifi and esp module and another with the buttons and the night lights. On the button board, the trace for the right button is purposely notched for that button so that it doesn't connect to the header leading to the second circuit board with the esp chip. I'm really wishing I verified that button before flashing as I don't intend to buy more to test it. Found this on the issues tracker Just a quick update. I've still not figured out the second button, but I do have energy monitoring working now. My current pinout is... * GPIO1 = Left Socket Button * GPIO3 = Left Socket Relay * GPIO4 = HLW8012/Voltage (HLWBL CF1) * GPIO5 = HLW8012 CF Power (HLW8012 CF) * GPIO12 = Right Socket Relay * GPIO13 = HLW8012 Output (HLWBL SEL) * GPIO14 = Red LED for both buttons Pins 6,7,8 and 11 cause hard resets when I try to set them to switches or buttons. If you have tasmota >= 6.4.1.14 then here is a template based on the above. {\"NAME\":\"SuperNight Dua\",\"GPIO\":[255,17,255,21,132,133,255,255,22,130,58,255,255],\"FLAG\":1,\"BASE\":18}","title":"Supernight dual wifi plug"},{"location":"devices/TYWE3S/","text":"Pinout for flashing TYWE3S devices. Module has a nearly identical pinout to ESP-12 module series. TYWE3S Wiring for Flashing ~ Vcc - 3.3V TX - RX RX - TX GND - GND Make sure to ground GPIO0 during boot. TYWE3S - Flashing Jig Additional Information ~ Pin Number Symbol IO type Function 1 TXD0 O UART0_TXD 2 RXD0 I/O UART0_RXD 3 GPIO5 I/O GPIO5_05 4 GPIO4 I/O GPIO5_04 5 GPIO0 I/O GPIO5_0 (Participate in the module power-on initialization process,use with caution) 6 GPIO2 O UART0_TXD (Used to print module internal information) 7 GPIO15 O GPIO_15 (Participate in the module power-on initialization process,use with caution) 8 GND P Power Reference Ground 9 VCC P Module Power Pin (3.3V) 10 GPIO13 I/O GPIO_13 11 GPIO12 I/O GPIO_12 12 GPIO14 I/O GPIO_14 13 GPIO16 I/O GPIO_16 (Use 10K pull-up resistor for use) 14 EN I Module enable pin,normal use needs to receive 3.3V 15 ADC AI ADC port, 10-bit precision SAR ADC 16 RST I/O Hardware reset pin (low level effective, internal pull-up resistance) For Switches and dimmers with additional MCU check guide here","title":"TYWE3S"},{"location":"devices/TYWE3S/#tywe3s-wiring-for-flashing","text":"Vcc - 3.3V TX - RX RX - TX GND - GND Make sure to ground GPIO0 during boot. TYWE3S - Flashing Jig","title":"TYWE3S Wiring for Flashing"},{"location":"devices/TYWE3S/#additional-information","text":"Pin Number Symbol IO type Function 1 TXD0 O UART0_TXD 2 RXD0 I/O UART0_RXD 3 GPIO5 I/O GPIO5_05 4 GPIO4 I/O GPIO5_04 5 GPIO0 I/O GPIO5_0 (Participate in the module power-on initialization process,use with caution) 6 GPIO2 O UART0_TXD (Used to print module internal information) 7 GPIO15 O GPIO_15 (Participate in the module power-on initialization process,use with caution) 8 GND P Power Reference Ground 9 VCC P Module Power Pin (3.3V) 10 GPIO13 I/O GPIO_13 11 GPIO12 I/O GPIO_12 12 GPIO14 I/O GPIO_14 13 GPIO16 I/O GPIO_16 (Use 10K pull-up resistor for use) 14 EN I Module enable pin,normal use needs to receive 3.3V 15 ADC AI ADC port, 10-bit precision SAR ADC 16 RST I/O Hardware reset pin (low level effective, internal pull-up resistance) For Switches and dimmers with additional MCU check guide here","title":"Additional Information"},{"location":"devices/Teckin-SP22/","text":"The BlitzWolf BW-SHP2 , HomeCube SP1, and Teckin SP22 are basically the same device barring the branding. Warning ~ There are at least two Versions of the SP22 out. An old one with a TYWE2S WiFi module and ESP... chip. This version is compatible with Tasmota. A new one with a WR2 WiFi module and RTL8710BN chip. This one is not compatible with Tasmota.","title":"Teckin SP22"},{"location":"devices/Teckin-SP22/#warning","text":"There are at least two Versions of the SP22 out. An old one with a TYWE2S WiFi module and ESP... chip. This version is compatible with Tasmota. A new one with a WR2 WiFi module and RTL8710BN chip. This one is not compatible with Tasmota.","title":"Warning"},{"location":"devices/Teckin-SP23/","text":"The Teckin SP23 is wifi enabled smart plug with the ability to remotely monitor power consumption and turn devices on and off. Details: ~ The Teckin SP23 appears to be a clone of the BlitzWolf SHP2 hardware with Tuya firmware. It uses an ESP8266EX and is capable of switching up to 16 amps at 250 VAC. Two Teckin SP23s (marked V1.2) purchased from Amazon UK (January 2019) have been flashed successfully and use BlitzWolf SHP2 Sonoff configuration. Voltage calibration may be required for accurate power monitoring. Two additional Teckin SP23s were purchased from Amazon UK (July 2019) and successfully flashed using Tuya-Convert. Upgrading to Tasmota 6.6 and using BlitzWolf SHP configuration was problematic - LED's did not show power status - but downgrading to 6.3 and using BlitzWolf SHP2 as above gave perfect performance. The units were not disassembled so there was no way of determining board version. A set of 4 Teckin SP23s were purchased from Amazon UK (Sept 2019) and they flashed without issues using Tuya-Convert. This device functions properly with tasmota.bin 6.6.0 (LED flashing blue when ON) with the template in the repository . Two devices purchased on Amazon ES were already patched, but have been successfully flashed with the new-sdk branch of kueblc's tuya-convert fork . How to flash ~ OTA Flashing ~ No hardware preparation is required to flash if you are confident about having the same version and can easily be flashed using Tuya-Convert methods. This results in a fully functional device when using the BlitzWolf SHP2 template. The ability to OTA flash the device may not work in the future . Tuya has patched their firmware to block the OTA flashing tools. If the manufacturer updates the firmware shipped with the device to the latest Tuya version, OTA flashing will cease to be an option. As of August 2019, devices purchased from Amazon (link above) were still able to be OTA flashed (via Tuya-Convert). Flashing via serial ~ Video Tutorial by Marcus Bennett Configuration ~ After flashing and configuring the Wi-Fi parameters, use the Tasmota web UI Configure Template. Set Based on to BlitzWolf SHP (45) and then change GPIO2 from Led1i (56) to Led2i (57) for the LED to operate properly. How to disassemble if desired ~ If you wish to confirm you have the same hardware the Teckin SP23 can be opened by hitting each side of the plug at the lip with a rubber mallet or similar. This will leave a visually unblemished enclosure which can be resecured with superglue or similar. Full album Home Automation Hub Integration ~ openHAB ~ sonoff.items: Switch BlitzwoIFSHP2 \"Switch\" { mqtt=\">[broker:cmnd/BlitzwoIFSHP2/POWER:command:*:default],<[broker:stat/BlitzwoIFSHP2/POWER:state:default]\" } Number Power_Total \"Total: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Total)]\" } Number Power_Today \"Today: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Today)]\" } Number Power_Yesterday \"Yesterday: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Yesterday)]\" } Number Power \"Power: [%.1f Watt]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Power)]\" } Number Voltage \"Voltage: [%.0f V]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Voltage)]\" } Number Current \"Current: [%.3f A]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Current)]\" } Number Factor \"Factor: [%.2f]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Factor)]\" } default.sitemap: Switch item=BlitzwoIFSHP2 label=\"BlitzWoIF SHP2\" icon=\"socket\" mappings=[OFF=\"Off\",ON=\"On\"] Text item=Power label=\"Power: [%.1f Watt]\" icon=\"energy\" Text item=Voltage label=\"Voltage: [%.0f V]\" icon=\"energy\" Text item=Current label=\"Current: [%.3f A]\" icon=\"energy\" Text item=Factor label=\"Factor: [%.2f]\" icon=\"energy\" Text item=Power_Total label=\"Power Total: [%.3f kWh]\" icon=\"energy\" Text item=Power_Today label=\"Power Today: [%.3f kWh]\" icon=\"energy\" Text item=iPower_Yesterday label=\"Power Yesterday: [%.3f kWh]\" icon=\"energy\" Home Assistant ~ switch : - platform : mqtt name : \"Blitzwolf\" state_topic : \"stat/blitzwolf/POWER\" command_topic : \"cmnd/blitzwolf/POWER\" payload_on : \"ON\" payload_off : \"OFF\" retain : false sensor : - platform : mqtt name : \"Blitzwolf Energy Today\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Today\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Yesterday\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Yesterday\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Total\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Total\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Power\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Power\"] }}' unit_of_measurement : \"W\" - platform : mqtt name : \"Blitzwolf Voltage\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Voltage\"] }}' unit_of_measurement : \"V\" - platform : mqtt name : \"Blitzwolf Power Factor\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Factor\"] }}'","title":"Teckin SP23"},{"location":"devices/Teckin-SP23/#details","text":"The Teckin SP23 appears to be a clone of the BlitzWolf SHP2 hardware with Tuya firmware. It uses an ESP8266EX and is capable of switching up to 16 amps at 250 VAC. Two Teckin SP23s (marked V1.2) purchased from Amazon UK (January 2019) have been flashed successfully and use BlitzWolf SHP2 Sonoff configuration. Voltage calibration may be required for accurate power monitoring. Two additional Teckin SP23s were purchased from Amazon UK (July 2019) and successfully flashed using Tuya-Convert. Upgrading to Tasmota 6.6 and using BlitzWolf SHP configuration was problematic - LED's did not show power status - but downgrading to 6.3 and using BlitzWolf SHP2 as above gave perfect performance. The units were not disassembled so there was no way of determining board version. A set of 4 Teckin SP23s were purchased from Amazon UK (Sept 2019) and they flashed without issues using Tuya-Convert. This device functions properly with tasmota.bin 6.6.0 (LED flashing blue when ON) with the template in the repository . Two devices purchased on Amazon ES were already patched, but have been successfully flashed with the new-sdk branch of kueblc's tuya-convert fork .","title":"Details:"},{"location":"devices/Teckin-SP23/#how-to-flash","text":"","title":"How to flash"},{"location":"devices/Teckin-SP23/#ota-flashing","text":"No hardware preparation is required to flash if you are confident about having the same version and can easily be flashed using Tuya-Convert methods. This results in a fully functional device when using the BlitzWolf SHP2 template. The ability to OTA flash the device may not work in the future . Tuya has patched their firmware to block the OTA flashing tools. If the manufacturer updates the firmware shipped with the device to the latest Tuya version, OTA flashing will cease to be an option. As of August 2019, devices purchased from Amazon (link above) were still able to be OTA flashed (via Tuya-Convert).","title":"OTA Flashing"},{"location":"devices/Teckin-SP23/#flashing-via-serial","text":"Video Tutorial by Marcus Bennett","title":"Flashing via serial"},{"location":"devices/Teckin-SP23/#configuration","text":"After flashing and configuring the Wi-Fi parameters, use the Tasmota web UI Configure Template. Set Based on to BlitzWolf SHP (45) and then change GPIO2 from Led1i (56) to Led2i (57) for the LED to operate properly.","title":"Configuration"},{"location":"devices/Teckin-SP23/#how-to-disassemble-if-desired","text":"If you wish to confirm you have the same hardware the Teckin SP23 can be opened by hitting each side of the plug at the lip with a rubber mallet or similar. This will leave a visually unblemished enclosure which can be resecured with superglue or similar. Full album","title":"How to disassemble if desired"},{"location":"devices/Teckin-SP23/#home-automation-hub-integration","text":"","title":"Home Automation Hub Integration"},{"location":"devices/Teckin-SP23/#openhab","text":"sonoff.items: Switch BlitzwoIFSHP2 \"Switch\" { mqtt=\">[broker:cmnd/BlitzwoIFSHP2/POWER:command:*:default],<[broker:stat/BlitzwoIFSHP2/POWER:state:default]\" } Number Power_Total \"Total: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Total)]\" } Number Power_Today \"Today: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Today)]\" } Number Power_Yesterday \"Yesterday: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Yesterday)]\" } Number Power \"Power: [%.1f Watt]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Power)]\" } Number Voltage \"Voltage: [%.0f V]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Voltage)]\" } Number Current \"Current: [%.3f A]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Current)]\" } Number Factor \"Factor: [%.2f]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Factor)]\" } default.sitemap: Switch item=BlitzwoIFSHP2 label=\"BlitzWoIF SHP2\" icon=\"socket\" mappings=[OFF=\"Off\",ON=\"On\"] Text item=Power label=\"Power: [%.1f Watt]\" icon=\"energy\" Text item=Voltage label=\"Voltage: [%.0f V]\" icon=\"energy\" Text item=Current label=\"Current: [%.3f A]\" icon=\"energy\" Text item=Factor label=\"Factor: [%.2f]\" icon=\"energy\" Text item=Power_Total label=\"Power Total: [%.3f kWh]\" icon=\"energy\" Text item=Power_Today label=\"Power Today: [%.3f kWh]\" icon=\"energy\" Text item=iPower_Yesterday label=\"Power Yesterday: [%.3f kWh]\" icon=\"energy\"","title":"openHAB"},{"location":"devices/Teckin-SP23/#home-assistant","text":"switch : - platform : mqtt name : \"Blitzwolf\" state_topic : \"stat/blitzwolf/POWER\" command_topic : \"cmnd/blitzwolf/POWER\" payload_on : \"ON\" payload_off : \"OFF\" retain : false sensor : - platform : mqtt name : \"Blitzwolf Energy Today\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Today\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Yesterday\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Yesterday\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Total\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Total\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Power\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Power\"] }}' unit_of_measurement : \"W\" - platform : mqtt name : \"Blitzwolf Voltage\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Voltage\"] }}' unit_of_measurement : \"V\" - platform : mqtt name : \"Blitzwolf Power Factor\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Factor\"] }}'","title":"Home Assistant"},{"location":"devices/Teckin-sp10/","text":"so I got a couple of these guys given to me teckin sp10 on amazon.ca follow some great info here I found the esp8266 as expected in here I was able to identify the module at a esp8266-s3 spec sheet @znanev did most of the work already the uk version of this plug as noted by Znanev it took a great deal of time to confirm that I did indeed have the same pin outs as this UK plug I stumbled apon what I think is the original manufacturer of these but we will probably never know plug maker I am going to now shamelessly steal from @znanev as he wrote this much better than I could have WiFi module pins ~ Here is a close-up view of the module's pins as seen from the bottom of the main PCB: And this is how module pins numbers are mapped (I had to desolder the module looking for labels when I tried to identify it): Failed to identify the module, I had remove the metal shielding cap to find the routing of the ESP8266's pins, so I grabbed the multimeter and soon I had the following table: Module pin ESP8266 pin Pin name Pin name ESP8266 pin Module pin 1 7 Chip Enable Tout (ADC) 6 2 3 9 MTMS / GPIO14 MTDI / GPIO12 10 4 5 12 MTCK / GPIO13 MTDO / GPIO15 13 6 7 15 GPIO0 GPIO2 14 8 9 16 GPIO4 GPIO5 24 10 11 25 U0RXD U0TXD 26 12 13 Vdd - - GND 14 Serial Connection ~ For programming you need to solder 4 jumper wires to pins 11 , 12 , 13 and 14 ( Rx , Tx , Vdd and GND ). Connect the other end of the wires to your USB-to-serial adapter and make sure the supply voltage selected is 3.3V. Shorting pin 7 (GPIO0) to ground while plugging the serial adapter into the computer's USB port will bring the module into UART firmware upload mode. Configuration ~ Once Tasmota 's WebUI configuration interface is loaded in the browser, you can change many settings using the menu options. Console window is where you can change almost all configuration parameters. Head straight to the Configure Module menu, selected 'Generic' for 'Module type' . Here are the settings that I selected on that screen: Sonoff devices usually have a bi-colour LED, but just one of the colours can be controlled directly. The other colour is usually tied together with the relay, so it cannot be controlled independently. I think that is the reason why the Tasmota firmware by default controls just Led1 when a single relay is configured. In the configuration above, only the blue LED will be used (tied to GPIO2 ). But if you prefer the red LED, just change the values for Led1i and Led2i (select Led1i for GPIO0 and Led2i for GPIO2 ). end quote if you care led 2 is blue and led 1 is red I flashed the standard tasmota.bin file to it with out any problems with both the esptools and with arduino the one benefit to using arduino is that I was able to configure my wifi in advance I hope to update this and clean it up but I thought I should get it up here as I found nothing about this plug before I forget to post and I can't remember any details. Note: I have a newer version of this, labelled C7 HYS-X5-SOCKET_V1.2. The connectors for the ESP8266 board seem different. Still mapping them, but beware of following these instructions unless you know you have the same version. Update: looks like I actually destroyed the ESP8266 board somehow, using the software-only tuya-convert technique. After failing to get it to update, I opened up the case by putting it between two dowels in my vise, and tightening until it cracked open. There was zero resistance between pins 13 and 14. I fed it power at 3.3 volts to 1 amp, before giving up. An identical second plug updated without incident.","title":"Teckin sp10"},{"location":"devices/Teckin-sp10/#wifi-module-pins","text":"Here is a close-up view of the module's pins as seen from the bottom of the main PCB: And this is how module pins numbers are mapped (I had to desolder the module looking for labels when I tried to identify it): Failed to identify the module, I had remove the metal shielding cap to find the routing of the ESP8266's pins, so I grabbed the multimeter and soon I had the following table: Module pin ESP8266 pin Pin name Pin name ESP8266 pin Module pin 1 7 Chip Enable Tout (ADC) 6 2 3 9 MTMS / GPIO14 MTDI / GPIO12 10 4 5 12 MTCK / GPIO13 MTDO / GPIO15 13 6 7 15 GPIO0 GPIO2 14 8 9 16 GPIO4 GPIO5 24 10 11 25 U0RXD U0TXD 26 12 13 Vdd - - GND 14","title":"WiFi module pins"},{"location":"devices/Teckin-sp10/#serial-connection","text":"For programming you need to solder 4 jumper wires to pins 11 , 12 , 13 and 14 ( Rx , Tx , Vdd and GND ). Connect the other end of the wires to your USB-to-serial adapter and make sure the supply voltage selected is 3.3V. Shorting pin 7 (GPIO0) to ground while plugging the serial adapter into the computer's USB port will bring the module into UART firmware upload mode.","title":"Serial Connection"},{"location":"devices/Teckin-sp10/#configuration","text":"Once Tasmota 's WebUI configuration interface is loaded in the browser, you can change many settings using the menu options. Console window is where you can change almost all configuration parameters. Head straight to the Configure Module menu, selected 'Generic' for 'Module type' . Here are the settings that I selected on that screen: Sonoff devices usually have a bi-colour LED, but just one of the colours can be controlled directly. The other colour is usually tied together with the relay, so it cannot be controlled independently. I think that is the reason why the Tasmota firmware by default controls just Led1 when a single relay is configured. In the configuration above, only the blue LED will be used (tied to GPIO2 ). But if you prefer the red LED, just change the values for Led1i and Led2i (select Led1i for GPIO0 and Led2i for GPIO2 ). end quote if you care led 2 is blue and led 1 is red I flashed the standard tasmota.bin file to it with out any problems with both the esptools and with arduino the one benefit to using arduino is that I was able to configure my wifi in advance I hope to update this and clean it up but I thought I should get it up here as I found nothing about this plug before I forget to post and I can't remember any details. Note: I have a newer version of this, labelled C7 HYS-X5-SOCKET_V1.2. The connectors for the ESP8266 board seem different. Still mapping them, but beware of following these instructions unless you know you have the same version. Update: looks like I actually destroyed the ESP8266 board somehow, using the software-only tuya-convert technique. After failing to get it to update, I opened up the case by putting it between two dowels in my vise, and tightening until it cracked open. There was zero resistance between pins 13 and 14. I fed it power at 3.3 volts to 1 amp, before giving up. An identical second plug updated without incident.","title":"Configuration"},{"location":"devices/Tuya-Smart-Plug-Models-ESP8266MOD-by-AI-THINKER-and-ESP-12F-by-TUYA-LN-0026/","text":"These are simple, No-Name smart plugs (I bought these at AliExpress). One of them has ESP8266MOD chip (by AI-THINKER), other one has ESP-12F chip (by TUYA L/N 0026). Both are actually same chips and are flashed the same way. You need to solder 5 wires: 1. VCC (3.3V) 2. GND (GROUND) 3. Rx 4. Tx 5. GPIO0 To put this chips into flash mode, we need to jump wire GPIO0 and GROUND, before you plug your USB adapter into computer. Release jump wire after couple of seconds. Red LED (bottom one) should slightly lit up. Now you can start flashing process. When flashing process is complete, you can unplug USB adapter. Your TUYA smart plug is TASMOTIZED. THIS IS OPTIONAL!!! You can now use Termite app, to load your router WiFi SSID and password using below commands: (just copy and paste all of it, but put your details in). In Termite settings, check your COM number, where adapter is plugged in and select 115200. Backlog SSID1 YOUR_SSID_NAME; Password1 YOUR_WIFI_PASSWORD; MqttHost MQTT_INTERNAL_IP_ADDRESS; MqttUser MQTT_USER_NAME; MqttPassword MQTT_PASSWORD; GPIO2 56; GPIO12 21; GPIO13 17 After that, Termite should tell you, what IP address was assigned to your smart plug. Put that IP address in your browser and you should see Tasmota GUI. Go into Configuration > Configure Module > Change to Generic (and click Save). After restart, go into Configuration > Configure Module and change GPIO's as on screen below. You can change between D4 GPIO2 56 LED1i and D4 GPIO2 52 LED1 (Blue led on when device is on, or blue led on when device is off) That's it, now your smart plug will flash both red and blue leds and smart plug button should respond to presses. Special thanks to Travis Griggs for his help with flashing process (I based this tutorial on his own: LINK )","title":"Tuya Smart Plug Models ESP8266MOD by AI THINKER and ESP 12F by TUYA LN 0026"},{"location":"devices/WL-SW01_10-WiFi-Smart-Switch/","text":"Manufactured by Blue50 as WL-SW01_10 and also sold as TISHRIC . Sonoff Basic in a different form factor with the same features. It contains an ESP8285 chip on a vertical breakout board with all the needed GPIOs broken out and labeled. There are also a couple pads on the board to solder VCC and G. Use template {\"NAME\":\"WL-SW01_10\",\"GPIO\":[17,149,0,148,0,0,0,0,21,56,0,0,0],\"FLAG\":0,\"BASE\":1} If your Tasmota version doesn't support templates select module Sonoff Basic (1) .","title":"WL SW01 10 WiFi Smart Switch"},{"location":"devices/WS03-WS01-WS05/","text":"WS03-Led Controller (from Aliexpress) ~ The WS01 LED-Controller uses an ESP8266-S1 Module (16MBit Flash) Alle required Pins for programming are available, as well as additional GPIO4 and GPIO2. Outside Images PCB Image with pinout GPIO2 & GPIO4 are working for I 2 C (2=SDA 4=SCL). (Tested with DS3231 Module ) The device uses an additional CD4050 at the pins used for PWM.","title":"WS03-Led Controller (from Aliexpress)"},{"location":"devices/WS03-WS01-WS05/#ws03-led-controller-from-aliexpress","text":"The WS01 LED-Controller uses an ESP8266-S1 Module (16MBit Flash) Alle required Pins for programming are available, as well as additional GPIO4 and GPIO2. Outside Images PCB Image with pinout GPIO2 & GPIO4 are working for I 2 C (2=SDA 4=SCL). (Tested with DS3231 Module ) The device uses an additional CD4050 at the pins used for PWM.","title":"WS03-Led Controller (from Aliexpress)"},{"location":"devices/Wemos-D1-Mini/","text":"Flashing Wemos with Tasmota ~ Flashing a Wemos D1 Mini with Tasmota firmware is nearly the same as for every other device. Just connect Wemos D1 mini via USB. No action required to enter Flashmode! Configure Tasmota for Wemos ~ Generic Module ~ In the Configuration -> Configure Module page, select Module Type: \"18 Generic\" . After Saving the settings, the WEMOS reboots with the Generic configuration. The first time you switch to \"18 Generic\" you will NOT see all the options as seen in the picture below YET. You have to save \"18 Generic\" first and when you go there again after the reboot you get the long table where you can change all the pin's parameters. These steps are confirmed to also work with the Wemos D1 mini PRO v2.0.0. Link to Wemos hardware & documentation ~ DOCS dot WEMOS dot CC","title":"Wemos D1 Mini"},{"location":"devices/Wemos-D1-Mini/#flashing-wemos-with-tasmota","text":"Flashing a Wemos D1 Mini with Tasmota firmware is nearly the same as for every other device. Just connect Wemos D1 mini via USB. No action required to enter Flashmode!","title":"Flashing Wemos with Tasmota"},{"location":"devices/Wemos-D1-Mini/#configure-tasmota-for-wemos","text":"","title":"Configure Tasmota for Wemos"},{"location":"devices/Wemos-D1-Mini/#generic-module","text":"In the Configuration -> Configure Module page, select Module Type: \"18 Generic\" . After Saving the settings, the WEMOS reboots with the Generic configuration. The first time you switch to \"18 Generic\" you will NOT see all the options as seen in the picture below YET. You have to save \"18 Generic\" first and when you go there again after the reboot you get the long table where you can change all the pin's parameters. These steps are confirmed to also work with the Wemos D1 mini PRO v2.0.0.","title":"Generic Module"},{"location":"devices/Wemos-D1-Mini/#link-to-wemos-hardware-documentation","text":"DOCS dot WEMOS dot CC","title":"Link to Wemos hardware &amp; documentation"},{"location":"devices/Wemos-D1-R1-%26-R2/","text":"Wemos D1 Release 1 (R1) and Release 2 (R2) ~ Here you can find information for the big brother of the Wemos D1 mini which can be found here . R1 vs. R2 - The Difference ~ When you take a look at the figure 1 you will see it with one blink of the eye thet the old Wemos is different against the new verion R2. The old version has an ESP8266 12B or 12E model. The new one has a ESP8266 12F model on the pcb board. You see this in the defference of the Wifi antenna. Here is a Wiki link to the different ESP8266 modules. The next part for R2 are the 2x4 solder pins for the serial and I2C interface which is not on the old model R1. The techncal data/specifiactions are the same. SO as you see they look like an Arduino UNO inculding the stacks to mount different shields. Later i will give more information over shields which i have tested and there are a lot of them. Figure: WeMos D1 R1 vs. WeMos D1 R2","title":"Wemos D1 R1 & R2"},{"location":"devices/Wemos-D1-R1-%26-R2/#wemos-d1-release-1-r1-and-release-2-r2","text":"Here you can find information for the big brother of the Wemos D1 mini which can be found here .","title":"Wemos D1 Release 1 (R1) and Release 2 (R2)"},{"location":"devices/Wemos-D1-R1-%26-R2/#r1-vs-r2-the-difference","text":"When you take a look at the figure 1 you will see it with one blink of the eye thet the old Wemos is different against the new verion R2. The old version has an ESP8266 12B or 12E model. The new one has a ESP8266 12F model on the pcb board. You see this in the defference of the Wifi antenna. Here is a Wiki link to the different ESP8266 modules. The next part for R2 are the 2x4 solder pins for the serial and I2C interface which is not on the old model R1. The techncal data/specifiactions are the same. SO as you see they look like an Arduino UNO inculding the stacks to mount different shields. Later i will give more information over shields which i have tested and there are a lot of them. Figure: WeMos D1 R1 vs. WeMos D1 R2","title":"R1 vs. R2 - The Difference"},{"location":"devices/Xenon-SM-SW102-2-two-relay-light-switch/","text":"Amazon Link: https://www.amazon.com/Tempered-Controlled-Separately-Standard-Compatible/dp/B0719Q5G5B/ref=sr_1_3?ie=UTF8&qid=1540511385&sr=8-3&keywords=xenon+light+switch&dpID=21PWx5MUrEL&preST= SY300_QL70 &dpSrc=srch Also sold as the Mojocraft Wireless Smart Wall Switch 2 Gang: https://www.amazon.com/Mojocraft-Wireless-Sensitive-Compatible-Required/dp/B072JCWH23/ref=sr_1_3?ie=UTF8&qid=1540858092&sr=8-3&keywords=Mojocraft I didn't spot any headers, but device has a sub-board with an ESP-12 module on it. Solder right to the 3.3V, Ground, TX, RX, and GPIO pins and flash away. I set the device up as a generic device with the following assignments. GPIO 3 is button 2 GPIO 4 is relay 2 GPIO 12 is button 1 GPIO 13 is relay 1","title":"Xenon SM SW102 2 two relay light switch"},{"location":"devices/Xiaomi-Mi-Desk-Lamp/","text":"Mi Desk Lamp is a cold+warm white led lamp, which has a rotary knob that also acts as a push-button: - pushing it turns the lamp on/off - rotating it controls the brightness - rotating it while pushed controls the color temperature At the bottom of the lamp stand there is also a 'Reset' button, which can be pressed by a hairpin/toothpick/etc only. Manufacturer Link Configuration ~ Tasmota supports it directly as Module \"Mi Desk Lamp\" . This module is deactivated by default. You must add #define ROTARY_V1 in your user_config_override.h and compile the firmware for this module to be available as a selection option. To configure it as Generic , here is the GPIO assignment: - GPIO02: Button ( GPIO_KEY1 ) - GPIO04: Cold White ( GPIO_PWM1 ) - GPIO05: Warm White ( GPIO_PWM2 ) - GPIO12: Rotary switch A pin ( GPIO_ROT_A ) - GPIO13: Rotary switch B pin ( GPIO_ROT_B ) NOTE: The operation of the rotary switch depends on the module type being MI_DESK_LAMP , so full functionality cannot be achieved with the Generic config. Flashing ~ This lamp is based on a YeeLight LXU 1.7 module, that contains: - an ESP8266 - 2 MB flash Disassembly ~ First of all, remove the knob by pushing some soft and flat tool underneath it and gently pry away from the stand. Then remove the bottom of the stand, held by 3 screws underneath the rubber strips: Underneath you find a small board for the power input and the reset button, and the controller board: The test points (8 vertical, 2 horizontal) are connected to the module pins 7..14 and 17..18 (see below). As GPIO0 is not among them, they aren't enough for flashing, so the board must be removed anyway. NOTE: You need to remove the knob before you can remove this controller board. The controller board contains - a 3.3V converter on the side of the white power wires - two LED drivers on the side of the red/blue/black LED wires - the rotary button - the Yeelight module Pinout ~ Left side: - Pin 1: ADC (N.C.) - Pin 2: GPIO15 (N.C.) - Pin 3: GND - Pin 4: GPIO0 - Pin 5: GND - Pin 6: GND Bottom: - Pin 7: GND - Pin 8: Vcc (3.3V) - Pin 9: GPIO14 (Reset button) - Pin 10: GPIO2 (Rotary button) - Pin 11: GPIO13 (Rotary B) - Pin 12: GPIO12 (Rotary A) - Pin 13: GPIO4 (Cold white) - Pin 14: GPIO5 (Warm white) Right side: - Pin 15: GND - Pin 16: GND - Pin 17: RxD (N.C.) - Pin 18: TxD (N.C.) - Pin 19: GND (N.C.) - Pin 20: GND (N.C.) Three pins (ADC, GPIO0 and GPIO15) are not used by the lamp, they are available for hacking :). Procedure ~ For serial flashing we need 2 power wires (GND, Vcc), 2 serial wires (RxD, TxD) and the boot mode button (GPIO0): As there is plenty of free space in the lamp stand, I left the wires long enough to reach some empty area and soldered solo pin head sockets on them. This way they will be available if/when I decide to add something on those 3 extra pins :). The rest of the serial flashing process is as usual , but if you want to make a backup of the original firmware, keep in mind that the flash size is 2 MBs . If you are re-flashing the original firmware, the flash size must be explicitly set to '2MB-c1', the auto-detected '2MB' doesn't work , so: esptool.py write_flash --flash_size 2MB-c1 0x00000 xiaomi_desk_lamp.orig.bin Serial logging ~ A bonus feature for debugging/logging: The lamp has an external DC12V power supply, so there is no shock hazard. Nonetheless, accidental 12V can still cause damage to a 3.3V serial converter, so be cautious if you do serial logging on a live lamp. The original firmware sets the USART to the same 74880 baud as the ESP boot loader, and it dumps some details as well: ets Jan 8 2013 , rst cause : 1 , boot mode :( 3 , 7 ) load 0x60000020 , len 4 , room 16 phy ver : 1055 _1 , pp ver : 10.7 rf cal sector : 507 tcpip_task_hdl : 3 fff2958 , prio : 10 , stack : 512 idle_task_hdl : 3 fff29f8 , prio : 0 , stack : 384 tim_task_hdl : 3 fff5188 , prio : 2 , stack : 512 pwm version : 1.0 . 2 mcu version : 1.3 . 0 _0055 prod : yeelink . light . lamp1 data : 0x3ffe8000 ~ 0x3ffe91f4 , len : 4596 rodata : 0x3ffe9310 ~ 0x3ffeaa7c , len : 5996 bss : 0x3ffeaa80 ~ 0x3fff27d8 , len : 32088 heap : 0x3fff27d8 ~ 0x40000000 , len : 55336 BUILD TIME : May 25 2018 , 07 : 01 : 12 ESP SDK VER : 1.5 . 0 - dev ( c6beda8 ) did is 65282142 mac addr 7811 dc06cfd9 reset reason : 0 current flash flag is 0 , current user bin addr 0x101000 mode : softAP ( 7 a : 11 : dc : 06 : cf : d9 ) dhcp server start :( ip : 192.168 . 4.1 , mask : 255.255 . 255.0 , gw : 192.168 . 4.1 ) add if1 bcn 100 Hacking ~ The lamp has 3 pins that aren't used in normal operation: ADC, GPIO0 and GPIO15. GPIO15 is and must be pulled up for boot selection, so its usability is somewhat limited. On the other hand, if you already soldered wires to VCC, GND and GPIO0 for serial flashing, they are perfect for a DHT11 or DHT22 temperature+humidity sensor! As the lamp has external power supply, and the LEDs are in the upper part of the lamp, the temperature of the base is the same as of the ambient, and by its nature the lamp is situated on your desk, so it's a perfect place for temp+humidity measurements. If you want to place the sensor inside the lamp base, then you may need to remove some material from one of the weight panels, and if you choose to place it on the outside (e.g., near the base), then a convenient and relatively hidden path for the 3 wires is above the power jack, just enlarge the hole by 2 mm-s with a file.","title":"Xiaomi Mi Desk Lamp"},{"location":"devices/Xiaomi-Mi-Desk-Lamp/#configuration","text":"Tasmota supports it directly as Module \"Mi Desk Lamp\" . This module is deactivated by default. You must add #define ROTARY_V1 in your user_config_override.h and compile the firmware for this module to be available as a selection option. To configure it as Generic , here is the GPIO assignment: - GPIO02: Button ( GPIO_KEY1 ) - GPIO04: Cold White ( GPIO_PWM1 ) - GPIO05: Warm White ( GPIO_PWM2 ) - GPIO12: Rotary switch A pin ( GPIO_ROT_A ) - GPIO13: Rotary switch B pin ( GPIO_ROT_B ) NOTE: The operation of the rotary switch depends on the module type being MI_DESK_LAMP , so full functionality cannot be achieved with the Generic config.","title":"Configuration"},{"location":"devices/Xiaomi-Mi-Desk-Lamp/#flashing","text":"This lamp is based on a YeeLight LXU 1.7 module, that contains: - an ESP8266 - 2 MB flash","title":"Flashing"},{"location":"devices/Xiaomi-Mi-Desk-Lamp/#disassembly","text":"First of all, remove the knob by pushing some soft and flat tool underneath it and gently pry away from the stand. Then remove the bottom of the stand, held by 3 screws underneath the rubber strips: Underneath you find a small board for the power input and the reset button, and the controller board: The test points (8 vertical, 2 horizontal) are connected to the module pins 7..14 and 17..18 (see below). As GPIO0 is not among them, they aren't enough for flashing, so the board must be removed anyway. NOTE: You need to remove the knob before you can remove this controller board. The controller board contains - a 3.3V converter on the side of the white power wires - two LED drivers on the side of the red/blue/black LED wires - the rotary button - the Yeelight module","title":"Disassembly"},{"location":"devices/Xiaomi-Mi-Desk-Lamp/#pinout","text":"Left side: - Pin 1: ADC (N.C.) - Pin 2: GPIO15 (N.C.) - Pin 3: GND - Pin 4: GPIO0 - Pin 5: GND - Pin 6: GND Bottom: - Pin 7: GND - Pin 8: Vcc (3.3V) - Pin 9: GPIO14 (Reset button) - Pin 10: GPIO2 (Rotary button) - Pin 11: GPIO13 (Rotary B) - Pin 12: GPIO12 (Rotary A) - Pin 13: GPIO4 (Cold white) - Pin 14: GPIO5 (Warm white) Right side: - Pin 15: GND - Pin 16: GND - Pin 17: RxD (N.C.) - Pin 18: TxD (N.C.) - Pin 19: GND (N.C.) - Pin 20: GND (N.C.) Three pins (ADC, GPIO0 and GPIO15) are not used by the lamp, they are available for hacking :).","title":"Pinout"},{"location":"devices/Xiaomi-Mi-Desk-Lamp/#procedure","text":"For serial flashing we need 2 power wires (GND, Vcc), 2 serial wires (RxD, TxD) and the boot mode button (GPIO0): As there is plenty of free space in the lamp stand, I left the wires long enough to reach some empty area and soldered solo pin head sockets on them. This way they will be available if/when I decide to add something on those 3 extra pins :). The rest of the serial flashing process is as usual , but if you want to make a backup of the original firmware, keep in mind that the flash size is 2 MBs . If you are re-flashing the original firmware, the flash size must be explicitly set to '2MB-c1', the auto-detected '2MB' doesn't work , so: esptool.py write_flash --flash_size 2MB-c1 0x00000 xiaomi_desk_lamp.orig.bin","title":"Procedure"},{"location":"devices/Xiaomi-Mi-Desk-Lamp/#serial-logging","text":"A bonus feature for debugging/logging: The lamp has an external DC12V power supply, so there is no shock hazard. Nonetheless, accidental 12V can still cause damage to a 3.3V serial converter, so be cautious if you do serial logging on a live lamp. The original firmware sets the USART to the same 74880 baud as the ESP boot loader, and it dumps some details as well: ets Jan 8 2013 , rst cause : 1 , boot mode :( 3 , 7 ) load 0x60000020 , len 4 , room 16 phy ver : 1055 _1 , pp ver : 10.7 rf cal sector : 507 tcpip_task_hdl : 3 fff2958 , prio : 10 , stack : 512 idle_task_hdl : 3 fff29f8 , prio : 0 , stack : 384 tim_task_hdl : 3 fff5188 , prio : 2 , stack : 512 pwm version : 1.0 . 2 mcu version : 1.3 . 0 _0055 prod : yeelink . light . lamp1 data : 0x3ffe8000 ~ 0x3ffe91f4 , len : 4596 rodata : 0x3ffe9310 ~ 0x3ffeaa7c , len : 5996 bss : 0x3ffeaa80 ~ 0x3fff27d8 , len : 32088 heap : 0x3fff27d8 ~ 0x40000000 , len : 55336 BUILD TIME : May 25 2018 , 07 : 01 : 12 ESP SDK VER : 1.5 . 0 - dev ( c6beda8 ) did is 65282142 mac addr 7811 dc06cfd9 reset reason : 0 current flash flag is 0 , current user bin addr 0x101000 mode : softAP ( 7 a : 11 : dc : 06 : cf : d9 ) dhcp server start :( ip : 192.168 . 4.1 , mask : 255.255 . 255.0 , gw : 192.168 . 4.1 ) add if1 bcn 100","title":"Serial logging"},{"location":"devices/Xiaomi-Mi-Desk-Lamp/#hacking","text":"The lamp has 3 pins that aren't used in normal operation: ADC, GPIO0 and GPIO15. GPIO15 is and must be pulled up for boot selection, so its usability is somewhat limited. On the other hand, if you already soldered wires to VCC, GND and GPIO0 for serial flashing, they are perfect for a DHT11 or DHT22 temperature+humidity sensor! As the lamp has external power supply, and the LEDs are in the upper part of the lamp, the temperature of the base is the same as of the ambient, and by its nature the lamp is situated on your desk, so it's a perfect place for temp+humidity measurements. If you want to place the sensor inside the lamp base, then you may need to remove some material from one of the weight panels, and if you choose to place it on the outside (e.g., near the base), then a convenient and relatively hidden path for the 3 wires is above the power jack, just enlarge the hole by 2 mm-s with a file.","title":"Hacking"},{"location":"devices/YTF-IR-Bridge/","text":"YTF BaKEN - Identical to the YTF Tuya Flashing ~ OTA flashing ~ This device is based on a Tuya Wi-Fi module and may still be flashable with Tuya-Convert . Serial flashing ~ Like most devices, GPIO0 has to be held low during power up to get into flash mode. In the picture below, notice the red jumper wire between IO0 and GND. I soldered it in such a way I could hold it during power on, but release later (basically acts as a button), since it can not be held low if you want normal operation. Configuration ~ Introduced in version 6.4.1.8 as YTF IR Bridge (62) GPIO Component Description 04 LED1i (52) Blue LED - Link status 05 IRrecv (51) IR Receiver 13 Button1 (17) Button 14 IRsend (8) IR Transmitter IR Codes ~ IR Code List","title":"YTF IR Bridge"},{"location":"devices/YTF-IR-Bridge/#flashing","text":"","title":"Flashing"},{"location":"devices/YTF-IR-Bridge/#ota-flashing","text":"This device is based on a Tuya Wi-Fi module and may still be flashable with Tuya-Convert .","title":"OTA flashing"},{"location":"devices/YTF-IR-Bridge/#serial-flashing","text":"Like most devices, GPIO0 has to be held low during power up to get into flash mode. In the picture below, notice the red jumper wire between IO0 and GND. I soldered it in such a way I could hold it during power on, but release later (basically acts as a button), since it can not be held low if you want normal operation.","title":"Serial flashing"},{"location":"devices/YTF-IR-Bridge/#configuration","text":"Introduced in version 6.4.1.8 as YTF IR Bridge (62) GPIO Component Description 04 LED1i (52) Blue LED - Link status 05 IRrecv (51) IR Receiver 13 Button1 (17) Button 14 IRsend (8) IR Transmitter","title":"Configuration"},{"location":"devices/YTF-IR-Bridge/#ir-codes","text":"IR Code List","title":"IR Codes"},{"location":"devices/YUNTONG-Smart/","text":"Sonoff Basic Clone can be flashed to Tasmota PIN assignment: PCB Antenna End: * TOP Layer - Bottom Layer * EN - TOUT * IO14 - IO12 * IO13 - IO15 * IO0 - IO2 * IO4 - IO5 * RX - TX * VCC - GND The clone are based on the ESP-03S - User manual","title":"YUNTONG Smart"},{"location":"devices/ZEOOTA-Wifi-Smart-Power-Strip-4-EU-outlets-with-4-USB-ports/","text":"This power strip has Tuya TYWE2S module (ESP8285 chip). Successfully flashed Tasmota on it. 4 power outlets are individually controlled. USB ports have just one relay to switch all ports on/off. Model purchased: https://www.aliexpress.com/item/Wifi-Smart-Power-Strip-4-EU-Outlets-Plug-Socket-with-USB-4-Charging-Port-App-Voice/32864686078.html Used this connection for flashing (just connect GPIO0 on the back side of the module to GND before USB connection to enter flash mode): Module configuration:","title":"ZEOOTA Wifi Smart Power Strip 4 EU outlets with 4 USB ports"},{"location":"devices/leegoal-plug/","text":"Description ~ Very nice and cheap plug :) https://www.amazon.de/gp/product/B07FD971T9/ Features: ~ 3800 W switchi ng USB port 5V 2.1A for charging Power monitor Tuya compatible Model description ~ FLHS ZN04 Configuration ~ Tasmota template based on BlitzWolf (45) {\"NAME\":\"Plug\",\"GPIO\":[57,0,56,0,0,134,0,0,131,17,132,21,0],\"FLAG\":0,\"BASE\":45} Flashing ~ It is possible to flash over OTA. But, it seems flashing via OTA may leave remains of old firmware because it wasn't fully erased before flashing Tasmota. So the device can fail after feature updates. (I have 3 devices originally flashed via OTA bricked after update later). So if you flashed via OTA it better to not update FW anymore. Unfortunately I bricked one of my plugs (probably by typing wrong Wifi name), so I needed to flash manually. Manual flash should be done exactly as shown here: * https://github.com/arendst/Tasmota/issues/3950#issuecomment-436074625 * devices/Hyleton-313-Smart-Plug Access to the internals is easy. Casing is held by 3 torx screws (no glue anywhere). Chip info ~ Detecting chip type... ESP8266 Chip is ESP8266EX Features: WiFi MAC: Manufacturer: a1 Device: 4014 Detected flash size: 1MB","title":"Description"},{"location":"devices/leegoal-plug/#description","text":"Very nice and cheap plug :) https://www.amazon.de/gp/product/B07FD971T9/","title":"Description"},{"location":"devices/leegoal-plug/#features","text":"3800 W switchi ng USB port 5V 2.1A for charging Power monitor Tuya compatible","title":"Features:"},{"location":"devices/leegoal-plug/#model-description","text":"FLHS ZN04","title":"Model description"},{"location":"devices/leegoal-plug/#configuration","text":"Tasmota template based on BlitzWolf (45) {\"NAME\":\"Plug\",\"GPIO\":[57,0,56,0,0,134,0,0,131,17,132,21,0],\"FLAG\":0,\"BASE\":45}","title":"Configuration"},{"location":"devices/leegoal-plug/#flashing","text":"It is possible to flash over OTA. But, it seems flashing via OTA may leave remains of old firmware because it wasn't fully erased before flashing Tasmota. So the device can fail after feature updates. (I have 3 devices originally flashed via OTA bricked after update later). So if you flashed via OTA it better to not update FW anymore. Unfortunately I bricked one of my plugs (probably by typing wrong Wifi name), so I needed to flash manually. Manual flash should be done exactly as shown here: * https://github.com/arendst/Tasmota/issues/3950#issuecomment-436074625 * devices/Hyleton-313-Smart-Plug Access to the internals is easy. Casing is held by 3 torx screws (no glue anywhere).","title":"Flashing"},{"location":"devices/leegoal-plug/#chip-info","text":"Detecting chip type... ESP8266 Chip is ESP8266EX Features: WiFi MAC: Manufacturer: a1 Device: 4014 Detected flash size: 1MB","title":"Chip info"},{"location":"devices/meross-MSS425/","text":"Be Aware ~ There are different versions of this power strip. An MSS425EEU-R purchased in August 2019 was based on the Mediatek Wi-Fi chip and not on an ESP82xx! Tasmota is only suitable for ESP82xx based devices. meross Power Strip ~ This power strip was selling on Amazon for about $17 when I bought it. The ESP module is mounted on the side vertically on board. It's another Tuya TYWE3S, 1MB. For more information on the Tuya TYWE3S, see this page . I soldered pins on and bent them down to get everything back in the case. To open, 4 screws are under the soft foot pads. They take a size 2.0 triangle bit; make sure you have a large collection of small screwdriver bits around. The programming header is directly on the Tuya module and is silkscreened with the labels for the pins. Solder onto those and program just like any other Tuya. There's unfortunately no button to get into firmware mode that I could find, so you have to ground the pin yourself. If you're using an external power source for the board and another power source for your TXD/RXD, make sure to tie the grounds together or else it won't talk. I burned on the generic tasmota release and set it up like so: Relays 1-3 are the AC plugs Relays 4,5 are the USBs The button only turns off the first AC by default, but you could write rules to do whatever you want.","title":"Be Aware"},{"location":"devices/meross-MSS425/#be-aware","text":"There are different versions of this power strip. An MSS425EEU-R purchased in August 2019 was based on the Mediatek Wi-Fi chip and not on an ESP82xx! Tasmota is only suitable for ESP82xx based devices.","title":"Be Aware"},{"location":"devices/meross-MSS425/#meross-power-strip","text":"This power strip was selling on Amazon for about $17 when I bought it. The ESP module is mounted on the side vertically on board. It's another Tuya TYWE3S, 1MB. For more information on the Tuya TYWE3S, see this page . I soldered pins on and bent them down to get everything back in the case. To open, 4 screws are under the soft foot pads. They take a size 2.0 triangle bit; make sure you have a large collection of small screwdriver bits around. The programming header is directly on the Tuya module and is silkscreened with the labels for the pins. Solder onto those and program just like any other Tuya. There's unfortunately no button to get into firmware mode that I could find, so you have to ground the pin yourself. If you're using an external power source for the board and another power source for your TXD/RXD, make sure to tie the grounds together or else it won't talk. I burned on the generic tasmota release and set it up like so: Relays 1-3 are the AC plugs Relays 4,5 are the USBs The button only turns off the first AC by default, but you could write rules to do whatever you want.","title":"meross Power Strip"},{"location":"devices/minitiger-Touch-Light-Switch/","text":"minitiger Touch Light Switch ~ This is a cheap Sonoff T1 clone. Available with 1/2/3 channels. The board has the ID 2PH89174A Device ~ ESP8285 micro Blue status LED (micro controlled) Separate touch IC controlled switch status indicators (blue and red) Aliexpress link: Click Aliexpress link for no neutral version (single live wire) version: Click Images ~ Front and soldering: Fullsize Front and identification number: Fullsize Back and GND: Fullsize Soldering layout: Fullsize Flashing ~ This board can be flashed with vanilla sonoff-tasmota. I used esptool on linux to upload the firmware. Programming mode: ~ Short GPIO0 to GND, as with all boards. If you have successfully put the micro into programming mode the LED does not light up! Config: ~ Single Channel: ~ Works out of the box, configured as Sonoff Basic. The LED does not light up when the switch is turned off. Configure as Sonoff T1 to enable the LED. Dual Channel: ~ {\"NAME\":\"Wall Switch 2C\",\"GPIO\":[17,255,255,255,0,22,18,0,21,56,0,0,0],\"FLAG\":0,\"BASE\":28} Dual Channel - No Neutral (Single Live Wire): ~ {\"NAME\":\"Wall Switch 2C\",\"GPIO\":[53,52,255,17,18,0,0,0,0,21,22,0,0],\"FLAG\":0,\"BASE\":28} Triple Channel: ~ Since I don't own such a board, you are on your own... Button 3 should be GPIO10 and Relay 3 should be GPIO4. Use at your own risk!","title":"minitiger Touch Light Switch"},{"location":"devices/minitiger-Touch-Light-Switch/#minitiger-touch-light-switch","text":"This is a cheap Sonoff T1 clone. Available with 1/2/3 channels. The board has the ID 2PH89174A","title":"minitiger Touch Light Switch"},{"location":"devices/minitiger-Touch-Light-Switch/#device","text":"ESP8285 micro Blue status LED (micro controlled) Separate touch IC controlled switch status indicators (blue and red) Aliexpress link: Click Aliexpress link for no neutral version (single live wire) version: Click","title":"Device"},{"location":"devices/minitiger-Touch-Light-Switch/#images","text":"Front and soldering: Fullsize Front and identification number: Fullsize Back and GND: Fullsize Soldering layout: Fullsize","title":"Images"},{"location":"devices/minitiger-Touch-Light-Switch/#flashing","text":"This board can be flashed with vanilla sonoff-tasmota. I used esptool on linux to upload the firmware.","title":"Flashing"},{"location":"devices/minitiger-Touch-Light-Switch/#programming-mode","text":"Short GPIO0 to GND, as with all boards. If you have successfully put the micro into programming mode the LED does not light up!","title":"Programming mode:"},{"location":"devices/minitiger-Touch-Light-Switch/#config","text":"","title":"Config:"},{"location":"devices/minitiger-Touch-Light-Switch/#single-channel","text":"Works out of the box, configured as Sonoff Basic. The LED does not light up when the switch is turned off. Configure as Sonoff T1 to enable the LED.","title":"Single Channel:"},{"location":"devices/minitiger-Touch-Light-Switch/#dual-channel","text":"{\"NAME\":\"Wall Switch 2C\",\"GPIO\":[17,255,255,255,0,22,18,0,21,56,0,0,0],\"FLAG\":0,\"BASE\":28}","title":"Dual Channel:"},{"location":"devices/minitiger-Touch-Light-Switch/#dual-channel-no-neutral-single-live-wire","text":"{\"NAME\":\"Wall Switch 2C\",\"GPIO\":[53,52,255,17,18,0,0,0,0,21,22,0,0],\"FLAG\":0,\"BASE\":28}","title":"Dual Channel - No Neutral (Single Live Wire):"},{"location":"devices/minitiger-Touch-Light-Switch/#triple-channel","text":"Since I don't own such a board, you are on your own... Button 3 should be GPIO10 and Relay 3 should be GPIO4. Use at your own risk!","title":"Triple Channel:"},{"location":"devices/others/","text":"Motor Clockwise/Anticlockwise ~ (Now retired, see https://www.itead.cc/motor-reversing-wifi-wireless-switch.html) This USB powered or external powered board provides one GPIO controlling two alternating relays with Normally Open (NO) and Normally Closed (NC) contacts. It can be used for changing directions of a connected motor. Programming the on-board 3.3V PSA-B is possible when Rx (Pin 7), Tx (Pin 8) and GND (Pin 9) are connected to the FTDI interface, the button is pressed and (USB) power is provided.","title":"Others"},{"location":"devices/others/#motor-clockwiseanticlockwise","text":"(Now retired, see https://www.itead.cc/motor-reversing-wifi-wireless-switch.html) This USB powered or external powered board provides one GPIO controlling two alternating relays with Normally Open (NO) and Normally Closed (NC) contacts. It can be used for changing directions of a connected motor. Programming the on-board 3.3V PSA-B is possible when Rx (Pin 7), Tx (Pin 8) and GND (Pin 9) are connected to the FTDI interface, the button is pressed and (USB) power is provided.","title":"Motor Clockwise/Anticlockwise"},{"location":"devices/wk30/","text":"Connection ~ Vcc - 3.3V TX - RX RX - TX GND - GND GPIO0 - GND Additional Information ~ This device is available on Amazon as \"Smart WiFi Plug Outlet Mini with Energy Monitoring.\" The product number, WK30 appears nowhere on the page on Amazon, so here's its ASIN: B07C326VKR It remains to be seen if this device actually features energy monitoring as in the title on Amazon. Nicely labeled holes for a header exist. The pictures below are with a header soldered on. All that was needed was to jumper GPIO0 to ground in addition to the usual connections. Once tasmota is up, configure the device as generic. Device Images ~ GPIO Config ~ This has the LEDs, GPIO4 and GPIO5 separated out as different relays so they can be controlled independently of the switch.","title":"Wk30"},{"location":"devices/wk30/#connection","text":"Vcc - 3.3V TX - RX RX - TX GND - GND GPIO0 - GND","title":"Connection"},{"location":"devices/wk30/#additional-information","text":"This device is available on Amazon as \"Smart WiFi Plug Outlet Mini with Energy Monitoring.\" The product number, WK30 appears nowhere on the page on Amazon, so here's its ASIN: B07C326VKR It remains to be seen if this device actually features energy monitoring as in the title on Amazon. Nicely labeled holes for a header exist. The pictures below are with a header soldered on. All that was needed was to jumper GPIO0 to ground in addition to the usual connections. Once tasmota is up, configure the device as generic.","title":"Additional Information"},{"location":"devices/wk30/#device-images","text":"","title":"Device Images"},{"location":"devices/wk30/#gpio-config","text":"This has the LEDs, GPIO4 and GPIO5 separated out as different relays so they can be controlled independently of the switch.","title":"GPIO Config"},{"location":"installation/","text":"","title":"Index"},{"location":"installation/Flashing/","text":"","title":"Flashing"},{"location":"installation/Hardware-Preparation/","text":"","title":"Hardware Preparation"},{"location":"installation/Initial-Configuration/","text":"","title":"Initial Configuration"},{"location":"installation/Prerequisites/","text":"","title":"Prerequisites"}]}